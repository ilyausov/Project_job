//---------------------------------------------------------------------------
#pragma hdrstop
#include "Logic.h"
#include "Modules\RRG\RRG.cpp"
#include "Modules\Klapan\Klapan.cpp"
#include "Modules\AZdrive\AZdrive.cpp"
//---------------------------------------------------------------------------
#pragma package(smart_init)

void LogicMain ()
{
    KOLCO();                    // кольцо
    if ( shr[1] )               // Проверка
    {                           // активации
        R_1();                  // режима 1 "Откачка камеры"
    };
    if ( shr[2] )               // Проверка
    {                           // активации
        R_2();                  // режима 2 "Откачка шлюза"
    };
    if ( shr[3] )               // Проверка
    {                           // активации
        R_3();                  // режима 3 "Рабочий цикл"
    };
    if ( shr[4] )               // Проверка
    {                           // активации
        R_4();                  // режима 4 "Технологический процесс"
    };
    if ( shr[5] )               // Проверка
    {                           // активации
        R_5();                  // режима 5 "Сброс Рабочего цикла"
    };
    if ( shr[6] )               // Проверка
    {                           // активации
        R_6();                  // режима 6 "Выгрузка п/д"
    };
    if ( shr[7] )               // Проверка
    {                           // активации
        R_7();                  // режима 7 "отключение установки"
    };
    if ( shr[8] )               // Проверка
    {                           // активации
        R_8();                  // режима 8 "Аварийное отключение установки"
    };
    if ( shr[9] )               // Проверка
    {                           // активации
        R_9();                  // режима 9 "Транспортный тест"
    };
    if ( shr[10] )               // Проверка
    {                           // активации
        R_10();                  // режима 10 "Открыть ЩЗ шлюза"
    };
    if ( shr[11] )               // Проверка
    {                           // активации
        R_11();                  // режима 11 "Закрыть ЩЗ шлюза"
    };
    if ( shr[12] )               // Проверка
    {                           // активации
        R_12();                  // режима 12 "Открыть затвор испарителя"
    };
    if ( shr[13] )               // Проверка
    {                           // активации
        R_13();                  // режима 13 "Закрыть затвор испарителя"
    };
    if ( shr[14] )               // Проверка
    {                           // активации
        R_14();                  // режима 14 "Кассета в HOME"
    };
    if ( shr[15] )               // Проверка
    {                           // активации
        R_15();                  // режима 15 "Кассета вверх/вниз"
    };
    if ( shr[16] )               // Проверка
    {                           // активации
        R_16();                  // режима 16 "ПГП в HOME"
    };
    if ( shr[17] )               // Проверка
    {                           // активации
        R_17();                  // режима 17 "ПГП вперёд/назад"
    };
    if ( shr[18] )               // Проверка
    {                           // активации
        R_18();                  // режима 18 "ПВП в HOME"
    };
    if ( shr[19] )               // Проверка
    {                           // активации
        R_19();                  // режима 19 "ПВП вверх/вниз"
    };
    if ( shr[20] )               // Проверка
    {                           // активации
        R_20();                  // режима 20 "Привод вращения п/д в HOME"
    };
    if ( shr[21] )               // Проверка
    {                           // активации
        R_21();                  // режима 21 "Привод вращения п/д вперёд"
    };
    if ( shr[22] )               // Проверка
    {                           // активации
        R_22();                  // режима 22 "ППД в HOME"
    };
    if ( shr[23] )               // Проверка
    {                           // активации
        R_23();                  // режима 23 "ППД вперёд/назад"
    };
    if ( shr[24] )               // Проверка
    {                           // активации
        R_24();                  // режима 24 "Привод вращения п/д (беск)"
    };
    if ( shr[25] )               // Проверка
    {                           // активации
        R_25();                  // режима 25 "Откачка испарителя"
    };
    if ( shr[26] )               // Проверка
    {                           // активации
        R_26();                  // режима 26 "Загрузка материала"
    };
    if ( shr[27] )               // Проверка
    {                           // активации
        R_27();                  // режима 27 "Нагрева Шлюза вкл"
    };
    if ( shr[28] )               // Проверка
    {                           // активации
        R_28();                  // режима 28 "Нагрев Шлюза откл"
    };
    if ( shr[29] )               // Проверка
    {                           // активации
        R_29();                  // режима 29 "Нагрев п/д вкл"
    };
    if ( shr[30] )               // Проверка
    {                           // активации
        R_30();                  // режима 30 "Нагрев п/д откл"
    };
    if ( shr[31] )               // Проверка
    {                           // активации
        R_31();                  // режима 31 "Привод вращения п/д откл."
    };
    if ( shr[32] )               // Проверка
    {                           // активации
        R_32();                  // режима 32 "Выбор датчика толщины"
    };
    if ( shr[36] )               // Проверка
    {                           // активации
        R_36();                  // режима 36 "ЭЛУ вкл."
    };
    if ( shr[37] )               // Проверка
    {                           // активации
        R_37();                  // режима 37 "ЭЛУ откл"
    };
    if ( shr[38] )               // Проверка
    {                           // активации
        R_38();                  // режима 38 "Рэмпинг ЭЛУ"
    };
    if ( shr[43] )               // Проверка
    {                           // активации
        R_43();                  // режима 43 "Подключение камеры слежения за расплавом"
    };


    POST();                     // дешифрация команд оператора
};
//---------------------------------------------------------------------------
void KOLCO()                    // подпрограмма "Кольцо"
{
	DIAGN_KOLCO();              // диагностика в кольце

    UPR_AVAR_OTKL();			// Управление аварийным отключением
    MEH_AVAR_CHK();				// слежение за авриями механизма


    
    AVAR_VODA_ISP(); // Реакция на попадание воды в испаритель ЭЛ
    AVAR_VODA_NG (); //Реакция на попадание воды в корпус нагревателя п/д
    //SLEJ_PGP ();    //подпрограмма "Слежение за наличием п/д на ПГП во время движения"
    SetOut((out[5]&0x10),4,0x2000); //Подключение азота при включённом ТМН кам
    
    if((out[3]&0x40)&&(zin[1]&0x800))
        diagn[10]|=0x08;                //отказ "Т° чиллера не в допуске"
    else
        diagn[10]&=(~0x08);             //сброс диагностики

}
//---------------------------------------------------------------------------
void POST()                     // Почта (приём и дешифрация команд)
{
    switch (qkk)
    {
        case 0:;break;          // проверка на KK = 0
        case 1:                 // проверка на KK = 1
        {
            if ( shr[1] == 0 )  // если режим ещё не активизирован
            {
                shr[1] = 1;     // активизируем
                sh[1]  = 1;     // режим 1 "Откачка камеры и испарителя"
            }
        }; break;
        case 2:                 // проверка на KK = 2
        {
            if ( shr[2] == 0 )  // если режим ещё не активизирован
            {
                shr[2] = 1;     // активизируем
                sh[2]  = 1;     // режим 2 "Откачка шлюза"
            }
        }; break;
        case 3:                 // проверка на KK = 3
        {
            if ( shr[3] == 0 )  // если режим ещё не активизирован
            {
                shr[3] = 1;     // активизируем
                sh[3]  = 1;     // режим 3 "Рабочий цикл"
            }
        }; break;
		case 5:                 // проверка на KK = 5
        {
            if ( shr[5] == 0 )  // если режим ещё не активизирован
            {
                shr[5] = 1;     // активизируем
                sh[5]  = 1;     // режим 5 "Сброс РЦ"
            }
        }; break;
        case 6:                 // проверка на KK = 6
        {
            if ( shr[6] == 0 )  // если режим ещё не активизирован
            {
                shr[6] = 1;     // активизируем
                sh[6]  = 1;     // режим 6 "Выгрузка пластин"
            }
        }; break;
		case 7:                 // проверка на KK = 7
        {
            if ( shr[7] == 0 )  // если режим ещё не активизирован
            {
                shr[7] = 1;     // активизируем
                sh[7]  = 1;     // режим 7 "Отключение установки"
            }
        }; break;

		case 9:                 // проверка на KK = 9
        {
            if ( shr[9] == 0 )  // если режим ещё не активизирован
            {
                shr[9] = 1;     // активизируем
                sh[9]  = 1;     // режим 9 "Транспортный тест"
            }
        }; break;
		case 109:				// проверка на KK = 109
        {
            PR_TRTEST = 1;		// признак окончания транспортного теста
        }; break;
		case 10:				// проверка на KK = 10
        {
            if ( shr[10] == 0 )  // если режим ещё не активизирован
            {
                shr[10] = 1;     // активизируем
                sh[10]  = 1;     // режим 10 "Открыть ЩЗ"
            }
        }; break;
		case 11:                 // проверка на KK = 11
        {
            if ( shr[11] == 0 )  // если режим ещё не активизирован
            {
                shr[11] = 1;     // активизируем
                sh[11]  = 1;     // режим 11 "Закрыть ЩЗ"
            }
        }; break;
		case 12:                 // проверка на KK = 12
        {
            if ( shr[12] == 0 )  // если режим ещё не активизирован
            {
                shr[12] = 1;     // активизируем
                sh[12]  = 1;     // режим 12 "Открыть затвор испарителя"
            }
        }; break;
		case 13:                 // проверка на KK = 13
        {
            if ( shr[13] == 0 )  // если режим ещё не активизирован
            {
                shr[13] = 1;     // активизируем
                sh[13]  = 1;     // режим 13 "Закрыть затвор испарителя"
            }
        }; break;
		case 101:				// проверка на KK = 101
        {
            SBROS_MEH();		// сброс механизмов
        }; break;
		case 213:				// проверка на KK = 213
        {
            MEH_AVAR_SBROS();	// сброс аварий механизмов
        }; break;
		case 14:                 // проверка на KK = 14
        {
            if ( shr[14] == 0 )  // если режим ещё не активизирован
            {
                shr[14] = 1;     // активизируем
                sh[14]  = 1;     // режим 14 "Кассета в Home"
            }
        }; break;
		case 15:                 // проверка на KK = 15
        {
            if ( shr[15] == 0 )  // если режим ещё не активизирован
            {
                shr[15] = 1;     // активизируем
                sh[15]  = 1;     // режим 15 "Кассета вверх/вниз"
            }
        }; break;
        case 16:                 // проверка на KK = 16
        {
            if ( shr[16] == 0 )  // если режим ещё не активизирован
            {
                shr[16] = 1;     // активизируем
                sh[16]  = 1;     // режим 16 "ПГП в Home"
            }
        }; break;
		case 17:                 // проверка на KK = 17
        {
            if ( shr[17] == 0 )  // если режим ещё не активизирован
            {
                shr[17] = 1;     // активизируем
                sh[17]  = 1;     // режим 17 "ПГП вперёд/назад"
            }
        }; break;
		case 18:                 // проверка на KK = 18
        {
            if ( shr[18] == 0 )  // если режим ещё не активизирован
            {
                shr[18] = 1;     // активизируем
                sh[18]  = 1;     // режим 18 "ПВП в Home"
            }
        }; break;
		case 19:                 // проверка на KK = 19
        {
            if ( shr[19] == 0 )  // если режим ещё не активизирован
            {
                shr[19] = 1;     // активизируем
                sh[19]  = 1;     // режим 19 "ПВП вверх/вниз"
            }
        }; break;
		case 100:				// проверка на KK = 100
        {
            OSBROS();			// общий сброс
        }; break;
		case 20:                // проверка на KK = 20
        {
              if ( shr[20] == 0 )  // если режим ещё не активизирован
            {
                shr[20] = 1;    // активизируем
                sh[20]  = 1;    // режим 20 "Привод вращения п/д в Home"
            }

        }; break;

		case 21:                // проверка на KK = 21
        {
              if ( shr[21] == 0 )  // если режим ещё не активизирован
            {
                shr[21] = 1;    // активизируем
                sh[21]  = 1;    // режим 21 "Привод вращения п/д вперёд"
            }

        }; break;
        case 22:                // проверка на KK = 22
        {
            if ( shr[22] == 0 ) // если режим ещё не активизирован
            {
                shr[22] = 1;    // активизируем
                sh[22]  = 1;    // режим 22 "Привод поворота датчиков в HOME"
            }
        }; break;
        case 23:                // проверка на KK = 23
        {
            if ( shr[23] == 0 ) // если режим ещё не активизирован
            {
                shr[23] = 1;    // активизируем
                sh[23]  = 1;    // режим 23 "Привод поворота датчиков вперёд/назад"
            }
        }; break;
        case 24:                // проверка на KK = 24
        {
            if ( shr[24] == 0 ) // если режим ещё не активизирован
            {
                shr[24] = 1;    // активизируем
                sh[24]  = 1;    // режим 23 "Вращение п/д беск"
            }
        }; break;
        case 25:                // проверка на KK = 25
        {
            if ( shr[25] == 0 ) // если режим ещё не активизирован
            {
                shr[25] = 1;    // активизируем
                sh[25]  = 1;    // режим 25 "Откачка испарителя"
            }
        }; break;
        case 26:                // проверка на KK = 26
        {
            if ( shr[26] == 0 ) // если режим ещё не активизирован
            {
                shr[26] = 1;    // активизируем
                sh[26]  = 1;    // режим 26 "Загрузка материала"
            }
        }; break;
        case 27:                // проверка на KK = 27
        {
              if ( shr[27] == 0 )  // если режим ещё не активизирован
            {
                shr[27] = 1;    // активизируем
                sh[27]  = 1;    // режим 27 "Нагрев шлюза вкл"
            }

        }; break;
		case 28:                // проверка на KK = 28
        {
            if ( shr[28] == 0 ) // если режим ещё не активизирован
            {
                shr[28] = 1;    // активизируем
                sh[28]  = 1;    // режим 28 "Нагрев шлюза откл"
            }
        }; break;
        case 29:                // проверка на KK = 20
        {
              if ( shr[29] == 0 )  // если режим ещё не активизирован
            {
                shr[29] = 1;    // активизируем
                sh[29]  = 1;    // режим 29 "Нагрев п/д вкл"
            }

        }; break;
        case 30:                // проверка на KK = 30
        {
            if ( shr[30] == 0 ) // если режим ещё не активизирован
            {
                shr[30] = 1;    // активизируем
                sh[30]  = 1;    // режим 30 "Нагрев п/д откл"
            }
        }; break;
		case 31:                // проверка на KK = 31
        {
            if ( shr[31] == 0 ) // если режим ещё не активизирован
            {
                shr[31] = 1;    // активизируем
                sh[31]  = 1;    // режим 31 "Привод вращения п/д откл"
            }
        }; break;
		case 32:                // проверка на KK = 32
        {

                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Выбор датчика толщины 1"
                PR_PPD_D=1;

        }; break;
        case 33:                // проверка на KK = 33
        {

                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Выбор датчика толщины 2"
                PR_PPD_D=2;

        }; break;
        case 34:                // проверка на KK = 34
        {

                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Выбор датчика толщины 3"
                PR_PPD_D=3;

        }; break;
        case 35:                // проверка на KK = 35
        {

                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Выбор датчика толщины 4"
                PR_PPD_D=4;

        }; break;
        case 36:                // проверка на KK = 36
        {

                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Выбор датчика толщины 5"
                PR_PPD_D=5;

        }; break;
        case 37:                // проверка на KK = 37
        {

                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Выбор датчика толщины 6"
                PR_PPD_D=6;

        }; break;
		case 39:                // проверка на KK = 39
        {

                SetOut(1,3,0x80);       //Чиллер охлаждения вкл

        }; break;
        case 40:                // проверка на KK = 40
        {

                SetOut(0,3,0x80);       //Чиллер охлаждения откл

        }; break;
        case 41:                // проверка на KK = 41
        {

                SetOut(1,3,0x40);       //Чиллер нагрева вкл
                SetOut(1,3,0x100);
        }; break;
        case 42:                // проверка на KK = 42
        {

                SetOut(0,3,0x40);       //Чиллер нагрева откл
                SetOut(0,3,0x100);
        }; break;
        case 43:                // проверка на KK = 43
        {
            if ( shr[43] == 0 ) // если режим ещё не активизирован
            {
                shr[43] = 1;    // активизируем
                sh[43]  = 1;    // режим 43 "Подключение камеры слежения за расплавом"
            }
        }; break;
        default:                // любая другая команда
        {
            diagnS[0] |= 0x80;  // отказ: "неопознанная команда"
            return;             //
        };

    };
    qkk = 0;                    // сброс кода команды
    diagnS[0] &= ~(0x80);       // сброс диагностики
}
//---------------------------------------------------------------------------
void DIAGN_KOLCO()				// "Подпрограмма: "Диагностика в кольце"       
{
    if(!(zin[0]&0x8000))
        diagn[25]|=0x01;            //отказ "Нет давления в пневмосети"
    else
        diagn[25]&=(~0x01);         //сброс диагностики

    if(!(out[3]&0x100))
    {
        if(!(zin[0]&0x01))
            diagn[25]|=0x02;            //отказ "Нет охлаждения камеры"
        else
            diagn[25]&=(~0x02);         //сброс диагностики

        if(!(zin[0]&0x02))
            diagn[25]|=0x04;            //отказ "Нет охлаждения камеры испарителя"
        else
            diagn[25]&=(~0x04);         //сброс диагностики

        if(!(zin[0]&0x04))
            diagn[25]|=0x08;            //отказ "Нет охлаждения испарителя ЭЛ"
        else
            diagn[25]&=(~0x08);         //сброс диагностики

        if(!(zin[0]&0x08))
            diagn[25]|=0x10;            //отказ "Нет охлаждения кварцевого датчика"
        else
            diagn[25]&=(~0x10);         //сброс диагностики

        if(!(zin[0]&0x200))
            diagn[25]|=0x20;            //отказ "Нет охлаждения верхней крышки"
        else
            diagn[25]&=(~0x20);         //сброс диагностики
    }
    else if(out[3]&0x40)
    {
        if(!(zin[0]&0x01))
            diagn[25]|=0x40;            //отказ "Нет прогрева камеры"
        else
            diagn[25]&=(~0x40);         //сброс диагностики

        if(!(zin[0]&0x02))
            diagn[25]|=0x80;            //отказ "Нет прогрева камеры испарителя"
        else
            diagn[25]&=(~0x80);         //сброс диагностики

        if(!(zin[0]&0x04))
            diagn[26]|=0x01;            //отказ "Нет прогрева испарителя ЭЛ"
        else
            diagn[26]&=(~0x01);         //сброс диагностики

        if(!(zin[0]&0x08))
            diagn[26]|=0x02;            //отказ "Нет прогрева кварцевого датчика"
        else
            diagn[26]&=(~0x02);         //сброс диагностики

        if(!(zin[0]&0x200))
            diagn[26]|=0x04;            //отказ "Нет прогрева верхней крышки"
        else
            diagn[26]&=(~0x04);         //сброс диагностики
    }

    if(!(zin[0]&0x10))
        diagn[26]|=0x08;            //отказ "Нет охлаждения ТМН камеры"
    else
        diagn[26]&=(~0x08);         //сброс диагностики


    if(!(zin[0]&0x20))
        diagn[26]|=0x10;            //отказ "Нет охлаждения ТМН шлюза"
    else
        diagn[26]&=(~0x10);         //сброс диагностики


    if(!(zin[0]&0x40))
        diagn[26]|=0x20;            //отказ "Нет охлаждения ТМН камеры испарителя"
    else
        diagn[26]&=(~0x20);         //сброс диагностики


    if(!(zin[0]&0x80))
        diagn[26]|=0x40;            //отказ "Нет охлаждения форнасоса шлюза"
    else
        diagn[26]&=(~0x40);         //сброс диагностики


    if(!(zin[0]&0x100))
        diagn[26]|=0x80;            //отказ "Нет охлаждения форнасоса камер"
    else
        diagn[26]&=(~0x80);         //сброс диагностики


    if(!(zin[0]&0x400))
        diagn[27]|=0x01;            //отказ "Нет охлаждения корпуса нагревателя п/д"
    else
        diagn[27]&=(~0x01);         //сброс диагностики


    if(!(zin[1]&0x02))
        diagn[27]|=0x02;            //отказ "Форнасос шлюза: предупреждение"
    else
        diagn[27]&=(~0x02);         //сброс диагностики


    if(!(zin[1]&0x10))
        diagn[27]|=0x04;            //отказ "Форнасос камеры: предупреждение"
    else
        diagn[27]&=(~0x04);         //сброс диагностики  


    if(!(zin[1]&0x400))
        diagn[27]|=0x08;            //отказ "Чиллер (охлаждение): авария"
    else
        diagn[27]&=(~0x08);         //сброс диагностики


    if((out[3]&0x40)&&(!(zin[1]&0x1000)))
        diagn[27]|=0x10;            //отказ "Чиллер (нагрев): авария"
    else
        diagn[27]&=(~0x10);         //сброс диагностики


    if((zin[3]&0x1000))
        diagn[27]|=0x20;            //отказ "Ошибка ЭЛ"
    else
        diagn[27]&=(~0x20);         //сброс диагностики


    if((zin[3]&0x2000))
        diagn[27]|=0x40;            //отказ "Отказ кристалла"
    else
        diagn[27]&=(~0x40);         //сброс диагностики

    if(!(zin[5]&0x10))
        diagn[27]|=0x80;            //отказ "ТМН камеры: предупреждение"
    else
        diagn[27]&=(~0x80);         //сброс диагностики


    if(!(zin[4]&0x04))
        diagn[22]|=0x40;            //отказ "Авария привода вращения п/д"
    else
        diagn[22]&=(~0x40);         //сброс диагностики


    if(!(zin[4]&0x20))
        diagn[20]|=0x40;            //отказ "Авария привода горизонт. перемещ."
    else
        diagn[20]&=(~0x40);         //сброс диагностики

    if(!(zin[4]&0x100))
        diagn[18]|=0x40;            //отказ "Авария привода кассеты"
    else
        diagn[18]&=(~0x40);         //сброс диагностики

    if(!(zin[4]&0x800))
        diagn[19]|=0x40;            //отказ "Авария привода вертикальн. перемещ."
    else
        diagn[19]&=(~0x40);         //сброс диагностики

    if(!(zin[4]&0x4000))
        diagn[21]|=0x40;            //отказ "Авария привода поворота датчиков"
    else
        diagn[21]&=(~0x40);         //сброс диагностики






}
//---------------------------------------------------------------------------
void TIME()			//  подпрограмма управления таймером
{					// (прерывание с периодом в 1 миллисекунду)

	CT_T1++;		// Сч.тиков (1 мсек=1кГц)
	
	// Счетчики тиковские (1 мсек) для устройств и режимов
    CT_VR++;
    CT_PER++;
    CT_POD++;
    CT_KAS++;
    CT_PPD++;
	if(CT_T1 < 20) return;
	CT_T1 = 0;		// Сброс сч.тиков (1 мсек.)
	CT_T20++;		// Счетчик тиков (20мсек = 50Гц)

	// Счетчики тиковские (20 мсек) для устройств и режимов


				    // (тик) сч.вр.режима 30


	if(CT_T20 < 50) return;
	CT_T20 = 0;		// Сброс сч.тиков (20 мсек.)

	// Счетчики секундные (1 сек)






    CT_RASPLAV++;
    CT_ELU++;
    CT_TEMP1++;
    CT_TEMP2++;
    CT_TMN++;
    CT_IST++;
    CT_VODA_NG++;
    CT_TOLSH++;
	// инкремент счетчиков механизмов
	//AZdrive_Time();

	// Счетчики времени режимов (секундные)
	CT_1++;
    CT_2++;
    CT_3++;
    CT_4++;
    CT_5++;
    CT_6++;
    CT_7++;
    CT_9++;
    CT_25++;
    CT_26++;
    CT_27++;
    CT27K1++;
    CT_29++;
    CT29K1++;
    CT_36++;
    CT36K1++;
    CT_38++;




	TimeRRG();
	TimeKlapan();
}

//---------------------------------------------------------------------------
//-------------------------------  РЕЖИМЫ  ----------------------------------
//---------------------------------------------------------------------------
void R_1 ()            // Режим "Откачка камеры"
{
  	sh_ = sh[1];

	if (shr[1] < 1 || shr[1] > 56) goto L100;
	if (shr[1] < 10) goto L00;
	if (shr[1] < 20) goto L01;
	if (shr[1] < 30) goto L02;
	if (shr[1] < 40) goto L03;
    if (shr[1] < 50) goto L04;
	else goto L05;
	
L00:if (shr[1] == 1) goto L1;
	if (shr[1] == 2) goto L2;
	if (shr[1] == 3) goto L3;
	if (shr[1] == 4) goto L4;
	if (shr[1] == 5) goto L5;
	if (shr[1] == 6) goto L6;
	if (shr[1] == 7) goto L7;
	if (shr[1] == 8) goto L8;
	if (shr[1] == 9) goto L9;
L01:if (shr[1] == 10) goto L10;
	if (shr[1] == 11) goto L11;
	if (shr[1] == 12) goto L12;
	if (shr[1] == 13) goto L13;
	if (shr[1] == 14) goto L14;
	if (shr[1] == 15) goto L15;
	if (shr[1] == 16) goto L16;
	if (shr[1] == 17) goto L17;
	if (shr[1] == 18) goto L18;
	if (shr[1] == 19) goto L19;
L02:if (shr[1] == 20) goto L20;
	if (shr[1] == 21) goto L21;
	if (shr[1] == 22) goto L22;
	if (shr[1] == 23) goto L23;
	if (shr[1] == 24) goto L24;
	if (shr[1] == 25) goto L25;
	if (shr[1] == 26) goto L26;
	if (shr[1] == 27) goto L27;
	if (shr[1] == 28) goto L28;
	if (shr[1] == 29) goto L29;
L03:if (shr[1] == 30) goto L30;
	if (shr[1] == 31) goto L31;
	if (shr[1] == 32) goto L32;
	if (shr[1] == 33) goto L33;
	if (shr[1] == 34) goto L34;
	if (shr[1] == 35) goto L35;
	if (shr[1] == 36) goto L36;
	if (shr[1] == 37) goto L37;
	if (shr[1] == 38) goto L38;
    if (shr[1] == 39) goto L39;
L04:if (shr[1] == 40) goto L40;
	if (shr[1] == 41) goto L41;
	if (shr[1] == 42) goto L42;
	if (shr[1] == 43) goto L43;
    if (shr[1] == 44) goto L44;
    if (shr[1] == 45) goto L45;
    if (shr[1] == 46) goto L46;
    if (shr[1] == 47) goto L47;
    if (shr[1] == 48) goto L48;
    if (shr[1] == 49) goto L49;
L05:if (shr[1] == 50) goto L50;
    if (shr[1] == 51) goto L51;
    if (shr[1] == 52) goto L52;
    if (shr[1] == 53) goto L53;
    if (shr[1] == 54) goto L54;
    if (shr[1] == 55) goto L55;
    if (shr[1] == 56) goto L56;

	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[1] = sh_;
	if (sh[1] != 0) goto L100;	// sh_ != 0
	++shr[1];					// след. шаг сч.шр1
	if (shr[1] > 56) goto L0;	// число шагов режима
	sh[1] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 1;					// норма: "Откачка камеры завершена"
	shr[1] = 0;
	goto L100;
L1: SetOut(0,1,0x06);           //Закрыть Кл-НАП 2-3
    sh_=0;
    goto L101;
L2: VR_HOME(10);//привод вращения п/д в HOME
    goto L101;
L3: POD_HOME(10);//ПВП в HOME
    goto L101;
L4: PER_HOME(10);//ПГП в HOME
    goto L101;
L5: Klapan(0,&ShZatvShl);//Закрыть Щелевой затвор
    if(sh_)goto L101;
    shr[2]=1;                   //активизация режима 2
    sh[2]=1;                    //Откачка шлюза
    sh_=0;
    goto L101;
L6: if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if((!(D_D5<nasmod[0]))||(!(D_D4<nasmod[1])))
        shr[1]=8;                   //переход на шаг 9
    sh_=0;
    goto L101;
L7: Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L8: Klapan(1,&ZatvTmnIsp);//Открыть затвор ТМН исп
    if(sh_)goto L101;
    shr[1]=50;
    goto L101;
L9: Klapan(1,&EkrZatv);//Экран затвора испарителя вверх
    goto L101;
L10:Klapan(0,&ZatvIsp);//Закрыть затвор испарителя
    if(sh_)goto L101;
    SetOut(1,3,0x100);              //Подключить прогрев камеры
    goto L101;
L11:Klapan(1,&FvnKam);//Вкл. ФВН камер
    if(sh_)goto L101;
    SetOut(1,3,0x40);               //Вкл. чиллер нагрева
    goto L101;
L12:Klapan(0,&KlIsp);//Закрыть Фк Исп
    goto L101;
L13:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    if(sh_)goto L101;
    if(zin[5]&0x07)
        goto L101;
    if((nasmod[3]))
    {
        N_ZIKL_PROM_KAM=0;
        shr[1]=21;              //переход на шаг 22
        goto L101;
    }
    shr[1]=14;
    goto L101;
L14:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    if(sh_)goto L101;
    shr[1]=33;                  //переход на шаг 34
    goto L101;
L15:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L16:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    if(sh_)goto L101;
    SetOut(1,3,0x02);           //Открыть Фк кам мягк
    CT_1=0;
    goto L101;
L17:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UVAK_KAM_MO)
    {
        diagn[9]&=(~0x01);             //сброс диагностики
        shr[1]=21;                  //переход на шаг 22
        sh_=0;
        goto L101;
    }
    if((out[5]&0x08))
    {
        sh_=0;
        goto L101;
    }
L17_1:if(CT_1>T_KKAM_MO)
        diagn[9]|=0x01;                //отказ "медленная мягкая фороткачка камеры"
    goto L101;
L18:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3<UVAKN_TMN)
    {
        shr[1]=17;
        goto L17_1;                 //переход на шаг 17_1
    }
    sh_=0;
    goto L101;
L19:Klapan(0,&KlTmnKam);//Закрыть ФК-ТМН кам
    if(sh_)goto L101;
    SetOut(0,3,0x02);               //Закрыть Фк кам мягк
    goto L101;
L20:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L21:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    shr[1]=14;                      //переход на шаг 15
    sh_=0;
    goto L101;
L22:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L23:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L24:Klapan(1,&KlKam);//Открыть Фк-Кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L25:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UVAK_KAM)
    {
        diagn[9]&=(~0x02);             //сброс диагностики
        if(nasmod[3])
        {
            if(N_ZIKL_PROM_KAM<nasmod[3])
            {
                shr[1]=30;          //переход на шаг 31
                sh_=0;
                goto L101;
            }
        }
        shr[1]=33;                  //переход на шаг 34
        sh_=0;
        goto L101;
    }
    if((out[5]&0x08))
    {
        sh_=0;
        goto L101;
    }
L25_1:if(CT_1>T_KKAM)
        diagn[9]|=0x02;                //отказ "Медленная фороткачка кам"
    goto L101;
L26:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3<=UVAKN_TMN)
    {
        shr[1]=25;
        goto L25_1;                 //переход на шаг 25_1
    }
    sh_=0;
    goto L101;
L27:Klapan(0,&KlKam);//Закрыть Фк Кам
    goto L101;
L28:Klapan(0,&KlTmnKam);//Закрыть ФК-ТМН кам
    goto L101;
L29:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L30:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)goto L101;
    shr[1]=21;                      //переход на шаг 22
    sh_=0;
    goto L101;
L31:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L32:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    if(sh_)goto L101;
    SetOut(1,1,0x02);               //Открыть Кл-НАП3
    goto L101;
L33:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UATM)
        goto L101;
    SetOut(0,1,0x02);               //Закрыть Кл-НАП3
    N_ZIKL_PROM_KAM++;
    shr[1]=22;                      //переход на шаг 23
    sh_=0;
    goto L101;
L34:Klapan(0,&KlKam);//Закрыть Фк Кам
    goto L101;
L35:VklTmnKam();//Пуск ТМН кам
    goto L101;
L36:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L37:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L38:if(zin[5]&0x04)                 //ТМН кам норма
    {
        diagn[9]&=(~0x04);             //сброс диагностики
        shr[1]=42;                  //переход на шаг 43
        sh_=0;
        goto L101;
    }
    if((out[5]&0x08))
    {
        sh_=0;
        goto L101;
    }
L38_1:if(CT_1>T_KTMN_KAM_RAZGON)
        diagn[9]|=0x04;                //отказ "Нет выхода на режим ТМН кам"
    goto L101;
L39:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
    shr[1]=38;
    goto L38_1;                     //переход на шаг 38_1
L40:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L41:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L42:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    shr[1]=35;
    sh_=0;
    goto L101;
L43:Klapan(0,&KlTmnIsp);//Закрыть Фк-Тмн исп
    goto L101;
L44:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L45:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UVVAK_KAM)
    {
        diagn[9]&=(~0x08);             //сброс диагностики
        shr[25]=1;                  //активизируем режим 25
        sh[25]=1;                   //Откачка испарителя
        sh_=0;
        shr[1]=49;                  //переход на шаг 50
        goto L101;
    }
    if((out[5]&0x08))         //ТМН исп включён
    {
        sh_=0;
        goto  L101;
    }
L45_1:if(CT_1>T_KVVAK_KAM)
        diagn[9]|=0x08;                //отказ "Медленная Высоковакуумная откачка камеры"
    goto L101;
L46:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
    shr[1]=45;
    goto L45_1;                     //переход на шаг 45_1
L47:Klapan(0,&KlTmnKam);//закрыть Фк-ТМН кам
    goto L101;
L48:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L49:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    shr[1]=42;                      //переход на шаг 43
    sh_=0;
    goto L101;
L50:if(shr[25])
        goto L101;
    sh_=0;
    goto L101;
L51:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L52:Klapan(1,&ZatvIsp);//Открыть затвор испарит
    goto L101;
L53:Klapan(0,&EkrZatv);//Опустить экран затвора
    goto L101;
L54:Klapan(0,&ZaslIsp);//Закрыть заслонку испарителя
    goto L101;
L55:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>nasmod[0])
        goto L101;
    SetOut(0,3,0x40);               //Отключить чиллер нагрева
    SetOut(0,3,0x100);              //Отключить прогрев камеры
    sh_=0;
    goto L101;
L56:if(shr[2])goto L101;
    sh_=0;
    goto L101;







}
//---------------------------------------------------------------------------
void R_2 ()            // Режим "Откачка шлюза"
{
  sh_ = sh[2];

	if (shr[2] == 1) goto L1;   if (shr[2] == 2) goto L2;
	if (shr[2] == 3) goto L3;   if (shr[2] == 4) goto L4;
	if (shr[2] == 5) goto L5;   if (shr[2] == 6) goto L6;
	if (shr[2] == 7) goto L7;   if (shr[2] == 8) goto L8;
    if (shr[2] == 9) goto L9;   if (shr[2] == 10) goto L10;
    if (shr[2] == 11) goto L11; if (shr[2] == 12) goto L12;
    if (shr[2] == 13) goto L13; if (shr[2] == 14) goto L14;
    if (shr[2] == 15) goto L15; if (shr[2] == 16) goto L16;
    if (shr[2] == 17) goto L17; if (shr[2] == 18) goto L18;
    if (shr[2] == 19) goto L19; if (shr[2] == 20) goto L20;
    if (shr[2] == 21) goto L21; if (shr[2] == 22) goto L22;
    if (shr[2] == 23) goto L23; if (shr[2] == 24) goto L24;
    if (shr[2] == 25) goto L25; if (shr[2] == 26) goto L26;
    if (shr[2] == 27) goto L27; if (shr[2] == 28) goto L28;
    if (shr[2] == 29) goto L29; if (shr[2] == 30) goto L30;
    if (shr[2] == 31) goto L31; if (shr[2] == 32) goto L32;
    if (shr[2] == 33) goto L33; if (shr[2] == 34) goto L34;
    if (shr[2] == 35) goto L35; if (shr[2] == 36) goto L36;
    if (shr[2] == 37) goto L37; if (shr[2] == 38) goto L38;
    if (shr[2] == 39) goto L39; if (shr[2] == 40) goto L40;
    if (shr[2] == 41) goto L41; if (shr[2] == 42) goto L42;
    if (shr[2] == 43) goto L43; if (shr[2] == 44) goto L44;
    if (shr[2] == 45) goto L45; if (shr[2] == 46) goto L46;

	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[2] = sh_;
	if (sh[2] != 0) goto L100;	// sh_ != 0
	++shr[2];					// след. шаг сч.шр2
	if (shr[2] > 46) goto L0;	// число шагов режима
	sh[2] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 2;					// норма: "Откачка шлюза завершена"
	shr[2] = 0;
	goto L100;
	
L1: if(nasmod[7])
    {
        shr[27]=1;                  //активизир. режим 22
        sh[27]=1;                   //Включить нагрев шлюза
    }
    SetOut(0,1,0x01);           //Закрыть Кл-НАП1
    sh_=0;
    goto L101;
L2: KAS_HOME(10);//Кассета в HOME
    goto L101;
L3: Klapan(1,&FvnShl);//Включить форнасос шлюза
    if(sh_)goto L101;
    if(shr[1])
    {
        shr[2]=20;              //переход на шаг 21
        goto L101;
    }
    if((nasmod[5])&&(!(shr[5])&&(!(shr[6]))))
        shr[2]=6;               //переход на шаг 7
    goto L101;
L4: if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1>UVAKV_SHL)
    {
        sh_=0;
        goto L101;
    }
    shr[2]=15;
    goto L15_1;                 //переход на шаг 15_1
L5: Klapan(0,&ZatvTmnShl);//закрыть затвор ТМН шлюза
    goto L101;
L6: if((zin[0]&0x2000))        //Дверь шлюза закрыта
    {
        diagn[12]|=0x40;            //отказ "Дверь шлюза не закрыта"
        goto L101;
    }
    diagn[12]&=(~0x40);             //сброс диагностики
    shr[2]=7;                   //переход на шаг 8
    sh_=0;
    goto L101;
L7: Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шлюза
    if(sh_)goto L101;
    N_ZIKL_PROM_SHL=0;
    shr[2]=19;                  //переход на шаг 20
    goto L101;
L8: Klapan(0,&KlTmnShl);//Закрыть Фк-ТМН шлюза
    if(sh_)goto L101;
    SetOut(1,0,0x02);           //Открыть Фк шлюза (мягк)
    CT_2=0;
    goto L101;
L9: if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=UVAK_SHL_MO)
    {
        diagn[10]&=(~0x10);             //сброс диагностики
        shr[2]=13;
        sh_=0;
        goto L101;
    }
    if(out[5]&0x02)                 //ТМН шлюза включён?
    {
        sh_=0;
        goto L101;
    }
    shr[2]=10;
    goto L10_1;                     //переход на шаг 10_1
L10:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L10_1:if(CT_2>T_KSHL_MO)
        diagn[10]|=0x10;                //отказ: "Медленная фороткачка шлюза"
    shr[2]=8;                       //переход на шаг 9
    sh_=0;
    goto L101;
L11:Klapan(0,&KlShl);//закрыть Фк шлюза
    goto L101;
L12:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шлюза
    goto L101;
L13:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKV_TMN)
        goto L101;
    sh_=0;
    shr[2]=7;                       //переход на шаг 8
    goto L101;
L14:Klapan(1,&KlShl);//Открыть Фк шлюза
    if(sh_)goto L101;
    CT_2=0;
    goto L101;
L15:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=UVAKV_SHL)
    {
        diagn[8]&=(~0x01);             //сброс диагностики
L15_1:  if((nasmod[5])&&(!(shr[5]))&&(!(shr[6])))
        {
            if(N_ZIKL_PROM_SHL<nasmod[5])
            {
                sh_=0;
                shr[2]=42;              //переход на шаг 43
                goto L101;
            }
        }                              //переход на шаг 21
        shr[2]=20;
        sh_=0;
        goto L101;
    }
    if(out[5]&0x02)             //ТМН шлюза включён?
    {
        sh_=0;
        goto L101;
    }
    shr[2]=16;
    goto L16_1;                 //переход на шаг 16_1
L16:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L16_1:if(CT_2>T_KKAM)
        diagn[8]|=0x01;            //отказ:"медленная фороткачка шлюза"
    shr[2]=14;                  //переход на шаг 15
    sh_=0;
    goto L101;
L17:Klapan(0,&KlShl);//ЗАкрыть Фк шлюза
    goto L101;
L18:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шлюза
    goto L101;
L19:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKV_TMN)
        goto L101;
    sh_=0;
    goto L101;
L20:Klapan(0,&KlTmnShl);//закрыть Фк-ТМН шлюза
    if(sh_)goto L101;
    shr[2]=13;                      //переход на шаг 14
    goto L101;
L21:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKV_TMN)
    {
        sh_=0;
        goto L101;
    }
    shr[2]=25;                      //переход на шаг 26
    sh_=0;
    goto L101;
L22:Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шлюза
    goto L101;
L23:Klapan(0,&KlShl);//закрыть Фк шлюза
    goto L101;
L24:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шлюза
    if(sh_)goto L101;
    CT_2=0;
    goto L101;
L25:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2<=UVAKV_TMN)
    {
        diagn[8]&=(~0x02);             //сброс диагностики
        shr[2]=27;                  //переход на шаг 28
        sh_=0;
        goto L101;
    }
    if(CT_2>T_KTMN)
        diagn[8]|=0x02;                //отказ:"Медленная фороткачка ТМН шлюза"
    goto L101;
L26:Klapan(0,&KlShl);//закрыть Фк шлюза
    goto L101;
L27:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шлюза
    goto L101;
L28:SetOut(1,5,0x02);//пуск ТМН шлюза
    sh_=0;
    CT_2=0;
    goto L101;
L29:if(zin[5]&0x100)                //ТМН шлюза норма?
    {
        diagn[8]&=(~0x04);             //сброс диагностики
        if(!(shr[1]))
        {
            sh_=0;
            goto L101;
        }
        shr[2]=46;                  //выход
        sh_=0;
        goto L101;
    }
    if(CT_2>T_KTMN_SHL_RAZGON)
        diagn[8]|=0x04;                //отказ:"Нет выхода на режим ТМН шлюза"
    goto L101;
L30:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1>UVAKN_SHL)
    {
        sh_=0;
        goto L101;
    }
    shr[2]=38;                      //переход на шаг 39
    sh_=0;
    goto L101;
L31:Klapan(0,&ZatvTmnShl);//закрыть затвор ТМН шлюза
    goto L101;
L32:Klapan(0,&KlTmnShl);//Закрыть Фк-ТМН шлюза
    goto L101;
L33:Klapan(1,&KlShl);//Открыть Фк шлюза
    if(sh_)goto L101;
    CT_2=0;
    goto L101;
L34:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=UVAKV_SHL)
    {
        diagn[8]&=(~0x01);             //сброс диагностики
        shr[2]=38;                  //переход на шаг 39
        sh_=0;
        goto L101;
    }
    if(out[5]&0x02)
    {
        sh_=0;
        goto L101;
    }
    shr[2]=35;
    goto L35_1;
L35:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L35_1:if(CT_2>T_KSHL)
        diagn[8]|=0x01;                //отказ "медленная фороткачка шлюза"
    shr[2]=33;                      //переход на шаг 34
    sh_=0;
    goto L101;
L36:Klapan(0,&KlShl);//Закрыть Фк шлюза
    goto L101;
L37:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шлюза
    goto L101;
L38:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKV_TMN)
        goto L101;
    shr[2]=31;
    sh_=0;
    goto L101;
L39:Klapan(0,&KlShl);//Закрыть Фк шлюза
    goto L101;
L40:Klapan(1,&KlTmnShl);//Открыть ФК-ТМН шлюза
    goto L101;
L41:Klapan(1,&ZatvTmnShl);//Открыть затвор ТМН шлюза
    if(sh_)goto L101;
    CT_2=0;
    goto L101;
L42:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=nasmod[2])
    {
        diagn[8]&=(~0x08);             //сброс диагностики
        shr[2]=46;                  //выход
        sh_=0;
        goto L101;
    }
    if(CT_2>T_KSHL_V)
        diagn[8]|=0x08;                //отказ "Медленная высоковакуумная откачка шлюза"
    goto L101;
L43:Klapan(0,&KlShl);//закрыть Фк-Шл
    goto L101;
L44:SetOut(1,1,0x01);               //Открыть Кл-НАП1
    sh_=0;
    goto L101;
L45:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=UATM)
        goto L101;
    sh_=0;
    goto L101;
L46:SetOut(0,1,0x01);               //Закрыть Кл-НАП1
    N_ZIKL_PROM_SHL++;
    shr[2]=13;                      //переход на шаг 14
    sh_=0;
    goto L101;


}

//---------------------------------------------------------------------------
void R_3 ()            // Режим "Рабочий цикл"
{
 	sh_ = sh[3];

	if (shr[3] < 1 || shr[3] > 45) goto L100;
	if (shr[3] < 10) goto L00;
	if (shr[3] < 20) goto L01;
	if (shr[3] < 30) goto L02;
	if (shr[3] < 40) goto L03;
	goto L04;

L00:if (shr[3] == 1) goto L1;		if (shr[3] == 2) goto L2;
	if (shr[3] == 3) goto L3;		if (shr[3] == 4) goto L4;
	if (shr[3] == 5) goto L5;		if (shr[3] == 6) goto L6;
	if (shr[3] == 7) goto L7;		if (shr[3] == 8) goto L8;
	if (shr[3] == 9) goto L9;
L01:if (shr[3] == 10) goto L10;		if (shr[3] == 11) goto L11;
	if (shr[3] == 12) goto L12;		if (shr[3] == 13) goto L13;
	if (shr[3] == 14) goto L14;		if (shr[3] == 15) goto L15;
	if (shr[3] == 16) goto L16;		if (shr[3] == 17) goto L17;
	if (shr[3] == 18) goto L18;		if (shr[3] == 19) goto L19;
L02:if (shr[3] == 20) goto L20;		if (shr[3] == 21) goto L21;
	if (shr[3] == 22) goto L22;		if (shr[3] == 23) goto L23;
	if (shr[3] == 24) goto L24;		if (shr[3] == 25) goto L25;
	if (shr[3] == 26) goto L26;		if (shr[3] == 27) goto L27;
	if (shr[3] == 28) goto L28;		if (shr[3] == 29) goto L29;
L03:if (shr[3] == 30) goto L30;		if (shr[3] == 31) goto L31;
	if (shr[3] == 32) goto L32;		if (shr[3] == 33) goto L33;
	if (shr[3] == 34) goto L34;		if (shr[3] == 35) goto L35;
	if (shr[3] == 36) goto L36;		if (shr[3] == 37) goto L37;
	if (shr[3] == 38) goto L38;		if (shr[3] == 39) goto L39;
L04:if (shr[3] == 40) goto L40;		if (shr[3] == 41) goto L41;
	if (shr[3] == 42) goto L42;		if (shr[3] == 43) goto L43;
	if (shr[3] == 44) goto L44;		if (shr[3] == 45) goto L45;

	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[3] = sh_;
	if (sh[3] != 0) goto L100;		// sh_ != 0
	++shr[3];						// след. шаг сч.шр2
	if (shr[3] > 45) goto L0;		// число шагов режима
	sh[3] = 1;
L100:return;						// возврат в "кольцо"

L0: norma = 3;						// норма: "РЦ завершен"
	shr[3] = 0;
	goto L100;
	
L1: N_ST=0;
    T_PROC=0;
    SOST_V=0;
    SOST_N=0;
    shr[1]=1;                       //актевизация режима 1
    sh[1]=1;                        //откачка камеры и испарителя
    sh_=0;
    goto L101;
L2: if(shr[1])
        goto L101;
    sh_=0;
    goto L101;
L3: Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шлюза
    goto L101;
L4: Klapan(0,&KlShl);//Закрыть ФК шлюза
    goto L101;
L5: KAS_HOME(10);//кассета в HOME
    if(sh_)goto L101;
    if((zin[0]&0x2000))
    {
        shr[3]=7;                   //переход на шаг 8
        goto L101;
    }
    CT_3=0;
    SetOut(1,1,0x01);               //Открыть Кл-НАП1
    goto L101;
L6: if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if((D_D1>UATM)||((zin[0]&0x2000)))
    {
        diagn[8]&=(~0x10);             //сброс диагностики
        SetOut(1,2,0x8000);
        SetOut(1,4,0x1100);         //Вкл звонок
        CT_3=0;
        sh_=0;
        goto L101;
    }
    if(CT_3>=T_KNAP)
        diagn[8]|=0x10;                //отказ "медленный напуск в шлюз"
    goto L101;
L7: if(CT_3<=T_NAPUSK)
        goto L101;
    SetOut(0,2,0x8000);
    SetOut(0,4,0x1100);         //Откл звонок
    SetOut(0,1,0x01);           //Закрыть Кл-НАП1
    sh_=0;
    goto L101;
L8: if(!(zin[0]&0x2000))
        goto L101;
    SetOut(0,1,0x01);               //Закрыть Кл-НАП1
    otvet=0;
    sh_=0;
    goto L101;
L9: if(!(zin[0]&0x2000)&&(otvet))
        sh_=0;
    goto L101;
L10:VIDK_KAS(1,ABS,par_t[7],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета в положение определения п/д
    if(sh_)goto L101;
    OPR_ZAGR_KAS();//подпрограмма проверки загруженных п/д в кассету
    if((SOST_V!=1)&&(SOST_N!=1))
    {
        otvet=0;
        shr[3]=42;
        goto L101;
    }
    shr[2]=1;                       //активизация режима 2
    sh[2]=1;                        //откачка шлюза
    goto L101;
L11:if(shr[2])goto L101;
    sh_=0;
    goto L101;
L12:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>nasmod[0])
    {
        diagn[8]|=0x20;                //отказ "Нет высокого вакуума в камере"
        goto L101;
    }
    diagn[8]&=(~0x20);                 //сброс диагностики
    sh_=0;
    goto L101;
L13:Klapan(1,&ShZatvShl);//Открыть Щелевой завтвор
    if(sh_) goto L101;
    if(SOST_V==1)
    {
        RAB_NIJN=0;
        goto L101;
    }
    RAB_NIJN=1;
    shr[3]=26;                      //переход на шаг 27
    goto L101;
L14:VIDK_PER(1,ABS,par_t[2],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кассету
    goto L101;
L15:VIDK_KAS(1,OTN,-par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вниз на h1
    goto L101;
L16:if(zin[5]&0x1000)
    {
        diagn[8]&=(~0x40);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                    //отказ "нет п/д на приводе горизонтального перемещения"
    goto L101;
L17:Klapan(1,&Shv);//Зафиксировать схват
    if(sh_)goto L101;
    if(RAB_NIJN)
        SOST_N=2;
    else
        SOST_V=2;
    sh_=0;
    goto L101;
L18:PER_HOME(10);//ПГП в HOME
    goto L101;
L19:Klapan(0,&ShZatvShl);//Закрыть Щелевой затвор
    goto L101;
L20:Klapan(0,&Shv);//Расфиксировать схват
    goto L101;
L21:if(zin[5]&0x1000)
    {
        diagn[8]&=(~0x40);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                    //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L22:VIDK_POD(1,ABS,par_t[5],AZ_drive[2]->data_mech.v_mech[0],10,0);//ПВП вверх в позицию переукладки
    if(sh_)goto L101;
    if(RAB_NIJN==0)
        SOST_V=3;
    else
        SOST_N=3;
    goto L101;
L23:VIDK_PER(1,ABS,par_t[4],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в рабоч положение
    if(sh_)goto L101;
    if(nasmod[14]==1)
    {
        PR_NALADKA=1;
        goto L101;
    }
    shr[4]=1;                   //активизация режима 4
    sh[4]=1;                    //Технологический процесс
    shr[3]=24;                  //переход на шаг 25
    goto L101;
L24:if(nasmod[14]==1)goto L101;
    PR_NALADKA=0;
    shr[3]=25;
    goto L25_1;
L25:if(shr[4])goto L101;
L25_1:if(shr[29])
    {
        shr[30]=1;              //активизация режима 30
        sh[30]=1;               //отключение нагрева п/д
    }
    sh_=0;
    goto L101;
L26:if(shr[30])goto L101;
    if(PR_VR)
    {
        SetOut(0,3,0x200);          //M0 привода вращения п/д
        shr[3]=27;          //переход на шаг 28
        sh_=0;
        goto L101;
    }
    shr[3]=28;              //переход на шаг 29
    sh_=0;
    goto L101;
L27:VIDK_KAS(1,OTN,par_t[0],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вверх на h
    if(sh_)goto L101;
    shr[3]=13;          //переход на шаг 14
    goto L101;
L28:VR_NEXT(20,0);//отключить вращение п/д  с остановкой в HOME
    goto L101;
L29:PER_HOME(10);//ПГП в HOME
    goto L101;
L30:POD_HOME(10);//ПВП в HOME
    goto L101;
L31:if(zin[5]&0x1000)           //опрос датчика наличия п/д на ПГП
    {
        diagn[8]&=(~0x40);         //сброс диагностики
        if(RAB_NIJN==0)
            SOST_V=2;
        else
            SOST_N=2;
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L32:Klapan(1,&Shv);//Зафиксировать схват
    goto L101;
L33:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=nasmod[0])
    {
        diagn[8]&=(~0x20);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x20;                    //отказ "Нет высокого вакуума в камере"
    goto L101;
L34:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=nasmod[2])
    {
        diagn[8]&=(~0x80);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x80;                    //отказ "Нет высокого вакуума в шлюзе"
    goto L101;
L35:Klapan(1,&ShZatvShl);//Открыть Щелевой затвор
    goto L101;
L36:VIDK_PER(1,ABS,par_t[2],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кассету
    goto L101;
L37:Klapan(0,&Shv);//Расфиксировать схват
    goto L101;
L38:if(zin[5]&0x1000)           //опрос датчика наличия п/д на ПГП
    {
        diagn[8]&=(~0x40);         //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L39:VIDK_KAS(1,OTN,par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вверх на h1
    if(sh_)goto L101;
    if(RAB_NIJN==0)
    {
        SOST_V=1;
        if(SOST_N!=1)
            shr[3]=40;          //переход на шаг 41
        goto L101;
    }
    SOST_N=1;
    shr[3]=40;                  //переход на шаг 41
    goto L101;
L40:VIDK_PER(1,ABS,par_t[3],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в камеру
    if(sh_)goto L101;
    RAB_NIJN=1;
    shr[3]=26;                  //переход на шаг 27
    goto L101;
L41:PER_HOME(10);//ПГП в HOME
    goto L101;
L42:Klapan(0,&ShZatvShl);//Закрыть щелевой затвор
    if(sh_)goto L101;
    shr[3]=2;                   //переход на шаг 3
    goto L101;
L43:if(otvet==0)goto L101;
    if(otvet==1)
    {
        sh_=0;
        goto L101;
    }
    shr[3]=45;                  //выход
    sh_=0;
    goto L101;
L44:if((zin[0]&0x2000))goto L101;
    shr[2]=1;                   //активизация режима 2
    sh[2]=1;                    //откачка шлюза
    sh_=0;
    goto L101;
L45:if(shr[2])
        goto L101;
    sh_=0;
    goto L101;
}
//---------------------------------------------------------------------------
void R_4()			//Режим "Технологический процесс"
{
 	sh_ = sh[4];

    if (shr[4] < 1 || shr[4] > 27) goto L100;
	if (shr[4] < 10) goto L00;
	if (shr[4] < 20) goto L01;
    else goto L02;

L00:if (shr[4] == 1) goto L1;
	if (shr[4] == 2) goto L2;
	if (shr[4] == 3) goto L3;
	if (shr[4] == 4) goto L4;
	if (shr[4] == 5) goto L5;
	if (shr[4] == 6) goto L6;
	if (shr[4] == 7) goto L7;
	if (shr[4] == 8) goto L8;
	if (shr[4] == 9) goto L9;
L01:if (shr[4] == 10) goto L10;
	if (shr[4] == 11) goto L11;
	if (shr[4] == 12) goto L12;
	if (shr[4] == 13) goto L13;
	if (shr[4] == 14) goto L14;
	if (shr[4] == 15) goto L15;
	if (shr[4] == 16) goto L16;
	if (shr[4] == 17) goto L17;
	if (shr[4] == 18) goto L18;
	if (shr[4] == 19) goto L19;
L02:if (shr[4] == 20) goto L20;
	if (shr[4] == 21) goto L21;
	if (shr[4] == 22) goto L22;
	if (shr[4] == 23) goto L23;
	if (shr[4] == 24) goto L24;
	if (shr[4] == 25) goto L25;
	if (shr[4] == 26) goto L26;
	if (shr[4] == 27) goto L27;


	goto L100;				//выход
	
	// конечный диспетчер режима	
L101:sh[4] = sh_;
	if (sh[4] != 0) goto L100;	// sh_ != 0	
	++shr[4];					// след. шаг сч.шр1
	if (shr[4] > 27) goto L0;	// число шагов режима
	sh[4] = 1;
L100:return;					//возврат в "кольцо"	

L0:	norma = 4;					//норма: "Тех.процесс завершен"
	shr[4] = 0;					
	goto L100;					

L1: T_PROC=0;
    SetOut(1,3,0x200);          //M0 привода вращения п/д
    SetOut(0,3,0x400);          //NEXT привода вращения п/д
    sh_=0;
    goto L101;
L2: VIDK_VR(0,0,0,0,0,0);//Вкл. Вращение п/д (беск)
    if(sh_)goto L101;
    if(par[1][2])
    {
        N_ST=1;
        shr[29]=1;              //активизируем режим 29
        sh[29]=1;               //нагрев п/д
        goto L101;
    }
    N_ST=2;
    shr[4]=6;
    sh_=1;
    goto L6_1;
L3: if(VRTEMP1)
    {
        CT_4=0;
        sh_=0;
    }
    goto L101;
L4: if(CT_4<=par[N_ST][2])
    {
        T_PROC=CT_4;
        goto L101;
    }
    sh_=0;
    goto L101;
L5: if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>nasmod[0])
        goto L101;
    shr[30]=1;                      //активизация режима 30
    sh[30]=1;                       //отключение нагрева п/д
    sh_=0;
    goto L101;
L6: if(shr[30])goto L101;
    T_PROC=0;
    N_ST=2;
L6_1:if(par[N_ST][5])
    {
        sh_=0;
        goto L101;
    }
    shr[4]=27;                      //выход
    sh_=0;
    goto L101;
L7: Klapan(0,&ZaslIsp);//закрыть заслонку испарителя
    goto L101;
L8: ResetTh();							//обнуление толщины
    goto L101;
L9: VIDK_TOLSH(1,15,0x01);				//передача N плёнки(FILM) на измеритель толщины
    goto L101;
L10:VIDK_ELU(1,13,0x08,0,7);			//Передача N процесса на контроллер ЭЛУ
    goto L101;
L11:VUEL();								//Включить высокое V на ЭЛУ
    goto L101;
L12:VIDK_ELU(4,13,0x40,0,7);			//Задание N тигля на контроллер ЭЛУ
    goto L101;
L13:VIDK_ELU(5,13,0x80,0,30);			//опрос тигля в позиции (перемещение тигля)
    goto L101;
L14:VIDK_PPD(1,1,RoundTo(IMP60*(par[N_ST][8]-1),0),AZ_drive[4]->data_mech.v_mech[0],10,0);//Выбор датчика толщины (таблетка - в револьверной головке)
    if(sh_)goto L101;
    shr[38]=1;                      //активизируем режим 38
    sh[38]=1;                       //Рэмпинг тока эмиссии
    goto L101;
L15:if(shr[38])goto L101;
    CT_4=0;
    SetOut(1,4,0x20);               //обнулить толщину
    if(par[N_ST][4]==1)
    {
        sh_=0;
        goto L101;
    }
    shr[4]=16;                      //переход на шаг 16_1
    goto L16_1;
L16:if(CT_4<=nasmod[8])goto L101;
L16_1:if(par[N_ST][4]==2)
    {
        sh_=0;
        goto L101;
    }
    shr[4]=17;                      //переход на шаг 17_1
    goto L17_1;
L17:if(CT_4<=nasmod[9])goto L101;
L17_1:if(par[N_ST][4]==3)
    {
        sh_=0;
        goto L101;
    }
    shr[4]=18;
    goto L18_1;                      //переход на шаг 18_1
L18:if(CT_4<=nasmod[10])goto L101;
L18_1:if(par[N_ST][4]==4)
    {
        sh_=0;
        goto L101;
    }
    shr[4]=19;
    goto L19_1;                      //переход на шаг 19_1
L19:if(CT_4<=nasmod[11])goto L101;
L19_1:if(par[N_ST][4]==5)
    {
        sh_=0;
        goto L101;
    }
    shr[4]=20;
    goto L20_1;                      //переход на шаг 20_1
L20:if(CT_4<=nasmod[12])goto L101;
L20_1:if(par[N_ST][4]==6)
    {
        sh_=0;
        goto L101;
    }
    shr[4]=21;                       //переход на шаг 22
    sh_=0;
    goto L101;
L21:if(CT_4<=nasmod[13])goto L101;
    sh_=0;
    goto L101;
L22:Klapan(1,&ZaslIsp);//Открыть заслонку испарителя
    if(sh_)goto L101;
    SetOut(0,4,0x20);               //снять обнуление толщины
    if(par[N_ST][2])
    {
        CT_4=0;
        shr[4]=23;                  //переход на шаг 23
    }
    goto L101;
L23:if(!(zin[3]&0x8000))           //уставка по толщине достигнута
        goto L101;
    shr[4]=24;                      //переход на шаг 25
    sh_=0;
    goto L101;
L24:if(CT_4<=par[N_ST][2])
    {
        T_PROC=CT_4;
        goto L101;
    }
    sh_=0;
    goto L101;
L25:Klapan(0,&ZaslIsp);//Закрыть заслонку испарителя
    if(sh_)goto L101;
    shr[37]=1;                      //активизация режима 37
    sh[37]=1;                       //Отключение ЭЛУ
    goto L101;
L26:if(shr[37])goto L101;
    sh_=0;
    goto L101;
L27:OUEL();//Выключить высокое V ЭЛУ
    if(sh_)goto L101;
    T_PROC=0;
    N_ST++;
    if(N_ST>N_ST_MAX)goto L101;
    shr[4]=6;
    sh_=1;
    goto L6_1;

}
//---------------------------------------------------------------------------
void R_5()            // Режим "Сброс РЦ"
{
	sh_ = sh[5];

    if (shr[5] < 1 || shr[5] > 35) goto L100;
	if (shr[5] < 10) goto L00;
	if (shr[5] < 20) goto L01;
    if (shr[5] < 30) goto L02;
    goto L03;

L00:if (shr[5] == 1) goto L1;
	if (shr[5] == 2) goto L2;
	if (shr[5] == 3) goto L3;
	if (shr[5] == 4) goto L4;
	if (shr[5] == 5) goto L5;
	if (shr[5] == 6) goto L6;
	if (shr[5] == 7) goto L7;
    if (shr[5] == 8) goto L8;
    if (shr[5] == 9) goto L9;
L01:if (shr[5] == 10) goto L10;
    if (shr[5] == 11) goto L11;
	if (shr[5] == 12) goto L12;
	if (shr[5] == 13) goto L13;
	if (shr[5] == 14) goto L14;
	if (shr[5] == 15) goto L15;
	if (shr[5] == 16) goto L16;
	if (shr[5] == 17) goto L17;
    if (shr[5] == 18) goto L18;
    if (shr[5] == 19) goto L19;
L02: if (shr[5] == 20) goto L20;
    if (shr[5] == 21) goto L21;
	if (shr[5] == 22) goto L22;
	if (shr[5] == 23) goto L23;
	if (shr[5] == 24) goto L24;
	if (shr[5] == 25) goto L25;
	if (shr[5] == 26) goto L26;
    if (shr[5] == 27) goto L27;
    if (shr[5] == 28) goto L28;
    if (shr[5] == 29) goto L29;
L03: if (shr[5] == 30) goto L30;
    if (shr[5] == 31) goto L31;
    if (shr[5] == 32) goto L32;
    if (shr[5] == 33) goto L33;
    if (shr[5] == 34) goto L34;
    if (shr[5] == 35) goto L35;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[5] = sh_;
	if (sh[5] != 0) goto L100;		// sh_ != 0
	++shr[5];						// след. шаг сч.шр2
	if (shr[5] > 35) goto L0;		// число шагов режима
	sh[5] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 5;						// норма: "Сброс РЦ завершен"
	shr[5] = 0;
	goto L100;

L1: if((!PR_PER)&&(!PR_KAS)&&(!PR_POD)&&(!PR_PPD)&&(!PR_VR))
    {
        shr[5]=5;                   //переход на шаг 5_2
        goto L5_2;
    }
    CT_5=0;
    sh_=0;
    goto L101;
L2: if(PR_PER)
    {
        if(CT_5>=T_DVIJ)
        {
            diagn[24]|=0x04;        //отказ "Отказ привода горизонт. перемещ."
            shr[5]=5;
            goto L5_1;              //переход на шаг 5_1
        }
        goto L101;
    }
    sh_=0;
    goto L101;
L3: if(PR_KAS)
    {
        if(CT_5>=T_DVIJ)
        {
            diagn[24]|=0x01;        //отказ "Отказ привода кассеты"
            shr[5]=5;
            goto L5_1;              //переход на шаг 5_1
        }
        goto L101;
    }
    sh_=0;
    goto L101;
L4: if(PR_POD)
    {
        if(CT_5>=T_DVIJ)
        {
            diagn[24]|=0x02;        //отказ "Отказ привода вертик. перемещ."
            shr[5]=5;
            goto L5_1;              //переход на шаг 5_1
        }
        goto L101;
    }
    sh_=0;
    goto L101;
L5: if(PR_PPD)
    {
        if(CT_5>=T_DVIJ)
        {
            diagn[24]|=0x08 ;        //отказ "Отказ привода поворота датчика"
            goto L5_1;              //переход на шаг 5_1
        }
        goto L101;
    }
L5_1:SBROS_MEH();                   //Стоп механизмов
L5_2:SetOut(0,1,0x07);              //Закрыть Кл-НАП1-3
    SetOut(0,2,0x8000);             //Откл звонок 1
    SetOut(0,4,0x1000);             //Откл звонок 2
    SetOut(0,4,0x100);              //Откл прерывистую индикацию
    zshr3=shr[3];
    shr[3]=0;                       //сброс активации режима 3
    sh[3]=0;                        //"Рабочий цикл"
    shr[2]=0;                       //сброс активации режима 2
    sh[2]=0;                        //"Откачка шлюза"
    shr[4]=0;                       //сброс активации режима 4
    sh[4]=0;                        //"Технологический процесс"
    for(int i=0;i<DIAGN_COUNT;i++)
        if((i != 14)&&(i != 24)&&(i != 28)) diagn[i] = 0;// сброс диагностик кроме аварийных
    if(shr[1])
    {
        shr[5]=32;                  //выход
        sh_=0;
        goto L101;
    }
    if((shr[36])||(shr[38]))
    {
        shr[37]=1;                  //Активизация режима 37
        sh[37]=1;                   //"Отключение ЭЛУ"
    }
    sh_=0;
    goto L101;
L6: if(shr[37])goto L101;
    if(shr[29])
    {
        shr[30]=1;                  //активизация режима 30
        sh[30]=1;                   //"Отключение нагрева п/д"
    }
    shr[5]=31;                      //переход на шаг 32
    sh_=0;
    goto L101;
L7: VR_HOME(10);//Привод вращения п/д в HOME
    goto L101;
L8: Klapan(0,&ZaslIsp);//Закрыть заслонку исп
    if(sh_)goto L101;
    if(shr[8])
    {
        shr[5]=32;                  //выход
        goto L101;
    }
    if(zshr3<=13)
        goto L101;
    if(zshr3==27)
    {
        shr[5]=9;                   //переход на шаг 10
        goto L101;
    }
    if(zshr3==14)
    {
        shr[5]=10;                  //переход на шаг 11
        goto L101;
    }
    if((zshr3==15)||(zshr3==16))
    {
        shr[5]=33;                  //переход на шаг 34
        goto L101;
    }
    if(zshr3==17)
    {
        shr[5]=13;                  //переход на шаг 14
        goto L101;
    }
    if(zshr3==18)
    {
        shr[5]=14;                  //переход на шаг 15
        goto L101;
    }
    if(zshr3==19)
    {
        shr[10]=1;                  //активизация режима 10
        sh[10]=1;                   //"Открыть ЩЗ"
        shr[5]=15;                  //переход на шаг 16
        goto L101;
    }
    if((zshr3==20)||(zshr3==21))
    {
        shr[5]=16;                  //переход на шаг 17
        goto L101;
    }
    if(zshr3==22)
    {
        shr[5]=18;                  //переход на шаг 19
        goto L101;
    }
    if((zshr3>=23)&&(zshr3<=29))
    {
        shr[5]=19;                  //переход на шаг 20
        goto L101;
    }
    if((zshr3>=30)&&(zshr3<=31))
    {
        shr[5]=18;                  //переход на шаг 19
        goto L101;
    }
    if((zshr3>=32)&&(zshr3<=36))
    {
        if(RAB_NIJN==0)
            SOST_V=1;
        else
            SOST_N=1;
        shr[5]=17;                  //переход на шаг 18
        goto L101;
    }
    if((zshr3==37)||(zshr3==38))
    {
        shr[5]=21;                  //переход на шаг 22
        goto L101;
    }
    if((zshr3>=39)&&(zshr3<=42))
    {

        shr[5]=34;                  //переход на шаг 35
        goto L101;
    }
    shr[5]=35;                      //выход
    goto L101;
L9: Klapan(0,&ShZatvShl);//Закрыть ЩЗ
    if(sh_)goto L101;
    shr[5]=22;                      //переход на шаг 23
    goto L101;
L10:KAS_HOME(10);//Кассета в HOME
    if(sh_)goto L101;
    shr[5]=8;                       //переход на шаг 9
    goto L101;
L11:PER_HOME(10);//ПГП в HOME
    if(sh_)goto L101;
    shr[5]=9;                       //переход на шаг 10
    goto L101;
L12:if(zin[5]&0x1000)
    {
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                    //Отказ "Нет п/д на ПГП"
    goto L101;
L13:VIDK_KAS(1,OTN,par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вверх на h1
    if(sh_)goto L101;
    if(RAB_NIJN==0)
        SOST_V=1;
    else
        SOST_N=1;
    shr[5]=10;                      //переход на шаг 11
    goto L101;
L14:Klapan(0,&Shv);//Расфиксировать схват
    if(sh_)goto L101;
    shr[5]=32;                      //переход на шаг 33
    goto L101;
L15:VIDK_PER(1,ABS,par_t[2],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кассету
    if(sh_)goto L101;
    shr[5]=13;                      //переход на шаг 14
    goto L101;
L16:if(shr[10])goto L101;
    shr[5]=14;                      //переход на шаг 15
    sh_=0;
    goto L101;
L17:if(zin[5]&0x1000)
    {
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                    //Отказ "Нет п/д на ПГП"
    goto L101;
L18:Klapan(1,&Shv);//Зафиксировать схват
    if(sh_)goto L101;
    shr[5]=15;
    shr[10]=1;                      //активиз. режим 10
    sh[10]=1;                       //"Открыть ЩЗ"
    goto L101;
L19:POD_HOME(10);//ПВП в HOME
    if(sh_)goto L101;
    if(RAB_NIJN==0)
        SOST_V=2;
    else
        SOST_N=2;
    shr[5]=20;                  //переход на шаг 21
    goto L101;
L20:PER_HOME(10);//ПГП в HOME
    if(sh_)goto L101;
    shr[5]=18;                      //переход на шаг 19
    goto L101;
L21:if(zin[5]&0x1000)
    {
        shr[5]=17;                  //переход на шаг 18
        if(RAB_NIJN==0)
            SOST_V=2;
        else
            SOST_N=2;
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                    //Отказ "Нет п/д на ПГП"
    goto L101;
L22:if(zin[5]&0x1000)
    {
        shr[5]=13;                  //переход на шаг 14
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                    //Отказ "Нет п/д на ПГП"
    goto L101;
L23:Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шл
    goto L101;
L24:Klapan(0,&KlShl);//Закрыть Фк шл
    goto L101;
L25:KAS_HOME(10);//Кассета в HOME
    if(sh_)goto L101;
    if(!(zin[0]&0x2000) )
    {
        CT_5=0;
        SetOut(1,1,0x01);           //Открыть Кл-НАП1
        goto L101;
    }
    SetOut(0,1,0x01);           //Закрыть Кл-НАП1
    otvet=0;
    shr[5]=28;                  //переход на шаг 29
    goto L101;
L26:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if((D_D1>UATM)||((zin[0]&0x2000)))
    {
        diagn[8]&=(~0x10);             //сброс диагностики
        SetOut(1,2,0x8000);             //Вкл звонок 1
        SetOut(1,4,0x1000);             //Вкл звонок 2
        SetOut(1,4,0x100);              //Вкл прерывистую индикацию
        CT_5=0;
        sh_=0;
        goto L101;
    }
    if(CT_5>=T_KNAP)
        diagn[8]|=0x10;                    //отказ "Медленный напуск в шлюз"
    goto L101;
L27:if(CT_5>T_NAPUSK)
    {
        SetOut(0,2,0x8000);             //Откл звонок 1
        SetOut(0,4,0x1000);             //Откл звонок 2
        SetOut(0,4,0x100);              //Откл прерывистую индикацию
        SetOut(0,1,0x01);           //Закрыть Кл-НАП1
        sh_=0;
    }
    goto L101;
L28:if(!(zin[0]&0x2000))
    {
        SetOut(0,1,0x01);           //Закрыть Кл-НАП1
        otvet=0;
        sh_=0;
    }
    goto L101;
L29:if(otvet==0)
        goto L101;
    if(otvet!=1)
        shr[5]=35;                  //выход
    sh_=0;
    goto L101;
L30:if(!(zin[0]&0x2000))
    {
        shr[2]=1;                   //активизация режима 2
        sh[2]=1;                    //"Откачка шлюза"
        sh_=0;
    }
    goto L101;
L31:if(shr[2])goto L101;
    shr[5]=35;                      //выход
    sh_=0;
    goto L101;
L32:if(shr[30])goto L101;
    shr[5]=6;                       //переход на шаг 7
    sh_=0;
    goto L101;
L33:if(!(zin[5]&0x1000))
    {
        diagn[8]|=0x40;                    //Отказ "Нет п/д на ПГП"
        goto L101;
    }
    sh_=0;
    shr[5]=12;                      //переход на шаг 13
    goto L101;
L34:if(diagn[24]&0x01)
        goto L101;
    shr[5]=11;                      //переход на шаг 12
    sh_=0;
    goto L101;
L35:if(diagn[24]&0x01)
        goto L101;
    if(RAB_NIJN==0)
        SOST_V=1;
    else
        SOST_N=1;
    shr[5]=10;                      //переход на шаг 11
    sh_=0;
    goto L101;
}
//---------------------------------------------------------------------------
void R_6 ()            // Режим "Сбор/выгрузка пластин"
{
	sh_ = sh[6];

	if (shr[6] < 1 || shr[6] > 32) goto L100;
	if (shr[6] < 10) goto L00;
    if (shr[6] < 20) goto L01;
	else goto L02;

L00:if (shr[6] == 1) goto L1;
	if (shr[6] == 2) goto L2;
	if (shr[6] == 3) goto L3;
	if (shr[6] == 4) goto L4;
	if (shr[6] == 5) goto L5;
	if (shr[6] == 6) goto L6;
	if (shr[6] == 7) goto L7;
	if (shr[6] == 8) goto L8;
	if (shr[6] == 9) goto L9;
L01:if (shr[6] == 10) goto L10;
	if (shr[6] == 11) goto L11;
	if (shr[6] == 12) goto L12;
	if (shr[6] == 13) goto L13;
	if (shr[6] == 14) goto L14;
	if (shr[6] == 15) goto L15;
	if (shr[6] == 16) goto L16;
	if (shr[6] == 17) goto L17;
	if (shr[6] == 18) goto L18;
	if (shr[6] == 19) goto L19;
L02:if (shr[6] == 20) goto L20;
    if (shr[6] == 21) goto L21;
	if (shr[6] == 22) goto L22;
	if (shr[6] == 23) goto L23;
	if (shr[6] == 24) goto L24;
	if (shr[6] == 25) goto L25;
	if (shr[6] == 26) goto L26;
	if (shr[6] == 27) goto L27;
	if (shr[6] == 28) goto L28;
	if (shr[6] == 29) goto L29;
    if (shr[6] == 30) goto L30;
    if (shr[6] == 31) goto L31;
    if (shr[6] == 32) goto L32;

	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[6] = sh_;
	if (sh[6] != 0) goto L100;			// sh_ != 0
	++shr[6];							// след. шаг сч.шр1
	if (shr[6] > 32) goto L0;			// число шагов режима
	sh[6] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma = 6;							// норма: "Сбор пластин завершен"
	shr[6] = 0;
	goto L100;
	
L1: SetOut(0,1,0x07);                 //закрыть кл НАП 1-2-3
    if(!(zin[5]&0x1000))                //Опрос П/д на ПГП
        shr[6]=19;                    //переход на шаг 20
    sh_=0;
    goto L101;
L2: if(diagnS[2]&0x08)				// пока нет связи с контролером ПГП
		goto L101;
    if(TEK_ABS_PER!=par_t[2])       //ПГП в шлюзе
        shr[6]=6;                   //переход на шаг 7
    sh_=0;
    goto L101;
L3: if(diagnS[2]&0x02)				// пока нет связи с контролером кассеты
		goto L101;
    if((TEK_ABS_KAS>=-2)&&(TEK_ABS_KAS<=2))
        shr[6]=5;                   //переход на шаг 6
    sh_=0;
    goto L101;
L4: if(diagnS[2]&0x02)				// пока нет связи с контролером кассеты
		goto L101;
    if((TEK_ABS_KAS>=-par_t[1])&&(TEK_ABS_KAS<0))
        shr[6]=5;                   //переход на шаг 6
    sh_=0;
    goto L101;
L5: if(diagnS[2]&0x02)				// пока нет связи с контролером кассеты
		goto L101;
    if(TEK_ABS_KAS==par_t[0])
    {
        shr[6]=19;                  //переход на шаг 20
        sh_=0;
        goto L101;
    }
    if((TEK_ABS_KAS>=par_t[0]-par_t[1])&&(TEK_ABS_KAS<par_t[0]))
    {
        shr[6]=18;                  //переход на шаг 19
        sh_=0;
        goto L101;
    }
    diagn[11]|=0x40;                    //отказ "Кассета не в позиции Загрузка/Выгрузка"
    shr[6]=31;                      //Выход
    sh_=0;
    goto L101;
L6: KAS_HOME(10);//Кассета в HOME
    if(sh_)goto L101;
    shr[6]=19;                      //переход на шаг 20
    goto L101;
L7: if(diagnS[2]&0x08)				// пока нет связи с контролером ПГП
		goto L101;
    if((TEK_ABS_PER>=-2)&&(TEK_ABS_PER<=2))
        shr[6]=8;                   //переход на шаг 9
    sh_=0;
    goto L101;
L8: if(diagnS[2]&0x08)				// пока нет связи с контролером ПГП
		goto L101;
    if((TEK_ABS_PER>=par_t[4])&&(TEK_ABS_PER<0))
    {
        sh_=0;
        goto L101;
    }
    shr[10]=1;                      //активиз. режима 10
    sh[10]=1;                       //"Открыть щелевой затвор"
    shr[6]=31;                      //переход на шаг 32
    sh_=0;
    goto L101;
L9: PER_HOME(10);//ПГП в HOME
    goto L101;
L10:POD_HOME(10);//ПВП в HOME
    goto L101;
L11:VR_HOME(10);//Вращ в HOME
    goto L101;
L12:KAS_HOME(10);//Кас в HOME
    if(sh_)goto L101;
    OPR_ZAGR_KAS();//подпрограмма проверки загруженных п/д в кассету
    if(SOST_V!=1)
        goto L101;
    if(SOST_N==1)
    {
        diagn[11]|=0x80;    //отказ "Нет свободного паза для выгрузки п/д"
        shr[6]=32;      //выход
        goto L101;
    }
    shr[6]=13;          //переход на шаг 14
    goto L101;
L13:VIDK_KAS(1,ABS,-par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кас в -par_t[1]
    if(sh_)goto L101;
    shr[10]=1;          //активиз. режима 10
    sh[10]=1;           //"Открыть Щелевой затвор"
    shr[6]=14;          //переход на шаг 15
    goto L101;
L14:VIDK_KAS(1,ABS,par_t[0]-par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета в положение (par_t[0]-par_t[1])
    if(sh_)goto L101;
    shr[10]=1;          //активиз. режима 10
    sh[10]=1;           //"Открыть Щелевой затвор"
    goto L101;
L15:if(shr[10])
        goto L101;
    sh_=0;
    goto L101;
L16:VIDK_PER(1,ABS,par_t[2],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в par_t[2]
    goto L101;
L17:VIDK_KAS(1,OTN,par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета на par_t[1]
    if(sh_)goto L101;
    shr[6]=19;              //переход на шаг 20
    goto L101;
L18:VIDK_PER(1,ABS,par_t[6],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в par_t[6]
    if(sh_)goto L101;
    shr[6]=11;              //переход на шаг 12
    goto L101;
L19:VIDK_KAS(1,ABS,par_t[0],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета в par_t[0]
    goto L101;
L20:PER_HOME(10);//ПГП в HOME
    goto L101;
L21:POD_HOME(10);//ПВП в HOME
    goto L101;
L22:VR_HOME(10);//Вращ в HOME
    goto L101;
L23:KAS_HOME(10);//Кас в HOME
    if(sh_)goto L101;
    OPR_ZAGR_KAS();//подпрограмма проверки загруженных п/д в кассету
    if((SOST_V!=1)&&(SOST_N!=1))
        shr[6]=32;          //выход
    goto L101;
L24:Klapan(0,&ShZatvShl);//Закрыть Щелевой затвор
    goto L101;
L25:Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шлюза
    goto L101;
L26:Klapan(0,&KlShl);//Закрыть ФК-Шл
    if(sh_)goto L101;
    if((zin[0]&0x2000))
    {
        SetOut(0,1,0x01);       //Закрыть Кл-НАП1
        otvet =0;
        shr[6]=29;
        goto L101;
    }
    CT_6=0;
    SetOut(1,1,0x01);           //Открыть Кл-НАП1
    goto L101;
L27:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if((D_D1>UATM)||((zin[0]&0x2000)))
    {
        diagn[8]&=(~0x10);             //сброс диагностики

        SetOut(1,2,0x8000);
        SetOut(1,4,0x1100);         //Включить звонок
        CT_6=0;
        sh_=0;
        goto L101;
    }
    if(CT_6>=T_KNAP)
        diagn[8]|=0x10;                //отказ "Медленный напуск в шлюз"
    goto L101;
L28:if(CT_6<=T_NAPUSK)
        goto L101;
    SetOut(0,2,0x8000);
    SetOut(0,4,0x1100);         //Отключить звонок
    SetOut(0,1,0x01);       //Закрыть Кл-НАП1
    sh_=0;
    goto L101;
L29:if(!(zin[0]&0x2000))
        goto L101;
    otvet=0;
    sh_=0;
    goto L101;
L30:if(otvet==0)
        goto L101;
    if(otvet==1)
    {
        shr[2]=1;           //активиз. режим 2
        sh[2]=1;            //"Откачка шлюза"
        sh_=0;
        goto L101;
    }
    shr[6]=32;              //выход
    sh_=0;
    goto L101;
L31:if(shr[2])
        goto L101;
    shr[6]=32;              //выход
    sh_=0;
    goto L101;
L32:if(shr[10])
        goto L101;
    shr[6]=17;              //переход на шаг 18
    sh_=0;
    goto L101;







}
//---------------------------------------------------------------------------
void R_7 ()							// Режим "Отключение установки"
{
	sh_ = sh[7];

    if (shr[7] < 1 || shr[7] > 34) goto L100;
	if (shr[7] < 10) goto L00;
    if (shr[7] < 20) goto L01;

	else goto L02;


L00:if (shr[7] == 1) goto L1;
	if (shr[7] == 2) goto L2;
	if (shr[7] == 3) goto L3;
	if (shr[7] == 4) goto L4;
	if (shr[7] == 5) goto L5;
	if (shr[7] == 6) goto L6;
	if (shr[7] == 7) goto L7;
	if (shr[7] == 8) goto L8;
	if (shr[7] == 9) goto L9;
L01:if (shr[7] == 10) goto L10;
	if (shr[7] == 11) goto L11;
	if (shr[7] == 12) goto L12;
	if (shr[7] == 13) goto L13;
	if (shr[7] == 14) goto L14;
	if (shr[7] == 15) goto L15;
	if (shr[7] == 16) goto L16;
	if (shr[7] == 17) goto L17;
	if (shr[7] == 18) goto L18;
	if (shr[7] == 19) goto L19;
L02:if (shr[7] == 20) goto L20;
	if (shr[7] == 21) goto L21;
	if (shr[7] == 22) goto L22;
	if (shr[7] == 23) goto L23;
    if (shr[7] == 24) goto L24;
    if (shr[7] == 25) goto L25;
    if (shr[7] == 26) goto L26;
    if (shr[7] == 27) goto L27;
    if (shr[7] == 28) goto L28;
    if (shr[7] == 29) goto L29;
    if (shr[7] == 30) goto L30;
    if (shr[7] == 31) goto L31;
    if (shr[7] == 32) goto L32;
    if (shr[7] == 33) goto L33;
    if (shr[7] == 34) goto L34;
	else goto L100;			// выход

	// конечный диспетчер режима
L101:sh[7] = sh_;
	if (sh[7] != 0) goto L100;			// SH != 0
	++shr[7];							// след. шаг сч.шр5
	if (shr[7] > 34) goto L0;			// число шагов режима
	sh[7] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma 	= 7;						// норма: "Отключение установки завершено"
	shr[7] 	= 0;
	goto L100;
	
L1: SetOut(0,1,0x07);                   //Закрыть Кл-НАП1-3
    shr[1]=0;                           //сброс активации режима 1
    sh[1]=0;
    sh_=0;
    goto L101;
L2: OUEL();//выключить высокое U ЭЛУ
    if(sh_)goto L101;
    SBROS_MEH();
    if(zin[4]&0x400)//ПВП в HOME
    {
        shr[7]=32;                      //переход на шаг 33
        goto L101;
    }
    if(zin[4]&0x10)//ПГП в HOME
    {
        shr[7]=31;                      //переход на шаг 32
        goto L101;
    }
    goto L101;
L3: VIDK_POD(1,ABS,par_t[5],AZ_drive[2]->data_mech.v_mech[0],10,0);//ПВП в раб поз
    goto L101;
L4: VR_HOME(10);//Вращ в HOME
    if(sh_)goto L101;
    shr[7]=30;                          //переход на шаг 31
    goto L101;
L5: KAS_HOME(10);//Кассета в HOME
    goto L101;
L6: Klapan(0,&ShZatvShl);//Закрыть ЩЗ
    goto L101;
L7: Klapan(1,&EkrZatv);//Экран затвора исп вверх (открыть)
    goto L101;
L8: Klapan(0,&ZatvIsp);//Закрыть затвор испарителя
    goto L101;
L9: Klapan(0,&ZaslIsp);//Закрыть заслонку испарителя
    goto L101;
L10:Klapan(0,&ZatvTmnIsp);//Закрыть затвор ТМН исп
    goto L101;
L11:Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шл
    goto L101;
L12:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L13:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L14:Klapan(0,&KlShl);//Закрыть Фк шл
    if(sh_)goto L101;
    if(zin[5]&0x07)
    {
        SetOut(0,5,0x10);               //Снять пуск ТМН кам
        if(diagn[14]&0x60)
        {
            shr[7]=16;
            goto L16_1;                 //переход на шаг 16_1
        }
        shr[7]=15;                      //переход на шаг 16
        goto L101;
    }
    goto L101;
L15:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    if(sh_)goto L101;
    shr[7]=16;
    goto L16_1;
L16:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    if(sh_)goto L101;
L16_1:if(out[5]&0x08)
    {
        SetOut(0,5,0x08);               //Выкл ТМН исп
        PR_OST_TMN_ISP=1;
        CT_7=0;
        if(diagn[14]&0x60)
        {
            shr[7]=18;                  //переход на шаг 18_1
            goto L18_1;
        }
        shr[7]=17;                      //переход на шаг 18
        goto L101;
    }
    goto L101;
L17:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    if(sh_)goto L101;
    shr[7]=18;
    goto L18_1;
L18:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    if(sh_)goto L101;
L18_1:if(out[5]&0x02)
    {
        SetOut(0,5,0x02);               //ТМН шл выкл
        PR_OST_TMN_SHL=1;
        CT_7=0;
        if(diagn[14]&0x18)
            shr[7]=20;                  //переход на шаг 21
        else
            shr[7]=19;                  //переход на шаг 20
        goto L101;
    }
    goto L101;
L19:Klapan(0,&KlTmnShl);//Закрыть Фк-ТМН шл
    if(sh_)goto L101;
    shr[7]=20;                          //переход на шаг 21
    goto L101;
L20:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шл
    goto L101;
L21:if(zin[5]&0x07)goto L101;
    sh_=0;
    goto L101;
L22:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    if(sh_)goto L101;
    if((PR_OST_TMN_ISP)||(PR_OST_TMN_SHL))

L23:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L24:Klapan(0,&KlTmnShl);//Закрыть Фк-ТМН шл
    goto L101;
L25:Klapan(0,&FvnKam);//Откл. ФВН кам
    goto L101;
L26:Klapan(0,&FvnShl);//Откл. ФВН шл
    if(sh_)goto L101;
    if(shr[29])
    {
        shr[30]=1;                  //активизируем режим 30
        sh[30]=1;
    }
    goto L101;
L27:if(shr[30])
        goto L101;
    if(shr[27])
    {
        shr[28]=1;                  //активизируем режим 28
        sh[28]=1;
    }
    sh_=0;
    goto L101;
L28:if(shr[28])
        goto L101;
    sh_=0;
    goto L101;
L29:VR_HOME(10);//вращение п/д в HOME
    if(sh_)goto L101;
    SetOut(0,3,0x40);               //Откл. чиллер нагрева
    SetOut(0,3,0x100);              //Откл. прогрев камеры
    goto L101;
L30:OBPN();//Отключить БПН
    if(sh_)goto L101;
    shr[7]=34;                      //выход
    goto L101;
L31:PER_HOME(10);//ПГП в HOME
    if(sh_)goto L101;
    shr[7]=31;                      //переход на шаг 32
    goto L101;
L32:POD_HOME(10);//ПВП в HOME
    if(sh_)goto L101;
    shr[7]=4;                       //переход на шаг 5
    goto L101;
L33:PER_HOME(10);//ПГП в Home
    if(sh_)goto L101;
    shr[7]=4;                       //переход на шаг 5
    goto L101;
L34:if(CT_7<=600)
        goto L101;
    PR_OST_TMN_ISP=0;
    PR_OST_TMN_SHL=0;
    shr[7]=22;
    sh_=0;
    goto L101;






}
//---------------------------------------------------------------------------
void R_8 ()							// Режим "Аварийное отключение установки"
{
 	sh_ = sh[8];

	if (shr[8] == 1) goto L1;
	if (shr[8] == 2) goto L2;
	if (shr[8] == 3) goto L3;
	if (shr[8] == 4) goto L4;
    if (shr[8] == 5) goto L5;

	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[8] = sh_;
	if (sh[8] != 0) goto L100;		// SH != 0
	++shr[8];						// след. шаг сч.шр5
	if (shr[8] > 5) goto L0;		// число шагов режима
	sh[8] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 8;						// норма: "Авар. откл. установки завершено"
	shr[8] = 0;
	goto L100;
	
L1: SetOut(0,0,0x404);
    SetOut(1,0,0x808);              //Закрыть затвор ТМН шл и исп
    if(diagn[14]&0x18)
        SetOut(0,0,0x10);           //Закрыть Фк-ТМН шл
    if(diagn[14]&0x60)
    {
        SetOut(0,0,0x1000);         //Фк-ТМН исп закрыть
        SetOut(0,3,0x04);           //Фк-ТМН кам закрыть
    }
    if(!(shr[5]))
    {
        if((shr[3]))
        {
            shr[5]=1;               //активизация режима 5
            sh[5]=1;                //"Сброс рабочего цикла"
            shr[8]=3;               //переход на шаг 4
            sh_=0;
            goto L101;
        }
        if(shr[27])
        {
            shr[28]=1;              //активиз. режим 28
            sh[28]=1;               //"Отключение нагрева шл"
        }
        sh_=0;
        goto L101;
    }
    shr[8]=3;               //переход на шаг 4
    sh_=0;
    goto L101;
L2: if(shr[28])
        goto L101;
    if(shr[29])
    {
        shr[30]=1;          //активизируем режим 30
        sh[30]=1;           //"Отключение нагрева п/д"
    }
    sh_=0;
    goto L101;
L3: if(shr[30])
        goto L101;
    shr[1]=0;               //сброс активиз. режима 1
    sh[1]=0;
    shr[2]=0;               //сброс активиз. режима 2
    sh[2]=0;
    shr[6]=0;               //сброс активиз. режима 6
    sh[6]=0;
    shr[10]=0;              //сброс активиз. режима 10
    sh[10]=0;
    shr[11]=0;              //сброс активиз. режима 11
    sh[11]=0;
    shr[12]=0;              //сброс активиз. режима 12
    sh[12]=0;
    shr[13]=0;              //сброс активиз. режима 13
    sh[13]=0;
    shr[25]=0;              //сброс активиз. режима 25
    sh[25]=0;
    shr[26]=0;              //сброс активиз. режима 26
    sh[26]=0;
    SBROS_MEH();
    for(int i=0;i<DIAGN_COUNT;i++)
        if((i != 14)&&(i != 24)&&(i != 28)) diagn[i] = 0;// сброс диагностик кроме аварийных
    shr[8]=4;
    goto L4_1;              //переход на шаг 4_1
L4: if(shr[5])
        goto L101;
L4_1:if(!(shr[7]))
    {
        shr[7]=1;           //активизируем режим 7
        sh[7]=1;
    }
    sh_=0;
    goto L101;
L5: if(shr[7])
        goto L101;
    sh_=0;
    goto L101;






}
//---------------------------------------------------------------------------
void R_9 ()							// Режим "Транспортный тест"
{
	sh_ = sh[9];

	if (shr[9] < 1 || shr[9] > 28) goto L100;
	if (shr[9] < 10) goto L00;
    if (shr[9] < 20) goto L00;

	else goto L02;

L00:if (shr[9] == 1) goto L1;
	if (shr[9] == 2) goto L2;
	if (shr[9] == 3) goto L3;
	if (shr[9] == 4) goto L4;
	if (shr[9] == 5) goto L5;
	if (shr[9] == 6) goto L6;
	if (shr[9] == 7) goto L7;
	if (shr[9] == 8) goto L8;
	if (shr[9] == 9) goto L9;
L01:if (shr[9] == 10) goto L10;
	if (shr[9] == 11) goto L11;
	if (shr[9] == 12) goto L12;
	if (shr[9] == 13) goto L13;
	if (shr[9] == 14) goto L14;
	if (shr[9] == 15) goto L15;
	if (shr[9] == 16) goto L16;
	if (shr[9] == 17) goto L17;
	if (shr[9] == 18) goto L18;
    if (shr[9] == 19) goto L19;
L02:if (shr[9] == 20) goto L20;
	if (shr[9] == 21) goto L21;
	if (shr[9] == 22) goto L22;
	if (shr[9] == 23) goto L23;
	if (shr[9] == 24) goto L24;
	if (shr[9] == 25) goto L25;
	if (shr[9] == 26) goto L26;
    if (shr[9] == 27) goto L27;
    if (shr[9] == 28) goto L28;
	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[9] = sh_;
	if (sh[9] != 0) goto L100;	// sh_ != 0
	++shr[9];					// след. шаг сч.шр1
	if (shr[9] > 28) goto L0;	// число шагов режима
	sh[9] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 9;					// норма: "Транспортный тест завершен"
	shr[9] = 0;
	goto L100;
	
L1: PR_TRTEST=0;
    SOST_V=0;
    SOST_N=0;
    sh_=0;
    goto L101;
L2: VIDK_KAS(1,ABS,par_t[7],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета в положение определения п/д
    if(sh_)goto L101;
    OPR_ZAGR_KAS();//подпрограмма определения загруженных п/д в кас
    if((SOST_V==1)||(SOST_N==1))
        PR_NAL_PD=1;
    else
    {
        PR_NAL_PD=0;
        SOST_V=1;
        SOST_N=1;
    }
     sh_=0;
     shr[9]=27;                      //переход на шаг 28
     goto L101;
L2_1:if(SOST_V==1)
    {
        RAB_NIJN=0;
        shr[9]=3;                 //переход на шаг 4
    }
    else
    {
        RAB_NIJN=1;
    }

    sh_=0;
    goto L101;
L3: VIDK_KAS(1,OTN,par_t[0],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вверх на h
    goto L101;
L4: VIDK_PER(1,ABS,par_t[2],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кассету
    goto L101;
L5: VIDK_KAS(1,OTN,-par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вверх на h1
    if(sh_)goto L101;
    if((PR_NAL_PD==0)||(nasmod[16]==1))
        shr[9]=6;               //переход на шаг 7
    goto L101;
L6: if(zin[5]&0x1000)           //опрос датчика наличия п/д на ПГП
    {
        diagn[8]&=(~0x40);         //Сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L7: Klapan(1,&Shv);//зафиксировать схват
    if(sh_)goto L101;
    if(RAB_NIJN==0)
        SOST_V=2;
    else
        SOST_N=2;
    goto L101;
L8: PER_HOME(10);//ПГП в HOME
    goto L101;
L9: Klapan(0,&Shv);//Расфиксировать схват
    if(sh_)goto L101;
    if((PR_NAL_PD==0)||(nasmod[16]==1))
        shr[9]=10;              //переход на шаг 11
    goto L101;
L10:if(zin[5]&0x1000)           //опрос датчика наличия п/д на ПГП
    {
        diagn[8]&=(~0x40);         //Сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L11:VIDK_POD(1,ABS,par_t[5],AZ_drive[2]->data_mech.v_mech[0],10,0);//ПВП вверх на поз переукладки
    if(sh_)goto L101;
    if(RAB_NIJN==0)
        SOST_V=3;
    else
        SOST_N=3;
    goto L101;
L12:VIDK_PER(1,ABS,par_t[4],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в раб полож
    if(sh_)goto L101;
    SetOut(1,3,0x200);          //M0 привода вращения п/д
    SetOut(0,3,0x400);          //NEXT привода вращения п/д
    goto L101;
L13:VIDK_VR(0,CON,0,AZ_drive[3]->data_mech.v_mech[0],0,0);//Вкл вращение п/д беск
    if(sh_)goto L101;
    CT_9=0;
    goto L101;
L14:if(CT_9<5)goto L101;
    SetOut(0,3,0x200);          //M0 привода вращения п/д
    sh_=0;
    goto L101;
L15:VR_NEXT(20,0);//Отключить вращение п/д с остановкой в HOME
    goto L101;
L16:PER_HOME(10);//ПГП в HOME
    goto L101;
L17:POD_HOME(10);//ПВП в HOME
    if(sh_)goto L101;
    if((PR_NAL_PD==0)||(nasmod[16]==1))
    {
        shr[9]=18;              //переход на шаг 18_1
        sh_=1;
        goto L18_1;
    }
    goto L101;
L18:if(zin[5]&0x1000)           //опрос датчика наличия п/д на ПГП
    {
        diagn[8]&=(~0x40);         //Сброс диагностики
L18_1:  if(RAB_NIJN==0)
            SOST_V=2;
        else
            SOST_N=2;
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L19:Klapan(1,&Shv);//Зафиксировать схват
    goto L101;
L20:VIDK_PER(1,ABS,par_t[2],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кас
    goto L101;
L21:Klapan(0,&Shv);//Расфиксировать схват
    if(sh_)goto L101;
    if((PR_NAL_PD==0)||(nasmod[16]==1))
        shr[9]=22;              //переход на шаг 2
    goto L101;
L22:if(zin[5]&0x1000)           //опрос датчика наличия п/д на ПГП
    {
        diagn[8]&=(~0x40);         //Сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[8]|=0x40;                //отказ "Нет п/д на приводе горизонтального перемещения"
    goto L101;
L23:VIDK_KAS(1,OTN,par_t[1],AZ_drive[0]->data_mech.v_mech[0],10,0);//Кассета вверх на h1
    if(sh_)goto L101;
    if(RAB_NIJN==0)
    {
        SOST_V=1;
        if(SOST_N==1)
        {
            if(PR_TRTEST==0)
                shr[9]=24;
            else
                shr[9]=25;
            goto L101;
        }
    }
    else
        SOST_N=1;
    if(PR_TRTEST!=0)
        shr[9]=25;
    goto L101;
L24:VIDK_PER(1,ABS,par_t[3],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кам
    if(sh_)goto L101;
    shr[9]=27;
    goto L101;
L25:VIDK_PER(1,ABS,par_t[3],AZ_drive[1]->data_mech.v_mech[0],10,0);//ПГП в кам
    if(sh_)goto L101;
    shr[9]=2;
    RAB_NIJN=1;
    goto L101;
L26:PER_HOME(10);//ПГП в HOME
    goto L101;
L27:KAS_HOME(10);//Кассета в HOME
    if(sh_)goto L101;
    if(PR_NAL_PD==0)
    {
        SOST_V=0;
        SOST_N=0;
    }
    shr[9]=28;                  //выход
    goto L101;
L28:KAS_HOME(10);//Кассета в HOME
    if(sh_)goto L101;
    shr[9]=2;
    sh_=1;
    goto L2_1;                  //переход на шаг 2_1

}
//---------------------------------------------------------------------------
void R_10 ()							// Режим "Открыть ЩЗ"
{
 	sh_ = sh[10];

	if (shr[10] < 1 || shr[10] > 35) goto L100;
	if (shr[10] < 10) goto L00;
    if (shr[10] < 20) goto L01;
    if (shr[10] < 30) goto L02;
	goto L03;

L00:if (shr[10] == 1) goto L1;
	if (shr[10] == 2) goto L2;
	if (shr[10] == 3) goto L3;
	if (shr[10] == 4) goto L4;
	if (shr[10] == 5) goto L5;
	if (shr[10] == 6) goto L6;
	if (shr[10] == 7) goto L7;
	if (shr[10] == 8) goto L8;
	if (shr[10] == 9) goto L9;
L01:if (shr[10] == 10) goto L10;
	if (shr[10] == 11) goto L11;
	if (shr[10] == 12) goto L12;
	if (shr[10] == 13) goto L13;
	if (shr[10] == 14) goto L14;
    if (shr[10] == 15) goto L15;
    if (shr[10] == 16) goto L16;
    if (shr[10] == 17) goto L17;
    if (shr[10] == 18) goto L18;
    if (shr[10] == 19) goto L19;
L02:if (shr[10] == 20) goto L20;
    if (shr[10] == 21) goto L21;
	if (shr[10] == 22) goto L22;
	if (shr[10] == 23) goto L23;
	if (shr[10] == 24) goto L24;
    if (shr[10] == 25) goto L25;
    if (shr[10] == 26) goto L26;
    if (shr[10] == 27) goto L27;
    if (shr[10] == 28) goto L28;
    if (shr[10] == 29) goto L29;
L03:if (shr[10] == 30) goto L30;
    if (shr[10] == 31) goto L31;
	if (shr[10] == 32) goto L32;
	if (shr[10] == 33) goto L33;
	if (shr[10] == 34) goto L34;
    if (shr[10] == 35) goto L35;

	goto L100;
	// конечный диспетчер режима
L101:sh[10] = sh_;
	if (sh[10] != 0) goto L100;		// SH != 0
	++shr[10];						// след. шаг сч.шр5
	if (shr[10] > 35) goto L0;		// число шагов режима
	sh[10] = 1;
L100:return;						// возврат в "кольцо"

L0:
	shr[10] = 0;
	goto L100;

L1: shr[11]=0;                      //сброс активации режима 11
    sh[11]=0;                       //"Закрыть щелевой затвор"
    diagn[4]&=(~0xF0);              //сброс диагностик режима
    sh_=0;
    goto L101;
L2: if((zin[3]&0x30)==0x10)         //ЩЗ строго открыт
    {
        diagn[4]&=(~0x40);             //сброс диагностики
        shr[10]=35;
        sh_=0;
        goto L101;
    }
    if((zin[3]&0x30)==0x20)         //ЩЗ строго закрыт
    {
        diagn[4]&=(~0x40);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[4]|=0x40;                    //отказ "Положение ЩЗ не определено"
    goto L101;
L3: if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UATM)
        shr[10]=6;                  //переход на шаг
    sh_=0;
    goto L101;
L4:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if((D_D1>UATM)||((zin[0]&0x2000)))
    {
        SetOut(0,1,0x01);           //Закрыть Кл-НАП1
        shr[10]=34;                 //переход на шаг 35
    }
    sh_=0;
    goto L101;
L5: Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шл
    goto L101;
L6: Klapan(0,&KlShl);//Закрыть Фк шл
    if(sh_)goto L101;
    SetOut(1,1,0x01);               //Открыть Кл-НАП1
    shr[10]=3;                      //переход на шаг 4
    goto L101;
L7: if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>UVAK_KAM)
    {
        SetOut(0,1,0x02);           //Закрыть Кл-НАП3
        sh_=0;
        goto L101;
    }
    shr[10]=21;                     //переход на шаг 22
    sh_=0;
    goto L101;
L8: Klapan(1,&FvnKam);//Вкл форнасос камеры
    goto L101;
L9: Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L10:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L11:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L12:Klapan(1,&KlKam);//Открыть Фк кам
    goto L101;
L13:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>UVAK_KAM)
    {
        if(out[5]&0x08)             //ТМН исп включён
            sh_=0;
        goto L101;
    }
    if(out[5]&0x08)
    {
        shr[10]=18;                 //переход на шаг 19
        sh_=0;
        goto L101;
    }
    shr[10]=21;                     //переход на шаг 22
    sh_=0;
    goto L101;
L14:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
    shr[10]=12;                     //переход на шаг 13
    sh_=0;
    goto L101;
L15:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L16:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L17:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L18:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    shr[10]=9;                      //переход на шаг 10
    sh_=0;
    goto L101;
L19:Klapan(0,&KlKam);//закрыть Фк кам
    goto L101;
L20:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L21:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L22:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1>UVAK_SHL)
    {
        SetOut(0,1,0x01);           //Закрыть Кл-НАП1
        sh_=0;
        goto L101;
    }
    shr[10]=32;                     //переход на шаг 33
    sh_=0;
    goto L101;
L23:Klapan(1,&FvnShl);//Вкл. Форнасос шл
    goto L101;
L24:if(!(zin[0]&0x2000))              //Дверь шлюза закрыта
    {
        diagn[10]&=(~0x02);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[10]|=0x02;                    //отказ "Дверь шлюза не закрыта"
    goto L101;
L25:Klapan(0,&ZatvTmnShl);//Закрыть затвор ТМН шл
    goto L101;
L26:Klapan(0,&KlTmnShl);//Закрыть Фк ТМН шл
    goto L101;
L27:Klapan(1,&KlShl);//Открыть Фк шл
    goto L101;
L28:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
    if(D_D1<=UVAK_SHL)
    {
        shr[10]=32;                 //переход на шаг 33
        sh_=0;
        goto L101;
    }
    if(out[5]&0x02)                //ТМН шл включён
        sh_=0;
    goto L101;
L29:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2<=UVAKN_TMN)
        shr[10]=27;                     //переход на шаг 28
    sh_=0;
    goto L101;
L30:Klapan(0,&KlShl);//Закрыть Фк шл
    goto L101;
L31:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шл
    goto L101;
L32:if(diagnS[0]&0x02)				// пока нет связи с D2
		goto L101;
    if(D_D2>UVAKV_TMN)
        goto L101;
    shr[10]=25;                     //переход на шаг 26
    sh_=0;
    goto L101;
L33:Klapan(0,&KlShl);//Закрыть Фк шл
    if(sh_)goto L101;
    if(!(out[5]&0x02))
        shr[10]=34;                 //переход на шаг 35
    goto L101;
L34:Klapan(1,&KlTmnShl);//Открыть Фк-ТМН шл
    goto L101;
L35:Klapan(1,&ShZatvShl);//Открыть ЩЗ
    goto L101;

}
//---------------------------------------------------------------------------
void R_11()							// Режим "Закрыть ЩЗ"
{
	sh_ = sh[11];

	if (shr[11] == 1) goto L1;
	if (shr[11] == 2) goto L2;
		else goto L100;				// выход

	// конечный диспетчер режима
L101:sh[11] = sh_;
	if (sh[11] != 0) goto L100;		// SH != 0
	++shr[11];						// след. шаг
	if (shr[11] > 2) goto L0;		// число шагов режима
	sh[11] = 1;
L100:return;						// возврат в "кольцо"

L0:
	shr[11] = 0;
	goto L100;

L1:	shr[10] = 0;					// сброс активизации режима 10
	sh[10] = 0;
	diagn[0] &= (~0xFF);			//сброс диагностик режима 10
	diagn[1] &= (~0xFF);			//
	diagn[2] &= (~0xFF);			//
    diagn[3] &= (~0xFF);			//
    diagn[4] &= (~0xF0);			//
    diagn[7] &= (~0xF0);			//
    diagn[10] &= (~0x02);			//
	sh_ = 0;
	goto L101;
L2:	Klapan(0,&ShZatvShl);			// закрыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_12() // режим 12 "Открыть затвор испарителя"
{
	sh_ = sh[12];

	if (shr[12] < 1 || shr[12] > 40) goto L100;
	if (shr[12] < 10) goto L00;
    if (shr[12] < 20) goto L01;
    if (shr[12] < 30) goto L02;
	goto L03;

L00:if (shr[12] == 1) goto L1;
	if (shr[12] == 2) goto L2;
	if (shr[12] == 3) goto L3;
	if (shr[12] == 4) goto L4;
	if (shr[12] == 5) goto L5;
	if (shr[12] == 6) goto L6;
	if (shr[12] == 7) goto L7;
	if (shr[12] == 8) goto L8;
	if (shr[12] == 9) goto L9;
L01:if (shr[12] == 10) goto L10;
    if (shr[12] == 11) goto L11;
	if (shr[12] == 12) goto L12;
	if (shr[12] == 13) goto L13;
	if (shr[12] == 14) goto L14;
	if (shr[12] == 15) goto L15;
	if (shr[12] == 16) goto L16;
	if (shr[12] == 17) goto L17;
	if (shr[12] == 18) goto L18;
	if (shr[12] == 19) goto L19;
L02:if (shr[12] == 20) goto L20;
    if (shr[12] == 21) goto L21;
	if (shr[12] == 22) goto L22;
	if (shr[12] == 23) goto L23;
	if (shr[12] == 24) goto L24;
	if (shr[12] == 25) goto L25;
	if (shr[12] == 26) goto L26;
	if (shr[12] == 27) goto L27;
	if (shr[12] == 28) goto L28;
	if (shr[12] == 29) goto L29;
L03:if (shr[12] == 30) goto L30;
    if (shr[12] == 31) goto L31;
	if (shr[12] == 32) goto L32;
	if (shr[12] == 33) goto L33;
	if (shr[12] == 34) goto L34;
	if (shr[12] == 35) goto L35;
	if (shr[12] == 36) goto L36;
	if (shr[12] == 37) goto L37;
	if (shr[12] == 38) goto L38;
	if (shr[12] == 39) goto L39;
    if (shr[12] == 40) goto L40;


	goto L100;
	// конечный диспетчер режима
L101:sh[12] = sh_;
	if (sh[12] != 0) goto L100;		// SH != 0
	++shr[12];						// след. шаг сч.шр5
	if (shr[12] > 40) goto L0;		// число шагов режима
	sh[12] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[12] = 0;
    norma=47;
	goto L100;

L1: shr[13]=0;                      //сброс активации режима 13
    sh[13]=0;                       //"Закрыть затвор испарителя"
    diagn[5]&=(~0x0F);                 //сброс диагностик затвора испарит
    diagn[6]&=(~0xF0);                 //сброс диагностик Экрана затвора испарителя
    sh_=0;
    goto L101;
L2: if((zin[3]&0xC0)==0x40)         //затвор испарителя строго открыт
    {
        diagn[5]&=(~0x04);             //сброс диагностики
        shr[12]=40;                 //выход
        sh_=0;
        goto L101;
    }
    if((zin[3]&0xC0)==0x80)         //затвор испарителя строго закрыт
    {
        diagn[5]&=(~0x04);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[5]|=0x04;                    //отказ "положение затвора испарителя не определено"
    goto L101;
L3: if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UATM)
        shr[12]=6;                  //переход на шаг 7
    sh_=0;
    goto L101;
L4: if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4>UATM)
    {
        SetOut(0,1,0x04);           //Закрыть Кл-НАП2
        shr[12]=39;                 //переход на шаг 40
    }
    sh_=0;
    goto L101;
L5: Klapan(0,&ZatvTmnIsp);//Закрыть затвор ТМН исп
    goto L101;
L6: Klapan(0,&KlIsp);//Закрыть Фк исп
    if(sh_)goto L101;
    SetOut(1,1,0x04);           //Открыть Кл-НАП2
    shr[12]=3;                  //переход на шаг 4
    goto L101;
L7: if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>UVAK_KAM)
    {
        SetOut(0,1,0x02);           //Закрыть Кл-НАП3
        sh_=0;
        goto L101;
    }
    shr[12]=18;                     //переход на шаг 19
    sh_=0;
    goto L101;
L8: Klapan(1,&FvnKam);//Вкл. ФВН камеры
    goto L101;
L9: Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L10:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L11:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L12:Klapan(1,&KlKam);//Открыть Фк кам
    goto L101;
L13:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5<=UVAK_KAM)
    {
        shr[12]=18;                 //переход на шаг 19
        sh_=0;
        goto L101;
    }
    if(out[5]&0x08)
        sh_=0;
    goto L101;
L14:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3<=UVAKN_TMN)
        shr[12]=12;                 //переход на шаг 13
    sh_=0;
    goto L101;
L15:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L16:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L17:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L18:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    shr[12]=9;                      //переход на шаг 10
    sh_=0;
    goto L101;
L19:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4>UVAKN_ISP)
    {
        sh_=0;
        goto L101;
    }
    shr[12]=24;
    goto L24_1;                     //переход на шаг 24_1
L20:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L21:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L22:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L23:Klapan(1,&KlIsp);//Открыть Фк исп
    goto L101;
L24:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=UVAKV_ISP)
    {
L24_1:  if(zin[5]&0x07)             //ТМН кам включён
        {
            shr[12]=33;             //переход на шаг 34
            sh_=0;
            goto L101;
        }
        shr[12]=36;
        goto L36_1;                 //переход на шаг 36_1
    }
    if(zin[5]&0x07)             //ТМН кам включён
    {
        sh_=0;
        goto L101;
    }
    shr[12]=25;
    goto L25_1;                 //переход на шаг 25_1
L25:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        shr[12]=30;                 //переход на шаг 31
        sh_=0;
        goto L101;
    }
L25_1:if(!(out[5]&0x08))               //ТМН исп включён
        shr[12]=23;                 //переход на шаг 24
    sh_=0;
    goto L101;
L26:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3<=UVAKN_TMN)
        shr[12]=23;                 //переход на шаг 24
    sh_=0;
    goto L101;
L27:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L28:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L29:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3<=UVAKV_TMN)
        sh_=0;
    goto L101;
L30:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    if(sh_)goto L101;
    shr[12]=22;                     //переход на шаг 23
    goto L101;
L31:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L32:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L33:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[12]=21;                     //переход на шаг 22
    sh_=0;
    goto L101;
L34:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L35:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L36:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    if(sh_)goto L101;
L36_1:if(out[5]&0x08)               //ТМН исп включён
    {
        sh_=0;
        goto L101;
    }
    shr[12]=39;                     //переход на шаг 40
    sh_=0;
    goto L101;
L37:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L38:Klapan(0,&KlKam);//Закрыть Фк кам
    goto L101;
L39:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L40:Klapan(1,&ZatvIsp);//Открыть затвор исп
    goto L101;



}
//---------------------------------------------------------------------------
void R_13() // режим 13 "Закрыть затвор испарителя"
{   sh_ = sh[13];
    if (shr[13] == 1) goto L1;
	if (shr[13] == 2) goto L2;
	if (shr[13] == 3) goto L3;
    	goto L100;
	// конечный диспетчер режима
L101:sh[13] = sh_;
	if (sh[13] != 0) goto L100;		// SH != 0
	++shr[13];						// след. шаг сч.шр5
	if (shr[13] > 3) goto L0;		// число шагов режима
	sh[13] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[13] = 0;
    norma =48;
	goto L100;

L1: shr[12]=0;                      //сброс активации режима 12
    sh[12]=0;                       //"Открыть затвор испарителя"
    diagn[0]&=(~0x0F);                 //сброс диагностик режима 12
    diagn[1]&=(~0xF0);                 //
    diagn[2]&=(~0x0F);                 //
    diagn[3]&=(~0x0F);                 //
    diagn[4]&=(~0x0F);                 //
    diagn[5]&=(~0x0F);                 //
    diagn[7]&=(~0xF0);                 //
    sh_=0;
    goto L101;
L2: Klapan(1,&EkrZatv);//Открыть экран затвора испарителя
    goto L101;
L3: Klapan(0,&ZatvIsp);//Закрыть затвор испарителя
    goto L101;
}
//---------------------------------------------------------------------------
void R_14() // режим 14 "Кассета в HOME"
{
	sh_ = sh[14];
	if((shr[14] < 1) || (shr[14] > 2)) goto L100; // на выход

L00:if(shr[14] == 1) goto L1;
	if(shr[14] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[14] = sh_;
	if (sh[14] != 0) goto L100;		// SH != 0
	shr[14]++;						// след.шаг
	if (shr[14] > 2) goto L0;		// число шагов режима
	sh[14] = 1;
L100: return;						// возврат в "кольцо"

L0:	shr[14] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[18] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: KAS_HOME(60);				// привод кассеты в Home
	goto L101;
}
//---------------------------------------------------------------------------
void R_15() // режим 15 "Кассета вверх/вниз"
{
	sh_ = sh[15];
	if ((shr[15] < 1) || (shr[15] > 2)) goto L100; // на выход

L00:if(shr[15] == 1) goto L1;
	if(shr[15] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[15] = sh_;
	if(sh[15] != 0) goto L100;		// SH != 0
	shr[15]++;						// след.шаг
	if(shr[15] > 2) goto L0;		// число шагов режима
	sh[15] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[15] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[14] = 0;							// сброс активации режима 14
	shr[14] = 0;
	diagn[18] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_KAS(1,OTN,par[0][12],AZ_drive[0]->data_mech.v_mech[par[0][14]],30,0);
	goto L101;
}
//---------------------------------------------------------------------------
void R_16 ()                    // режим 16 "ПГП в HOME"
{

	sh_ = sh[16];
	if ((shr[16] < 1) || (shr[16] > 2)) goto L100; // на выход

L00:if(shr[16] == 1) goto L1;
	if(shr[16] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[16] = sh_;
	if(sh[16] != 0) goto L100;		// SH != 0
	shr[16]++;						// след.шаг
	if(shr[16] > 2) goto L0;		// число шагов режима
	sh[16] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[16] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[17] = 0;							// сброс активации режима 17
	shr[17] = 0;
	diagn[20] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: PER_HOME(60);				// ПГП в Home
	goto L101;
}
//---------------------------------------------------------------------------
void R_17 ()                    // режим 17 "ПГП вперёд/назад"
{
    sh_ = sh[17];
	if ((shr[17] < 1) || (shr[17] > 2)) goto L100; // на выход

L00:if(shr[17] == 1) goto L1;
	if(shr[17] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[17] = sh_;
	if(sh[17] != 0) goto L100;		// SH != 0
	shr[17]++;						// след.шаг
	if(shr[17] > 2) goto L0;		// число шагов режима
	sh[17] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[17] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[16] = 0;							// сброс активации режима 17
	shr[16] = 0;
	diagn[20] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PER(1,OTN,par[0][9],AZ_drive[1]->data_mech.v_mech[par[0][14]],30,0);
	goto L101;
}
//---------------------------------------------------------------------------
void R_18 ()                    // режим 18 "ПВП в Home"
{
    sh_ = sh[18];
	if ((shr[18] < 1) || (shr[18] > 2)) goto L100; // на выход

L00:if(shr[18] == 1) goto L1;
	if(shr[18] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[18] = sh_;
	if(sh[18] != 0) goto L100;		// SH != 0
	shr[18]++;						// след.шаг
	if(shr[18] > 2) goto L0;		// число шагов режима
	sh[18] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[18] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[19] = 0;							// сброс активации режима 17
	shr[19] = 0;
	diagn[19] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: POD_HOME(60);//
	goto L101;
}
//---------------------------------------------------------------------------
void R_19 ()							// Режим "ПВП вверх/вниз"
{
    sh_ = sh[19];
	if ((shr[19] < 1) || (shr[19] > 2)) goto L100; // на выход

L00:if(shr[19] == 1) goto L1;
	if(shr[19] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[19] = sh_;
	if(sh[19] != 0) goto L100;		// SH != 0
	shr[19]++;						// след.шаг
	if(shr[19] > 2) goto L0;		// число шагов режима
	sh[19] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[19] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[18] = 0;							// сброс активации режима 18
	shr[18] = 0;
	diagn[19] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POD(1,OTN,par[0][10],AZ_drive[2]->data_mech.v_mech[par[0][14]],30,0);
	goto L101;
}
//---------------------------------------------------------------------------
void R_20()							// РЕЖИМ 20 "Привод вращения п/д в HOME"
{
        sh_ = sh[20];
	if ((shr[20] < 1) || (shr[20] > 2)) goto L100; // на выход

L00:if(shr[20] == 1) goto L1;
	if(shr[20] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[20] = sh_;
	if(sh[20] != 0) goto L100;		// SH != 0
	shr[20]++;						// след.шаг
	if(shr[20] > 2) goto L0;		// число шагов режима
	sh[20] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[20] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[21] = 0;							// сброс активации режима 21
	shr[21] = 0;
    sh[24] = 0;							// сброс активации режима 24
	shr[24] = 0;
    sh[31] = 0;							// сброс активации режима 31
	shr[31] = 0;
	diagn[22] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VR_HOME(60);// Привод вращения п/д в HOME
	goto L101;
}
//---------------------------------------------------------------------------
void R_21()							// РЕЖИМ 21 "Привод вращения п/д вперёд"
{
        sh_ = sh[21];
	if ((shr[21] < 1) || (shr[21] > 2)) goto L100; // на выход

L00:if(shr[21] == 1) goto L1;
	if(shr[21] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[21] = sh_;
	if(sh[21] != 0) goto L100;		// SH != 0
	shr[21]++;						// след.шаг
	if(shr[21] > 2) goto L0;		// число шагов режима
	sh[21] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 17;						// норма: "Привод вращения подложкодержателя путь прошёл"
	shr[21] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[20] = 0;							// сброс активации режима 21
	shr[20] = 0;
    sh[24] = 0;							// сброс активации режима 24
	shr[24] = 0;
    sh[31] = 0;							// сброс активации режима 31
	shr[31] = 0;
	diagn[22] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_VR(1,OTN,par[0][11],AZ_drive[3]->data_mech.v_mech[par[0][14]],30,0);// Привод вращения п/д вперёд
	goto L101;
}
//---------------------------------------------------------------------------
void R_22()							// РЕЖИМ 22 "Привод поворота датчиков в HOME"
{
    sh_ = sh[22];
	if ((shr[22] < 1) || (shr[22] > 2)) goto L100; // на выход

L00:if(shr[22] == 1) goto L1;
	if(shr[22] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[22] = sh_;
	if(sh[22] != 0) goto L100;		// SH != 0
	shr[22]++;						// след.шаг
	if(shr[22] > 2) goto L0;		// число шагов режима
	sh[22] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[22] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[23] = 0;							// сброс активации режима 23
	shr[23] = 0;
    sh[32] = 0;							// сброс активации режима 23
	shr[32] = 0;
	diagn[21] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: PPD_HOME(60);//
	goto L101;
}
//---------------------------------------------------------------------------
void R_23()							// РЕЖИМ 23 "Привод поворота датчиков вперёд/назад"
{
    sh_ = sh[23];
	if ((shr[23] < 1) || (shr[23] > 2)) goto L100; // на выход

L00:if(shr[23] == 1) goto L1;
	if(shr[23] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[23] = sh_;
	if(sh[23] != 0) goto L100;		// SH != 0
	shr[23]++;						// след.шаг
	if(shr[23] > 2) goto L0;		// число шагов режима
	sh[23] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[23] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[22] = 0;							// сброс активации режима 23
	shr[22] = 0;
    sh[32] = 0;							// сброс активации режима 23
	shr[32] = 0;
	diagn[21] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PPD(1,OTN,par[0][13],AZ_drive[4]->data_mech.v_mech[par[0][14]],30,0);
	goto L101;
}
//---------------------------------------------------------------------------
void R_24()								// режим "Привод вращения п/д бесконечное"
{

    sh_ = sh[24];
	if ((shr[24] < 1) || (shr[24] > 2)) goto L100; // на выход

L00:if(shr[24] == 1) goto L1;
	if(shr[24] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[24] = sh_;
	if(sh[24] != 0) goto L100;		// SH != 0
	shr[24]++;						// след.шаг
	if(shr[24] > 2) goto L0;		// число шагов режима
	sh[24] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[24] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[20] = 0;							// сброс активации режима 23
	shr[20] = 0;
    sh[21] = 0;							// сброс активации режима 23
	shr[21] = 0;
    sh[31] = 0;							// сброс активации режима 23
	shr[31] = 0;
	diagn[22] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
    SetOut(1,3,0x200);
    SetOut(0,3,0x400);
	goto L101;
L2: VIDK_VR(0,CON,0,AZ_drive[3]->data_mech.v_mech[par[0][14]],0,0);//
	goto L101;


}
//---------------------------------------------------------------------------
void R_25() // режим 25 "Откачка испарителя"
{
    sh_ = sh[25];
    if (shr[25] < 1 || shr[25] > 70) goto L100;
	if (shr[25] < 10) goto L00;
	if (shr[25] < 20) goto L01;
	if (shr[25] < 30) goto L02;
	if (shr[25] < 40) goto L03;
    if (shr[25] < 50) goto L04;
    if (shr[25] < 60) goto L05;
	else goto L06;
	


L00:if ( shr[25] == 1 ) goto L1;
	if ( shr[25] == 2 ) goto L2;
    if ( shr[25] == 3 ) goto L3;
    if ( shr[25] == 4 ) goto L4;
    if ( shr[25] == 5 ) goto L5;
    if ( shr[25] == 6 ) goto L6;
    if ( shr[25] == 7 ) goto L7;
    if ( shr[25] == 8 ) goto L8;
    if ( shr[25] == 9 ) goto L9;
L01:if ( shr[25] == 10 ) goto L10;
    if ( shr[25] == 11 ) goto L11;
	if ( shr[25] == 12 ) goto L12;
    if ( shr[25] == 13 ) goto L13;
    if ( shr[25] == 14 ) goto L14;
    if ( shr[25] == 15 ) goto L15;
    if ( shr[25] == 16 ) goto L16;
    if ( shr[25] == 17 ) goto L17;
    if ( shr[25] == 18 ) goto L18;
    if ( shr[25] == 19 ) goto L19;
L02:if ( shr[25] == 20 ) goto L20;
    if ( shr[25] == 21 ) goto L21;
	if ( shr[25] == 22 ) goto L22;
    if ( shr[25] == 23 ) goto L23;
    if ( shr[25] == 24 ) goto L24;
    if ( shr[25] == 25 ) goto L25;
    if ( shr[25] == 26 ) goto L26;
    if ( shr[25] == 27 ) goto L27;
    if ( shr[25] == 28 ) goto L28;
    if ( shr[25] == 29 ) goto L29;
L03:if ( shr[25] == 30 ) goto L30;
    if ( shr[25] == 31 ) goto L31;
	if ( shr[25] == 32 ) goto L32;
    if ( shr[25] == 33 ) goto L33;
    if ( shr[25] == 34 ) goto L34;
    if ( shr[25] == 35 ) goto L35;
    if ( shr[25] == 36 ) goto L36;
    if ( shr[25] == 37 ) goto L37;
    if ( shr[25] == 38 ) goto L38;
    if ( shr[25] == 39 ) goto L39;
L04:if ( shr[25] == 40 ) goto L40;
    if ( shr[25] == 41 ) goto L41;
	if ( shr[25] == 42 ) goto L42;
    if ( shr[25] == 43 ) goto L43;
    if ( shr[25] == 44 ) goto L44;
    if ( shr[25] == 45 ) goto L45;
    if ( shr[25] == 46 ) goto L46;
    if ( shr[25] == 47 ) goto L47;
    if ( shr[25] == 48 ) goto L48;
    if ( shr[25] == 49 ) goto L49;
L05:if ( shr[25] == 50 ) goto L50;
    if ( shr[25] == 51 ) goto L51;
	if ( shr[25] == 52 ) goto L52;
    if ( shr[25] == 53 ) goto L53;
    if ( shr[25] == 54 ) goto L54;
    if ( shr[25] == 55 ) goto L55;
    if ( shr[25] == 56 ) goto L56;
    if ( shr[25] == 57 ) goto L57;
    if ( shr[25] == 58 ) goto L58;
    if ( shr[25] == 59 ) goto L59;
L06:if ( shr[25] == 60 ) goto L60;
    if ( shr[25] == 61 ) goto L61;
	if ( shr[25] == 62 ) goto L62;
    if ( shr[25] == 63 ) goto L63;
    if ( shr[25] == 64 ) goto L64;
    if ( shr[25] == 65 ) goto L65;
    if ( shr[25] == 66 ) goto L66;
    if ( shr[25] == 67 ) goto L67;
    if ( shr[25] == 68 ) goto L68;
    if ( shr[25] == 69 ) goto L69;
    if ( shr[25] == 70 ) goto L70;
	goto L100;// на выход


//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[25] = sh_;
	if ( sh[25] != 0) goto L100;    // SH != 0
	shr[25]++;                      // след.шаг сч.шр1
	if ( shr[25] > 70) goto L0;      // число шагов режима
	sh[25] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 21;		           	    // норма: "Откачка испарителя завершена"
	shr[25] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: SetOut(0,1,0x04);               //Закрыть Кл-НАП2
    sh_=0;
    goto L101;
L2: Klapan(1,&Isp);//Зафиксировать испаритель
    goto L101;
L3: Klapan(1,&FvnKam);//Вкл форнасос камер
    goto L101;
L4: Klapan(0,&KlKam);//Закрыть Фк-Кам
    goto L101;
L5: Klapan(0,&ZatvTmnIsp);//Закрыть затвор ТМН исп
    if(sh_)goto L101;
    if(nasmod[4])
        shr[25]=6;                  //переход на шаг 7
    goto L101;
L6: if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4>UVAKN_ISP)
    {
        shr[25]=7;                  //переход на шаг 8
        sh_=0;
        goto L101;
    }
    if((out[5]&0x08))         //Тмн исп включён
        shr[25]=39;                 //переход на шаг 40
    else
        shr[25]=31;                 //переход на шаг 32
    sh_=0;
    goto L101;
L7: Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    if(sh_)goto L101;
    N_ZIKL_PROM_ISP=0;
    shr[25]=17;                     //переход на шаг 18
    goto L101;
L8: Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L9: Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    if(sh_)goto L101;
    SetOut(1,0,0x200);              //Открыть Фк-исп (мягк)
    CT_25=0;
    goto L101;
L10:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=UVAK_ISP_MO)
    {
        diagn[9]&=(~0x10);             //сброс диагностики
        shr[25]=17;                 //переход на шаг 18
        sh_=0;
        goto L101;
    }
    if(zin[5]&0x07)                 //ТМН кам включён
    {
        sh_=0;
        goto L101;
    }
    shr[25]=11;                     //переход на шаг 11_1
    goto L11_1;
L11:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        SetOut(0,0,0x200);              //Закрыть Фк-исп (мягк)
        shr[25]=15;                     //переход на шаг 16
        sh_=0;
        goto L101;
    }
L11_1:if((out[5]&0x08))             //ТМН исп включён
    {
        sh_=0;
        goto L101;
    }
L11_2:if(CT_25>T_KISP_MO)
        diagn[9]|=0x10;                    //отказ "Медленная мягкая фороткачка испарителя"
    shr[25]=9;                          //переход на шаг 10
    sh_=0;
    goto L101;
L12:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKN_TMN)
    {
        SetOut(0,0,0x200);              //Закрыть Фк-исп (мягк)
        sh_=0;
        goto L101;
    }
    shr[25]=11;
    goto L11_2;                         //переход на шаг 11_2
L13:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L14:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    sh_=0;
    goto L101;
L15:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    if(sh_)goto L101;
    SetOut(1,0,0x200);              //Открыть Фк-исп (мягк)
    CT_25=0;
    shr[25]=9;                      //переход на шаг 10
    goto L101;
L16:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L17:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[25]=8;                      //переход на шаг 9
    sh_=0;
    goto L101;
L18:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L19:Klapan(1,&KlIsp);//Открытьь Фк исп
    if(sh_)goto L101;
    CT_25=0;
    goto L101;
L20:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=UVAKV_ISP)
    {
        diagn[9]&=(~0x20);             //сброс диагностики
        if(nasmod[4])
        {
            if(N_ZIKL_PROM_ISP<nasmod[4])
            {
                shr[25]=26;         //переход на шаг 27
                sh_=0;
                goto L101;
            }
        }
        shr[25]=31;                 //переход на шаг 32
        sh_=0;
        goto L101;
    }
    if(zin[5]&0x07)                 //Тмн кам включён
    {
        sh_=0;
        goto L101;
    }
    shr[25]=21;                     //переход на шаг 21_1
    goto L21_1;
L21:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        shr[25]=28;                 //переход на шаг 29
        sh_=0;
        goto L101;
    }
L21_1:if((out[5]&0x08))
    {
        sh_=0;
        goto L101;
    }
L21_2:if(CT_25>T_KISP)
        diagn[9]|=0x20;                //отказ "Медленная фороткачка испаритля"
    shr[25]=19;                     //переход на шаг 20
    sh_=0;
    goto L101;
L22:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
    shr[25]=21;                     //переход на шаг 21_2
    goto L21_2;
L23:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L24:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L25:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    sh_=0;
    goto L101;
L26:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    if(sh_)goto L101;
    shr[25]=18;                     //переход на шаг 19
    goto L101;
L27:Klapan(0,&KlIsp);//Закрыть Фк Исп
    if(sh_)goto L101;
    SetOut(1,1,0x04);               //Открыть Кл-НАП2
    goto L101;
L28:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=UATM)
        goto L101;
    SetOut(0,1,0x04);               //Закрыть Кл-НАП2
    N_ZIKL_PROM_ISP++;
    shr[25]=18;
    sh_=0;
    goto L101;
L29:Klapan(0,&KlIsp);//Закрыть Фк-исп
    goto L101;
L30:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L31:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[25]=17;                     //переход на шаг 18
    sh_=0;
    goto L101;
L32:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L33:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L34:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    if(sh_)goto L101;
    CT_25=0;
L35:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3<=UVAKV_TMN)
    {
        diagn[9]&=(~0x40);             //сброс диагностики
        SetOut(1,5,0x08);           //Пуск ТМН исп
        shr[25]=40;                 //переход на шаг 41
        sh_=0;
        goto L101;
    }
    if(zin[5]&0x07)                 //ТМН кам включён
    {
        sh_=0;
        goto L101;
    }
    shr[25]=36;                     //переход на шаг 37
    goto L36_1;
L36:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L36_1:if(CT_25>T_KTMN)
        diagn[9]|=0x40;                //отказ "Медленная фороткачка ТМН испарителя"
    shr[25]=34;                     //переход на шаг 35
    sh_=0;
    goto L101;
L37:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L38:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L39:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[25]=32;                     //переход на шаг 33
    sh_=0;
    goto L101;
L40:Klapan(0,&KlIsp);//Закрыть фк исп
    goto L101;
L41:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    goto L101;
L42:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    if(sh_)goto L101;
    CT_25=0;
    goto L101;
L43:if(zin[5]&0x400)                    //ТМН исп норма
    {
        diagn[9]&=(~0x80);                //сброс диагностики
        shr[25]=47;                     //переход на шаг 48
        sh_=0;
        goto L101;
    }
    if(zin[5]&0x07)                     //ТМН кам включён
    {
        sh_=0;
        goto L101;
    }
    shr[25]=44;
    goto L44_1;
L44:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L44_1:if(CT_25>T_KTMN_ISP_RAZGON)
        diagn[9]|=0x80;                //отказ "Нет выхода на режим ТМН испарителя"
    shr[25]=42;                     //переход на шаг 43
    sh_=0;
    goto L101;
L45:Klapan(0,&KlTmnIsp);//Закрыть Фк ТМН исп
    goto L101;
L46:Klapan(1,&KlTmnKam);//Открыть Фк ТМН кам
    goto L101;
L47:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[25]=40;                     //переход на шаг 41
    sh_=0;
    goto L101;
L48:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4>UVAKN_ISP)
    {
        sh_=0;
        goto L101;
    }
    shr[25]=58;                     //переход на шаг 59
    sh_=0;
    goto L101;
L49:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L50:Klapan(0,&KlTmnKam);//Закрыть Фк ТМН кам
    if(sh_)goto L101;
    shr[25]=67;                     //переход на шаг 68
    goto L101;
L51:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=UVAKV_ISP)
    {
        diagn[9]&=(~0x20);             //сброс диагностики
        shr[25]=58;                 //переход на шаг 59
        sh_=0;
        goto L101;
    }
    if(zin[5]&0x07)                 //ТМН кам включён
    {
        sh_=0;
        goto L101;
    }
    shr[25]=52;                     //переход на шаг 52_1
    goto L52_1;
L52:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        shr[25]=68;
        sh_=0;
        goto L101;
    }
L52_1:if((out[5]&0x08))       //ТМН испарителя включён
    {
        sh_=0;
        goto L101;
    }
L52_2:if(CT_25>T_KISP)
        diagn[9]|=0x20;                //отказ "Медленная фороткачка испарителя"
    shr[25]=50;                     //переход на шаг 51
    sh_=0;
    goto L101;
L53:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKN_TMN)
    {
        shr[25]=69;                 //переход на шаг 70
        sh_=0;
        goto L101;
    }
    shr[25]=52;
    goto L52_2;                     //переход на шаг 52_2
L54:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    goto L101;
L55:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>UVAKV_TMN)
        goto L101;
    sh_=0;
    goto L101;
L56:Klapan(0,&KlTmnIsp);//закрыть Фк-ТМН исп
    if(sh_)goto L101;
    shr[25]=67;                     //переход на шаг 68
    goto L101;
L57:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L58:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[25]=49;                     //переход на шаг 50
    sh_=0;
    goto L101;
L59:Klapan(0,&KlIsp);//Закрыть Фк исп
    goto L101;
L60:Klapan(1,&ZatvTmnIsp);//Открыть затвор ТМН исп
    goto L101;
L61:Klapan(1,&KlTmnIsp);//Открыть Фк-ТМН исп
    if(sh_)goto L101;
    CT_25=0;
    goto L101;
L62:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=nasmod[1])
    {
        diagn[10]&=(~0x01);             //сброс диагностики
        shr[25]=70;                 //выход
        sh_=0;
        goto L101;
    }
    if(zin[5]&0x07)
    {
        sh_=0;
        goto L101;
    }
    shr[25]=63;
    goto L63_1;
L63:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L63_1:if(CT_25>T_KISP_V)
        diagn[10]|=0x01;                //отказ "Медленная высковакуумная откачка испарителя"
    shr[25]=61;                     //переход на шаг 62
    sh_=0;
    goto L101;
L64:Klapan(0,&KlTmnIsp);//Закрыть Фк-ТМН исп
    goto L101;
L65:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L66:if(diagnS[0]&0x20)				// пока нет связи с D6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    sh_=0;
    goto L101;
L67:Klapan(0,&KlTmnKam);//Закрыть Фк-ТМН кам
    if(sh_)goto L101;
    shr[25]=60;                     //переход на шаг 61
    goto L101;
L68:Klapan(1,&KlIsp);//Открыть Фк исп
    if(sh_)goto L101;
    CT_25=0;
    shr[25]=50;
    goto L101;
L69:Klapan(0,&KlIsp);//Закрыть Фк исп
    if(sh_)goto L101;
    shr[25]=56;                     //переход на шаг 57
    goto L101;
L70:Klapan(0,&KlIsp);//Закрыть Фк исп
    if(sh_)goto L101;
    shr[25]=53;                     //переход на шаг 54
    goto L101;







}
//---------------------------------------------------------------------------
void R_26() // режим 26 "Закрыть заслонку"
{
	sh_ = sh[26];
	if ( shr[26] < 1 || shr[26] > 15 ) goto L100; // на выход

    if ( shr[26] == 1 ) goto L1;
	if ( shr[26] == 2 ) goto L2;
    if ( shr[26] == 3 ) goto L3;
    if ( shr[26] == 4 ) goto L4;
    if ( shr[26] == 5 ) goto L5;
    if ( shr[26] == 6 ) goto L6;
    if ( shr[26] == 7 ) goto L7;
    if ( shr[26] == 8 ) goto L8;
    if ( shr[26] == 9 ) goto L9;
    if ( shr[26] == 10 ) goto L10;
    if ( shr[26] == 11 ) goto L11;
    if ( shr[26] == 12 ) goto L12;
    if ( shr[26] == 13 ) goto L13;
    if ( shr[26] == 14 ) goto L14;
    if ( shr[26] == 15 ) goto L15;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[26] = sh_;
	if ( sh[26] != 0 ) goto L100;   // SH != 0
	shr[26]++;                      // след.шаг сч.шр1
	if ( shr[26] > 15) goto L0;    	// число шагов режима
	sh[26] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 22;		           	    // норма: "Загрузка материала окончена"
	shr[26] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: Klapan(1,&EkrZatv);//Поднять экран затвора испарителя
    goto L101;
L2: Klapan(0,&ZatvIsp);//Закрыть затвор исп
    goto L101;
L3: Klapan(0,&ZatvTmnIsp);//Закрыть затвор ТМН исп
    goto L101;
L4: Klapan(0,&KlIsp);//Закрыть Фк исп
    if(sh_)goto L101;
    SetOut(1,1,0x04);               //Открыть Кл Нап2
    goto L101;
L5: if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4<=UATM)
        goto L101;
    sh_=0;
    goto L101;
L6: Klapan(0,&Isp);//Расфиксировать испарит
    if(sh_)goto L101;
    CT_26=0;
    goto L101;
L7: if(CT_26<=T_NAPUSK)
        goto L101;
    SetOut(0,1,0x04);               //Закрыть Кл Нап2
    otvet=0;
    sh_=0;
    goto L101;
L8: if(otvet==0)
        goto L101;
    if(otvet==1)
    {
        SetOut(1,3,0x140);          //Подключить прогрев камеры и чиллер нагрева
        shr[25]=1;                  //активизация режима 25
        sh[25]=1;                   //"откачка испарителя"
        sh_=0;
        goto L101;
    }
    shr[26]=15;                     //выход
    sh_=0;
    goto L101;
L9: if(shr[25])
        goto L101;
    if(!(zin[5]&0x05))
        shr[26]=15;
    sh_=0;
    goto L101;
L10:Klapan(1,&KlTmnKam);//Открыть Фк-ТМН кам
    goto L101;
L11:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>UVVAK_KAM)
        goto L101;
    sh_=0;
    goto L101;
L12:Klapan(1,&ZatvIsp);//Открыть затвор исп
    goto L101;
L13:Klapan(0,&EkrZatv);//Опустить экран затвора исп
    goto L101;
L14:Klapan(0,&ZaslIsp);//Закрыть заслонку испарителя
    goto L101;
L15:if(diagnS[0]&0x10)				// пока нет связи с D5
		goto L101;
    if(D_D5>nasmod[0])
        goto L101;
    SetOut(0,3,0x140);          //Отключить прогрев камеры и чиллер нагрева
    sh_=0;
    goto L101;


}
//---------------------------------------------------------------------------
void R_27 ()            // Режим "Нагрев шлюза вкл"
{
    	sh_ = sh[27];
	if (shr[27] == 1) goto L1;
	if (shr[27] == 2) goto L2;
	if (shr[27] == 3) goto L3;
	if (shr[27] == 4) goto L4;
	if (shr[27] == 5) goto L5;
	if (shr[27] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[27] = sh_;	   				// |                           |
	if (sh[27] != 0) goto L100;	  	// |    SH != 0                |
	shr[27]++;		        		// |    след.шаг 	           |
	sh[27] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: SetOut(0,4,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,4,0x01);				// Вкл. пускатель нагревателя
    shr[28] = 0;					// режима 34
	sh[28] = 0;						// 'Откл. нагрева'
	VRTEMP2 = 0;               		// сброс признака выхода на режим БПН
	diagn[16] &= (~0xE7);      		// сброс диагностики режима БПН
	CT_27 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_27<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x4000)==0)			// нет включения силового питания БПН
	{
		SetOut(1,4,0x01);			// вкл. силовое питание БПН
		CT_27 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[27] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x4000)==0)			// нет включения силового питания БПН
	{
		if (CT_27<=T_VKL_BPN) goto L101;
		diagn[16]|=0x08;			// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,4,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[16]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP2();		     		// выбор параметра БПН
	VIDK_TEMP2(1,16,040,1);			// выдать задание по температуре
	if(sh_) goto L101;            	//
	ZPAR_TEMP2 = PAR_TEMP2;			// запоминание параметра задания температуры
	CT_27 = 0;	           			// сброс
	CT27K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP2();		     		// выбор параметра БПН
	if ( PAR_TEMP2 == ZPAR_TEMP2 )  // параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 	// обход задания
	VIDK_TEMP2(1,16,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;           //
	ZPAR_TEMP2 = PAR_TEMP2; 		// зап.парам.задания температуры
L6_8:	PDTEMP2 ();                 // Подготовка аналоговых данных
	RLIMTEMP2();	        		// расчет LIM для БПН
	if (DELTEMP2<=LIM1TEMP2)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP2 == 0) goto L6_6;	// нет выхода на режим
	diagn[16] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[16] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP2<=LIM2TEMP2)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP2 == 0) goto L6_6;	// нет выхода на режим
	diagn[16] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[16] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT27K1 = 0;
L6_7:if (CT_27<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP2 != 0) goto L6_1;     // есть выход на режим
	diagn[16] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[16] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT27K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP2 = 1;	               		// выход на режим
L6_3:shr[27]=5;                 		// Возврат на L6
	goto L101;

}
//---------------------------------------------------------------------------
void R_28 ()	                    // режим "Нагрев шлюза откл"
{
	sh_ = sh[28];

L00:if (shr[28] == 1)  goto L1;
	if (shr[28] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[28] = sh_;
	if (sh[28] != 0) goto L100;   // SH != 0
	shr[28]++;                    // след.шаг сч.шр1
	if (shr[28] > 2) goto L0;    	// число шагов режима
	sh[28] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[28] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[27]  = 0;                  // режима 33
	shr[27] = 0;                  // "Вкл. БПН"
	diagn[16] &= (~0xE7);		// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP2(1,16,0100,0);		// выкл. БПН 0 температуры
	goto L101;

}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void R_29 ()	             		// режим "Вкл. нагрева п/д"
{
	sh_ = sh[29];
	if (shr[29] == 1) goto L1;
	if (shr[29] == 2) goto L2;
	if (shr[29] == 3) goto L3;
	if (shr[29] == 4) goto L4;
	if (shr[29] == 5) goto L5;
	if (shr[29] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[29] = sh_;	   				// |                           |
	if (sh[29] != 0) goto L100;	  	// |    SH != 0                |
	shr[29]++;		        		// |    след.шаг 	           |
	sh[29] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: SetOut(0,4,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,4,0x01);				// Вкл. пускатель нагревателя
    shr[30] = 0;					// режима 34
	sh[30] = 0;						// 'Откл. нагрева'
	VRTEMP1 = 0;               		// сброс признака выхода на режим БПН
	diagn[17] &= (~0xE7);      		// сброс диагностики режима БПН
	CT_29 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_29<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x4000)==0)			// нет включения силового питания БПН
	{
		SetOut(1,4,0x01);			// вкл. силовое питание БПН
		CT_29 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[29] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x4000)==0)			// нет включения силового питания БПН
	{
		if (CT_29<=T_VKL_BPN) goto L101;
		diagn[16]|=0x08;			// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,4,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[16]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP1();		     		// выбор параметра БПН
	VIDK_TEMP1(1,17,040,1);			// выдать задание по температуре
	if(sh_) goto L101;            	//
	ZPAR_TEMP1 = PAR_TEMP1;			// запоминание параметра задания температуры
	CT_29 = 0;	           			// сброс
	CT29K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP1();		     		// выбор параметра БПН
	if ( PAR_TEMP1 == ZPAR_TEMP1 )  // параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 	// обход задания
	VIDK_TEMP1(1,17,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;           //
	ZPAR_TEMP1 = PAR_TEMP1; 		// зап.парам.задания температуры
L6_8:	PDTEMP1 ();                 // Подготовка аналоговых данных
	RLIMTEMP1();	        		// расчет LIM для БПН
	if (DELTEMP1<=LIM1TEMP1)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[17] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[17] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP1<=LIM2TEMP1)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[17] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[17] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT29K1 = 0;
L6_7:if (CT_29<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP1 != 0) goto L6_1;     // есть выход на режим
	diagn[17] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[17] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT29K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP1 = 1;	               		// выход на режим
L6_3:shr[29]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void R_30() // режим 30 "Откл. нагрева п/д"
{
	sh_ = sh[30];

L00:if (shr[30] == 1)  goto L1;
	if (shr[30] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[30] = sh_;
	if (sh[30] != 0) goto L100;   // SH != 0
	shr[30]++;                    // след.шаг сч.шр1
	if (shr[30] > 2) goto L0;    	// число шагов режима
	sh[30] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[30] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[29]  = 0;                  // режима 33
	shr[29] = 0;                  // "Вкл. БПН"
	diagn[17] &= (~0xE7);		// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP1(1,17,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//---------------------------------------------------------------------------
void R_31 ()	             		// режим "привод вращения п/д откл"
{   sh_ = sh[31];
L00:if(shr[31] == 1) goto L1;
	if(shr[31] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[31] = sh_;
	if(sh[31] != 0) goto L100;		// SH != 0
	shr[31]++;						// след.шаг
	if(shr[31] > 2) goto L0;		// число шагов режима
	sh[31] = 1;
L100:return;						// возврат в "кольцо"

L0: norma=23;
    shr[31] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[20] = 0;							// сброс активации режима 23
	shr[20] = 0;
    sh[21] = 0;							// сброс активации режима 23
	shr[21] = 0;
    sh[24] = 0;							// сброс активации режима 23
	shr[24] = 0;
	diagn[22] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
    SetOut(0,3,0x200);
	goto L101;
L2: VR_NEXT(20,0);//
	goto L101;
}
//---------------------------------------------------------------------------
void R_32() // режим 32 "Выбор датчика толщины"
{
    sh_ = sh[32];
	if ((shr[32] < 1) || (shr[32] > 2)) goto L100; // на выход

L00:if(shr[32] == 1) goto L1;
	if(shr[32] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[32] = sh_;
	if(sh[32] != 0) goto L100;		// SH != 0
	shr[32]++;						// след.шаг
	if(shr[32] > 2) goto L0;		// число шагов режима
	sh[32] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[32] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[22] = 0;							// сброс активации режима 23
	shr[22] = 0;
    sh[23] = 0;							// сброс активации режима 23
	shr[23] = 0;
	diagn[21] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PPD(1,ABS,RoundTo(IMP60*(PR_PPD_D-1),0),AZ_drive[4]->data_mech.v_mech[par[0][14]],30,0);
	goto L101;
}
//------------------------------------------------------------------------------

void R_36()							// режим "ЭЛУ" ()
{
	sh_ = sh[36];
	if (shr[36] == 1) goto L1;
	if (shr[36] == 2) goto L2;
	if (shr[36] == 3) goto L3;
	if (shr[36] == 4) goto L4;
	else goto L100;					// на выход

L101:sh[36] = sh_;					// |						|
	if (sh[36] != 0) goto L100;		// |		SH != 0			|
	shr[36]++;						// |		след.шаг		|
	sh[36] = 1;						// |						|
L100:return;						// |	возврат в "кольцо"	|

L1:	shr[37] = 0;					// деактивизация режима 37
	sh[37] = 0;
	VRELU = 0;						// сброс признака выхода на режим ЭЛ
	diagn[24] &= (~0xFF);			// сброс диагностики режима ЭЛ
	sh_ = 0;
	goto L101;
L2:	sh_ = 0;
	goto L101;
L3:	VIBPAR_ELU();					// выбор параметра
	VIDK_ELU(3,13,0x20,1,7);		// выдать задание тока эмиссии
	if(sh_!=0) goto L101;			//
    ZPAR_ELU = PAR_ELU; 	        // зап.парам.задания
	CT_36 = 0;						// сброс
	CT36K1 = 0;						// счетчиков
	// выход на режим и диагностика
L4: VIBPAR_ELU();					// выбор параметра
	if(PAR_ELU == ZPAR_ELU)         // параметр не изменился
	{
		sh_ = 0;
		goto L4_8;					// обход задания
	}
	VIDK_ELU(3,13,0x20,1,7);		// выдать задание тока эмиссии
	if(sh_!=0) goto L101;			//
    ZPAR_ELU = PAR_ELU; 	        // зап.парам.задания
L4_8:PDELU ();						// Подготовка аналоговых данных
	RLIMELU();						// расчет LIM для ЭЛ
	if (DELELU<=LIM1ELU)goto L4_4;	// модуль Ет <= LIM1
	if (VRELU == 0) goto L4_6;		// нет выхода на режим
	diagn[13] |= 0x04;				// отказ: "нет регулирования ЭЛ"
	goto L4_5;						// на сброс диагн."больш.ош."
L4_4:diagn[13] &= (~0x04);			// сброс д."нет регулирования ЭЛ"
	if (DELELU<=LIM2ELU)goto L4_5;	// LIM2 (зона регулирования)
	if (VRELU == 0) goto L4_6;		// нет выхода на режим
	diagn[13] |= 0x02;				// отказ: "б.ош.регулирования ЭЛУ"
	goto L4_7;
L4_5:diagn[13] &= (~0x02);			// сброс д."б.ош.регулирования ЭЛУ"
	goto L4_7;
L4_6:CT36K1 = 0;
L4_7:if (CT_36<=T_VRELU) goto L4_2;	// Ттек <= Тзад
	if (VRELU != 0) goto L4_1;		// есть выход на режим
	diagn[13] |= 0x01;				// отказ: "нет выхода на режим ЭЛ"
	goto L4_2;
L4_1:diagn[13] &= (~0x01);			// сброс д."нет выхода на режим ЭЛ"
L4_2:if (CT36K1<=T_KELU) goto L4_3;	// Т.K.тек <= Т.K.зад
	VRELU = 1;						// выход на режим
L4_3:shr[36]=3;						// Возврат на L4
	goto L101;
}
//----------------------------------------------------------------------------
void RLIMELU()						// подпрограмма "Расчет LIM для ЭЛ"
{
	if (PAR_ELU == 0)				// если задание = 0, расшир.лимитов
	{
		LIM1ELU = 3000;				// MAX доп.знач.по входу (300 мА)
		LIM2ELU = LIM1ELU / 2;		// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2ELU = PAR_ELU / DOPELU;	// LIM2 (малый)
		LIM1ELU = PAR_ELU / 2;		// LIM1 (большой)
	}
}
//----------------------------------------------------------------------------
void PDELU()						// подготовка аналоговых данных ЭЛ
 {
	X_ELU = TEK_ELU;				// тек.значение тока
	E_ELU = PAR_ELU - X_ELU;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_ELU >= 0) DELELU = E_ELU;
	else  DELELU = E_ELU * (-1);	// вычисление модуля ошибки
 }
//---------------------------------------------------------------------------
void VIBPAR_ELU()					// выбор параметра ЭЛ
 {

	if((shr[38] > 0)&&(shr[38] <= 2)) PAR_ELU = 10;	// 1 мА
	else if((shr[38] > 2)&&(shr[38] <= 4)) PAR_ELU = UST_ELU;//
	else
	{
		 PAR_ELU = par[N_ST][6];
	}
 }
//---------------------------------------------------------------------------
void R_37()							// режим 37 "Откл. ЭЛ"
{
	sh_ = sh[37];
	if (shr[37] == 1)  goto L1;
	if (shr[37] == 2)  goto L2;
	if (shr[37] == 3)  goto L3;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[37] = sh_;
	if (sh[37] != 0) goto L100;		// SH != 0
	shr[37]++;						// след.шаг сч.шр1
	if (shr[37] > 3) goto L0;		// число шагов режима
	sh[37] = 1;
L100: return;						// возврат в "кольцо"

L0:	shr[37] = 0;
	goto L100;

L1:	shr[36] = 0;					// деактивизация режима 36
	sh[36] = 0;
	shr[38] = 0;					// деактивизация режима 38
	sh[38] = 0;
	diagn[13] &= (~0xFF);			// сброс диагностик ЭЛ
	sh_ = 0;
	goto L101;
L2:	VIDK_ELU(3,13,0x20,0,7);		// выкл. ЭЛ (ток 0)
	goto L101;
L3:	OUEL();							// отключить U ЭЛ
	goto L101;
}
//---------------------------------------------------------------------------
void R_38()							// режим 38 "Ремпинг тока ЭЛ"
{
	sh_ = sh[38];
	if (shr[38] == 1)  goto L1;
	if (shr[38] == 2)  goto L2;
	if (shr[38] == 3)  goto L3;
	if (shr[38] == 4)  goto L4;
	if (shr[38] == 5)  goto L5;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[38] = sh_;
	if (sh[38] != 0) goto L100;		// SH != 0
	shr[38]++;						// след.шаг сч.шр1
	if (shr[38] > 5) goto L0;		// число шагов режима
	sh[38] = 1;
L100: return;						// возврат в "кольцо"

L0:	shr[38] = 0;
	goto L100;

L1:	sh[36] = 1;						// активизация режима 36
	shr[36] = 1;
	sh_ = 0;
	goto L101;
L2:	if(!VRELU) goto L101;			// ожидание выхода на режим
	UST_ELU = 30;					// 30 мА
L2_1:REMP_ELU = int((par[N_ST][6]*T_KUST_ELU)/par[N_ST][7]); // расчет приращения тока
    if(REMP_ELU < 1) REMP_ELU = 1;
	sh_ = 0;
	goto L101;
L3:	UST_ELU = UST_ELU + REMP_ELU;
    if(UST_ELU > par[N_ST][6])		// расчет новой уставки,
        UST_ELU = par[N_ST][6];		// проверка на превышение
    PAR_ELU = UST_ELU;			// и запись
	CT_38 = 0;
	sh_ = 0;
	goto L101;
L4:	if(CT_38 <= T_KUST_ELU) goto L101;// выстой
    if(UST_ELU < par[N_ST][6])
    {
        shr[38] = 2;
        goto L2_1;				// возврат на L2_1
    }
	sh[36] = 1;						// активизация режима 36
	shr[36] = 1;
	sh_ = 0;
	goto L101;
L5:	if(!VRELU) goto L101;			// ожидание выхода на режим
	sh_ = 0;
	goto L101;
}
//------------------------------------------------------------------------------
void R_43()							// режим 43 "Подключение камеры слежения за расплавом"
{
	sh_ = sh[43];
	if (shr[43] == 1)  goto L1;
	if (shr[43] == 2)  goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[43] = sh_;
	if (sh[43] != 0) goto L100;		// SH != 0
	shr[43]++;						// след.шаг сч.шр1
	if (shr[43] > 2) goto L0;		// число шагов режима
	sh[43] = 1;
L100: return;						// возврат в "кольцо"

L0:	shr[43] = 0;
	goto L100;

L1: SetOut(0,0,0xC000);
    SetOut(1,0,0x4000);             //Открыть заслонку смотрового окна
    SetOut(1,3,0x20);               //Подключить камеру контроля расплава
    CT_RASPLAV=0;
    sh_=0;
    goto L101;
L2: if(CT_RASPLAV<nasmod[15])goto L101;
    SetOut(0,0,0x4000);             //Закрыть заслонку смотрового окна
    SetOut(1,0,0x8000);
    SetOut(0,3,0x20);               //Отключить камеру контроля расплава
    sh_=0;
    goto L101;
}


//---------------------------------------------------------------------------
//---------  ПОДПРОГРАММЫ  --------------------------------------------------
//---------------------------------------------------------------------------
void AVAR_VODA_NG () //Реакция на попадание воды в корпус нагревателя п/д
{
    if(shr[29])
    {
        if(zin[0]&0x400)
        {
            CT_VODA_NG=0;
            return;
        }
        if(CT_VODA_NG>=T_VODA)
        {
            diagn[14]|=0x02;            //отказ"Авария: нет охлаждения корпуса нагревателя п/д"
            if((shr[3])&&(PR_NALADKA==0))
            {
                shr[5]=1;           //активизируем режим 5
                sh[5]=1;            //"Сброс рабочего цикла"
            }
            else
            {                       
                shr[30]=1;          //активизируем режим 30
                sh[30]=1;           //"Отключение нагрева п/д"
            }
        }
    }
    else
        CT_VODA_NG=0;
    return;
}
//------------------------------------------------------------------------------
void AVAR_VODA_ISP () // Реакция на попадание воды в испаритель ЭЛ
{
    if((shr[36])||(shr[38]))
    {
        if(!(zin[0]&0x04))
        {
            diagn[14]|=0x04;        //отказ "Авария: нет охлаждения испарителя ЭЛ"
            if(shr[3])
            {
                shr[5]=1;       //активизируем режим 5
                sh[5]=1;        //"сброс рабочего цикла"
            }
        }
    }
}



void AVAR_DAVL()      // "Реакция на высокое давление в камере при работе ТМН"
{
}

//---------------------------------------------------------------------------
void MEH_AVAR_CHK()				// слежение за авриями механизма
{
	// если нет аварии механизма
	if(
    (zin[4]&0x04)&&
    (zin[4]&0x20)&&
    (zin[4]&0x100)&&
    (zin[4]&0x800)&&
    (zin[4]&0x4000))
		SetOut(0,2,0x400);		// сбросить сигнал "Сброс аварий"
}
//---------------------------------------------------------------------------
void MEH_AVAR_SBROS()			// сброс аварий механизма (не в кольце)
{
	SetOut(1,2,0x400);			// выдать сигнал "Сброс аварий"(по кнопке)
}
//---------------------------------------------------------------------------
void OSBROS()					// подпрограмма Общий сброс
{

    shr[1]=0;
    sh[1]=0;
    shr[2]=0;
    sh[2]=0;
    shr[5]=0;
    sh[5]=0;
    shr[6]=0;
    sh[6]=0;
    shr[7]=0;
    sh[7]=0;
    shr[8]=0;
    sh[8]=0;
    shr[10]=0;
    sh[10]=0;
    shr[11]=0;
    sh[11]=0;
    shr[12]=0;
    sh[12]=0;
    shr[13]=0;
    sh[13]=0;
    shr[25]=0;
    sh[25]=0;
    shr[26]=0;
    sh[26]=0;
    shr[28]=0;
    sh[28]=0;
    shr[30]=0;
    sh[30]=0;
    shr[37]=0;
    sh[37]=0;
    N_ST=0;
    PR_NALADKA=0;
    SetOut(1,2,0x800);          //стоп механизмов
    SBROS_MEH();
    for(int i=0;i<DIAGN_COUNT;i++)
            diagn[i] = 0;// сброс диагностик
    SetOut(0,4,0x40);
    SetOut(1,4,0x80);
    SetOut(0,2,0x8000);
    SetOut(0,4,0x1100);
	norma = 25;					// норма: общий сброс завершен
    PR_OST_TMN_ISP=0;
    PR_OST_TMN_SHL=0;
}

//---------------------------------------------------------------------------
void SBROS_MEH() 				// режим "Сброс механизмов"
{
	// сброс движения МАН
	// сброс режимов
	shr[9] 	= 0;				// транспортный тест
	sh[9]  	= 0;
	shr[14] = 0;           		// Кас в HOME
	sh[14]  = 0;
	shr[15] = 0;           		// Кас вверх/вниз
	sh[15]  = 0;
	shr[16] = 0;           		// ПГП в HOME
	sh[16]  = 0;
	shr[17]	= 0;				// ПГП вперёд/назад
	sh[17]	= 0;
    shr[18]	= 0;				// ПВП в HOME
	sh[18]	= 0;
    shr[19] = 0;                // ПВП вверх/вниз
    sh[19]  = 0;
    shr[20] = 0;                // Вращ. п/д в HOME
    sh[20]  = 0;
    shr[21] = 0;                // Вращ. п/д (по углу)
    sh[21]  = 0;
    shr[22] = 0;                // Пов. датч. в HOME
    sh[22]  = 0;
    shr[23] = 0;                // Пов. датч. впердёд/назад
    sh[23]  = 0;
    shr[24] = 0;                // Вращ п/д беск.
    sh[24]  = 0;
    shr[31] = 0;                // Откл. вращ. п/д беск
    sh[31]  = 0;
    shr[32] = 0;                // Выбор датч. толщины
    sh[32]  = 0;

	diagn[18] &=  (~0xFF);		// сброс диагностик
    diagn[19] &=  (~0xFF);		// сброс диагностик
    diagn[20] &=  (~0xFF);		// сброс диагностик
    diagn[21] &=  (~0xFF);		// сброс диагностик
    diagn[22] &=  (~0xFF);		// сброс диагностик

    PR_PER=0;
    PR_POD=0;
    PR_KAS=0;
    PR_PPD=0;
    PR_VR=0;

	SetOut(0,2,0x3FF);			// Отключение движения механизмов
	SetOut(1,2,0x800);			// СТОП движение

    SetOut(0,3,0x200);          //M0
    SetOut(0,3,0x400);          //NEXT

	norma = 20;					// сброс механизмов завершен
}
//---------------------------------------------------------------------------
void UPR_AVAR_OTKL()			// Управление аварийным отключением
{
	if(!(out[5]&0x02))          //ТМН шл включён
        goto A1;
    if(!(zin[5]&0x200))            //есть авария ТМН шл
    {
        diagn[14]|=0x80;            //отказ "Авария ТМН шлюза"
        goto A2;
    }
    if(!(zin[1]&0x01))             //форнасос шлюза включён
    {
        diagn[14]|=0x08;            //отказ "Авария: отключение форнасоса шлюза"
        goto A2;
    }
A1: if(!(zin[5]&0x07))          //ТМН кам включён
        goto A3;
    if(!(zin[5]&0x08))             //Есть сигнал ТМН кам авария
    {
        diagn[24]|=0x20;            //отказ "Авария ТМН камеры"
        goto A2;
    }
A1_1:if(!(zin[1]&0x08))          //форнасос камеры включён
    {
        diagn[14]|=0x20;            //отказ "Авария: отключение форнасоса камеры"
        goto A2;
    }
A3: if(out[5]&0x08)             //ТМН испарителя включён
    {
        if(!(zin[5]&0x800))        //Есть сигнал аварии ТМН испарителя
        {
            diagn[24]|=0x80;        //отказ "Авария ТМН испарителя"
            goto A2;
        }
        if(!(zin[1]&0x08))          //форнасос камеры включён
        {
            diagn[14]|=0x20;            //отказ "Авария: отключение форнасоса камеры"
            goto A2;
        }
    }
    if(out[3]&0x08)             //есть сигнал на включение форнасоса шлюза
    {
        if(!(zin[1]&0x04))         //Есть сигнал аварии форнасоса шлюза
        {
            diagn[14]|=0x10;        //отказ "Авария форнасоса шлюза"
            goto A2;
        }
    }
    if(out[3]&0x10)             //Есть сигнал на вкл. форнасоса камеры
    {
        if(!(zin[1]&0x20))         //Есть сигнал аварии форнасоса камеры
        {
            diagn[14]|=0x40;        //отказ "Авария форнасоса камеры"
A2:         if(!(shr[8]))
            {
                shr[8]=1;       //активизируем режим 8
                sh[8]=1;
            }
        }
    }
}



////////////////////////////////////////////////////////////////////////////////
void VIBPAR_TEMP1 ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP1 = par[N_ST][1];            //
}
//---------------------------------------------------------------------------
void RLIMTEMP1 ()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP1 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP1 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP1 = LIM1TEMP1 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP1 = PAR_TEMP1 / DOPTEMP1;	// LIM2 (малый)
		LIM1TEMP1 = PAR_TEMP1 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDTEMP1 ()						// подготовка аналоговых данных БПН
{
	X_TEMP1 = TEK_TEMP1;	           	// тек.значение температуры
	E_TEMP1 = PAR_TEMP1 - X_TEMP1;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP1 >= 0) DELTEMP1 = E_TEMP1;
	else  DELTEMP1 = E_TEMP1 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------//
//--Подпрограмма выдачи команд на ТЕРМОДАТ--//
//------------------------------------------//
void VIDK_TEMP1 ( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x10 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP1 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP1();			// выбор параметра температуры
						ZAD_TEMP1 = PAR_TEMP1;	// запись задания
					}
				}
				CT_TEMP1 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ((diagnS[2] & 0x10) || (!PR_TEMP))
			{
				if ( CT_TEMP1 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP1 ( 1 , 16 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP1 ( 1 , 16 , 0100 , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP1 ( 2 , 16 , 0200 , X )  - Опрос температуры
//------------------------------------------//
void VIDK_TEMP2( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x40 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP2 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP2 ();			// выбор параметра температуры
						ZAD_TEMP2 = PAR_TEMP2;	// запись задания
					}
				}
				CT_TEMP2 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ( ( diagnS[2] & 0x40 ) || ( PR_TEMP == 0 ) )
			{
				if ( CT_TEMP2 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP2 ( 1 , 17 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP2 ( 1 , 17 , 0100  , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP2 ( 2 , 17 , 0200 , X )  - Опрос температуры
//------------------------------------------------------------------------------
void VIBPAR_TEMP2 ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP2 = nasmod[7];            //
}
//---------------------------------------------------------------------------
void PDTEMP2()						// подготовка аналоговых данных БПН
{
	X_TEMP2 = TEK_TEMP2;	           	// тек.значение температуры
	E_TEMP2 = PAR_TEMP2 - X_TEMP2;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP2 >= 0) DELTEMP2 = E_TEMP2;
	else  DELTEMP2 = E_TEMP2 * (-1);	// вычисление модуля ошибки
}
void RLIMTEMP2()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP2 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP2 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP2 = LIM1TEMP2 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP2 = PAR_TEMP2 / DOPTEMP2;	// LIM2 (малый)
		LIM1TEMP2 = PAR_TEMP2 / 2;    	// LIM1 (большой)
	}
}

//------------------------------------------------------------------------------

void OBPN()				// подпрограмма "Отключить БПН (сил. пит. на термодат)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;      // выход

A1:	SetOut(0,4,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	SetOut(1,4,0x02);		   	// выкл. силового питания БПН
	CT_IST = 0;			   		// сброс сч.времени
	sh_ = 2;
A2:	if (zin[0]&0x4000)	   	// силовое питание включено
	{
		if (CT_IST<=T_VKL_BPN) return;// время не вышло
		diagn[16]|=0x10;	           // отказ:"Силовое питание БПН не выкл."
		return;
	}
	SetOut(0,4,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	diagn[16]&=(~0x10);		   	// сброс диагностики
	sh_ = 0;
	norma = 21;					// норма: "Силовое питание БПН отключено"
 }
//------------------------------------------------------------------------------

void SLEJ_PGP ()    //подпрограмма "Слежение за наличием п/д на ПГП во время движения"
{
    if(
    (shr[3]==18)||
    (shr[3]==36)||
    ((PR_NAL_PD==0)&&((shr[9]==8)||(shr[9]==20)))||
    ((shr[5]==15)&&((SOST_V==2)||(SOST_N==2)))
    )
    {
        if(!(zin[5]&0x1000))
        {
            diagn[14]|=0x01;        //отказ "Авария: Нет п/д на ПГП"
            SBROS_MEH();        //Стоп механизмов
        }
    }
}
void OPR_ZAGR_KAS()    //подпрограмма "определения загруженных п/д в кассету"
{
    if(zin[1]&0x2000)
        SOST_V=1;
    else
        SOST_V=0;
    if(zin[1]&0x4000)
        SOST_N=1;
    else
        SOST_N=0;
}
////////////////////////////////////////////////////////////////////////////////
void VIDK_ELU( int a , int b , int c , int d , int e )
// a - код команды к контроллеру ЭЛУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x40 ) == 0 )	// нет диагностики "нет связи с контроллером ЭЛУ"
			{
				pri_elu[a] = 0;
//				PR_ELU = 0;						// обнуление признака положительного ответа контроллера ЭЛУ
				KOM_ELU = a;					// выдача заданной команды
				if( KOM_ELU == 3)				// задание тока эмиссии
				{
					if(d == 0)					// сброс тока
						PAR_ELU = 0;
				}
				else if ( KOM_ELU == 1 )		// передача номера процесса
				{
                    N_PROCESS_ELU = par[N_ST][3];//
				}
				else if ( KOM_ELU == 4 )		// передача номера тигля
				{
                    N_TIGEL = par[N_ST][4];	//
				}
				CT_ELU = 0;						// сброс сч. времени
				sh_ = 2;						// переход на второй шаг
			}
		}; break;
		case 2:
		{
		// если есть диагностика "нет связи с контроллером ЭЛУ" или нет пр.полож.ответа
			if (((diagnS[2]&0x40)==0x40)||(pri_elu[a]==0))
//			if ( ( ( diagnS[1] & 0x80 ) == 0x80 ) || ( PR_ELU == 0 ) )
			{
				if ( CT_ELU > e )				// время ожидания вышло
				diagn[b] |= c;					// отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_ELU = 0;					// запись кода опроса
				pri_elu[a] = 0;
//				PR_ELU = 0;
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
//------------------------------------------------------------------------------
// Команды на контроллер ЭЛУ
//            КК    диагн
// VIDK_ELU ( 1 , 13 , 0x08 , 0 , 7 ) - передача номера процесса на ЭЛ
// VIDK_ELU ( 2 , 13 , 0x10 , 0 , 7 ) - опрос тока эмиссии
// VIDK_ELU ( 3 , 13 , 0x20 , 1 , 7 ) - задание тока эмиссии
// VIDK_ELU ( 3 , 13 , 0x20 , 0 , 7 ) - сброс тока эмиссии
// VIDK_ELU ( 4 , 13 , 0x40 , 0 , 7 ) - задание номера тигля (тигель в позицию)
// VIDK_ELU ( 5 , 13 , 0x80 , 0 , 30 ) - опрос (тигель в позиции)
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
void VUEL ()	// подпрограмма "Включить U электронного луча"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;				// выход

A1:	SetOut(0,4,0xC0);			// сброс выходных сигналов на вкл/откл
								// силового питания ЭЛ
	CT_IST = 0;					// сброс сч.времени
	sh_ = 2;					
A2:	if (CT_IST<=T_VKL_BPN) return; // задержка на откл. реле и пускателя
	sh_ = 3;
A3:	if ((zin[3]&0x800)!=0) goto S0; // питание ЭЛ включено
	SetOut(1,4,0x40);			// вкл. силовое питание ЭЛ
	CT_IST = 0;					// сброс сч.времени
	sh_ = 4;
	return;
A4:	if ((zin[3]&0x800)==0)		// нет включения силового питания ЭЛ
	{
		if (CT_IST<=T_VKL_BPN) return;// время не вышло
		diagn[10]|=0x40;			// отказ:"Питание ЭЛ не вкл."
		return;
	}
S0:	SetOut(0,3,0xC0);			// сброс всех сигналов на вкл/выкл
								// силового питания ЭЛ
	diagn[10]&=(~0x40);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------
void OUEL ()	// подпрограмма "Отключить U электронного луча"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;				// выход

A1:	SetOut(0,4,0xC0);			// сброс выходных сигналов на вкл/откл
								// силового питания ЭЛ
	SetOut(1,4,0x80);			// выкл. силового питания ЭЛ
	CT_IST = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if ((zin[3]&0x800)!=0)		// силовое питание включено
	{
		if (CT_IST<=T_VKL_BPN) return;// время не вышло
		diagn[10]|=0x80;			// отказ:"Питание ЭЛ не выкл."
		return;
	}
	SetOut(0,4,0xC0);			// сброс выходных сигналов на вкл/откл
								// силового питания ЭЛ
	diagn[10]&=(~0x80);		 	// сброс диагностики
	sh_ = 0;
}
//---------------------------------------------------------------------------
void ResetTh ()			// подпрограмма "Обнуление значения толщины"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;				// выход
	
A1:	SetOut(1,4,0x20);			// выставляем сигнал обнуления толщины
	CT_IST = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if (CT_IST<=2) return;		// время не вышло
	SetOut(0,4,0x20);			// сброс выходных сигналов
	sh_ = 0;
}
//------------------------------------------------------------------------------
//--Подпрограмма выдачи команд на измеритель толщины--//
//------------------------------------------------------------------------------
void VIDK_TOLSH( int a, int b, int c )
// a - код команды к измерителю толщины
// b - номер байта массива диагностики
// c - номер бита массива диагностики
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x20 ) == 0 )	// нет диагностики "нет связи с изм.толщины"
			{
				PR_TOLSH = 0;					// обнуление признака положительного ответа изм.толщ.
				KOM_TOLSH = a;					// выдача заданной команды

					ZAD_N_PL = par[N_ST][5];			// слой 2

				CT_TOLSH = 0;					// сброс сч. времени
				sh_ = 2;						// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с изм.толщины" или нет пр.полож.ответа
			if ( ( ( diagnS[2] & 0x20 ) == 0x20 ) || ( PR_TOLSH == 0 ) )
			{
				if ( CT_TOLSH > 5 )				// время ожидания вышло
					diagn[b] |= c;				// отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TOLSH = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
//------------------------------------------------------------------------------
// Команды на измеритель толщины
//              КК    диагн
// VIDK_TOLSH ( 1 , 15 , 0x01 ) - Задать номер плёнки
// VIDK_TOLSH ( 2 , 15 , 0x02 ) - Опрос толщины

//*******************Подпрограммы приводов**************************************
//-------------------Вращение п/д-----------------------------------------------
void VR_HOME(unsigned int a)
// перемещение механизма в Home
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// VR_HOME(10);	// механизм перемещения в Home с 10 сек контр. временем

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	// выход
	
A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_VR = 1;
	CT_VR = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x01))		// нет готовности привода
	{
		if(CT_VR >= 2000)	// 2 сек в 1 мс тиках
			diagn[22] |= 0x01;	// диагностика "Нет готовности привода .."
		return;
	}
	diagn[22] &= (~0x01);			// сброс диагностики
	CT_VR = 0;
    TEK_OTN_VR = 0;
	SetOut(1,2,0x02);           	// выдать сигнал движения в Home
	sh_ = 3;
A3:	if(!(zin[4]&0x02)||(TEK_ABS_VR < -5)||(TEK_ABS_VR > 5)) // механизм не пришел в Home
	{
		if(CT_VR >= (a*1000))
			diagn[22] |= 0x10;		// отказ: "Привод .. не пришел в Home"
		return;
	}
	diagn[22] &= (~0x10);			// сброс диагностики
	SetOut(0,2,0x02);               // снять движение в Home
	CT_VR = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x01))				// нет готовности привода
	{
		if(CT_VR >= 2000)			// 2 сек в 1 мс тиках
		diagn[22] |= 0x01;			// отказ: "Нет готовности привода.."
		return;
	}
	diagn[22] &= (~0x01);			// сброс диагностики
	PR_VR = 0;
	norma = 16;						// "Привод .. пришел в Home"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//---------------------------------------------------------------------------
void VR_NEXT(unsigned int a,unsigned int b)
// переход на следующий шаг в последовательности движений
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// b - время перемещения в сек (для движений по времени)
	// VR_NEXT(0,0); // следующее движение механизма без контроля окончания
	// VR_NEXT(10,0); // следующее движение механизма с 10 сек контр. временем
	// VR_NEXT(0,15); // следующее движение механизма длительностью 15 сек (для бесконечных)


	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	else return;	// выход
	
A1:	if(!PR_VR)				// нет признака движения механизма
	{
		diagn[22] |= 0x02 ;		// диагностика "Нет движения привода перемещения"
		return;
	}
	diagn[22] &= (~0x02 );			// сброс диагностики
	CT_VR = 0;
	SetOut(1,3,0x400 );           // выдать сигнал Next механизма
	sh_ = 2;
A2:	if(CT_VR <= 200)			// 10 мс испульсного сигнала
		return;
	SetOut(0,3,0x400);               // снять сигнал Next
	if(a||b)				// нужен контроль окончания
	{
		if(b)				// задано время контроля
		{
			sh_ = 3;		// переход на шаг 3
			goto A3;
		}
		else
		{
			sh_ = 5;		// переход на шаг 5
			goto A5;
		}
	}
	sh_ = 0;				// выход без контроля окончания
	return;
A3:	if(CT_VR <= (b*1000))		// время не вышло
		return;
	SetOut(1,2,0x800);				// выставить Стоп механизмов
	CT_VR = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x01))				// нет готовности привода
	{
		if(CT_VR >= 2000)			// 2 сек в 1 мс тиках
			diagn[22] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[22] &= (~0x20);			// сброс диагностики
	sh_ = 5;
	goto S1;
A5:	if(!(zin[4]&0x01))				// нет готовности привода
	{
		if(CT_VR >= (a*1000))	// контрольное время движения
			diagn[22] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[22] &= (~0x20);			// сброс диагностики
S1:	PR_VR = 0;
	norma =17  ;						// "Привод перемещения выполнил движение"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;

}
//---------------------------------------------------------------------------
void VIDK_VR(bool prRS,unsigned char a,int b,int c,unsigned int d, unsigned int e)
// выдача команд на механизм для стандартных движений
{
	// prRS - необходимость записи задания по RS
	// a - тип движения (соответствует типам в контроллере стр.61):
	// ABS = 1 - по абсолютной координате
	// OTN = 2 - по относительной координате
	// CON = 7 - "бесконечное"
	// ABS_F = 10 - абс. движение в прямом напр. (для циклич.)
	// ABS_R = 11 - абс. движение в обратном напр. (для циклич.)
	// b - путь (в имп)
	// c - скорость (в имп/сек)
	// d - контр. время перемещения в сек (выдача диагностики)
	// e - время перемещения в сек (для движений по времени)
	// VIDK_VR(0,0,0,0,10,0); // движение по выбранным параметрам с 10 сек контр. временем
	// VIDK_VR(1,OTN,par[3],v_mech[0][1],15,0); // с записью параметров с 15 сек контр. временем
	// VIDK_VR(0,0,0,0,0,30); // движение по выбранным параметрам длительностью 30 сек
	// VIDK_VR(1,CON,0,par[2],0,0); // "бесконечное" движение без контроля окончания
	// VIDK_VR(0,0,0,0,0,0); // движение по выбранным параметрам без контроля окончания

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_VR = 1;
	if(!(zin[4]&0x01))				// нет готовности привода
	{
		diagn[22] |= 0x01;			// отказ: "Нет готовности привода перемещения"
		return;
	}
	diagn[22] &= (~0x01);				// сброс диагностики
	CT_VR = 0;
	TYPE_VR = a;
	PUT_VR = b;
	V_VR = c;
	TEK_OTN_VR = 0;
	if(prRS)						// нужна запись задания
	{
		if(diagnS[2]&0x01) return;	// нет связи с контроллером
		KOM_VR = 1;
		OTVET_VR = 0;
		sh_ = 2;
		goto A2;					// переход на шаг 3
	}
	SetOut(1,2,0x01);           	// выдать сигнал старт движения
	CT_VR = 0;
	sh_ = 3;						// переход на шаг 3
	goto A3;
A2:	if(diagnS[2]&0x01||(!OTVET_VR))	// есть диагностика нет связи или нет ответа
	{
		if(CT_VR >= 5000)
			diagn[22] |= 0x04;		// отказ: "Нет ответа на команду приводу перемещения"
		return;
	}
	diagn[22] &= (~0x04);			// сброс диагностики
	KOM_VR = 0;
	SetOut(1,2,0x01);           		// выдать сигнал старт движения
	CT_VR = 0;
	sh_ = 3;
A3:	if(zin[4]&0x01)					// готовность привода не пропала
	{
		if(CT_VR >= 2000)
			diagn[22] |= 0x08;		// отказ: "Нет начала движения привода перемещения"
		return;
	}
	diagn[22] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x01);               // сбросить сигнал старт движения
	CT_VR = 0;
	if(e)							// задано время движения
	{
		sh_ = 4;
		goto A4;					// переход на шаг 4
	}
	else if(d)						// задано контрольное время
	{
		sh_ = 6;
		goto A6;					// переход на шаг 6
	}
	sh_ = 0;						// выход без контроля окончания
	return;
A4:	if(CT_VR <= (e*1000))		// время не вышло
		return;
	SetOut(1,2,0x800);				// выставить Стоп механизмов
	CT_VR = 0;
	sh_ = 5;
A5:	if(!(zin[4]&0x01))				// нет готовности привода
	{
		if(CT_VR >= 2000)			// 2 сек в 1 мс тиках
			diagn[22] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[22] &= (~0x20);			// сброс диагностики
	sh_ = 6;
	goto S1;
A6:	if(!(zin[4]&0x01)||(prRS&&(((a==ABS)&&((TEK_ABS_VR < b-5)||(TEK_ABS_VR > b+5)))||((a==OTN)&&((TEK_OTN_VR < b-5)||(TEK_OTN_VR > b+5))))))
	// нет готовности привода или пути не достигнуты для "RS-овских"
	{
		if(CT_VR >= (d*1000))		// контрольное время движения
			diagn[22] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[22] &= (~0x20);				// сброс диагностики
S1:	PR_VR = 0;
	norma =17 ;						// "Привод перемещения выполнил движение"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}


//----------------------------ПГП-----------------------------------------------
void PER_HOME(unsigned int a)
// перемещение механизма в Home
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// VR_HOME(10);	// механизм перемещения в Home с 10 сек контр. временем

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_PER = 1;
	CT_PER = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x08))		// нет готовности привода
	{
		if(CT_PER >= 2000)	// 2 сек в 1 мс тиках
			diagn[20] |= 0x01;	// диагностика "Нет готовности привода .."
		return;
	}
	diagn[20] &= (~0x01);			// сброс диагностики
	CT_PER = 0;
    TEK_OTN_PER = 0;
	SetOut(1,2,0x08);           	// выдать сигнал движения в Home
	sh_ = 3;
A3:	if(!(zin[4]&0x10)||(TEK_ABS_PER < -5)||(TEK_ABS_PER > 5)) // механизм не пришел в Home
	{
		if(CT_PER >= (a*1000))
			diagn[20] |= 0x10;		// отказ: "Привод .. не пришел в Home"
		return;
	}
	diagn[20] &= (~0x10);			// сброс диагностики
	SetOut(0,2,0x08);               // снять движение в Home
	CT_PER = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x08))				// нет готовности привода
	{
		if(CT_PER >= 2000)			// 2 сек в 1 мс тиках
		diagn[20] |= 0x01;			// отказ: "Нет готовности привода.."
		return;
	}
	diagn[20] &= (~0x01);			// сброс диагностики
	PR_PER = 0;
	norma = 12;						// "Привод .. пришел в Home"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//---------------------------------------------------------------------------

void VIDK_PER(bool prRS,unsigned char a,int b,int c,unsigned int d, unsigned int e)
// выдача команд на механизм для стандартных движений
{
	// prRS - необходимость записи задания по RS
	// a - тип движения (соответствует типам в контроллере стр.61):
	// ABS = 1 - по абсолютной координате
	// OTN = 2 - по относительной координате
	// CON = 7 - "бесконечное"
	// ABS_F = 10 - абс. движение в прямом напр. (для циклич.)
	// ABS_R = 11 - абс. движение в обратном напр. (для циклич.)
	// b - путь (в имп)
	// c - скорость (в имп/сек)
	// d - контр. время перемещения в сек (выдача диагностики)
	// e - время перемещения в сек (для движений по времени)
	// VIDK_VR(0,0,0,0,10,0); // движение по выбранным параметрам с 10 сек контр. временем
	// VIDK_VR(1,OTN,par[3],v_mech[0][1],15,0); // с записью параметров с 15 сек контр. временем
	// VIDK_VR(0,0,0,0,0,30); // движение по выбранным параметрам длительностью 30 сек
	// VIDK_VR(1,CON,0,par[2],0,0); // "бесконечное" движение без контроля окончания
	// VIDK_VR(0,0,0,0,0,0); // движение по выбранным параметрам без контроля окончания

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_PER = 1;
	if(!(zin[4]&0x08))				// нет готовности привода
	{
		diagn[20] |= 0x01;			// отказ: "Нет готовности привода перемещения"
		return;
	}
	diagn[20] &= (~0x01);				// сброс диагностики
	CT_PER = 0;
	TYPE_PER = a;
	PUT_PER = b;
	V_PER = c;
	TEK_OTN_PER = 0;
	if(prRS)						// нужна запись задания
	{
		if(diagnS[2]&0x08) return;	// нет связи с контроллером
		KOM_PER = 1;
		OTVET_PER = 0;
		sh_ = 2;
		goto A2;					// переход на шаг 3
	}
	SetOut(1,2,0x04);           	// выдать сигнал старт движения
	CT_PER = 0;
	sh_ = 3;						// переход на шаг 3
	goto A3;
A2:	if(diagnS[2]&0x08||(!OTVET_PER))	// есть диагностика нет связи или нет ответа
	{
		if(CT_PER >= 5000)
			diagn[20] |= 0x04;		// отказ: "Нет ответа на команду приводу перемещения"
		return;
	}
	diagn[20] &= (~0x04);			// сброс диагностики
	KOM_PER = 0;
	SetOut(1,2,0x04);           		// выдать сигнал старт движения
	CT_PER = 0;
	sh_ = 3;
A3:	if(zin[4]&0x08)					// готовность привода не пропала
	{
		if(CT_PER >= 2000)
			diagn[20] |= 0x08;		// отказ: "Нет начала движения привода перемещения"
		return;
	}
	diagn[20] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x04);               // сбросить сигнал старт движения
	CT_PER = 0;
	if(e)							// задано время движения
	{
		sh_ = 4;
		goto A4;					// переход на шаг 4
	}
	else if(d)						// задано контрольное время
	{
		sh_ = 6;
		goto A6;					// переход на шаг 6
	}
	sh_ = 0;						// выход без контроля окончания
	return;
A4:	if(CT_PER <= (e*1000))		// время не вышло
		return;
	SetOut(1,2,0x800);				// выставить Стоп механизмов
	CT_PER = 0;
	sh_ = 5;
A5:	if(!(zin[4]&0x08))				// нет готовности привода
	{
		if(CT_PER >= 2000)			// 2 сек в 1 мс тиках
			diagn[20] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[20] &= (~0x20);			// сброс диагностики
	sh_ = 6;
	goto S1;
A6:	if(!(zin[4]&0x08)||(prRS&&(((a==ABS)&&((TEK_ABS_PER < b-5)||(TEK_ABS_PER > b+5)))||((a==OTN)&&((TEK_OTN_PER < b-5)||(TEK_OTN_PER > b+5))))))
	// нет готовности привода или пути не достигнуты для "RS-овских"
	{
		if(CT_PER >= (d*1000))		// контрольное время движения
			diagn[20] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[20] &= (~0x20);				// сброс диагностики
S1:	PR_PER = 0;
	norma =13 ;						// "Привод перемещения выполнил движение"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//----------------------------ПВП-----------------------------------------------
void POD_HOME(unsigned int a)
// перемещение механизма в Home
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// VR_HOME(10);	// механизм перемещения в Home с 10 сек контр. временем

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_POD = 1;
	CT_POD = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x200))		// нет готовности привода
	{
		if(CT_POD >= 2000)	// 2 сек в 1 мс тиках
			diagn[19] |= 0x01;	// диагностика "Нет готовности привода .."
		return;
	}
	diagn[19] &= (~0x01);			// сброс диагностики
	CT_POD = 0;
    TEK_OTN_POD = 0;
	SetOut(1,2,0x80);           	// выдать сигнал движения в Home
	sh_ = 3;
A3:	if(!(zin[4]&0x400)||(TEK_ABS_POD < -5)||(TEK_ABS_POD > 5)) // механизм не пришел в Home
	{
		if(CT_POD >= (a*1000))
			diagn[19] |= 0x10;		// отказ: "Привод .. не пришел в Home"
		return;
	}
	diagn[19] &= (~0x10);			// сброс диагностики
	SetOut(0,2,0x80);               // снять движение в Home
	CT_POD = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x200))				// нет готовности привода
	{
		if(CT_POD >= 2000)			// 2 сек в 1 мс тиках
		diagn[19] |= 0x01;			// отказ: "Нет готовности привода.."
		return;
	}
	diagn[19] &= (~0x01);			// сброс диагностики
	PR_POD = 0;
	norma = 14;						// "Привод .. пришел в Home"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//---------------------------------------------------------------------------

void VIDK_POD(bool prRS,unsigned char a,int b,int c,unsigned int d, unsigned int e)
// выдача команд на механизм для стандартных движений
{
	// prRS - необходимость записи задания по RS
	// a - тип движения (соответствует типам в контроллере стр.61):
	// ABS = 1 - по абсолютной координате
	// OTN = 2 - по относительной координате
	// CON = 7 - "бесконечное"
	// ABS_F = 10 - абс. движение в прямом напр. (для циклич.)
	// ABS_R = 11 - абс. движение в обратном напр. (для циклич.)
	// b - путь (в имп)
	// c - скорость (в имп/сек)
	// d - контр. время перемещения в сек (выдача диагностики)
	// e - время перемещения в сек (для движений по времени)
	// VIDK_VR(0,0,0,0,10,0); // движение по выбранным параметрам с 10 сек контр. временем
	// VIDK_VR(1,OTN,par[3],v_mech[0][1],15,0); // с записью параметров с 15 сек контр. временем
	// VIDK_VR(0,0,0,0,0,30); // движение по выбранным параметрам длительностью 30 сек
	// VIDK_VR(1,CON,0,par[2],0,0); // "бесконечное" движение без контроля окончания
	// VIDK_VR(0,0,0,0,0,0); // движение по выбранным параметрам без контроля окончания

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_POD = 1;
	if(!(zin[4]&0x200))				// нет готовности привода
	{
		diagn[19] |= 0x01;			// отказ: "Нет готовности привода перемещения"
		return;
	}
	diagn[19] &= (~0x01);				// сброс диагностики
	CT_POD = 0;
	TYPE_POD = a;
	PUT_POD = b;
	V_POD = c;
	TEK_OTN_POD = 0;
	if(prRS)						// нужна запись задания
	{
		if(diagnS[2]&0x04) return;	// нет связи с контроллером
		KOM_POD = 1;
		OTVET_POD = 0;
		sh_ = 2;
		goto A2;					// переход на шаг 3
	}
	SetOut(1,2,0x40);           	// выдать сигнал старт движения
	CT_POD = 0;
	sh_ = 3;						// переход на шаг 3
	goto A3;
A2:	if(diagnS[2]&0x04||(!OTVET_POD))	// есть диагностика нет связи или нет ответа
	{
		if(CT_POD >= 5000)
			diagn[19] |= 0x04;		// отказ: "Нет ответа на команду приводу перемещения"
		return;
	}
	diagn[19] &= (~0x04);			// сброс диагностики
	KOM_POD = 0;
	SetOut(1,2,0x40);           		// выдать сигнал старт движения
	CT_POD = 0;
	sh_ = 3;
A3:	if(zin[4]&0x200)					// готовность привода не пропала
	{
		if(CT_POD >= 2000)
			diagn[19] |= 0x08;		// отказ: "Нет начала движения привода перемещения"
		return;
	}
	diagn[19] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x40);               // сбросить сигнал старт движения
	CT_POD = 0;
	if(e)							// задано время движения
	{
		sh_ = 4;
		goto A4;					// переход на шаг 4
	}
	else if(d)						// задано контрольное время
	{
		sh_ = 6;
		goto A6;					// переход на шаг 6
	}
	sh_ = 0;						// выход без контроля окончания
	return;
A4:	if(CT_POD <= (e*1000))		// время не вышло
		return;
	SetOut(1,2,0x800);				// выставить Стоп механизмов
	CT_POD = 0;
	sh_ = 5;
A5:	if(!(zin[4]&0x200))				// нет готовности привода
	{
		if(CT_POD >= 2000)			// 2 сек в 1 мс тиках
			diagn[19] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[19] &= (~0x20);			// сброс диагностики
	sh_ = 6;
	goto S1;
A6:	if(!(zin[4]&0x200)||(prRS&&(((a==ABS)&&((TEK_ABS_POD < b-5)||(TEK_ABS_POD > b+5)))||((a==OTN)&&((TEK_OTN_POD < b-5)||(TEK_OTN_POD > b+5))))))
	// нет готовности привода или пути не достигнуты для "RS-овских"
	{
		if(CT_POD >= (d*1000))		// контрольное время движения
			diagn[19] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[19] &= (~0x20);				// сброс диагностики
S1:	PR_POD = 0;
	norma =15 ;						// "Привод перемещения выполнил движение"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//----------------------------Кассета-----------------------------------------------
void KAS_HOME(unsigned int a)
// перемещение механизма в Home
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// VR_HOME(10);	// механизм перемещения в Home с 10 сек контр. временем

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_KAS = 1;
	CT_KAS = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x40))		// нет готовности привода
	{
		if(CT_KAS >= 2000)	// 2 сек в 1 мс тиках
			diagn[18] |= 0x01;	// диагностика "Нет готовности привода .."
		return;
	}
	diagn[18] &= (~0x01);			// сброс диагностики
	CT_KAS = 0;
    TEK_OTN_KAS = 0;
	SetOut(1,2,0x20);           	// выдать сигнал движения в Home
	sh_ = 3;
A3:	if(!(zin[4]&0x80)||(TEK_ABS_KAS < -5)||(TEK_ABS_KAS > 5)) // механизм не пришел в Home
	{
		if(CT_KAS >= (a*1000))
			diagn[18] |= 0x10;		// отказ: "Привод .. не пришел в Home"
		return;
	}
	diagn[18] &= (~0x10);			// сброс диагностики
	SetOut(0,2,0x20);               // снять движение в Home
	CT_KAS = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x40))				// нет готовности привода
	{
		if(CT_KAS >= 2000)			// 2 сек в 1 мс тиках
		diagn[18] |= 0x01;			// отказ: "Нет готовности привода.."
		return;
	}
	diagn[18] &= (~0x01);			// сброс диагностики
	PR_KAS = 0;
	norma = 10;						// "Привод .. пришел в Home"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//---------------------------------------------------------------------------
void VIDK_KAS(bool prRS,unsigned char a,int b,int c,unsigned int d, unsigned int e)
// выдача команд на механизм для стандартных движений
{
	// prRS - необходимость записи задания по RS
	// a - тип движения (соответствует типам в контроллере стр.61):
	// ABS = 1 - по абсолютной координате
	// OTN = 2 - по относительной координате
	// CON = 7 - "бесконечное"
	// ABS_F = 10 - абс. движение в прямом напр. (для циклич.)
	// ABS_R = 11 - абс. движение в обратном напр. (для циклич.)
	// b - путь (в имп)
	// c - скорость (в имп/сек)
	// d - контр. время перемещения в сек (выдача диагностики)
	// e - время перемещения в сек (для движений по времени)
	// VIDK_VR(0,0,0,0,10,0); // движение по выбранным параметрам с 10 сек контр. временем
	// VIDK_VR(1,OTN,par[3],v_mech[0][1],15,0); // с записью параметров с 15 сек контр. временем
	// VIDK_VR(0,0,0,0,0,30); // движение по выбранным параметрам длительностью 30 сек
	// VIDK_VR(1,CON,0,par[2],0,0); // "бесконечное" движение без контроля окончания
	// VIDK_VR(0,0,0,0,0,0); // движение по выбранным параметрам без контроля окончания

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_KAS = 1;
	if(!(zin[4]&0x40))				// нет готовности привода
	{
		diagn[18] |= 0x01;			// отказ: "Нет готовности привода перемещения"
		return;
	}
	diagn[18] &= (~0x01);				// сброс диагностики
	CT_KAS = 0;
	TYPE_KAS = a;
	PUT_KAS = b;
	V_KAS = c;
	TEK_OTN_KAS = 0;
	if(prRS)						// нужна запись задания
	{
		if(diagnS[2]&0x02) return;	// нет связи с контроллером
		KOM_KAS = 1;
		OTVET_KAS = 0;
		sh_ = 2;
		goto A2;					// переход на шаг 3
	}
	SetOut(1,2,0x10);           	// выдать сигнал старт движения
	CT_KAS = 0;
	sh_ = 3;						// переход на шаг 3
	goto A3;
A2:	if(diagnS[2]&0x02||(!OTVET_KAS))	// есть диагностика нет связи или нет ответа
	{
		if(CT_KAS >= 5000)
			diagn[18] |= 0x04;		// отказ: "Нет ответа на команду приводу перемещения"
		return;
	}
	diagn[18] &= (~0x04);			// сброс диагностики
	KOM_KAS = 0;
	SetOut(1,2,0x10);           		// выдать сигнал старт движения
	CT_KAS = 0;
	sh_ = 3;
A3:	if(zin[4]&0x40)					// готовность привода не пропала
	{
		if(CT_KAS >= 2000)
			diagn[18] |= 0x08;		// отказ: "Нет начала движения привода перемещения"
		return;
	}
	diagn[18] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x10);               // сбросить сигнал старт движения
	CT_KAS = 0;
	if(e)							// задано время движения
	{
		sh_ = 4;
		goto A4;					// переход на шаг 4
	}
	else if(d)						// задано контрольное время
	{
		sh_ = 6;
		goto A6;					// переход на шаг 6
	}
	sh_ = 0;						// выход без контроля окончания
	return;
A4:	if(CT_KAS <= (e*1000))		// время не вышло
		return;
	SetOut(1,2,0x800);				// выставить Стоп механизмов
	CT_KAS = 0;
	sh_ = 5;
A5:	if(!(zin[4]&0x40))				// нет готовности привода
	{
		if(CT_KAS >= 2000)			// 2 сек в 1 мс тиках
			diagn[18] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[18] &= (~0x20);			// сброс диагностики
	sh_ = 6;
	goto S1;
A6:	if(!(zin[4]&0x40)||(prRS&&(((a==ABS)&&((TEK_ABS_KAS < b-5)||(TEK_ABS_KAS > b+5)))||((a==OTN)&&((TEK_OTN_KAS < b-5)||(TEK_OTN_KAS > b+5))))))
	// нет готовности привода или пути не достигнуты для "RS-овских"
	{
		if(CT_KAS >= (d*1000))		// контрольное время движения
			diagn[18] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[18] &= (~0x20);				// сброс диагностики
S1:	PR_KAS = 0;
	norma =11 ;						// "Привод перемещения выполнил движение"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//----------------------------ППД-------------------------------------------
void PPD_HOME(unsigned int a)
// перемещение механизма в Home
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// VR_HOME(10);	// механизм перемещения в Home с 10 сек контр. временем

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_PPD = 1;
	CT_PPD = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x1000))		// нет готовности привода
	{
		if(CT_PPD >= 2000)	// 2 сек в 1 мс тиках
			diagn[21] |= 0x01;	// диагностика "Нет готовности привода .."
		return;
	}
	diagn[21] &= (~0x01);			// сброс диагностики
	CT_PPD = 0;
    TEK_OTN_PPD = 0;
	SetOut(1,2,0x200);           	// выдать сигнал движения в Home
	sh_ = 3;
A3:	if(!(zin[4]&0x2000)||(TEK_ABS_PPD < -5)||(TEK_ABS_PPD > 5)) // механизм не пришел в Home
	{
		if(CT_PPD >= (a*1000))
			diagn[21] |= 0x10;		// отказ: "Привод .. не пришел в Home"
		return;
	}
	diagn[21] &= (~0x10);			// сброс диагностики
	SetOut(0,2,0x200);               // снять движение в Home
	CT_PPD = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x1000))				// нет готовности привода
	{
		if(CT_PPD >= 2000)			// 2 сек в 1 мс тиках
		diagn[21] |= 0x01;			// отказ: "Нет готовности привода.."
		return;
	}
	diagn[21] &= (~0x01);			// сброс диагностики
	PR_PPD = 0;
	norma = 18;						// "Привод .. пришел в Home"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
//---------------------------------------------------------------------------
void VIDK_PPD(bool prRS,unsigned char a,int b,int c,unsigned int d, unsigned int e)
// выдача команд на механизм для стандартных движений
{
	// prRS - необходимость записи задания по RS
	// a - тип движения (соответствует типам в контроллере стр.61):
	// ABS = 1 - по абсолютной координате
	// OTN = 2 - по относительной координате
	// CON = 7 - "бесконечное"
	// ABS_F = 10 - абс. движение в прямом напр. (для циклич.)
	// ABS_R = 11 - абс. движение в обратном напр. (для циклич.)
	// b - путь (в имп)
	// c - скорость (в имп/сек)
	// d - контр. время перемещения в сек (выдача диагностики)
	// e - время перемещения в сек (для движений по времени)
	// VIDK_VR(0,0,0,0,10,0); // движение по выбранным параметрам с 10 сек контр. временем
	// VIDK_VR(1,OTN,par[3],v_mech[0][1],15,0); // с записью параметров с 15 сек контр. временем
	// VIDK_VR(0,0,0,0,0,30); // движение по выбранным параметрам длительностью 30 сек
	// VIDK_VR(1,CON,0,par[2],0,0); // "бесконечное" движение без контроля окончания
	// VIDK_VR(0,0,0,0,0,0); // движение по выбранным параметрам без контроля окончания

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	else return;	// выход

A1:	SetOut(0,2,0x800);		// снять "стоп механизмов"
	PR_PPD = 1;
	if(!(zin[4]&0x1000))				// нет готовности привода
	{
		diagn[21] |= 0x01;			// отказ: "Нет готовности привода перемещения"
		return;
	}
	diagn[21] &= (~0x01);				// сброс диагностики
	CT_PPD = 0;
	TYPE_PPD = a;
	PUT_PPD = b;
	V_PPD = c;
	TEK_OTN_PPD = 0;
	if(prRS)						// нужна запись задания
	{
		if(diagnS[2]&0x10) return;	// нет связи с контроллером
		KOM_PPD = 1;
		OTVET_PPD = 0;
		sh_ = 2;
		goto A2;					// переход на шаг 3
	}
	SetOut(1,2,0x100);           	// выдать сигнал старт движения
	CT_PPD = 0;
	sh_ = 3;						// переход на шаг 3
	goto A3;
A2:	if(diagnS[2]&0x10||(!OTVET_PPD))	// есть диагностика нет связи или нет ответа
	{
		if(CT_PPD >= 5000)
			diagn[21] |= 0x04;		// отказ: "Нет ответа на команду приводу перемещения"
		return;
	}
	diagn[21] &= (~0x04);			// сброс диагностики
	KOM_PPD = 0;
	SetOut(1,2,0x100);           		// выдать сигнал старт движения
	CT_PPD = 0;
	sh_ = 3;
A3:	if(zin[4]&0x1000)					// готовность привода не пропала
	{
		if(CT_PPD >= 2000)
			diagn[21] |= 0x08;		// отказ: "Нет начала движения привода перемещения"
		return;
	}
	diagn[21] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x100);               // сбросить сигнал старт движения
	CT_PPD = 0;
	if(e)							// задано время движения
	{
		sh_ = 4;
		goto A4;					// переход на шаг 4
	}
	else if(d)						// задано контрольное время
	{
		sh_ = 6;
		goto A6;					// переход на шаг 6
	}
	sh_ = 0;						// выход без контроля окончания
	return;
A4:	if(CT_PPD <= (e*1000))		// время не вышло
		return;
	SetOut(1,2,0x800);				// выставить Стоп механизмов
	CT_PPD = 0;
	sh_ = 5;
A5:	if(!(zin[4]&0x1000))				// нет готовности привода
	{
		if(CT_PPD >= 2000)			// 2 сек в 1 мс тиках
			diagn[21] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[21] &= (~0x20);			// сброс диагностики
	sh_ = 6;
	goto S1;
A6:	if(!(zin[4]&0x1000)||(prRS&&(((a==ABS)&&((TEK_ABS_PPD < b-5)||(TEK_ABS_PPD > b+5)))||((a==OTN)&&((TEK_OTN_PPD < b-5)||(TEK_OTN_PPD > b+5))))))
	// нет готовности привода или пути не достигнуты для "RS-овских"
	{
		if(CT_PPD >= (d*1000))		// контрольное время движения
			diagn[21] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[21] &= (~0x20);				// сброс диагностики
S1:	PR_PPD = 0;
	norma =19 ;						// "Привод перемещения выполнил движение"
    SetOut(1,2,0x800);				// выставить Стоп механизмов
	sh_ = 0;
}
void VklTmnKam ()               //Включение ТМН кам
{
    if(sh_==1)
    {
        if(out[5]&0x20)
        {
            SetOut(1,5,0x10);           //вкл ТМНкам
            sh_=3;
            CT_TMN=0;
        }
        SetOut(1,5,0x20);
        CT_TMN=0;
        sh_=2;

    }
    else if(sh_==2)
    {
        if(CT_TMN>2)
        {
            SetOut(1,5,0x10);           //вкл ТМНкам
            sh_=3;
            CT_TMN=0;
        }

    }

    else if(sh_=3)
    {
        if(zin[5]&0x05)
        {
            diagn[10]&=(~0x04);         //сброс диагностики
            sh_=0;
            norma=59;
            return;
        }
        if(CT_TMN>10)
            diagn[10]|=0x04;            //отказ "ТМН камеры не включился"
        return;
    }

    else
    {
        sh_=1;
    }
    return;
}

