//---------------------------------------------------------------------------
//--Файл описания шаблонных функций--//
//---------------------------------------------------------------------------
#include "Klapan.h"
//---------------------------------------------------------------------------
//--Функция инкрементации счетчика объекта--//
//---------------------------------------------------------------------------
void SKlapan::Time()
{
    ctObject++;
}
//---------------------------------------------------------------------------
//--Функция управления объектами через дискретные входы-выходы--//
//---------------------------------------------------------------------------
void Klapan(bool action, SKlapan *object)
{
    switch ( object -> type )
    {
        case 11: DoAction11(action, object); break;
        case 12: DoAction12(action, object); break;
        case 21: DoAction21(action, object); break;
        case 22: DoAction22(action, object); break;
        // неверный тип объекта
        default: diagn[0] |= 0x01; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 1 входом--//
//---------------------------------------------------------------------------
void DoAction11(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 2 входами--//
//---------------------------------------------------------------------------
void DoAction12(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 1 входом--//
//---------------------------------------------------------------------------
void DoAction21(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 2 входами--//
//---------------------------------------------------------------------------
void DoAction22(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция инкремента счетчиков--//
//---------------------------------------------------------------------------
void TimeKlapan()
{
	FvnKam.Time();
    FvnShl.Time();
    KlShl.Time();
    KlKam.Time();
    KlIsp.Time();
    KlTmnKam.Time();
    KlTmnShl.Time();
    KlTmnIsp.Time();
    ZatvTmnShl.Time();
    ZatvTmnIsp.Time();
    ShZatvShl.Time();
    ZatvIsp.Time();
    ZaslWindow.Time();
    ZaslIsp.Time();
    EkrZatv.Time();
    Shv.Time();
    Isp.Time();

}
//---------------------------------------------------------------------------
//--Функция инициализации объектов с дискретным управлением и дискретной обратной связью--//
//---------------------------------------------------------------------------
void InitObjectsKl()
{
	// описание форнасоса камеры
	FvnKam.type = 11;					// тип 1/1
	// нормы объекта                                                                                         
	FvnKam.normaNmb[0] = 37;				// код нормы включения
	FvnKam.normaNmb[1] = 38;				// код нормы отключения
	// контрольные времена объекта
	FvnKam.tkAction[0] = 2;				// к.время открытия
	FvnKam.tkAction[1] = 15;				// к.время закрытия
	FvnKam.tkAction[2] = 30;				// к.время задержки после открытия
	FvnKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnKam.diagnObject[0].x = 0;			// номер байта диагностики "не открылся"
	FvnKam.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	FvnKam.diagnObject[1].x = 0;			// номер байта диагностики "не закрылся"
	FvnKam.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	FvnKam.diagnObject[2].x = 0;			// номер байта диагностики "не определено"
	FvnKam.diagnObject[2].y = 0x02;		// маска бита диагностики "не определено"
	FvnKam.diagnObject[3].x = 0;			// номер байта диагностики "неоднозначно"
	FvnKam.diagnObject[3].y = 0x02;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnKam.zinOut[0].x = 3;				// номер байта упр. выходного сигнала на "открытие"
	FvnKam.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	FvnKam.zinOut[1].x = 3;				// номер байта упр. выходного сигнала на "закрытие"
	FvnKam.zinOut[1].y = 0x10;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnKam.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	FvnKam.zinIn[0].y = 0x08;			// маска бита ответного входного сигнала об "открытии"
	FvnKam.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	FvnKam.zinIn[1].y = 0x08;			// маска бита ответного входного сигнала о "закрытии"

    // описание форнасос шлюза
	FvnShl.type = 11;					// тип 1/1
	// нормы объекта
	FvnShl.normaNmb[0] = 39;				// код нормы включения
	FvnShl.normaNmb[1] = 40;				// код нормы отключения
	// контрольные времена объекта
	FvnShl.tkAction[0] = 2;				// к.время открытия
	FvnShl.tkAction[1] = 15;				// к.время закрытия
	FvnShl.tkAction[2] = 30;				// к.время задержки после открытия
	FvnShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnShl.diagnObject[0].x = 0;			// номер байта диагностики "не открылся"
	FvnShl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	FvnShl.diagnObject[1].x = 0;			// номер байта диагностики "не закрылся"
	FvnShl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	FvnShl.diagnObject[2].x = 0;			// номер байта диагностики "не определено"
	FvnShl.diagnObject[2].y = 0x20;		// маска бита диагностики "не определено"
	FvnShl.diagnObject[3].x = 0;			// номер байта диагностики "неоднозначно"
	FvnShl.diagnObject[3].y = 0x20;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnShl.zinOut[0].x = 3;				// номер байта упр. выходного сигнала на "открытие"
	FvnShl.zinOut[0].y = 0x08;			// маска бита упр. выходного сигнала  на "открытие"
	FvnShl.zinOut[1].x = 3;				// номер байта упр. выходного сигнала на "закрытие"
	FvnShl.zinOut[1].y = 0x08;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnShl.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	FvnShl.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	FvnShl.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	FvnShl.zinIn[1].y = 0x01;			// маска бита ответного входного сигнала о "закрытии"

    // описание Фк шлюза
	KlShl.type = 12;					// тип 1/2
	// нормы объекта
	KlShl.normaNmb[0] = 27;				// код нормы включения
	KlShl.normaNmb[1] = 28;				// код нормы отключения
	// контрольные времена объекта
	KlShl.tkAction[0] = 2;				// к.время открытия
	KlShl.tkAction[1] = 2;				// к.время закрытия
	KlShl.tkAction[2] = 2;				// к.время задержки после открытия
	KlShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlShl.diagnObject[0].x = 1;			// номер байта диагностики "не открылся"
	KlShl.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlShl.diagnObject[1].x = 1;			// номер байта диагностики "не закрылся"
	KlShl.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlShl.diagnObject[2].x = 1;			// номер байта диагностики "не определено"
	KlShl.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlShl.diagnObject[3].x = 1;			// номер байта диагностики "неоднозначно"
	KlShl.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlShl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlShl.zinOut[0].y = 0x03;			// маска бита упр. выходного сигнала  на "открытие"
	KlShl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"                                      
	KlShl.zinOut[1].y = 0x03;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlShl.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	KlShl.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	KlShl.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	KlShl.zinIn[1].y = 0x02;			// маска бита ответного входного сигнала о "закрытии"

    // описание  Фк кам
	KlKam.type = 12;					// тип 1/2
	// нормы объекта
	KlKam.normaNmb[0] = 29;				// код нормы включения
	KlKam.normaNmb[1] = 30;				// код нормы отключения
	// контрольные времена объекта
	KlKam.tkAction[0] = 2;				// к.время открытия
	KlKam.tkAction[1] = 2;				// к.время закрытия
	KlKam.tkAction[2] = 2;				// к.время задержки после открытия
	KlKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlKam.diagnObject[0].x = 1;			// номер байта диагностики "не открылся"
	KlKam.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlKam.diagnObject[1].x = 1;			// номер байта диагностики "не закрылся"
	KlKam.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"                                                        
	KlKam.diagnObject[2].x = 1;			// номер байта диагностики "не определено"
	KlKam.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlKam.diagnObject[3].x = 1;			// номер байта диагностики "неоднозначно"
	KlKam.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlKam.zinOut[0].x = 3;				// номер байта упр. выходного сигнала на "открытие"
	KlKam.zinOut[0].y = 0x03;			// маска бита упр. выходного сигнала  на "открытие"
	KlKam.zinOut[1].x = 3;				// номер байта упр. выходного сигнала на "закрытие"
	KlKam.zinOut[1].y = 0x03;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlKam.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	KlKam.zinIn[0].y = 0x04;			// маска бита ответного входного сигнала об "открытии"
	KlKam.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	KlKam.zinIn[1].y = 0x08;			// маска бита ответного входного сигнала о "закрытии"

    // описание  Фк исп
	KlIsp.type = 12;					// тип 1/2
	// нормы объекта
	KlIsp.normaNmb[0] = 31;				// код нормы включения
	KlIsp.normaNmb[1] = 32;				// код нормы отключения
	// контрольные времена объекта
	KlIsp.tkAction[0] = 2;				// к.время открытия
	KlIsp.tkAction[1] = 2;				// к.время закрытия
	KlIsp.tkAction[2] = 2;				// к.время задержки после открытия
	KlIsp.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlIsp.diagnObject[0].x = 2;			// номер байта диагностики "не открылся"
	KlIsp.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlIsp.diagnObject[1].x = 2;			// номер байта диагностики "не закрылся"
	KlIsp.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlIsp.diagnObject[2].x = 2;			// номер байта диагностики "не определено"
	KlIsp.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlIsp.diagnObject[3].x = 2;			// номер байта диагностики "неоднозначно"
	KlIsp.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlIsp.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlIsp.zinOut[0].y = 0x300;			// маска бита упр. выходного сигнала  на "открытие"
	KlIsp.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"                                                        
	KlIsp.zinOut[1].y = 0x300;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlIsp.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	KlIsp.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	KlIsp.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	KlIsp.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"

    // описание ФК-ТМН камеры
	KlTmnKam.type = 12;					// тип 1/2
	// нормы объекта
	KlTmnKam.normaNmb[0] = 60;				// код нормы включения
	KlTmnKam.normaNmb[1] = 61;				// код нормы отключения
	// контрольные времена объекта
	KlTmnKam.tkAction[0] = 2;				// к.время открытия
	KlTmnKam.tkAction[1] = 2;				// к.время закрытия
	KlTmnKam.tkAction[2] = 2;				// к.время задержки после открытия
	KlTmnKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlTmnKam.diagnObject[0].x = 7;			// номер байта диагностики "не открылся"
	KlTmnKam.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlTmnKam.diagnObject[1].x = 7;			// номер байта диагностики "не закрылся"
	KlTmnKam.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlTmnKam.diagnObject[2].x = 7;			// номер байта диагностики "не определено"
	KlTmnKam.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlTmnKam.diagnObject[3].x = 7;			// номер байта диагностики "неоднозначно"
	KlTmnKam.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlTmnKam.zinOut[0].x = 3;				// номер байта упр. выходного сигнала на "открытие"
	KlTmnKam.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	KlTmnKam.zinOut[1].x = 3;				// номер байта упр. выходного сигнала на "закрытие"
	KlTmnKam.zinOut[1].y = 0x04;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlTmnKam.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	KlTmnKam.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	KlTmnKam.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	KlTmnKam.zinIn[1].y = 0x02;			// маска бита ответного входного сигнала о "закрытии"

    // описание ФК-ТМН шлюза
	KlTmnShl.type = 12;					// тип 1/2
	// нормы объекта
	KlTmnShl.normaNmb[0] = 33;				// код нормы включения
	KlTmnShl.normaNmb[1] = 34;				// код нормы отключения
	// контрольные времена объекта
	KlTmnShl.tkAction[0] = 2;				// к.время открытия
	KlTmnShl.tkAction[1] = 2;				// к.время закрытия
	KlTmnShl.tkAction[2] = 2;				// к.время задержки после открытия
	KlTmnShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlTmnShl.diagnObject[0].x = 2;			// номер байта диагностики "не открылся"
	KlTmnShl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlTmnShl.diagnObject[1].x = 2;			// номер байта диагностики "не закрылся"
	KlTmnShl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlTmnShl.diagnObject[2].x = 2;			// номер байта диагностики "не определено"
	KlTmnShl.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlTmnShl.diagnObject[3].x = 2;			// номер байта диагностики "неоднозначно"
	KlTmnShl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlTmnShl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlTmnShl.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	KlTmnShl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlTmnShl.zinOut[1].y = 0x10;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlTmnShl.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	KlTmnShl.zinIn[0].y = 0x04;			// маска бита ответного входного сигнала об "открытии"
	KlTmnShl.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	KlTmnShl.zinIn[1].y = 0x08;			// маска бита ответного входного сигнала о "закрытии"

    // описание Фк-ТМН исп
	KlTmnIsp.type = 12;					// тип 1/2
	// нормы объекта
	KlTmnIsp.normaNmb[0] = 35;				// код нормы включения
	KlTmnIsp.normaNmb[1] = 36;				// код нормы отключения
	// контрольные времена объекта
	KlTmnIsp.tkAction[0] = 2;				// к.время открытия
	KlTmnIsp.tkAction[1] = 2;				// к.время закрытия
	KlTmnIsp.tkAction[2] = 2;				// к.время задержки после открытия
	KlTmnIsp.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlTmnIsp.diagnObject[0].x = 3;			// номер байта диагностики "не открылся"
	KlTmnIsp.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlTmnIsp.diagnObject[1].x = 3;			// номер байта диагностики "не закрылся"
	KlTmnIsp.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlTmnIsp.diagnObject[2].x = 3;			// номер байта диагностики "не определено"
	KlTmnIsp.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlTmnIsp.diagnObject[3].x = 3;			// номер байта диагностики "неоднозначно"
	KlTmnIsp.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlTmnIsp.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlTmnIsp.zinOut[0].y = 0x1000;			// маска бита упр. выходного сигнала  на "открытие"
	KlTmnIsp.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlTmnIsp.zinOut[1].y = 0x1000;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlTmnIsp.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	KlTmnIsp.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	KlTmnIsp.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	KlTmnIsp.zinIn[1].y = 0x800;			// маска бита ответного входного сигнала о "закрытии"

    // описание   затвор ТМН шлюза
	ZatvTmnShl.type = 22;					// тип 2/2
	// нормы объекта
	ZatvTmnShl.normaNmb[0] = 41;				// код нормы включения
	ZatvTmnShl.normaNmb[1] = 42;				// код нормы отключения
	// контрольные времена объекта
	ZatvTmnShl.tkAction[0] = 2;				// к.время открытия
	ZatvTmnShl.tkAction[1] = 2;				// к.время закрытия
	ZatvTmnShl.tkAction[2] = 2;				// к.время задержки после открытия
	ZatvTmnShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	ZatvTmnShl.diagnObject[0].x = 3;			// номер байта диагностики "не открылся"
	ZatvTmnShl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	ZatvTmnShl.diagnObject[1].x = 3;			// номер байта диагностики "не закрылся"
	ZatvTmnShl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	ZatvTmnShl.diagnObject[2].x = 3;			// номер байта диагностики "не определено"
	ZatvTmnShl.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	ZatvTmnShl.diagnObject[3].x = 3;			// номер байта диагностики "неоднозначно"
	ZatvTmnShl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZatvTmnShl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	ZatvTmnShl.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	ZatvTmnShl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	ZatvTmnShl.zinOut[1].y = 0x08;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZatvTmnShl.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	ZatvTmnShl.zinIn[0].y = 0x10;			// маска бита ответного входного сигнала об "открытии"
	ZatvTmnShl.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	ZatvTmnShl.zinIn[1].y = 0x20;			// маска бита ответного входного сигнала о "закрытии"

    // описание Затвор ТМН исп
	ZatvTmnIsp.type = 22;					// тип 2/2
	// нормы объекта
	ZatvTmnIsp.normaNmb[0] = 43;				// код нормы включения
	ZatvTmnIsp.normaNmb[1] = 44;				// код нормы отключения
	// контрольные времена объекта
	ZatvTmnIsp.tkAction[0] = 2;				// к.время открытия
	ZatvTmnIsp.tkAction[1] = 2;				// к.время закрытия
	ZatvTmnIsp.tkAction[2] = 2;				// к.время задержки после открытия
	ZatvTmnIsp.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	ZatvTmnIsp.diagnObject[0].x = 4;			// номер байта диагностики "не открылся"
	ZatvTmnIsp.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	ZatvTmnIsp.diagnObject[1].x = 4;			// номер байта диагностики "не закрылся"
	ZatvTmnIsp.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	ZatvTmnIsp.diagnObject[2].x = 4;			// номер байта диагностики "не определено"
	ZatvTmnIsp.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	ZatvTmnIsp.diagnObject[3].x = 4;			// номер байта диагностики "неоднозначно"
	ZatvTmnIsp.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZatvTmnIsp.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	ZatvTmnIsp.zinOut[0].y = 0x400;			// маска бита упр. выходного сигнала  на "открытие"
	ZatvTmnIsp.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	ZatvTmnIsp.zinOut[1].y = 0x800;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZatvTmnIsp.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	ZatvTmnIsp.zinIn[0].y = 0x1000;			// маска бита ответного входного сигнала об "открытии"
	ZatvTmnIsp.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	ZatvTmnIsp.zinIn[1].y = 0x2000;			// маска бита ответного входного сигнала о "закрытии"

    // описание Щелевой затвор шлюза
	ShZatvShl.type =22 ;					// тип 2/2
	// нормы объекта
	ShZatvShl.normaNmb[0] = 45;				// код нормы включения
	ShZatvShl.normaNmb[1] = 46;				// код нормы отключения
	// контрольные времена объекта
	ShZatvShl.tkAction[0] = 4;				// к.время открытия
	ShZatvShl.tkAction[1] = 4;				// к.время закрытия
	ShZatvShl.tkAction[2] = 1;				// к.время задержки после открытия
	ShZatvShl.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ShZatvShl.diagnObject[0].x = 4;			// номер байта диагностики "не открылся"
	ShZatvShl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	ShZatvShl.diagnObject[1].x = 4;			// номер байта диагностики "не закрылся"
	ShZatvShl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	ShZatvShl.diagnObject[2].x = 4;			// номер байта диагностики "не определено"
	ShZatvShl.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	ShZatvShl.diagnObject[3].x = 4;			// номер байта диагностики "неоднозначно"
	ShZatvShl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ShZatvShl.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ShZatvShl.zinOut[0].y = 0x08;			// маска бита упр. выходного сигнала  на "открытие"
	ShZatvShl.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ShZatvShl.zinOut[1].y = 0x10;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ShZatvShl.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	ShZatvShl.zinIn[0].y = 0x10;			// маска бита ответного входного сигнала об "открытии"
	ShZatvShl.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	ShZatvShl.zinIn[1].y = 0x20;			// маска бита ответного входного сигнала о "закрытии"

    // описание  Затвор испарителя
	ZatvIsp.type =22 ;					// тип 2/2
	// нормы объекта
	ZatvIsp.normaNmb[0] = 47;				// код нормы включения
	ZatvIsp.normaNmb[1] = 48;				// код нормы отключения
	// контрольные времена объекта
	ZatvIsp.tkAction[0] = 4;				// к.время открытия
	ZatvIsp.tkAction[1] = 4;				// к.время закрытия
	ZatvIsp.tkAction[2] = 1;				// к.время задержки после открытия
	ZatvIsp.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ZatvIsp.diagnObject[0].x = 5;			// номер байта диагностики "не открылся"
	ZatvIsp.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	ZatvIsp.diagnObject[1].x = 5;			// номер байта диагностики "не закрылся"
	ZatvIsp.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	ZatvIsp.diagnObject[2].x = 5;			// номер байта диагностики "не определено"
	ZatvIsp.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	ZatvIsp.diagnObject[3].x = 5;			// номер байта диагностики "неоднозначно"
	ZatvIsp.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZatvIsp.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ZatvIsp.zinOut[0].y = 0x20;			// маска бита упр. выходного сигнала  на "открытие"
	ZatvIsp.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ZatvIsp.zinOut[1].y = 0x40;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZatvIsp.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	ZatvIsp.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	ZatvIsp.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	ZatvIsp.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"

    // описание  заслонка смотрового окна
	ZaslWindow.type = 22;					// тип 2/2
	// нормы объекта
	ZaslWindow.normaNmb[0] = 49;				// код нормы включения
	ZaslWindow.normaNmb[1] = 50;				// код нормы отключения
	// контрольные времена объекта
	ZaslWindow.tkAction[0] = 10;				// к.время открытия
	ZaslWindow.tkAction[1] = 10;				// к.время закрытия
	ZaslWindow.tkAction[2] = 1;				// к.время задержки после открытия
	ZaslWindow.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ZaslWindow.diagnObject[0].x = 5;			// номер байта диагностики "не открылся"
	ZaslWindow.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	ZaslWindow.diagnObject[1].x = 5;			// номер байта диагностики "не закрылся"
	ZaslWindow.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	ZaslWindow.diagnObject[2].x = 5;			// номер байта диагностики "не определено"
	ZaslWindow.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	ZaslWindow.diagnObject[3].x = 5;			// номер байта диагностики "неоднозначно"
	ZaslWindow.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZaslWindow.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	ZaslWindow.zinOut[0].y = 0x4000;			// маска бита упр. выходного сигнала  на "открытие"
	ZaslWindow.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	ZaslWindow.zinOut[1].y = 0x8000;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZaslWindow.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	ZaslWindow.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	ZaslWindow.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	ZaslWindow.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"

    // описание  Заслонка испарителя
	ZaslIsp.type =22 ;					// тип 2/2
	// нормы объекта
	ZaslIsp.normaNmb[0] = 51;				// код нормы включения
	ZaslIsp.normaNmb[1] = 52;				// код нормы отключения
	// контрольные времена объекта
	ZaslIsp.tkAction[0] = 10;				// к.время открытия
	ZaslIsp.tkAction[1] = 10;				// к.время закрытия
	ZaslIsp.tkAction[2] = 1;				// к.время задержки после открытия
	ZaslIsp.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ZaslIsp.diagnObject[0].x = 6;			// номер байта диагностики "не открылся"
	ZaslIsp.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	ZaslIsp.diagnObject[1].x = 6;			// номер байта диагностики "не закрылся"
	ZaslIsp.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	ZaslIsp.diagnObject[2].x = 6;			// номер байта диагностики "не определено"
	ZaslIsp.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	ZaslIsp.diagnObject[3].x = 6;			// номер байта диагностики "неоднозначно"
	ZaslIsp.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZaslIsp.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ZaslIsp.zinOut[0].y = 0x1000;			// маска бита упр. выходного сигнала  на "открытие"
	ZaslIsp.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ZaslIsp.zinOut[1].y = 0x2000;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZaslIsp.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	ZaslIsp.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	ZaslIsp.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	ZaslIsp.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"

    // описание  Экран затвора испарителя
	EkrZatv.type = 22;					// тип 2/2
	// нормы объекта
	EkrZatv.normaNmb[0] = 53;				// код нормы включения
	EkrZatv.normaNmb[1] = 54;				// код нормы отключения
	// контрольные времена объекта
	EkrZatv.tkAction[0] = 10;				// к.время открытия
	EkrZatv.tkAction[1] = 10;				// к.время закрытия
	EkrZatv.tkAction[2] = 1;				// к.время задержки после открытия
	EkrZatv.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	EkrZatv.diagnObject[0].x = 6;			// номер байта диагностики "не открылся"
	EkrZatv.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	EkrZatv.diagnObject[1].x = 6;			// номер байта диагностики "не закрылся"
	EkrZatv.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	EkrZatv.diagnObject[2].x = 6;			// номер байта диагностики "не определено"
	EkrZatv.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	EkrZatv.diagnObject[3].x = 6;			// номер байта диагностики "неоднозначно"
	EkrZatv.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	EkrZatv.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	EkrZatv.zinOut[0].y = 0x40;			// маска бита упр. выходного сигнала  на "открытие"
	EkrZatv.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	EkrZatv.zinOut[1].y = 0x80;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	EkrZatv.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	EkrZatv.zinIn[0].y = 0x4000;			// маска бита ответного входного сигнала об "открытии"
	EkrZatv.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	EkrZatv.zinIn[1].y = 0x8000;			// маска бита ответного входного сигнала о "закрытии"

    // описание Схват
	Shv.type = 22;					// тип 2/2
	// нормы объекта
	Shv.normaNmb[0] = 55;				// код нормы включения
	Shv.normaNmb[1] = 56;				// код нормы отключения
	// контрольные времена объекта
	Shv.tkAction[0] = 10;				// к.время открытия
	Shv.tkAction[1] = 10;				// к.время закрытия
	Shv.tkAction[2] = 1;				// к.время задержки после открытия
	Shv.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	Shv.diagnObject[0].x = 7;			// номер байта диагностики "не открылся"
	Shv.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	Shv.diagnObject[1].x = 7;			// номер байта диагностики "не закрылся"
	Shv.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	Shv.diagnObject[2].x = 7;			// номер байта диагностики "не определено"
	Shv.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	Shv.diagnObject[3].x = 7;			// номер байта диагностики "неоднозначно"
	Shv.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	Shv.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	Shv.zinOut[0].y = 0x100;			// маска бита упр. выходного сигнала  на "открытие"
	Shv.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	Shv.zinOut[1].y = 0x200;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	Shv.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	Shv.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	Shv.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	Shv.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"

    // описание испаритель
	Isp.type = 21;					// тип 2/1
	// нормы объекта
	Isp.normaNmb[0] = 57;				// код нормы включения
	Isp.normaNmb[1] = 58;				// код нормы отключения
	// контрольные времена объекта
	Isp.tkAction[0] = 10;				// к.время открытия
	Isp.tkAction[1] = 10;				// к.время закрытия
	Isp.tkAction[2] = 1;				// к.время задержки после открытия
	Isp.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	Isp.diagnObject[0].x = 11;			// номер байта диагностики "не открылся"
	Isp.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	Isp.diagnObject[1].x = 11;			// номер байта диагностики "не закрылся"
	Isp.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	Isp.diagnObject[2].x = 11;			// номер байта диагностики "не определено"
	Isp.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	Isp.diagnObject[3].x = 11;			// номер байта диагностики "неоднозначно"
	Isp.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	Isp.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	Isp.zinOut[0].y = 0x400;			// маска бита упр. выходного сигнала  на "открытие"
	Isp.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	Isp.zinOut[1].y = 0x800;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	Isp.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	Isp.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	Isp.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	Isp.zinIn[1].y = 0x400;			// маска бита ответного входного сигнала о "закрытии"




}






