//---------------------------------------------------------------------------
//--Файл описания шаблонных функций--//
//---------------------------------------------------------------------------
#include "Zasl.h"
//---------------------------------------------------------------------------
//--Функция инкрементации счетчика объекта--//
//---------------------------------------------------------------------------
void SZasl::Time()
{
    ctObject++;
}
//---------------------------------------------------------------------------
//--Функция управления объектами через дискретные входы-выходы--//
//---------------------------------------------------------------------------
void Zasl(bool action, SZasl *object)
{
    switch ( object -> type )
    {
        
        case 21: DoAction21(action, object); break;
        
        // неверный тип объекта
        default: diagn[0] |= 0x01; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 1 входом--//
//---------------------------------------------------------------------------
void DoAction21(bool action, SZasl *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) != action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) != action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция инкремента счетчиков--//
//---------------------------------------------------------------------------
void TimeZasl()
{

	
    II.Time();
    M1.Time();
    M2.Time();

}
//---------------------------------------------------------------------------
//--Функция инициализации объектов с дискретным управлением и дискретной обратной связью--//
//---------------------------------------------------------------------------
void InitObjectsZasl()
{
	
    
    // описание заслонки ии
	II.type = 21;						// тип 2/1
	// нормы объекта
	II.normaNmb[0] = 76;				// код нормы включения
	II.normaNmb[1] = 77;				// код нормы отключения
	// контрольные времена объекта
	II.tkAction[0] = 10;				// к.время открытия
	II.tkAction[1] = 10;				// к.время закрытия
	II.tkAction[2] = 1;					// к.время задержки после открытия
	II.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	II.diagnObject[0].x = 29;			// номер байта диагностики "не открылся"
	II.diagnObject[0].y = 0x01;			// маска бита диагностики "не открылся"
	II.diagnObject[1].x = 29;			// номер байта диагностики "не закрылся"
	II.diagnObject[1].y = 0x02;			// маска бита диагностики "не закрылся"
	II.diagnObject[2].x = 29;			// номер байта диагностики "не определено"
	II.diagnObject[2].y = 0x04;			// маска бита диагностики "не определено"
	II.diagnObject[3].x = 29;			// номер байта диагностики "неоднозначно"
	II.diagnObject[3].y = 0x08;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	II.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	II.zinOut[0].y = 0x100;			// маска бита упр. выходного сигнала  на "открытие"
	II.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	II.zinOut[1].y = 0x200;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	II.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	II.zinIn[0].y = 0x20;			// маска бита ответного входного сигнала об "открытии"
	II.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	II.zinIn[1].y = 0x20;			// маска бита ответного входного сигнала о "закрытии"
    
    // описание заслонки М1
	M1.type = 21;						// тип 2/1
	// нормы объекта
	M1.normaNmb[0] = 78;				// код нормы включения
	M1.normaNmb[1] = 79;				// код нормы отключения
	// контрольные времена объекта
	M1.tkAction[0] = 10;				// к.время открытия
	M1.tkAction[1] = 10;				// к.время закрытия
	M1.tkAction[2] = 1;					// к.время задержки после открытия
	M1.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	M1.diagnObject[0].x = 29;			// номер байта диагностики "не открылся"
	M1.diagnObject[0].y = 0x10;			// маска бита диагностики "не открылся"
	M1.diagnObject[1].x = 29;			// номер байта диагностики "не закрылся"
	M1.diagnObject[1].y = 0x20;			// маска бита диагностики "не закрылся"
	M1.diagnObject[2].x = 29;			// номер байта диагностики "не определено"
	M1.diagnObject[2].y = 0x40;			// маска бита диагностики "не определено"
	M1.diagnObject[3].x = 29;			// номер байта диагностики "неоднозначно"
	M1.diagnObject[3].y = 0x80;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	M1.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	M1.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	M1.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	M1.zinOut[1].y = 0x20;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	M1.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	M1.zinIn[0].y = 0x08;			// маска бита ответного входного сигнала об "открытии"
	M1.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	M1.zinIn[1].y = 0x08;			// маска бита ответного входного сигнала о "закрытии"

    // описание заслонки М2
	M2.type = 21;						// тип 2/1
	// нормы объекта
	M2.normaNmb[0] = 80;				// код нормы включения
	M2.normaNmb[1] = 81;				// код нормы отключения
	// контрольные времена объекта
	M2.tkAction[0] = 10;				// к.время открытия
	M2.tkAction[1] = 10;				// к.время закрытия
	M2.tkAction[2] = 1;					// к.время задержки после открытия
	M2.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	M2.diagnObject[0].x = 30;			// номер байта диагностики "не открылся"
	M2.diagnObject[0].y = 0x01;			// маска бита диагностики "не открылся"
	M2.diagnObject[1].x = 30;			// номер байта диагностики "не закрылся"
	M2.diagnObject[1].y = 0x02;			// маска бита диагностики "не закрылся"
	M2.diagnObject[2].x = 30;			// номер байта диагностики "не определено"
	M2.diagnObject[2].y = 0x04;			// маска бита диагностики "не определено"
	M2.diagnObject[3].x = 30;			// номер байта диагностики "неоднозначно"
	M2.diagnObject[3].y = 0x08;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	M2.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	M2.zinOut[0].y = 0x40;			// маска бита упр. выходного сигнала  на "открытие"
	M2.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	M2.zinOut[1].y = 0x80;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	M2.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	M2.zinIn[0].y = 0x10;			// маска бита ответного входного сигнала об "открытии"
	M2.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	M2.zinIn[1].y = 0x10;			// маска бита ответного входного сигнала о "закрытии"

}
