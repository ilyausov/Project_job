//---------------------------------------------------------------------------
#pragma hdrstop
#include "Logic.h"
#include "Modules\RRG.cpp"
#include "Modules\Klapan.cpp"
//---------------------------------------------------------------------------
#pragma package(smart_init)

void LogicMain ()
{                                                                                                                                             
    KOLCO();                    // кольцо
    if ( shr[1] )               // Проверка
    {                           // активации
        R_1();                  // режима 1 "Откачка камеры"
    };
    if ( shr[2] )               // Проверка
    {                           // активации
        R_2();                  // режима 2 "Откачка шлюза"
    };
	if ( shr[3] )               // Проверка
    {                           // активации
        R_3();                  // режима 3 "Рабочий цикл"
    };
	if ( shr[4] )               // Проверка
    {                           // активации
        R_4();                  // режима 4 "Технологический процесс"
    };
    if ( shr[5] )               // Проверка
    {                           // активации
        R_5();                  // режима 5 "Сброс РЦ"
    };
	if ( shr[6] )               // Проверка
    {                           // активации
        R_6();                  // режима 6 "Сбор(выгрузка) пластин"
    };
    if ( shr[7] )               // Проверка
    {                           // активации
        R_7();                  // режима 7 "Отключение установки"
    };
	if ( shr[8] )               // Проверка
    {                           // активации
        R_8();                  // режима 8 "Аварийное отключение установки"
    };
	if ( shr[9] )               // Проверка
    {                           // активации
        R_9();                  // режима 9 "Транспортный тест"
    };	
	if ( shr[10] )               // Проверка
    {                            // активации
        R_10();                  // режима 10 "Открыть ЩЗ"
    };
    if ( shr[11] )               // Проверка
    {                            // активации
        R_11();                  // режима 11 "Закрыть ЩЗ"
    };
	if ( shr[12] )               // Проверка
    {                            // активации
        R_12();                  // режима 12 "Ман. в исх"
    };
	if ( shr[13] )               // Проверка
    {                            // активации
        R_13();                  // режима 13 "Ман. вперед/назад"
    };
	if ( shr[14] )               // Проверка
    {                            // активации
        R_14();                  // режима 14 "Ман. пов. в исх"
    };
	if ( shr[15] )               // Проверка
    {                            // активации
        R_15();                  // режима 15 "Ман. влево/вправо"
    };
	if ( shr[17] )               // Проверка
    {                            // активации
        R_17();                  // режима 17 "Дросселирование ДЗ"
    };
    if ( shr[18] )               // Проверка
    {                            // активации
        R_18();                  // режима 18 "Открыть ДЗ"
    };
    if ( shr[19] )               // Проверка
    {                            // активации
        R_19();                  // режима 19 "Закрыть ДЗ"
    };
    if ( shr[20] )              // Проверка
    {                           // активации
        R_20();                 // режима 20 "РРГ1"
    };	
    if ( shr[21] )              // Проверка
    {                           // активации
        R_21();                 // режима 21 "РРГ2"
    };
    if ( shr[22] )              // Проверка
    {                           // активации
        R_22();                 // режима 22 "РРГ3"
    };
    if ( shr[23] )              // Проверка
    {                           // активации
        R_23();                 // режима 23 "РРГ4"
    };
	if ( shr[24] )              // Проверка
    {                           // активации
        R_24();                 // режима 24 "РРГ5"
    };
	if ( shr[25] )              // Проверка
    {                           // активации
        R_25();                 // режима 25 "РРГ6"
    };
	if ( shr[26] )              // Проверка
    {                           // активации
        R_26();                 // режима 26 "РРГ7"
    };
	if ( shr[27] )              // Проверка
    {                           // активации
        R_27();                 // режима 27 "Вкл. ВЧГ стола(мощ)"
    };	
	if ( shr[28] )              // Проверка
    {                           // активации
        R_28();                 // режима 28 "Вкл. ВЧГ стола(смещ)"
    };	
   	if ( shr[29] )              // Проверка
    {                           // активации
        R_29();                 // режима 29 "Вкл. ВЧГ реактора"
    };
    if ( shr[30] )              // Проверка
    {                           // активации
        R_30();                 // режима 30 "Автосогласование ВЧГ реактора(точно)"
    };
	if ( shr[31] )              // Проверка
    {                           // активации
        R_31();                 // режима 31 "Движ. в точку согл. ВЧГ реатора(грубо)"
    };
	if ( shr[32] )              // Проверка
    {                           // активации
        R_32();                 // режима 32 "Движ. в точку согл. ВЧГ реатора(точно)"
    };
	if ( shr[33] )              // Проверка
    {                           // активации
        R_33();                 // режима 33 "Вкл. нагрев 1"
    };
    if ( shr[34] )              // Проверка
    {                           // активации
        R_34();                 // режима 34 "Откл. нагрев 1"
    };
    if ( shr[35] )              // Проверка
    {                           // активации
        R_35();                 // режима 35 "Вкл. нагрев 2"
    };
    if ( shr[36] )              // Проверка
    {                           // активации
        R_36();                 // режима 36 "Откл. нагрев 2"
    };
	if ( shr[37] )              // Проверка
    {                           // активации
        R_37();                 // режима 37 "Прижим вверх"
    };
	if ( shr[38] )              // Проверка
    {                           // активации
        R_38();                 // режима 38 "Прижим вниз"
    };
    if ( shr[39] )              // Проверка
    {                           // активации
        R_39();                 // режима 39 "Кассета в HOME"
    };
    if ( shr[40] )              // Проверка
    {                           // активации
        R_40();                 // режима 40 "Кассета вверх/вниз"
    };

    POST();                     // дешифрация команд оператора
};
//---------------------------------------------------------------------------
void KOLCO()                    // подпрограмма "Кольцо"
{
	DIAGN_KOLCO();              // диагностика в кольце
	AVAR_VODA_STOL();	        // "Реакция на пропадание воды в п/держ."
//	AVAR_VODA_IP();	            // реакция на пропадание воды в ИП
	AVAR_DAVL();	            // "Реакция на высокое давление в камере при работе ТМН"
	UPR_AVAR_OTKL();            // управление аварийным отключением
	UPR_R_30();	                // управление режимом автосогл.
	VID_DIAGN_GIS();            // выдача диагностики нет согласования ВЧГ стола
	VID_DIAGN_GIR();            // выдача диагностики нет согласования ВЧГ реактора
	OKNSGIR_g();	            // отработка кнопок грубо ВЧГ реактора
	OKNSGIR_t();	            // отработка кнопок точно ВЧГ реактора
	ZashDD();                   // подпрограмма защиты датчика
	OpenFK_TMN_CloseFK_SHL();   // Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
	MEH_AVAR_CHK();	            // слежение за авриями механизмов
	Vkl_FK_TMN();		        // включение ТМН
	UPR();						// подъём/опускание штырей (управл.)
	OPROS_SOST();				// подпрограмма "Опрос и запись состояния"
	PUSK_TP();					// Пуск ТП
}
//---------------------------------------------------------------------------
void POST()                     // Почта (приём и дешифрация команд)
{
    switch (qkk)
    {
        case 0:;break;          // проверка на KK = 0
        case 1:                 // проверка на KK = 1
        {
            if ( shr[1] == 0 )  // если режим ещё не активизирован
            {
                shr[1] = 1;     // активизируем
                sh[1]  = 1;     // режим 1 "Откачка камеры"
            }
        }; break;
        case 3:                 // проверка на KK = 3
        {
            if ( shr[3] == 0 )  // если режим ещё не активизирован
            {
                shr[3] = 1;     // активизируем
                sh[3]  = 1;     // режим 3 "Рабочий цикл"
            }
        }; break;
		case 5:                 // проверка на KK = 5
        {
            if ( shr[5] == 0 )  // если режим ещё не активизирован
            {
                shr[5] = 1;     // активизируем
                sh[5]  = 1;     // режим 5 "Сброс РЦ"
            }
        }; break;
        case 6:                 // проверка на KK = 6
        {
            if ( shr[6] == 0 )  // если режим ещё не активизирован
            {
                shr[6] = 1;     // активизируем
                sh[6]  = 1;     // режим 6 "Сбор пластин"
            }
        }; break;
		case 7:                 // проверка на KK = 7
        {
            if ( shr[7] == 0 )  // если режим ещё не активизирован
            {
                shr[7] = 1;     // активизируем
                sh[7]  = 1;     // режим 7 "Отключение установки"
            }
        }; break;
		
		case 9:                 // проверка на KK = 9
        {
            if ( shr[9] == 0 )  // если режим ещё не активизирован
            {
                shr[9] = 1;     // активизируем
                sh[9]  = 1;     // режим 9 "Транспортный тест"
            }
        }; break;		
		case 109:				// проверка на KK = 109
        {
            PR_TRTEST = 1;		// признак окончания транспортного теста
        }; break;
		case 10:				// проверка на KK = 10
        {
            if ( shr[10] == 0 )  // если режим ещё не активизирован
            {
                shr[10] = 1;     // активизируем
                sh[10]  = 1;     // режим 10 "Открыть ЩЗ"
            }
        }; break;
		case 11:                 // проверка на KK = 11
        {
            if ( shr[11] == 0 )  // если режим ещё не активизирован
            {
                shr[11] = 1;     // активизируем
                sh[11]  = 1;     // режим 11 "Закрыть ЩЗ"
            }
        }; break;
		case 12:                 // проверка на KK = 12
        {
            if ( shr[12] == 0 )  // если режим ещё не активизирован
            {
                shr[12] = 1;     // активизируем
                sh[12]  = 1;     // режим 12 "Мех. перем. в исх"
            }
        }; break;
		case 13:                 // проверка на KK = 13
        {
            if ( shr[13] == 0 )  // если режим ещё не активизирован
            {
                shr[13] = 1;     // активизируем
                sh[13]  = 1;     // режим 13 "Мех. перем. вперед/назад"
            }
        }; break;
		case 113:				// проверка на KK = 113
        {
            SBROS_MEH();		// сброс механизмов
        }; break;
		case 213:				// проверка на KK = 213
        {
            MEH_AVAR_SBROS();	// сброс аварий механизмов
        }; break;
		case 14:                 // проверка на KK = 14
        {
            if ( shr[14] == 0 )  // если режим ещё не активизирован
            {
                shr[14] = 1;     // активизируем
                sh[14]  = 1;     // режим 14 "Мех. пов. в HOME"
            }
        }; break;
		case 15:                 // проверка на KK = 15
        {
            if ( shr[15] == 0 )  // если режим ещё не активизирован
            {
                shr[15] = 1;     // активизируем
                sh[15]  = 1;     // режим 15 "Мех. пов. вправо/влево"
            }
        }; break;
		case 17:                 // проверка на KK = 17
        {
            if ( shr[17] == 0 )  // если режим ещё не активизирован
            {
                shr[17] = 1;     // активизируем
                sh[17]  = 1;     // режим 17 "Дросселирование ДЗ"
            }
        }; break;
		case 18:                 // проверка на KK = 18
        {
            if ( shr[18] == 0 )  // если режим ещё не активизирован
            {
                shr[18] = 1;     // активизируем
                sh[18]  = 1;     // режим 18 "Открыть ДЗ"
            }
        }; break;
		case 19:                 // проверка на KK = 19
        {
            if ( shr[19] == 0 )  // если режим ещё не активизирован
            {
                shr[19] = 1;     // активизируем
                sh[19]  = 1;     // режим 19 "Закрыть ДЗ"
            }
        }; break;
		case 100:				// проверка на KK = 100
        {
            OSBROS();			// общий сброс
        }; break;
		case 20:                // проверка на KK = 20
        {
            if ( shr[20] == 0 ) // если режим ещё не активизирован
            {
                shr[20] = 1;    // активизируем
                sh[20]  = 1;    // режим 20 "Вкл. РРГ1"
            }
        }; break;
		case 120:                // проверка на KK = 120
        {
			RRGOff(ObjRRG[0]);	// отключение РРГ1
		}; break;
		case 21:                // проверка на KK = 21
        {
            if ( shr[21] == 0 ) // если режим ещё не активизирован
            {
                shr[21] = 1;    // активизируем
                sh[21]  = 1;    // режим 21 "Вкл. РРГ2"
            }
        }; break;
		case 121:                // проверка на KK = 121
        {
			RRGOff(ObjRRG[1]);	// отключение РРГ2
		}; break;
		case 22:                // проверка на KK = 22
        {
            if ( shr[22] == 0 ) // если режим ещё не активизирован
            {
                shr[22] = 1;    // активизируем
                sh[22]  = 1;    // режим 22 "Вкл. РРГ3"
            }
        }; break;
		case 122:                // проверка на KK = 122
        {
			RRGOff(ObjRRG[2]);	// отключение РРГ3
		}; break;
		case 23:                // проверка на KK = 23
        {
            if ( shr[23] == 0 ) // если режим ещё не активизирован
            {
                shr[23] = 1;    // активизируем
                sh[23]  = 1;    // режим 23 "Вкл. РРГ4"
            }
        }; break;
		case 123:                // проверка на KK = 123
        {
			RRGOff(ObjRRG[3]);	// отключение РРГ4
		}; break;
		case 24:                // проверка на KK = 24
        {
            if ( shr[24] == 0 ) // если режим ещё не активизирован
            {
                shr[24] = 1;    // активизируем
                sh[24]  = 1;    // режим 24 "Вкл. РРГ5"
            }
        }; break;
		case 124:                // проверка на KK = 124
        {
			RRGOff(ObjRRG[4]);	// отключение РРГ5
		}; break;
		case 25:                // проверка на KK = 25
        {
            if ( shr[25] == 0 ) // если режим ещё не активизирован
            {
                shr[25] = 1;    // активизируем
                sh[25]  = 1;    // режим 25 "Вкл. РРГ5"
            }
        }; break;
		case 125:                // проверка на KK = 125
        {
			RRGOff(ObjRRG[5]);	// отключение РРГ6
		}; break;
		case 26:                // проверка на KK = 26
        {
                shr[26] = 1;    // активизируем
                sh[26]  = 1;    // режим 26 "Вкл. РРГ7"
				PR_HEL = 0;
        }; break;
		case 126:                // проверка на KK = 126
        {

                shr[26] = 1;    // активизируем
                sh[26]  = 1;    // режим 26 "Вкл. РРГ7"
		PR_HEL = 1;

        }; break;
		case 226:                // проверка на KK = 226
        {
			RRGOff(ObjRRG[6]);	// отключение РРГ7
			PR_HEL = 0;
		}; break;		
		case 27:                // проверка на KK = 27
        {
            if ( shr[27] == 0 ) // если режим ещё не активизирован
            {
                shr[27] = 1;    // активизируем
                sh[27]  = 1;    // режим 27 "Вкл. ВЧГ стола(мощ)"
            }
        }; break;
		case 127:				// проверка на KK = 127
        {
            SBROSR_27();		// сброс режимов ВЧГ стола
        }; break;
		case 28:                // проверка на KK = 28
        {
            if ( shr[28] == 0 ) // если режим ещё не активизирован
            {
                shr[28] = 1;    // активизируем
                sh[28]  = 1;    // режим 28 "Вкл. ВЧГ стола(смещ)"
            }
        }; break;
		case 29:                // проверка на KK = 29
        {
            if ( shr[29] == 0 ) // если режим ещё не активизирован
            {
                shr[29] = 1;    // активизируем
                sh[29]  = 1;    // режим 29 "Вкл. ВЧГ реактора"
            }
        }; break;
		case 129:				// проверка на KK = 129
        {
            SBROSR_29();		// сброс режимов ВЧГ реактора
        }; break;
        case 30:                // проверка на KK = 30
        {
            if ( shr[30] == 0 ) // если режим ещё не активизирован
            {
                shr[30] = 1;    // активизируем
                sh[30]  = 1;    // режим 30 "Автосогласование ВЧГ реактора(точно)"
            }
        }; break;
		case 31:                // проверка на KK = 31
        {
            if ( shr[31] == 0 ) // если режим ещё не активизирован
            {
                shr[31] = 1;    // активизируем
                sh[31]  = 1;    // режим 31 "Движение в точку согл. УС ВЧГ реактора(грубо)"
            }
        }; break;
		case 32:                // проверка на KK = 32
        {
            if ( shr[32] == 0 ) // если режим ещё не активизирован
            {
                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "Движение в точку согл. УС ВЧГ реактора(точно)"
            }
        }; break;
		case 33:                // проверка на KK = 33
        {
            if ( shr[33] == 0 ) // если режим ещё не активизирован
            {
                shr[33] = 1;    // активизируем
                sh[33]  = 1;    // режим 33 "Вкл нагрев 1"
            }
        }; break;
		case 34:                // проверка на KK = 34
        {
            if ( shr[34] == 0 ) // если режим ещё не активизирован
            {
                shr[34] = 1;    // активизируем
                sh[34]  = 1;    // режим 33 "Откл нагрев 1"
            }
        }; break;
		case 35:                // проверка на KK = 35
        {
            if ( shr[35] == 0 ) // если режим ещё не активизирован
            {
                shr[35] = 1;    // активизируем
                sh[35]  = 1;    // режим 35 "Вкл нагрев 2"
            }
        }; break;
		case 36:                // проверка на KK = 36
        {
            if ( shr[36] == 0 ) // если режим ещё не активизирован
            {
                shr[36] = 1;    // активизируем
                sh[36]  = 1;    // режим 36 "Откл нагрев 2"
            }
        }; break;
		case 37:                // проверка на KK = 37
        {
            if ( shr[37] == 0 ) // если режим ещё не активизирован
            {
                shr[37] = 1;    // активизируем
                sh[37]  = 1;    // режим 37 "Прижим вверх"
            }
        }; break;
		case 38:                // проверка на KK = 38
        {
            if ( shr[38] == 0 ) // если режим ещё не активизирован
            {
                shr[38] = 1;    // активизируем
                sh[38]  = 1;    // режим 38 "Прижим вниз"
            }
        }; break;
		case 39:                // проверка на KK = 39
        {
            if ( shr[39] == 0 ) // если режим ещё не активизирован
            {
                shr[39] = 1;    // активизируем
                sh[39]  = 1;    // режим 39 "Кассета в HOME"
            }
        }; break;
		case 40:                // проверка на KK = 40
        {
            if ( shr[40] == 0 ) // если режим ещё не активизирован
            {
                shr[40] = 1;    // активизируем
                sh[40]  = 1;    // режим 40 "Кассета вверх/вниз"
            }
        }; break;
        default:                // любая другая команда
        {
            diagnS[0] |= 0x80;  // отказ: "неопознанная команда"
            return;             //
        };

    };
    qkk = 0;                    // сброс кода команды
    diagnS[0] &= ~(0x80);       // сброс диагностики
}
//---------------------------------------------------------------------------
void DIAGN_KOLCO()				// "Подпрограмма: "Диагностика в кольце"
{
	if((zin[0] & 0x01) == 0)
		diagn[13] |= 0x02;		// Отказ: "Нет охл/нагр. п/держателя"
	else
		diagn[13] &= (~0x02);	// Сброс диагностики
	
	if((zin[0] & 0x02) == 0)
		diagn[13] |= 0x04;		// Отказ: "Нет охл. ФВН камеры"
	else
		diagn[13] &= (~0x04);	// Сброс диагностики

	if((zin[0] & 0x04) == 0)
		diagn[13] |= 0x80;		// Отказ: "Нет охл. ТМН"
	else
		diagn[13] &= (~0x80);	// Сброс диагностики

	if((zin[0] & 0x20) == 0)
		diagn[13] |= 0x01;		// Отказ: "Нет давления в пневмосети"
	else
		diagn[13] &= (~0x01);	// Сброс диагностики
	
	if((zin[0] & 0x40) == 0)
		diagn[19] |=0x20 ;		// Отказ: "Нет воды в скруббере"
	else
		diagn[19] &=(~0x20);	// Сброс диагностики

	if(zin[1] & 0x400)
		diagn[7] |= 0x80;		// Отказ: "Превышение темп. ВЧГ ИП"
	else 
		diagn[7] &= (~0x80);	// Сброс диагностики
	
	if(zin[1] & 0x1000)
		diagn[4] |= 0x80;		// Отказ: "Превышение темп. ВЧГ п/д"
	else 
		diagn[4] &= (~0x80);	// Сброс диагностики

	if(!(zin[2]&0x10))
		diagn[19] |= 0x02;		// Отказ: "ФВН камеры: предупреждение"
	else
		diagn[19] &= (~0x02);	// Сброс диагностики
	
	if(!(zin[2]&0x20))
		diagn[19] |= 0x01;		// Отказ: "ФВН камеры: нет удаленного упр."
	else
		diagn[19] &= (~0x01);	// Сброс диагностики


	if(zin[2]&0x200)
		diagn[19] |= 0x40;		// Отказ: "ТМН: авария"
	else
		diagn[19] &= (~0x40);	// Сброс диагностики
	
	if(zin[2]&0x4000)
		diagn[19] |= 0x80;		// Отказ: "ТМН: предупреждение"
	else
		diagn[19] &= (~0x80);	// Сброс диагностики
	
	if(!(zin[2]&0x8000))
		diagn[13] |= 0x10;		// Отказ: "ТМН: температура не в норме"
	else
		diagn[13] &= (~0x10);	// Сброс диагностики
	
	if(!(zin[3]&0x10))
		diagn[12] |= 0x80;		// Отказ: "Чиллер(п/д):авария"
	else
		diagn[12] &= (~0x80);	// Сброс диагностики
	
	if((!(zin[4] & 0x2000))&&(!PR_KLASTER))
		diagn[28] |= 0x08;		// "Авария привода манипулятора поворота"
	else
		diagn[28] &= (~0x08);	// Сброс диагностики

	if((!(zin[4] & 0x400))&&(!PR_KLASTER))
		diagn[14] |= 0x40;		// "Авария привода манипулятора перемещения"
	else
		diagn[14] &= (~0x40);	// Сброс диагностики
	if(!(zin[3] & 0x2000))
		diagn[28] |= 0x01;		// "Авария привода прижима"
	else
		diagn[28] &= (~0x01);	// Сброс диагностики

	if((!(zin[4] & 0x80))&&(!PR_KLASTER))
		diagn[28] |= 0x04;		// "Авария привода кассеты"
	else
		diagn[28] &= (~0x04);	// Сброс диагностики
	if(zin[3] & 0x100)
	{
		diagn[11] |= 0x01;		// Отказ:"Отказ двигателя ИП точно"
		SetOut(0,1,0xC00);
		A_OUT(9,8192);
	}
	else
		diagn[11] &= (~0x01);	// Сброс диагностики

	if(zin[3] & 0x200)
	{
		diagn[11] |= 0x02;		// Отказ:"Отказ двигателя ИП грубо"
		SetOut(0,1,0x3000);
		A_OUT(10,8192);
	}
	else
		diagn[11] &= (~0x02);	// Сброс диагностики

	if(aik[2] > 901)			// T° > 30°C
		diagn[13] |= 0x40;		// Отказ: "Высокая темп. воды охл. ТМН"
	else
		diagn[13] &= ~(0x40);	// Сброс диагностики
	
	if(zin[4] & 0x01)
		diagn[19] |= 0x04;		// "Газоанализатор: предупреждение"//
	else
		diagn[19] &= (~0x04);	// Сброс диагностики 
	
	if(zin[4] & 0x02)
		diagn[19] |= 0x08;		// "Газоанализатор: авария"//
	else
		diagn[19] &= (~0x08);	// Сброс диагностики 
	
	if(zin[4] & 0x04)
		diagn[19] |= 0x10;		// "Газоанализатор: неисправность"//
	else
		diagn[19] &= (~0x10);	// Сброс диагностики

	
	
}
//---------------------------------------------------------------------------
void AVAR_VODA_STOL()			// "Реакция на пропадание воды в п/держ."
{
	if(shr[27]||shr[28])				// есть активизация режимов 27 и 28
	{
		if(zin[0] & 0x01)				// есть охлаждение п/д
		{
			CT_VODA_STOL = 0;
			return;
		}
		if(CT_VODA_STOL >= T_VODA)		// время вышло (5 сек)
		{
			diagn[14] |= 0x01;			// "Авария:нет охл/нагр. п/д"
			if(shr[4]&&(!PR_NALADKA))	// есть активизация РЦ
			{
                if(!shr[5])
                {
				    shr[5] = 1;			// запуск режима 5
				    sh[5] = 1;			// "Сброс РЦ"
                }
			}
			else
			{
				SBROSR_27();			// сброс режима "Откл. ВЧГ стола"
				SBROSR_29();			// сброс режима "Откл. ВЧГ реактора"
			}			
		}
	}
	else
		CT_VODA_STOL = 0;
}
//---------------------------------------------------------------------------
void AVAR_DAVL()      // "Реакция на высокое давление в камере при работе ТМН"
{
 if((zin[2] & 0x1C00) != 0)             // есть входной сигнал ТМН
  if((zin[1] & 0x30) != 0x20)	        // Затвор не закрыт
   if((zin[0] & 0xC000) != 0x8000)		// Кл-D4 не закрыт
    if((diagnS[0] & 0x08) == 0)         // есть свяь с D4
     if(D_D4 >= POROG_DAVL)             // давление больше 100 Па
      {
		SetOut(0,0,0x80);				// закрыть ДЗ
		SetOut(1,0,0x100);				// закрыть ДЗ

	
       diagn[14] |= 0x04;               // "Авария: высокое давление в камере"

       shr[1] = 0;                      // сброс активизации режимов
       sh[1] = 0;                       // "Откачка"
	   shr[2] = 0;
       sh[2] = 0;                       // "Откачка шлюза"
       shr[3] = 0;
       sh[3] = 0;                       // "РЦ"
	   shr[4] = 0;
       sh[4] = 0;                       // "Тех. процесс"
       shr[5] = 0;
       sh[5] = 0;                       // "Сброс РЦ"
	   shr[6] = 0;
       sh[6] = 0;                       // "Сбор пластин"
	   shr[7] = 0;
       sh[7] = 0;                       // "Отключение установки"
	   shr[9] = 0;
       sh[9] = 0;                       // "Транспортный тест"
	   shr[10] = 0;
       sh[10] = 0;						// "Открыть ЩЗ"
	   shr[11] = 0;
       sh[11] = 0;						// "Закрыть ЩЗ"
	   
	   shr[17] = 0;
       sh[17] = 0;                      // "Дросселирование ДЗ"
       shr[18] = 0;
       sh[18] = 0;                      // "Открыть ДЗ"
       shr[19] = 0;                     
       sh[19] = 0;                      // "Закрыть ДЗ"

       SBROSR_29();						// ВЧГ реактора
	   SBROSR_27();						// сброс ВЧГ реактора
	   SetOut(0,1,0x300);
       A_OUT(7,8192);
	   A_OUT(8,8192);

	   shr[31] = 0;
       sh[31] = 0;                      // Движение ИП в точку точно
	   SetOut(0,1,0xC00);
	   A_OUT(9,8192);

	   shr[32] = 0;
       sh[32] = 0;                      // Движение ИП в точку грубо
	   SetOut(0,1,0x3000);
	   A_OUT(10,8192);

	   SBROS_MEH();						// сброс движений
	   
	   RRGOff(ObjRRG[0]);				// отключение РРГ1
	   RRGOff(ObjRRG[1]);				// отключение РРГ2
       RRGOff(ObjRRG[2]);				// отключение РРГ3
	   RRGOff(ObjRRG[3]);				// отключение РРГ4
	   RRGOff(ObjRRG[4]);				// отключение РРГ5
       RRGOff(ObjRRG[5]);				// отключение РРГ6
	   RRGOff(ObjRRG[6]);				// отключение РРГ7
 
	   SetOut(0,2,0x700);				// закрыть Кл1,Кл2,Кл-Нап1
	   SetOut(0,3,0x6C00);				// закрыть Кл-Нап2,Кл-Нап3,Кл4,Кл3

       for(int i=0;i<DIAGN_COUNT;i++)
            if((i != 14)&&(i != 14)) diagn[i] = 0;// сброс диагностик кроме аварийных
		
       KOM_DZASL = 7;                    // "Общий опрос" заслонке
      }
}
//---------------------------------------------------------------------------
void UPR_AVAR_OTKL()			// Управление аварийным отключением
{
	if(zin[2] & 0x1C00)  						// ТМН работает
	{
		if (zin[2] & 0x200)
			diagn[14] |= 0x08;					// авария ТМН
		else if (zin[2] & 0x02) goto A_1;  		// ФВН включен
		else diagn[14] |= 0x10;					// диагностика: "Авария: Отключение ФВН"
        if(shr[8] == 0)							// режим R_8 не активизирован
		{
			shr[8] = 1;							// активизация режима R_8
			sh[8] = 1;
		}
	}
	else
	{
A_1:	   if((out[3]&0x10)&&!(zin[2]&0x08))	// ФВН камеры включен и есть авария
		{
                diagn[14] |= 0x02;				// диагностика: "Авария: ФВН камеры"
			if(shr[8] == 0)						// режим R_8 не активизирован
			{
				shr[8] = 1;						// активизация режима R_8
				sh[8] = 1;
			}
		}
	}
}
//---------------------------------------------------------------------------
void UPR_R_30 ()			                // Подпр."Управление режимом
					                        // "Автом.согласование ВЧГ реактора"
{
	if((!nasmod[3]) || (!shr[4] && shr[29]))
		diagn[7] |= 0x40;   // автосогласование запрещено
    else
        diagn[7] &=(~0x40); // снять диагностику
	
    // если есть движение в точку УС ВЧГ реактора - обход
    if(prDvijGir_g || prDvijGir_t) return;	// движение в точку еще работает
	if(!nasmod[3])							// Автом.согласов.ВЧГ реактора запрещено
	{
		if(shr[30])     					// Есть активиз.реж.автом.согл.ВЧГ реактора
        {
			shr[30] = 0;				    // деактивизация режима
			sh[30] = 0;			            // "Автом.согласование ВЧГ реактора"
			diagn[7] &= (~0x08);		    // Сброс диагн."Нет согл.ВЧГ реактора",
			diagn[11] &= (~0x03);			// "Отказ двигат.УС ВЧГ реактора(точно)"
											// "Отказ двигат.УС ВЧГ реактора(грубо)"
			A_OUT(9,8192);					// Сброс уставки скорости и направления
			A_OUT(10,8192);					// Сброс уставки скорости и направления
			SetOut(0,1,0x3C00);				// двигателей СУ ВЧГ реактора
		}
	}
	else
	{
		if(!shr[29])						// нет активизации режима ВЧГ реактора
		{
			shr[30] = 0;				    // деактивизация режима
			sh[30] = 0;			            // "Автом.согласование ВЧГ реактора"
			diagn[7] &= (~0x08);		    // Сброс диагн."Нет согл.ВЧГ реактора",
											// "Отказ двигат.УС ВЧГ реактора(точно)"
											// "Отказ двигат.УС ВЧГ реактора(грубо)"
			A_OUT(9,8192);					// Сброс уставки скорости и направления
			A_OUT(10,8192);					// Сброс уставки скорости и направления
			SetOut(0,1,0x3C00);				// двигателей СУ ВЧГ реактора
		}
		else if(!shr[30] && VRGIR && N_ST)	// не актив.автосогл., был выход на режим и не наладка 
		{
			shr[30] = 1;				    // активизация режима
			sh[30] = 1;			            // "Автом.согласование ВЧГ реактора"
		}
	}
}
//---------------------------------------------------------------------------
void VID_DIAGN_GIS()			// выдача диагностики нет согласования ВЧГ стола
{
    if (((shr[27])||(shr[28]))&&// есть активизация режима ВЧГ стола
        (VRGIS)&&				// есть выход на режим ВЧГ стола
        (aik[15]))				// отраженная мощность не 0
    {
        N_TEK_GIS=aik[14]*10/aik[15];// текущий коэф. согласования
        if(N_TEK_GIS >= nasmod[6])
            diagn[4] &= (~0x08);// снять диагностику
        else
            diagn[4] |= 0x08;	// диагн.: "нет согл. ВЧГ стола"
    }
    else
    {
        diagn[4] &= (~0x08);// снять диагностику
        N_TEK_GIS = 0;
    }
}
//---------------------------------------------------------------------------
void VID_DIAGN_GIR()            // выдача диагностики нет согласования ВЧГ реактора
{
    if ((shr[29])&&				// есть активизация режима ВЧГ реактора
        (VRGIR)&&				// есть выход на режим ВЧГ реактора
        (aik[13]))				// отраженная мощность не 0
    {
        N_TEK_GIR=aik[12]*10/aik[13];// текущий коэф. согласования
        if (N_TEK_GIR >= nasmod[5])
            diagn[7] &= (~0x08);// снять диагностику
        else
            diagn[7] |= 0x08;	// диагн.: "нет согл. ВЧГ реактора"
    }
    else
    {
     diagn[7] &= (~0x08);// снять диагностику
     N_TEK_GIR = 0;
    }
}
//---------------------------------------------------------------------------
void OKNSGIR_g()		// Подпрограмма: "Отработка кнопок
						// > и < ВЧГ реактора (грубо)(вверх/вниз)
{
    // отказ: "Ограничение движ. УС ВЧГ реактора(грубо)"
	if(aik[17]<82 || aik[17]>4012) diagn[15] |= 0x04;
    else diagn[15] &= (~0x04);               // сброс диагностики
    // есть запрет автоматического согласования ВЧГ реактора
    if(nasmod[3]) return;
    // если есть движение в точку УС ВЧГ реактора - обход
    if(prDvijGir_g) return;
	// опрос кнопки > (вперед)
	if(!klGir_gV) goto S0;		        	// кнопка не включена
	if(aik[17]>=4012)
    {
        SetOut(0,1,0x3000);     // сброс дискреты вперед
        return;
    }
	if((out[1] & 0x2000) != 0) goto S1;		// движ.назад (<) включено
	if((out[1] & 0x1000) != 0) return;		// движ.вперед (>) включено
	if(CT_DVIJ_GIR_g <= T_ZAD_DVS)return;	// время задержки не вышло(тик)
	// движение GIR вперед (>)
	A_OUT (10,nasmod[4]);			        // задание скорости GIR(nasmod[4])
	SetOut(0,1,0x2000);						// задание направления
	SetOut(1,1,0x1000);						// вперед (>)
	return;
	// стоп движения
S1: A_OUT (10,8192);						// сброс скорости
	SetOut(0,1,0x3000);						// сброс направления
	CT_DVIJ_GIR_g = 0;			            // сброс сч.вр.задержки
	return;
	// опрос кнопки < (назад)
S0: if(!klGir_gN)	                    	// кнопка не включена
	// стоп движения
	{
		A_OUT(10,8192);			            // сброс скорости
		SetOut(0,1,0x3000);		        	// сброс направления
		return;
	}
	if(aik[17]<=82)
    {
        SetOut(0,1,0x3000);     // сброс дискреты вперед
        return;
    }
	if((out[1] & 0x1000) != 0) goto S1; 	// движ.вперед (>) включено
	if((out[1] & 0x2000) != 0) return;  	// движ.назад (<) включено
	if(CT_DVIJ_GIR_g <= T_ZAD_DVS)return;   // время задержки не вышло
	// движение GIR назад (<)
	A_OUT(10,nasmod[4]);			        // задание скорости GIR(nasmod[4])
	SetOut(0, 1, 0x1000);			        // задание направления
   	SetOut(1, 1, 0x2000);			        // назад (<)
}
//---------------------------------------------------------------------------
void OKNSGIR_t()		// Подпрограмма: "Отработка кнопок
						// > и < ВЧГ реактора (точно)(влево/вправо)
{
    // отказ: "Ограничение движ. УС ВЧГ реактора(точно)"
	if(aik[16]<82 || aik[16]>4012) diagn[15] |= 0x08;
    else diagn[15] &= (~0x08);               // сброс диагностики
    // есть запрет автоматического согласования ВЧГ реактора
    if(nasmod[3]) return;
    // если есть движение в точку УС ВЧГ реактора - обход
    if(prDvijGir_t) return;
	// опрос кнопки > (вперед)
	if(!klGir_tV) goto S0;		        	// кнопка не включена
	if(aik[17]>=4012)
    {
        SetOut(0,1,0x3000);     // сброс дискреты вперед
        return;
    }
	if((out[1] & 0x800) != 0) goto S1;		// движ.назад (<) включено
	if((out[1] & 0x400) != 0) return;		// движ.вперед (>) включено
	if(CT_DVIJ_GIR_t <= T_ZAD_DVS)return;	// время задержки не вышло(тик)
	// движение GIR вперед (>)
	A_OUT (9,nasmod[4]);			        // задание скорости GIR(nasmod[4])
	SetOut(0,1,0x800);						// задание направления
	SetOut(1,1,0x400);						// вперед (>)
	return;
	// стоп движения
S1: A_OUT (9,8192);							// сброс скорости
	SetOut(0,1,0xC00);						// сброс направления
	CT_DVIJ_GIR_t = 0;			            // сброс сч.вр.задержки
	return;
	// опрос кнопки < (назад)
S0: if(!klGir_tN)	                    	// кнопка не включена
	// стоп движения
	{
		A_OUT(9,8192);			            // сброс скорости
		SetOut(0,1,0xC00);		        	// сброс направления
		return;
	}
	if(aik[17]<=82)
    {
        SetOut(0,1,0x3000);     // сброс дискреты вперед
        return;
    }
	if((out[1] & 0x400) != 0) goto S1; 		// движ.вперед (>) включено
	if((out[1] & 0x800) != 0) return;  		// движ.назад (<) включено
	if(CT_DVIJ_GIR_t <= T_ZAD_DVS)return;   // время задержки не вышло
	// движение GIR назад (<)
	A_OUT(9,nasmod[4]);			        	// задание скорости GIR(nasmod[4])
	SetOut(0, 1, 0x400);			        // задание направления
   	SetOut(1, 1, 0x800);			        // назад (<)
}
//---------------------------------------------------------------------------
void ZashDD()                           // подпрограмма защиты Д4 и Д5
{
	if((out[2]&0x3F)||(shr[29])) //
        SetOut(0,0,0x18);				// закрыть Кл-Д5,Кл-Д4
}
//---------------------------------------------------------------------------
void OpenFK_TMN_CloseFK_SHL()	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
{
	if(zin[2] & 0x1C00 )				// если есть вращение ТМН
	 if((zin[1] & 0x03) != 0x02)		// Кл-Д5 не закрыт
	  if((diagnS[0] & 0x10) == 0)		// есть свяь с D5
	   if(D_D5 >= UVAK_ZTMN)			// давление больше 40 Па
		if((zin[0]&0x3000)!=0x1000)		// ФК-ТМН не открыт
		{
			if((zin[0]&0xC00)==0x800)	// ФК-КАМ строго закрыт
				SetOut(1,0,0x04);		// открыть ФК-ТМН
			else	
				SetOut(0,0,0x02);		// закрыть ФК-КАМ
		}
}
//---------------------------------------------------------------------------
void Vkl_FK_TMN()	// Подпрограмма: Напуска азота в ТМН
{
    if((zin[2]&0x1C00)&&((zin[1]&0x30)!=0x20)) // есть хоть один из 3 сигнал ТМН и ДЗ не закрыта
        SetOut(1,3,0x1000);   // открыть Кл5
    else
        SetOut(0,3,0x1000);   // закрыть Кл5
}
//---------------------------------------------------------------------------
void MEH_AVAR_CHK()				// слежение за авриями механизма
{
	// если нет аварии механизма
	if((zin[3]&0x2000)&&(zin[4]&0x80)&&(zin[4]&0x2000)&&(zin[4]&0x400))
		SetOut(0,1,0x08);		// сбросить сигнал "Сброс аварий"
}
//---------------------------------------------------------------------------
void MEH_AVAR_SBROS()			// сброс аварий механизма (не в кольце)
{
	SetOut(1,1,0x08);			// выдать сигнал "Сброс аварий"(по кнопке)
}
//---------------------------------------------------------------------------
void OSBROS()					// подпрограмма Общий сброс
{
	PR_PER = 0;

	PR_NALADKA = 0;
	N_ST = 0;
	KOM_DZASL = 7;
	if(shr[5])
	{
		shr[4]	=0;
		sh[4]	=0;
	}
	shr[1] 	= 0;					// сброс активизации режима 1
	sh[1] 	= 0;					// "Откачка камеры"
	shr[2] 	= 0;					// сброс активизации режима 2
	sh[2] 	= 0;					// "Откачка шлюза"
	shr[5] 	= 0;					// сброс активизации режима 5
	sh[5] 	= 0;					// "Сброс РЦ"
	shr[6] 	= 0;					// сброс активизации режима 6
	sh[6] 	= 0;					// "Сбор пластин"
	shr[7] 	= 0;					// сброс активизации режима 7
	sh[7] 	= 0;					// "Отключение установки"
	shr[8] 	= 0;					// сброс активизации режима 8
	sh[8] 	= 0;					// "Аварийное отключение установки"
	shr[9] 	= 0;					// сброс активизации режима 9
	sh[9] 	= 0;					// "Транспортный тест"
	shr[10] = 0;					// сброс активизации режима 10
	sh[10] 	= 0;					// "Открыть ЩЗ"
	shr[11] = 0;					// сброс активизации режима 11
	sh[11] 	= 0;					// "Закрыть ЩЗ"
	shr[17] = 0;					// сброс активизации режима 17
	sh[17] 	= 0;					// "ДЗ дросселирование"
	shr[18] = 0;					// сброс активизации режима 18
	sh[18] 	= 0;					// "Открыть ДЗ"
	shr[19] = 0;					// сброс активизации режима 19
	sh[19] 	= 0;					// "Закрыть ДЗ"
	shr[34] = 0;               		// сброс активизации режима 34
    sh[34] 	= 0;                 	// "Откл. нагрева кам. откач."
    shr[36] = 0;                	// сброс активизации режима 36
    sh[36] 	= 0;                 	// "Откл. нагрев кам. разряд"
	SBROSR_27();
	SBROSR_29();
	RRGOff(ObjRRG[0]);			// отключение РРГ1
	RRGOff(ObjRRG[1]);			// отключение РРГ2
	RRGOff(ObjRRG[2]);			// отключение РРГ3
	RRGOff(ObjRRG[3]);			// отключение РРГ4
	RRGOff(ObjRRG[4]);			// отключение РРГ5
	RRGOff(ObjRRG[5]);			// отключение РРГ6
	RRGOff(ObjRRG[6]);			// отключение РРГ7

	SBROS_MEH();				// сброс движений

	for(int i=0;i<DIAGN_COUNT;i++) // сброс всех диагностик
	diagn[i] = 0;
	
	SetOut(0,1,0x10);			// отключить звонок
	

	norma = 7;					// норма: общий сброс завершен
}
//---------------------------------------------------------------------------
void TIME()			//  подпрограмма управления таймером
{					// (прерывание с периодом в 1 миллисекунду)

	CT_T1++;		// Сч.тиков (1 мсек=1кГц)
	
	// Счетчики тиковские (1 мсек) для устройств и режимов
	

	if(CT_T1 < 20) return;
	CT_T1 = 0;		// Сброс сч.тиков (1 мсек.)
	CT_T20++;		// Счетчик тиков (20мсек = 50Гц)
	
	// Счетчики тиковские (20 мсек) для устройств и режимов
    CT_DVIJ_GIR_g++;
	CT_DVIJ_GIR_t++;
	CT_SUT_g++;
	CT_SUT_t++;
	CT_30T++;			    // (тик) сч.вр.режима 30

	if(CT_T20 < 50) return;
	CT_T20 = 0;		// Сброс сч.тиков (20 мсек.)
	
	// Счетчики секундные (1 сек)

	CT_VHG++;
	CT_VODA_STOL++;
    CT_VODA_IP++;
    CT_PER++;
    CT_POV++;
    CT_KAS++;
    CT_PRIJ++;
    CT_TEMP1++;
	CT_TEMP2++;
    CT_DZASL++;
    CT_TMN++;
	CT_IST++;
	
	// инкремент счетчиков механизмов
	//AZdrive_Time(); 
	
	// Счетчики времени режимов (секундные)
	CT_1++;
	CT_2++;
	CT_3++;
	CT_4++;
	CT_5++;
	CT_6++;
	CT_7++;
	CT_9++;
	CT_17++;
	CT17K1++;
	CT_27++;
	CT27K1++;
	CT_28++;
	CT28K1++;
	CT_29++;
	CT29K1++;
	CT_33++;
	CT33K1++;
	CT_35++;
	CT35K1++;

	TimeRRG();
	TimeKlapan();
}
//---------------------------------------------------------------------------
//-------------------------------  РЕЖИМЫ  ----------------------------------
//---------------------------------------------------------------------------
void R_1 ()            // Режим "Откачка камеры"
{
	sh_ = sh[1];
	
	if (shr[1] < 1 || shr[1] > 39) goto L100;
	if (shr[1] < 10) goto L00;
	if (shr[1] < 20) goto L01;
	if (shr[1] < 30) goto L02;
	else goto L03;
	
L00:if (shr[1] == 1) goto L1;
	if (shr[1] == 2) goto L2;
	if (shr[1] == 3) goto L3;
	if (shr[1] == 4) goto L4;
	if (shr[1] == 5) goto L5;
	if (shr[1] == 6) goto L6;
	if (shr[1] == 7) goto L7;
	if (shr[1] == 8) goto L8;
	if (shr[1] == 9) goto L9;
L01:if (shr[1] == 10) goto L10;
	if (shr[1] == 11) goto L11;
	if (shr[1] == 12) goto L12;
	if (shr[1] == 13) goto L13;
	if (shr[1] == 14) goto L14;
	if (shr[1] == 15) goto L15;
	if (shr[1] == 16) goto L16;
	if (shr[1] == 17) goto L17;
	if (shr[1] == 18) goto L18;
	if (shr[1] == 19) goto L19;
L02:if (shr[1] == 20) goto L20;
	if (shr[1] == 21) goto L21;
	if (shr[1] == 22) goto L22;
	if (shr[1] == 23) goto L23;
	if (shr[1] == 24) goto L24;
	if (shr[1] == 25) goto L25;
	if (shr[1] == 26) goto L26;
	if (shr[1] == 27) goto L27;
	if (shr[1] == 28) goto L28;
	if (shr[1] == 29) goto L29;
L03:if (shr[1] == 30) goto L30;
	if (shr[1] == 31) goto L31;
	if (shr[1] == 32) goto L32;
	if (shr[1] == 33) goto L33;
	if (shr[1] == 34) goto L34;
	if (shr[1] == 35) goto L35;
	if (shr[1] == 36) goto L36;
	if (shr[1] == 37) goto L37;
	if (shr[1] == 38) goto L38;
    if (shr[1] == 39) goto L39;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[1] = sh_;
	if (sh[1] != 0) goto L100;	// sh_ != 0
	++shr[1];					// след. шаг сч.шр1
	if (shr[1] > 39) goto L0;	// число шагов режима
	sh[1] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 2;					// норма: "Откачка камеры завершена"
	shr[1] = 0;
	goto L100;

L1: SetOut(0,2,0x73F);			// закрыть  РРГ1-6 Кл Нап1 Кл1-2
    SetOut(0,3,0x7000);          //закрыть Кл 3-5
	for(int i=0;i<DIAGN_COUNT;i++)
		diagn[i] = 0;		    // сброс всех диагностик
    if(!(zin[3]&0x1000))   // прижим не в HOME
    {
        shr[1] = 38;
        sh_ = 0;                    // переход на шаг 39
        goto L101;
    }
    sh_ = 0;
    goto L101;
L2: Klapan(1,&KlD4);			// Открыть Кл-Д4
	goto L101;
L3: Klapan(1,&KlD5);			// Открыть Кл-Д5
	if(sh_) goto L101;
	if(PR_KLASTER)				//
	{
		shr[1] = 7;				// переход на шаг 8
		sh_ = 0;
		goto L101;
	}	
	if(zin[4]&0x200)			// МАН пер. в HOME?
	{
		shr[1] = 4;				// Переход на шаг 4_1
		sh_ = 1;
		goto L4_1;
	}
	goto L101;
L4: VIDK_PER(0,0,0,1,10);		// МАН пер. в HOME
	if(sh_) goto L101;
L4_1:if(zin[4]&0x1000)			// МАН пов. в HOME?
	{
		shr[1] = 5;				// переход на шаг 5_1
		sh_ = 1;
		goto L5_1;
	}
    sh_ = 0;
	goto L101;
L5:	VIDK_POV(0,0,0,1,10);		// МАН пов. в HOME
	if(sh_) goto L101;
L5_1:if(zin[4]&0x40)			// кассета в HOME
	{
		shr[1] = 6;				// переход на шаг 7
		sh_ = 0;
		goto L101;
	}
    sh_ = 0;
	goto L101;
L6: VIDK_KAS(0,0,0,1,10); 		// кассета в HOME
	goto L101;
L7: Klapan(0,&ShZatvor);		// закрыть ШЗ
	goto L101;
L8: Klapan(1,&FvnKam);			// включить ФВН-КАМ
    goto L101;
L9: Klapan(0,&PP);				// подъемник пластин вниз
	if(sh_) goto L101;
	if(zin[2]&0x800)			// есть ТМН:Норма
		shr[1] = 10;			// переход на шаг 11
	goto L101;
L10:Klapan(0,&DZasl);			// закрыть ДЗ
	goto L101;
L11:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 <= UVAKV_KAM )		// проверка уровня вакуума в камере
		shr[1] = 18;			// переход на шаг 19
	sh_ = 0;
	goto L101;
L12:Klapan(0,&KlTmn);			// закрыть ФК-ТМН
	goto L101;
L13:Klapan(1,&KlKam);			// закрыть ФК-Кам
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L14:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 > UVAKV_KAM )		// проверка уровня вакуума в камере
	{
		if(zin[2]&0x1C00)		// есть хоть один из трех сигналов ТМН
		{
			sh_ = 0;			// переход на шаг 15
			goto L101;
		}
		sh_ = 1;
		shr[1] = 15;			// переход на подшаг 15_1 
		goto L15_1;				
	}
	diagn[12] &= (~0x01);        // сброс диагностики
	shr[1] = 18;				// переход на шаг 19
	sh_ = 0;
	goto L101;
L15:if(!(zin[3]&0x40))			// нет форвакуума в ТМН
	{
		sh_ = 0;
		goto L101;
	}
L15_1:if(CT_1 > T_KKAM)			// контрольное время вышло
		diagn[12] |= 0x01;		// диагностика "Медленная фороткачка камеры"
	shr[1] = 13;				// возврат на шаг 14
	sh_ = 0;
	goto L101;
L16:Klapan(0,&KlKam);			// закрыть ФК-Кам
	goto L101;
L17:Klapan(1,&KlTmn);			// открыть ФК-Тмн
	goto L101;
L18:if(!(zin[3]&0x40)) goto L101; // нет форвакуума в ТМН
	shr[1] = 11;				// переход на шаг 12
	sh_ = 0;
	goto L101;
L19:Klapan(0,&KlKam);			// закрыть ФК-Кам
	goto L101;
L20:Klapan(1,&KlTmn);			// открыть ФК-Тмн
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L21:if(!(zin[3]&0x40))			// нет форвакуума в ТМН
	{
		if(CT_1 > T_KTMN)		// контрольное время вышло
			diagn[12] |= 0x02;	// диагностика "Медленная фороткачка ТМН"
		goto L101;
	}
	diagn[12] &= (~0x02);		// сброс диагностики
	sh_ = 0;
	goto L101;
L22:VTMN();			            // включить ТМН
    if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L23:if(!(zin[2]&0x800))			// нет сигнала "ТМН: норма"
	{
		if(CT_1 > T_KTMN_RAZGON)// контрольное время вышло
			diagn[15] |= 0x01;	// диагностика "Нет выхода на режим ТМН"
		goto L101;
	}
	diagn[15] &= (~0x01);		// сброс диагностики
	sh_ = 0;
	goto L101;
L24:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 > UVAKN_KAM )		// проверка уровня вакуума в камере
	{
		sh_ = 0;
		goto L101;
	}
	shr[1] = 31;				// переход на шаг 32
	sh_ = 0;
	goto L101;
L25:Klapan(0,&KlTmn);			// закрыть ФК-Тмн
	goto L101;
L26:Klapan(1,&KlKam);			// открыть ФК-Кам
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L27:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 <= UVAKV_KAM )		// проверка уровня вакуума в камере
	{
		diagn[12] &= (~0x01);	// сброс диагностики
		shr[1] = 31;			// переход на шаг 32
		sh_ = 0;
		goto L101;	
	}	
	if(zin[2]&0x1C00)			// есть хоть один из трех сигналов ТМН
	{
		sh_ = 0;
		goto L101;
	}
	shr[1] = 28;			
	sh_ = 1;
	goto L28_1;
L28:if(!(zin[3]&0x40))		// нет форвакуума в ТМН
	{
		sh_ = 0;
		goto L101;			// переход на шаг 27
	}
L28_1:if(CT_1 > T_KKAM)		// контрольное время вышло
	diagn[12] |= 0x01;		// диагностика "Медленная фороткачка камеры"
	shr[1] = 26;			// возврат на шаг 27
	sh_ = 0;
	goto L101;
L29:Klapan(0,&KlKam);		// закрыть ФК-Кам
	goto L101;
L30:Klapan(1,&KlTmn);		// открыть ФК-Тмн
	goto L101;
L31:if(!(zin[3]&0x40)) goto L101;// нет форвакуума в ТМН
	shr[1] = 24;			// переход на шаг 25
	sh_ = 0;
	goto L101;
L32:Klapan(0,&KlKam);		// закрыть ФК-Кам
	goto L101;
L33:Klapan(1,&KlTmn);		// открыть ФК-Тмн
	goto L101;
L34:Klapan(1,&DZasl);		// открыть ДЗ
	if(sh_) goto L101;
	CT_1 = 0;
	if(nasmod[11])			// есть зад. по t прогрева кам. откачки
	{
		shr[33] = 1;		// активиз. режим 33
		sh[33] = 1;			// "Откл. нагрев"
L34_1:	if(nasmod[12])		// есть зад. по t прогрева кам. разряд.
		{
			shr[35] = 1;	// активиз. режима 35
			sh[35] = 1; 	// "Вкл. нагрев кам. разр."
			sh_ = 0;
			goto L101;
		}
		if(shr[35])
		{
			shr[36] = 1;	// активиз. режима 36
			sh[36] = 1; 	// "Откл. нагрев кам. разр."
			sh_ = 0;
			goto L101;
		}
		sh_ = 0;
		goto L101;
	}
	if(shr[33])
	{
		shr[34] = 1;	// активиз. режима 34
		sh[34] = 1; 	// "Откл. нагрев кам. откачки."
	}
	shr[1] = 34;		// переход на шаг 34_1
	sh_ = 1;
	goto L34_1;
L35:if(shr[3])
	{
		if(diagnS[0]&0x08)		// пока нет связи с D4
			goto L101;
		if(D_D4 > nasmod[1])	// проверка уровня вакуума в камере
		{
			if(CT_1 > T_KKAM_V)	// контролькое время вышло
				diagn[15] |= 0x02;	// диагностика "Медленная высоковакуумная откачка камеры"
			goto L101;
		}
	}
	    else
        {
	        if(diagnS[0]&0x08)			// пока нет связи с D4
		        goto L101;
	        if(D_D4 > nasmod[0])		// проверка уровня вакуума в камере
	        {
		        if(CT_1 > T_KKAM_V)		// контролькое время вышло
			        diagn[15] |= 0x02;	// диагностика "Медленная высоковакуумная откачка камеры"
		        goto L101;
	        }
        }
	diagn[15] &= (~0x02);				// сброс диагностики
	sh_ = 0;
	goto L101;
L36:if(shr[34]||shr[36]) goto L101;		// ожид. откл. нагрев.
	sh_ = 0;
	goto L101;
L37:VRR_GIR();					        // вкл. разреш. раб. ВЧГ реактора
	goto L101;
L38:VRR_GIS();					        // вкл. разреш. работы ВЧГ стола
    if(sh_) goto L101;
    shr[1] = 39;                        // ВЫХОД!!!
	goto L101;
L39:OPRIJIM();			                // механизм прижима в HOME
    if(sh_) goto L101;
    shr[1] = 1;                         // переход на шаг 2
	goto L101;
}
//---------------------------------------------------------------------------
void R_2 ()            // Режим "Откачка шлюза"
{
	sh_ = sh[2];
	
	if (shr[2] == 1) goto L1;
	if (shr[2] == 2) goto L2;
	if (shr[2] == 3) goto L3;
	if (shr[2] == 4) goto L4;
	if (shr[2] == 5) goto L5;
	if (shr[2] == 6) goto L6;
	if (shr[2] == 7) goto L7;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[2] = sh_;
	if (sh[2] != 0) goto L100;	// sh_ != 0
	++shr[2];					// след. шаг сч.шр2
	if (shr[2] > 7) goto L0;	// число шагов режима
	sh[2] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 1;					// норма: "Откачка шлюза завершена"
	shr[2] = 0;
	goto L100;

L1: if(!(zin[3]&0x4000))		// дверь шлюза не закрыта
	{
		diagn[12] |= 0x40;		// диагностика "Дверь шлюза не закрыта"
		goto L101;
	}
	diagn[12] &= (~0x40);		// сброс диагностики
	SetOut(0,3,0xC00);			// закрыть Кл-Нап2-3
	sh_ = 0;
	goto L101;
L2: if(zin[3]&0x20)			// есть форвакуум в шлюзе
	{
		shr[2] = 7;				// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	sh_ = 0;
	goto L101;
L3: sh_ = 0;
	goto L101;
L4:	Klapan(1,&FvnShl);			// включить ФВН шлюза
	if(sh_) goto L101;
	SetOut(1,0,0x1000);			// откр. Фк-Шл(мягк.)
	CT_2 = 0;
	goto L101;
L5: if(diagnS[0]&0x01)			// пока нет связи с D1
		goto L101;
	if(D_D1 > UVAK_SHL_MO)		// проверка уровня вакуума в камере
	{
		if(CT_2 > T_KSHL_MO)	// контролькое время вышло
		diagn[12] |= 0x04;		// диагностика "Медленная мягкая откачка шлюза"
		goto L101;
	}
	diagn[12] &= (~0x04);		// сброс диагностики
	sh_ = 0;
	goto L101;
L6: Klapan(1,&KlShl);			// открыть Кл-Шл
	goto L101;
L7: if(!(zin[3]&0x20))			// нет форвакуума в шлюзе
	{
		if(CT_2 > T_KSHL)		// контролькое время вышло
		diagn[23] |= 0x01;		// диагностика "Медленная фороткачка шлюза"
		goto L101;
	}
	diagn[23] &= (~0x01);		// сброс диагностики
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_3 ()            // Режим "Рабочий цикл"
{
	sh_ = sh[3];
	
	if (shr[3] < 1 || shr[3] > 52) goto L100;
	if (shr[3] < 10) goto L00;
	if (shr[3] < 20) goto L01;
	if (shr[3] < 30) goto L02;
	if (shr[3] < 40) goto L03;
	goto L04;

L00:if (shr[3] == 1) goto L1;		if (shr[3] == 2) goto L2;
	if (shr[3] == 3) goto L3;		if (shr[3] == 4) goto L4;
	if (shr[3] == 5) goto L5;		if (shr[3] == 6) goto L6;
	if (shr[3] == 7) goto L7;		if (shr[3] == 8) goto L8;
	if (shr[3] == 9) goto L9;
L01:if (shr[3] == 10) goto L10;		if (shr[3] == 11) goto L11;
	if (shr[3] == 12) goto L12;		if (shr[3] == 13) goto L13;
	if (shr[3] == 14) goto L14;		if (shr[3] == 15) goto L15;
	if (shr[3] == 16) goto L16;		if (shr[3] == 17) goto L17;
	if (shr[3] == 18) goto L18;		if (shr[3] == 19) goto L19;
L02:if (shr[3] == 20) goto L20;		if (shr[3] == 21) goto L21;
	if (shr[3] == 22) goto L22;		if (shr[3] == 23) goto L23;
	if (shr[3] == 24) goto L24;		if (shr[3] == 25) goto L25;
	if (shr[3] == 26) goto L26;		if (shr[3] == 27) goto L27;
	if (shr[3] == 28) goto L28;		if (shr[3] == 29) goto L29;
L03:if (shr[3] == 30) goto L30;		if (shr[3] == 31) goto L31;
	if (shr[3] == 32) goto L32;		if (shr[3] == 33) goto L33;
	if (shr[3] == 34) goto L34;		if (shr[3] == 35) goto L35;
	if (shr[3] == 36) goto L36;		if (shr[3] == 37) goto L37;
	if (shr[3] == 38) goto L38;		if (shr[3] == 39) goto L39;
L04:if (shr[3] == 40) goto L40;		if (shr[3] == 41) goto L41;
	if (shr[3] == 42) goto L42;		if (shr[3] == 43) goto L43;
	if (shr[3] == 44) goto L44;		if (shr[3] == 45) goto L45;
	if (shr[3] == 46) goto L46;		if (shr[3] == 47) goto L47;
	if (shr[3] == 48) goto L48;		if (shr[3] == 49) goto L49;
	if (shr[3] == 50) goto L50;		if (shr[3] == 51) goto L51;
	if (shr[3] == 52) goto L52;
	goto L100;			// выход	
	
	// конечный диспетчер режима
L101:sh[3] = sh_;
	if (sh[3] != 0) goto L100;		// sh_ != 0
	++shr[3];						// след. шаг сч.шр2
	if (shr[3] > 52) goto L0;		// число шагов режима
	sh[3] = 1;
L100:return;						// возврат в "кольцо"

L0: norma = 3;						// норма: "РЦ завершен"
	shr[3] = 0;
	goto L100;
	
L1: N_ST = 0;
	T_PROC = 0;
	N_PL = 0;
	sh[1] = 1;						// активизация режима "Откачка камеры"
	shr[1] = 1;
	sh_ = 0;
	goto L101;
L2:	if(shr[1]) goto L101;			// ожидание конца режима
	sh_ = 0;
	goto L101;
L3:	Klapan(0,&KlShl);				// закрыть ФК-Шл
	if(sh_) goto L101;
	if(zin[3]&0x4000)				// дверь шлюза закрыта
	{
		CT_3 = 0;
		SetOut(1,3,0x400);			// открыть Кл-Нап2
		goto L101;
	}
	otvet = 0;
	shr[3] = 6;						// переход на шаг 7
	goto L101;
L4:	if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
	if(D_D1 <= UVAK_SHL_MN) goto L101;	// проверка уровня вакуума в шлюзе	
	SetOut(1,3,0x800);				// открыть Кл-Нап3
	sh_ = 0;
	goto L101;
L5: if(zin[3]&0x4000)				// дверь шлюза закрыта
	{
		if(CT_3 >= T_KNAP)
			diagn[12] |= 0x08;		// диагностика "Медленный напуск в шлюз"
		goto L101;
	}
	diagn[12] &= (~0x08);			// сброс диагностики
	SetOut(0,3,0xC00);				// закрыть Кл-Нап2, Кл-Нап3
    SetOut(1,1,0x10);				// включить звонок
    CT_3 = 0;
	sh_ = 0;
	goto L101;
L6: if(CT_3 <= 3) goto L101;		// задержка
	SetOut(0,1,0x10);				// отключить звонок
	otvet = 0;
	sh_ = 0;
	goto L101;
L7:	if(!otvet) goto L101;		// ожидание ответа оператора
	N_PL = 0;
	if(otvet == 1)
	{
		shr[2] = 1;				// активизация режима "Откачка шлюза"
		sh[2] = 1;
		shr[3] = 11;			// переход на шаг 12
		sh_ = 0;
		goto L101;
	}
	otvet = 0;
	sh_ = 0;
	goto L101;
L8:	if(!otvet) goto L101;		// ожидание ответа оператора
	if(otvet == 1)
	{
		shr[2] = 1;				// активизация режима "Откачка шлюза"
		sh[2] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[3] = 9;					// переход на шаг 10
	sh_ = 0;
	goto L101;
L9:	if(shr[2]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
L10:Klapan(0,&KlShl);			// закрыть ФК-Шл
	goto L101;
L11:Klapan(0,&FvnShl);			// отключить ФВН шлюза
	if(sh_) goto L101;
	shr[3] = 52;				// ВЫХОД!!!
	goto L101;
L12:if(shr[2]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
L13:if(!(zin[3]&0x08)) goto L101;	// температура чиллера не в допуске
	if(!shr[33])				// нет активизации нагрева 1
	{
		shr[3] = 14;
		sh_ = 1;
		goto L14_1;				// переход на L14_1
	}
	sh_ = 0;
	goto L101;
L14:if(!VRTEMP1) goto L101;		// ожидание прогрева камеры
L14_1:if(!shr[35])				// нет активизации нагрева 2
	{
		shr[3] = 15;
		sh_ =0 ;
		goto L101;				// переход на L16
	}
	sh_ = 0;
	goto L101;
L15:if(!VRTEMP2) goto L101;		// ожидание прогрева камеры
	sh_ = 0;
	goto L101;
L16:VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету
	goto L101;
L17:VIDK_KAS(0,OTN,-par_t[5],0,10);	// кассета вниз (h1)
	goto L101;
L18:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	goto L101;
L19:if(!(zin[4]&0x4000))			// пров. налич пластин перед кассетой
	{
		diagn[8] |= 0x01;			// диагностика "Ман. не взял пластину из кассеты"
		goto L101;
	}
	diagn[8] &= (~0x01);			// сброс диагностики
	N_PL++;
	sh_ = 0;
	goto L101;
L20:VIDK_POV(0,ABS,par_t[3],0,10); // ман. пов. к камере
	goto L101;
L21:if(!(zin[4]&0x8000))			// пров. налич пластин перед камерой
	{
		diagn[8] |=0x02 ;			// диагностика "Нет пластины на манип. перед камерой"
		goto L101;
	}
	diagn[8] &= (~0x02 );			// сброс диагностики
	sh_ = 0;
	goto L101;
L22:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 > nasmod[1])		// проверка уровня вакуума в камере
	{
		diagn[27] |=0x40 ;		// диагностика "Нет рабочего вакуума в камере"
		goto L101;	
	}
	diagn[27] &= (~0x40 );		// сброс диагностики
	sh_ = 0;
	goto L101;
L23:if(!(zin[3]&0x20))			// нет форвакуума в шлюзе
	{
		diagn[12] |=0x20 ;			// диагностика "Нет форвакуума в шлюзе"
		goto L101;	
	}
	diagn[12] &= (~0x20 );			// сброс диагностики
	sh_ = 0;
	goto L101;
L24:Klapan(0,&KlShl);				// закрыть ФК-Шл
	goto L101;
L25:Klapan(1,&ShZatvor);			// открыть ШЗ
	goto L101;
L26:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в камеру
	goto L101;
L27:Klapan(1,&PP);					// подъемник вверх
	goto L101;
L28:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	goto L101;
L29:if(zin[4]&0x8000)			// пров. налич пластин перед камерой
	{
		diagn[8] |=0x04 ;			// диагностика "Манипулятор не загрузил пластину в камеру"
		goto L101;
	}
	diagn[8] &= (~0x02 );			// сброс диагностики
	sh_ = 0;
	goto L101;
L30:Klapan(0,&ShZatvor);		// закрыть ШЗ
	goto L101;
L31:Klapan(1,&KlShl);			// открыть ФК-Шл
	goto L101;
L32:Klapan(0,&PP);				// подъемник вниз
	if(sh_) goto L101;
	shr[4] = 1;					// активизация режима "Технол. процесс"
	sh[4] = 1;
	goto L101;
L33:if(shr[4]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
L34:if(!(zin[3]&0x20))			// нет форвакуума в шлюзе
	{
		diagn[12] |=0x20 ;		// диагностика "Нет форвакуума в шлюзе"
		goto L101;
	}
	diagn[12] &= (~0x20 );		// сброс диагностики
	sh_ = 0;
	goto L101;
L35:Klapan(0,&KlShl);			// закрыть ФК-Шл
	goto L101;
L36:Klapan(1,&ShZatvor);		// открыть ШЗ
	goto L101;
L37:Klapan(1,&PP);				// подъемник вверх
	goto L101;
L38:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в камеру
	goto L101;
L39:Klapan(0,&PP);				// подъемник вниз
	goto L101;
L40:VIDK_PER(0,0,0,1,10);		// ман. пер. в HOME
	goto L101;
L41:if(!(zin[4]&0x8000))		// пров. налич пластин перед камерой
	{
		diagn[8] |=0x08 ;		// диагностика "Манип. не выгрузил пласт. из камеры"
		goto L101;
	}
	diagn[8] &= (~0x08 );		// сброс диагностики
	sh_ = 0;
	goto L101;
L42:VIDK_POV(0,0,0,1,10);		// ман. пов. в HOME
	goto L101;
L43:if(!(zin[4]&0x4000))		// пров. налич пластин перед кассетой
	{
		diagn[8] |=0x10;		// диагностика "Нет пластины на манип. перед кассетой"
		goto L101;
	}
	diagn[8] &= (~0x10);		// сброс диагностики
	sh_ = 0;
	goto L101;
L44:VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету
	goto L101;
L45:VIDK_KAS(0,OTN,par_t[5],0,10);	// Кассета вверх на h1
	goto L101;
L46:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	goto L101;
L47:if(zin[4]&0x4000)				// есть пластина перед кассетой
	{
		diagn[8] |=0x20;			// диагностика "Манип. не выгрузил пластину в кассету"
		goto L101;
	}
	diagn[8] &= (~0x20);			// сброс диагностики
	if(N_PL < par[N_ST][20])
	{
		sh_ = 0;
		goto L101;
	}
	shr[3] = 48;				// переход на шаг 49
	sh_ = 0;
	goto L101;
L48:VIDK_KAS(0,OTN,par_t[4],0,10);	// кассета вверх на h
	if(sh_) goto L101;
	shr[3] = 15;
	goto L101;					// переход на шаг 16
L49:VIDK_KAS(0,0,0,1,10);		// кассета в HOME
	goto L101;
L50:Klapan(0,&ShZatvor);		// закрыть ШЗ
	if(sh_) goto L101;
	otvet = 0;
	goto L101;
L51:if(!otvet) goto L101;		// ожидание ответа оператора
	if(otvet == 1)
	{
		shr[3] = 2;				// переход на шаг 3
		sh_ = 0;
		goto L101;
	}
	shr[2] = 1;					// активизация режима 2 "Откачка шлюза"
	sh[2] = 1;
	sh_ = 0;
	goto L101;
L52:if(shr[2]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_4()			//Режим "Технологический процесс"
{
	sh_ = sh[4];
	
	if (shr[4] == 1) goto L1;
	if (shr[4] == 2) goto L2;
	if (shr[4] == 3) goto L3;
	if (shr[4] == 4) goto L4;
	if (shr[4] == 5) goto L5;
	if (shr[4] == 6) goto L6;
	if (shr[4] == 7) goto L7;
	if (shr[4] == 8) goto L8;
	if (shr[4] == 9) goto L9;
	if (shr[4] == 10) goto L10;
	if (shr[4] == 11) goto L11;
	if (shr[4] == 12) goto L12;
	if (shr[4] == 13) goto L13;
	if (shr[4] == 14) goto L14;
	if (shr[4] == 15) goto L15;
	if (shr[4] == 16) goto L16;
	if (shr[4] == 17) goto L17;
	if (shr[4] == 18) goto L18;
	if (shr[4] == 19) goto L19;
	if (shr[4] == 20) goto L20;
	if (shr[4] == 21) goto L21;
	if (shr[4] == 22) goto L22;
	if (shr[4] == 23) goto L23;
	if (shr[4] == 24) goto L24;
	if (shr[4] == 25) goto L25;
	if (shr[4] == 26) goto L26;
	if (shr[4] == 27) goto L27;
	if (shr[4] == 28) goto L28;
	goto L100;				//выход
	
	// конечный диспетчер режима	
L101:sh[4] = sh_;
	if (sh[4] != 0) goto L100;	// sh_ != 0	
	++shr[4];					// след. шаг сч.шр1
	if (shr[4] > 28) goto L0;	// число шагов режима	
	sh[4] = 1;
L100:return;					//возврат в "кольцо"	

L0:	norma = 8;					//норма: "Тех.процесс завершен"	
	shr[4] = 0;					
	goto L100;					

L1:	N_ST	=0;
	T_PROC	=0;
	if(zin[3]&0x08)
	{
		if(shr[33])	{sh_=0;goto L101;}	//есть активиз. нагрева кам. откачн.
		shr[4]	=2;
		goto L2_1;				//переход на шаг 2_1
	}
	sh_=1;
	goto L101;
L2:	if(VRTEMP1==1)				//ожид. прогрева кам. откачив.
	{
L2_1:	if(shr[35])				//есть актив. нагрев кам. разрядной
		{
			sh_	=0;
			goto L101;
		}
		sh_		=0;
		shr[4]	=25;			//переход на шаг 26
		goto L101;
	}
	sh_=1;
	goto L101;
L3:	if(VRTEMP2==1)
	{
		sh_=0;
		shr[4]=25;				//переход на шаг 26
		goto L101;
	}
	sh_=1;
	goto L101;

L4:	if(CT_4<2)					//задержка
	{
		sh_=1;
		goto L101;
	}
    sh_=0;
	 goto L101;
L5:	if(diagnS[0]&0x02)					// пока нет связи с D2
		goto L101;
	if(D_D2>nasmod[13])			//проверка уровня вакуума в шлюзе
	{
		diagn[11] &= (~0x08);	//сброс значений
		sh_=0;
		goto L101;
	}
	diagn[11] |= 0x08; 			//Отказ плохо положены пластины на п.д.
	sh_=1;
	goto L101;
L6:	Klapan(0,&KlD4);			//Закрыть Кл-Д4
	goto L101;
L7:	Klapan(0,&KlD5);			//Закрыть Кл-Д5
	if(sh_) goto L101;
	if(nasmod[8]==1)			//тех. процесс разрешен
	{
		PR_NALADKA=1;
		sh_=0;
		goto L101;
	}
	N_ST	=1;
L7_1:T_PROC	=0;
	if(par[N_ST][0])			//есть зад.на РРГ1
	{
		shr[20]	=1;				// активиз. режима 20
		sh[20]	=1;				//РРГ1
	}
	else ObjRRG[0]->vRRG 	= 1;
	if(par[N_ST][1])			//есть зад.на РРГ2
	{
		shr[21]	=1;				// активиз. режима 21
		sh[21]	=1;				//РРГ2
	}
	else ObjRRG[1]->vRRG 	= 1;
	if(par[N_ST][2])			//есть зад.на РРГ3
	{
		shr[22]	=1;				// активиз. режима 22
		sh[22]	=1;				//РРГ3
	}
	else ObjRRG[2]->vRRG 	= 1;
	if(par[N_ST][3])			//есть зад.на РРГ4
	{
		shr[23]	=1;				// активиз. режима 23
		sh[23]	=1;				//РРГ4
	}
	else ObjRRG[3]->vRRG 	= 1;
	if(par[N_ST][4])			//есть зад.на РРГ5
	{
		shr[24]	=1;				// активиз. режима 24
		sh[24]	=1;				//РРГ5
	}
	else ObjRRG[4]->vRRG 	= 1;
	if(par[N_ST][5])			//есть зад.на РРГ6
	{
		shr[25]	=1;				// активиз. режима 25
		sh[25]	=1;				//РРГ6
	}
	else ObjRRG[5]->vRRG	 = 1;
	sh_		=0;
	shr[4]	= 8;				//переход на шаг 9
	goto L101;
L8:	if(nasmod[8]==1)			//тех. процесс разрешен		
	{
		sh_	=1;
		goto L101;
	}
	sh_		=0;
	shr[4]	=16;				//переход на шаг 17
	goto L101;
L9:	if ((ObjRRG[0]->vRRG == 1)&&(ObjRRG[1]->vRRG == 1)&&
(ObjRRG[2]->vRRG == 1)&&(ObjRRG[3]->vRRG == 1)&&
(ObjRRG[4]->vRRG == 1)&&(ObjRRG[5]->vRRG == 1))			// ожид. выхода на реж. всех РРГ
	{
		shr[17]	=1;				//активиз. режима 17
		sh[17]	=1;
		if(par[N_ST][8])
		{
			shr[31]	=1;			//активиз. режима 31
			sh[31]	=1;			//"движ. в точку согл. (грубо)"
			shr[32]	=1;			//активиз. режима 32
			sh[32]	=1;			//"движ. в точку согл. (грубо)"
		}
		sh_=0;
		goto L101;
	}
	sh_	=1;
	goto L101;
L10:if((shr[31])||(shr[32]))	// ожид. вых. в точку обоих конденсаторов
	{
		sh_	=1;
		goto L101;
	}
	sh_	=0;
	goto L101;
L11:if(!VRDZASL)				//ожид. вых. на режим заслонки
	{	
	sh_		=1;
	goto 	L101;
	}
	if(par[N_ST][8])			//есть зад. по мощн. на ВЧГ ИП (ВЧГ реакт.)
	{
		shr[29]	=1;				//активиз. режима 29
		sh[29]	=1;				//"ВЧГ ИП"
	}
	if(par[N_ST][11])			//есть зад. по мощн. на ВЧГ стола
	{
		shr[27]	=1;				//активиз. режима 27
		sh[27]	=1;				//"ВЧГ стола по мощн."
	}
	else if(par[N_ST][12])
		{
		shr[28]	=1;
		sh[28]	=1;
		}
	CT_4	=0;
	sh_	=0;
	goto L101;


L12:if(CT_4<=2)					// задержка
	{
		sh_		=1;
		goto 	L101;
	}
	CT_4=0;
	sh_	=0;
	goto L101;
L13:if(CT_4<=par[N_ST][13])		//ожид. конца процесса
	{
		T_PROC = CT_4;
		sh_		=1;
		goto 	L101;
	}
L13_1:if(par[N_ST][14])			//есть прокачка после стадии
	{
		sh_		=0;
		shr[4]	=16;			//переход на шаг 17
		goto	L101;
	}
	N_ST++;
	if((N_ST>N_ST_MAX)||(!(par[N_ST][13])))// проверка зад. времени процесса след. стадии
	{
		N_ST--;
		shr[4]	=16;			//переход на шаг 17
		sh_		=0;
		goto	L101;
	}
	T_PROC	=0;
	if(!par[N_ST][0])RRGOff(ObjRRG[0]);	// отключение РРГ1
	else
	{
		if(!shr[20])
		{
		shr[20]		=1;			//активиз. режима 20
		sh[20]		=1;			//"РРГ1"
		}	
	}
	if(!par[N_ST][1])RRGOff(ObjRRG[1]);	// отключение РРГ2
	else
	{
		if(!shr[21])
		{
		shr[21]		=1;			//активиз. режима 21
		sh[21]		=1;			//"РРГ2"
		}	
	}
	if(!par[N_ST][2])RRGOff(ObjRRG[2]);	// отключение РРГ3
	else
	{
		if(!shr[22])
		{
		shr[22]		=1;			//активиз. режима 22
		sh[22]		=1;			//"РРГ3"
		}	
	}
	
	if(!par[N_ST][3])
	{
		RRGOff(ObjRRG[3]);		// отключение РРГ4	
	}
	else
	{
		if(!shr[23])
		{
		shr[23]		=1;			//активиз. режима 23
		sh[23]		=1;			//"РРГ4"
		}	
	}
	
		if(!par[N_ST][4])
	{
		RRGOff(ObjRRG[4]);		// отключение РРГ5	
	}
	else
	{
		if(!shr[24])
		{
		shr[24]		=1;			//активиз. режима 24
		sh[24]		=1;			//"РРГ5"
		}	
	}
		if(!par[N_ST][5])
	{
		RRGOff(ObjRRG[5]);		// отключение РРГ6	
	}
	else
	{
		if(!shr[25])
		{
		shr[25]		=1;			//активиз. режима 25
		sh[25]		=1;			//"РРГ6"
		}	
	}
	if(par[N_ST][11])			//есть зад. по мощн. вчг стола(п/д)
	{
		if(!shr[27])			//есть активиз. режима 27 "Вкл. ВЧГ п/д"
		{
			shr[27]	=1;			//активиз. режима 27
			sh[27]	=1;			//"Вкл. ВЧГ п/д"
		}
	}
	else
	{
		if(par[N_ST][12])		
		{
			if(!shr[28])			//есть активиз. режима 27 "Вкл. ВЧГ стола (смещ)"
			{
				shr[28]	=1;		//активизируем режим 28
				sh[28]	=1;		//"Вкл. ВЧГ стола (смещ)"
			}
		}
		else SBROSR_27();		//сброс активиз. режима 27
	}
	if(par[N_ST][8])			//есть зад. по мощности ИП (ВЧГ реак.)
	{
		if(shr[29])
		{
			shr[4]	=14;		//переход на шаг 15
			goto L14_1;
		}
		shr[31]	=1;				//активиз. режима 31
		sh[31]	=1;				//"движ. в точку согл. (грубо)"
		shr[32]	=1;				//активиз. режима 32
		sh[32]	=1;				//"движ. в точку согл. (точно)"
		sh_		=0;
		goto L101;
	}
	else
	{
		SBROSR_29();			//сброс активиз. режима 29
		shr[4]	=14;			// переход на шаг 14_1
		goto L14_1;
	}	
L14:if((shr[31])||(shr[32]))	// ожид. вых. в точку обоих конденсаторов
	{
		sh_	=1;
		goto L101;
	}
	shr[29]	=1;					//активиз. режима 29					
	sh[29]	=1;					//"ВЧГ ИП"
L14_1:CT_4	=0;	
	sh_		=0;
	goto L101;
L15:if(CT_4<=2)					//задержка
	{
		sh_		=1;
		goto L101;
	}
	CT_4		=0;
	sh_			=0;
	goto L101;
L16:if(CT_4<=par[N_ST][13])		//ожид. конца процесса
	{
		T_PROC = CT_4;
		sh_		=1;
		goto L101;
	}
	shr[4]	=13;				//переход на шаг 14
	goto L13_1;
L17:SBROSR_27();				//сброс активиз. режима 27
	SBROSR_29();				//сброс активиз. режима 29
	RRGOff(ObjRRG[0]);			// отключение РРГ1
	RRGOff(ObjRRG[1]);			// отключение РРГ2
	RRGOff(ObjRRG[2]);			// отключение РРГ3
	RRGOff(ObjRRG[3]);			// отключение РРГ4
	RRGOff(ObjRRG[4]);			// отключение РРГ5
	RRGOff(ObjRRG[5]);			// отключение РРГ6
	if(!shr[8])
	{
		shr[18]		=1;			//активиз. режима 18
		sh[18]		=1;			//"открыть ДЗ"
		sh_			=0;
		goto L101;
	}
	shr[4]	=22;				//переход на шаг 23
	goto L22_1;
L18:if(shr[18])					// ожидад. открытия ДЗ
	{
		sh_		=1;
		goto 	L101;
	}
	PR_NALADKA	=0;
	CT_4 		=0;
	sh_			=0;
	goto L101;
L19:if(CT_4<=nasmod[14])		//задержка на прокачку кам.
	{
		sh_		=1;
		goto 	L101;
	}
	sh_		=0;
	goto L101;
L20:Klapan(1,&KlD4);			//открыть Кл-Д4
	goto L101;
L21:Klapan(1,&KlD5);			//открыть Кл-Д5
	if(sh_) goto L101;
	if(shr[26])					//есть активиз. РРГ7
	{
		SetOut(0,3,0x4000);		//закрыть Кл3
		SetOut(1,3,0x2000);		//открыть Кл4
        PR_HEL = 0;
	}
	sh_		=0;
	goto L101;
L22:if(diagnS[0]&0x08)					// пока нет связи с D4
		goto L101;
	if(D_D4>=nasmod[7])			//проверка уровня вакуума в камере
	{
		sh_	=1;
		goto L101;
	}
	if(N_ST!=0)
	{
		N_ST			+=1;
		if((N_ST<=N_ST_MAX)&&(par[N_ST][13]!=0))	//проверка зад. времени процесса след. стадии
		{
			if(shr[26])
			{
				SetOut(1,3,0x4000);	//открыть Кл3
				SetOut(0,3,0x2000);	//закрыть Кл4
                PR_HEL = 1;
			}
			sh_	=0;
			goto L101;
		}
	}
L22_1:RRGOff(ObjRRG[6]);				// отключение РРГ7
	N_ST				=0;
	T_PROC				=0;
	PR_NALADKA			=0;
	sh_					=0;
	shr[4]				=24;		//переход на шаг 25
	goto L101;
L23:Klapan(0,&KlD4);				//закрыть Кл-Д4
	goto L101;
L24:Klapan(0,&KlD5);				//закрыть Кл-Д5
	if(sh_) goto L101;
	shr[4] = 7;						//переход на шаг 7
	sh_ = 1;
	goto L7_1;
L25:OPRIJIM();						// прижим в Home
	if(sh_) goto L101;
	shr[4] = 28;					//выход
	goto L101;
L26:VPPRIJIM();						// подпрограмма "Прижим вниз"
	if(sh_) goto L101;
	if(nasmod[2])
	{
		PR_HEL	=0;
		shr[26]	=1;					//активиз. режима 26
		sh[26]	=1;					//"Вкл. РРГ7"
		sh_		=0;
		goto L101;
	}
	sh_			=0;
	shr[4]		=5;					//переход на шаг 6
	goto L101;
L27:if ((ObjRRG[6]->vRRG) == 1)		//отключение РРГ7
	{
	CT_4	=0;
	sh_		=0;
	goto L101;
	}
	sh_		=1;
	goto L101;
L28:if(CT_4<=T_SBROSHE)
	{
		sh_	=1;
		goto L101;
	}
	SetOut(0,3,0x2000);				//закрыть Кл4
	SetOut(1,3,0x4000);				//открыть Кл3
    PR_HEL = 1;
	CT_4	=0;
	shr[4] = 3;						// переход на шаг 4
	sh_		=0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_5()            // Режим "Сброс РЦ"
{
	sh_ = sh[5];
	
	if (shr[5] == 1) goto L1;
	if (shr[5] == 2) goto L2;
	if (shr[5] == 3) goto L3;
	if (shr[5] == 4) goto L4;
	if (shr[5] == 5) goto L5;
	if (shr[5] == 6) goto L6;
	if (shr[5] == 7) goto L7;
	goto L100;				// выход
		
	// конечный диспетчер режима
L101:sh[5] = sh_;
	if (sh[5] != 0) goto L100;		// sh_ != 0
	++shr[5];						// след. шаг сч.шр2
	if (shr[5] > 7) goto L0;		// число шагов режима
	sh[5] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 4;						// норма: "Сброс РЦ завершен"
	shr[5] = 0;
	goto L100;	
	
L1:	prDvijGir_g = 0;
	prDvijGir_t = 0;
	shr[31] = 0;					// сброс режима 31
	sh[31] = 0;
	shr[32] = 0;					// сброс режима 32
	sh[32] = 0;
	SetOut(0,1,0x3C00);				// сброс направлений ИП
	A_OUT(9,8192);					// сброс скоростей ИП
	A_OUT(10,8192);
	if((!PR_PER)&&(!PR_POV)&&(!PR_KAS)&&(!PR_PRIJ))	// нет движения манипулятора
	{
		shr[5] = 5;
		sh_ = 1;
		goto L5_1;				 // переход на шаг 5_1
	}
	CT_5 = 0;
	sh_ = 0;
	goto L101;	
L2: if(PR_PER)						// пока ман. перем. движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[24] |= 0x01;			// отказ: "Отказ манипулятора перем."
                shr[5] = 5;
		sh_ = 1;
		goto L5_2;				// переход на шаг 5_2
	}
        sh_ = 0;
        goto L101;
L3:if(PR_POV)						// пока ман. пов. движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[24] |= 0x02;			// отказ: "Отказ манипулятора пов."
                shr[5] = 5;
		sh_ = 1;
		goto L5_2;				// переход на шаг 5_2
	}
        sh_ = 0;
        goto L101;
L4:if(PR_KAS)						// пока ман. кас. движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[24] |= 0x04;			// отказ: "Отказ манипулятора кас."
                shr[5] = 5;
		sh_ = 1;
		goto L5_2;				// переход на шаг 5_2
	}
        sh_ = 0;
        goto L101;
L5:if(PR_PRIJ)						// пока мех. прижима движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[24] |= 0x08;			// отказ: "Отказ мех. прижима"
L5_2:	PR_PER = 0;
		PR_POV = 0;
		PR_KAS = 0;
		PR_PRIJ = 0;
	}
L5_1:SBROS_MEH();					// "Стоп механизма"
	SetOut(0,2,0x100);				// закрыть Кл-Нап1, Кл-Нап2, Кл-Нап3
	SetOut(0,3,0xC00);
	SetOut(0,1,0x10);				// откл. звуковую сигнализацию
	zshr3 = shr[3];
	shr[3] = 0;					// сброс активиз. режима 3
	sh[3] = 0;				       	// "РЦ"
	shr[2] = 0;					// сброс активиз. режима 2
	sh[2] = 0;					// "Откл. Шл"
	shr[1] = 0;					// сброс активиз. режима 1
	sh[1] = 0;					// "Откачки Кам."
	for(int i=0;i<DIAGN_COUNT;i++)
        if((i != 14)&&(i != 24)&&(i != 28)) diagn[i] = 0;// сброс диагностик кроме аварийных
	if((zshr3>0)&&(zshr3<=2))
	{
		shr[5] = 7;					
		sh_ = 0;					// ВЫХОД
		goto L101;
	}
	if(shr[4])
	{
		shr[4]	=17;				//активизация режима 4 "Технолог. процесс"
		sh[4]	=1;					//на шаге 17
		N_ST	=0;
		sh_		=0;
		goto L101;
	}
	shr[5]	=6;						//переход на шаг 6_1
	sh_	=1;
	goto L6_1;
L6:	if(shr[4]) goto L101;			//ожидание конца режима 4 "Технолог. процесс "
L6_1:if(PR_KLASTER) goto L0;
    if(shr[8]) goto L0;
	shr[6]	=1;						//активиз. режима 6
	sh[6]	=1;						//"сбор(выгрузка) пластин"
	sh_=0;
	goto L101;
L7:	if(shr[6]) goto L101;			// ожидание конца режима
	sh_=0;
	goto L101;	
}
//---------------------------------------------------------------------------
void R_6 ()            // Режим "Сбор/выгрузка пластин"
{
	sh_ = sh[6];
	
	if (shr[6] < 1 || shr[6] > 28) goto L100;
	if (shr[6] < 10) goto L00;
	if (shr[6] < 20) goto L01;
	else goto L02;
	
L00:if (shr[6] == 1) goto L1;
	if (shr[6] == 2) goto L2;
	if (shr[6] == 3) goto L3;
	if (shr[6] == 4) goto L4;
	if (shr[6] == 5) goto L5;
	if (shr[6] == 6) goto L6;
	if (shr[6] == 7) goto L7;
	if (shr[6] == 8) goto L8;
	if (shr[6] == 9) goto L9;
L01:if (shr[6] == 10) goto L10;
	if (shr[6] == 11) goto L11;
	if (shr[6] == 12) goto L12;
	if (shr[6] == 13) goto L13;
	if (shr[6] == 14) goto L14;
	if (shr[6] == 15) goto L15;
	if (shr[6] == 16) goto L16;
	if (shr[6] == 17) goto L17;
	if (shr[6] == 18) goto L18;
	if (shr[6] == 19) goto L19;
L02:if (shr[6] == 20) goto L20;
	if (shr[6] == 21) goto L21;
	if (shr[6] == 22) goto L22;
	if (shr[6] == 23) goto L23;
	if (shr[6] == 24) goto L24;
	if (shr[6] == 25) goto L25;
	if (shr[6] == 26) goto L26;
	if (shr[6] == 27) goto L27;
	if (shr[6] == 28) goto L28;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[6] = sh_;
	if (sh[6] != 0) goto L100;			// sh_ != 0
	++shr[6];							// след. шаг сч.шр1
	if (shr[6] > 28) goto L0;			// число шагов режима
	sh[6] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma = 11;							// норма: "Сбор пластин завершен"
	shr[6] = 0;
	goto L100;
L1: SetOut(0,2,0x73F);					// закрыть Кл-РРГ1,Кл-РРГ2,Кл-РРГ3,Кл-РРГ4,Кл-РРГ5,Кл-РРГ6,Кл-НАП1,Кл1,Кл2
	SetOut(0,3,0x6C00);					// закрыть Кл-НАП2,Кл-НАП3,Кл4,Кл3
	Klapan(1,&KlD4);					// открыть Кл-Д4
	goto L101;
L2: Klapan(1,&KlD5);					// Открыть Кл-Д5
	if(sh_) goto L101;
	if(zin[4]&0x200)					// МАН пер. в HOME?
	{
		shr[6] = 3;						// Переход на шаг 3_1
		sh_ = 1;
		goto L3_1;
	}
	goto L101;
L3: VIDK_PER(0,0,0,1,10);				// МАН пер. в HOME
	if(sh_) goto L101;
L3_1:if(zin[4]&0x1000)					// МАН пов. в HOME?
	{
		shr[6] = 4;						// переход на шаг 4_1
		sh_ = 1;
		goto L4_1;
	}
    sh_ = 0;
	goto L101;
L4:	VIDK_POV(0,0,0,1,10);				// МАН пов. в HOME
	if(sh_) goto L101;
L4_1:if(zin[4]&0x4000)					// проверка нал. пл. перед кам.
	{
		shr[6] = 12;					// переход на шаг 13
		sh_ = 0;
		goto L101;
	}
	if(shr[5])							// есть активиз. режима 5 "Сброс РЦ"
	{
		if((27>zshr3)||(zshr3>39))		// Пл в кам.
		{
			shr[6] = 27;				// переход на шаг 28
			sh_ = 0;
			goto L101;
		}
	}
	shr[10] = 1;						// активиз. режима 10
	sh[10] = 1;							// "открыть ЩЗ"
	sh_ = 0;
	goto L101;
L5: if(shr[10]) goto L101;				// ожид. конца режима
	sh_ = 0;
	goto L101;
L6: OPRIJIM();							// прижим в HOME
	goto L101;
L7: Klapan(1,&PP);						// подъемник вверх
	goto L101;
L8:	VIDK_POV(0,ABS,par_t[3],0,10);		// МАН пов. к кам.
	goto L101;
L9: VIDK_PER(0,ABS,par_t[2],0,10);		// ман. перем. в кам.
	goto L101;
L10:Klapan(0,&PP);						// подъемник вниз
	goto L101;
L11:VIDK_PER(0,0,0,1,10);				// ман. пер. в HOME
	if(sh_)goto L101;
	if(!(zin[4]&0x8000))				// проверка нал. пл. перед кам.
	{
		diagn[8]|=0x40;					//отказ:"Нет пластины в камере и на манипуляторе"	
		shr[6]	=16;
		sh_		=0;
		goto L101;
	}
	sh_	=0;
	goto L101;
L12:VIDK_POV(0,0,0,1,10);				// МАН пов. в HOME
    if(sh_)goto L101;
	if(!(zin[4]&0x4000))
	{
		diagn[8]|=0x10;					// отказ "Нет пластины на манипуляторе перед кассетой"
		shr[6]	=16;
		goto L101;
	}
	sh_	=0;
	goto L101;
L13:if(!KasVPaze())
	{
		diagn[8]|=0x80;					// отказ:"Кассета не в положении загрузки - выгрузки"
		shr[6] = 17;
		sh_ = 0;
		goto L101;
	}
	sh_ = 0;
	goto L101;
L14:VIDK_PER(0,ABS,par_t[1],0,10);		// МАН перемещ. в кассету
	goto L101;	
L15:VIDK_KAS(0,OTN,par_t[5],0,10);		// Кассета вверх на h1
	goto L101;
L16:VIDK_PER(0,0,0,1,10);				// МАН перемещения в HOME
	if(sh_) goto L101;
	if(zin[4]&0x4000)diagn[8]|=0x20;	// Проверка отсутствия пластины перед кассетой 									
	sh_ = 0;							// отказ:"Манип. не выгрузил пласт. в кассету"
	goto L101;
L17:VIDK_KAS(0,0,0,1,15);				// Кассета в HOME
	goto L101;
L18:Klapan(0,&ShZatvor);	 			// Закрыть ЩЗ
	goto L101;
L19:Klapan(0,&KlShl);					// Закрыть ФК-Шл
	if(sh_) goto L101;
	CT_6	=0;
	SetOut(1,3,0x400);					// Открыть Кл-Нап2
	goto L101;
L20:if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1 <= UVAK_SHL_MN) goto L101;	// Проверка вак. в шлюзе(НАПУСК в шлюз для охлаждения)
	SetOut(1,3,0x800);					// Открыть Кл-Нап3
	sh_=0;
	goto L101;
L21:if(zin[3]&0x4000)
	{
		if(CT_6>=T_KNAP) diagn[12]|=0x08;//отказ "Медленный напуск в шлюз"
		goto L101;
	}
	diagn[12] &= (~0x08);				// сброс диагностики
	SetOut(0,3,0xC00);					// Закрыть Кл-НАП2,Кл-НАП3
	CT_6=0;
	SetOut(1,1,0x10);					// включить звонок
	sh_=0;
	goto L101;
L22:if(CT_6<=3)goto L101;
	SetOut(0,1,0x10);					// отключить звонок
	otvet=0;
	sh_=0;
	goto L101;
L23:if(!otvet)goto L101;				// нет ответа оператора
	if(otvet==1)
	{
		sh_=0;
		goto L101;
	}
	shr[6]=25;							// переход в шаг 26
	sh_=0;
	goto L101;
L24:if(!(zin[3]&0x4000))goto L101;		//дверь шлюза закрыта
	shr[2]=1;							//активиз. режима 2
	sh[2]=1;							// "Откачка шлюза"
	sh_=0;
	goto L101;
L25:if(!shr[2])sh_=0;
	goto L101;
L26:Klapan(0,&KlShl);					// Закрыть ФК-Шл
	goto L101;
L27:Klapan(0,&FvnShl);					// отключить ФВН шлюза
	if(sh_)goto L101;
	goto L0;							//	Выход
L28:Klapan(0,&ShZatvor);	 			// Закрыть ЩЗ
	if(sh_)goto L101;
	shr[6]=16;
	goto L101;
}
//---------------------------------------------------------------------------
void R_7 ()							// Режим "Отключение установки"
{
	sh_ = sh[7];

	if (shr[7] == 1) goto L1;
	if (shr[7] == 2) goto L2;
	if (shr[7] == 3) goto L3;
	if (shr[7] == 4) goto L4;
	if (shr[7] == 5) goto L5;
	if (shr[7] == 6) goto L6;
	if (shr[7] == 7) goto L7;
	if (shr[7] == 8) goto L8;
	if (shr[7] == 9) goto L9;
	if (shr[7] == 10) goto L10;
	if (shr[7] == 11) goto L11;
	if (shr[7] == 12) goto L12;
	if (shr[7] == 13) goto L13;
	if (shr[7] == 14) goto L14;
	if (shr[7] == 15) goto L15;
	if (shr[7] == 16) goto L16;
	if (shr[7] == 17) goto L17;
	if (shr[7] == 18) goto L18;
	if (shr[7] == 19) goto L19;
	if (shr[7] == 20) goto L20;
	if (shr[7] == 21) goto L21;
	if (shr[7] == 22) goto L22;
	if (shr[7] == 23) goto L23;
	else goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[7] = sh_;
	if (sh[7] != 0) goto L100;			// SH != 0
	++shr[7];							// след. шаг сч.шр5
	if (shr[7] > 23) goto L0;			// число шагов режима
	sh[7] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma 	= 6;						// норма: "Отключение установки завершено"
	shr[7] 	= 0;
	goto L100;
	
L1:	SetOut(0,2,0x73F);					// закрыть Кл1,Кл2,Кл-Нап1 Кл-РРГ1-Кл-РРГ6
	SetOut(0,3,0x6C00);					// закрыть Кл3,Кл4,Кл-Нап2,Кл-Нап3
	sh_ = 0;
	goto L101;
L2: ORR_GIR();							// снять р/р ВЧГ ип
	goto L101;	
L3:	ORR_GIS();							// снять р/р ВЧГ п/д
	if(sh_) goto L101;	
	if(PR_KLASTER)
	{
        shr[7]	= 7;					// Переход на шаг 7_1
        sh_=1;
        goto L7_1;
	}
	if(zin[4]&0x200)					// МАН пер. в HOME?
	{
		shr[7] 	=4;						// Переход на шаг 4_1
		sh_		=1;
		goto L4_1;
	}
	sh_	=0;
	goto L101;
L4:	VIDK_PER(0,0,0,1,10);				// МАН пер. в HOME
	if(sh_)goto L101;
L4_1:if(!(zin[4]&0x1000))		// МАН пов. в HOME?
	{
		sh_=0;
		goto L101;
	}
	sh_=1;
	shr[7]=5;
	goto L5_1;							// Переход на шаг 5_1
L5:	VIDK_POV(0,0,0,1,10);				// МАН пов. в HOME
	if(sh_) goto L101;
L5_1:if(zin[4]&0x40)shr[7]=6;			// кас. в HOME?// переход на шаг 7
    sh_=0;
	goto L101;
L6:	VIDK_KAS(0,0,0,1,10); 				// кассета в HOME
	goto L101;
L7:	Klapan(0,&ShZatvor);				// закрыть ЩЗ
    if(sh_) goto L101;
L7_1:if(zin[3]&0x1000)			        // прижим  в HOME
        shr[7]=8;                           // переход на шаг 9
	sh_=0;
	goto L101;							
L8:	OPRIJIM();							// подъемник в Home
	goto L101;
L9:	Klapan(0,&PP);						// мех. подъёма вниз
	goto L101;
L10:Klapan(0,&KlKam);					// закрыть ФК-Кам
	goto L101;
L11:Klapan(0,&KlShl);					// закрыть ФК-Шл
	goto L101;
L12:Klapan(0,&DZasl);					// закрыть ДЗ
	if(sh_) goto L101;
	if(!(zin[2]&0x1C00))				// нет вращение ТМН
	{
		shr[7] = 15;					// переход на шаг 16
		goto L101;
	}
	goto L101;
L13:Klapan(1,&KlTmn);					// открыть ФК-Тмн
	if(sh_) goto L101;
	SetOut(0,3,0x40);					// снять сигнал "Старт ТМН"
	CT_7 = 0;
	goto L101;
L14:if(CT_7 <= 5) goto L101;			// задержка 5 сек
	sh_ = 0;
	goto L101;
L15:sh_=1;
    if(!(zin[2]&0x1C00))sh_ = 0; 			// есть вращение ТМН
	goto L101;
L16:Klapan(0,&KlTmn);					// закрыть ФК-Тмн
	goto L101;
L17:Klapan(0,&FvnKam);					// отключить ФВН-Кам
	goto L101;	
L18:Klapan(0,&FvnShl);					// отключить ФВН-Шл
	goto L101;
L19:Klapan(0,&KlD4);					// закрыть Кл-Д4
	goto L101;
L20:Klapan(0,&KlD5);					// закрыть Кл-Д5
if(sh_) goto L101;
	if(shr[33])							// режим 33 активирован	"нагр. камеры"
	{
		shr[34] = 1;					// активизация режима 34 "откл. нагр. камеры"
		sh[34] = 1;
	}
	goto L101;
L21:if(shr[34]) goto L101;				// ожидание режима 34 "откл. нагр. камеры"
	if(shr[35])							// есть активиз. режима 35 "откл. нагр. трубопровода"
	{
		shr[36] = 1;					// активиз. режима 36
		sh[36] = 1;						// "откл. нагр. 2 трубопровода"
	}
	sh_ = 0;
	goto L101;
L22:if(shr[36]) goto L101;				// ожид. откл. нагр. 2 трубопровода
	sh_ = 0;
	goto L101;
L23:OBPN();								// отключить питание БПН
	goto L101;
}
//---------------------------------------------------------------------------
void R_8 ()							// Режим "Аварийное отключение установки"
{
	sh_ = sh[8];

	if (shr[8] == 1) goto L1;
	if (shr[8] == 2) goto L2;
	if (shr[8] == 3) goto L3;
	if (shr[8] == 4) goto L4;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[8] = sh_;
	if (sh[8] != 0) goto L100;		// SH != 0
	++shr[8];						// след. шаг сч.шр5
	if (shr[8] > 4) goto L0;		// число шагов режима
	sh[8] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 9;						// норма: "Авар. откл. установки завершено"
	shr[8] = 0;
	goto L100;
L1:	if(shr[5])						// есть активизация режима 5 "Сброс РЦ"
	{
		shr[8] = 2;					// переход на шаг 3
		sh_ = 0;
		goto L101;
	}
	if((shr[3])||(shr[4]))			// есть актив режимы: "Рабочий цикл" или "Технологический процесс"
	{
		sh[5] = 1;					// активизация режима 5 "Сброс РЦ"
		shr[5]  = 1;
		shr[8] = 2;					// переход на шаг 5
		sh_ = 0;
		goto L101;
	}
	SBROSR_27();            // сброс ВЧГ п/д
    SBROSR_29();            // сброс ВЧГ ИП

	RRGOff(ObjRRG[0]);				// отключение РРГ1
	RRGOff(ObjRRG[1]);				// отключение РРГ2
    RRGOff(ObjRRG[2]);				// отключение РРГ3
	RRGOff(ObjRRG[3]);				// отключение РРГ4
	RRGOff(ObjRRG[4]);				// отключение РРГ5
    RRGOff(ObjRRG[5]);				// отключение РРГ6
	RRGOff(ObjRRG[6]);				// отключение РРГ7
	shr[19] = 1;
	sh[19]  = 1;					// активизация режима 19 "Закрыть ДЗ"
	sh_ = 0;
	goto L101;
L2: if(shr[19]) goto L101;			// ожидание конца режима "ЗАкрыть ДЗ"
	sh[1] = 0;						// сброс режимов
	shr[1] = 0;
	sh[2] = 0;
	shr[2] = 0;
	sh[6] = 0;
	shr[6] = 0;
	sh[9] = 0;
	shr[9] = 0;
	sh[10] = 0;
	shr[10] = 0;
	sh[11] = 0;
	shr[11] = 0;
	SBROS_MEH();					//стоп движений механизма
	shr[8] = 3;
	sh_ = 1;
	goto L3_1;
L3: if(shr[5]) goto L101;			// ожидание конца режима "Сброс РЦ"
L3_1:if(!(shr[7])) 					// есть активация режима "отключение установки"
	{
		sh[7]  = 1;					// активация режима 7 "Откл. установки"
		shr[7] = 1;
	}					
	sh_ = 0;
	goto L101;
L4: if(shr[7]) goto L101;			// ожидание конца режима "отключение установки"
	sh_ = 0;
	goto L101;
}	
//---------------------------------------------------------------------------
void R_9 ()							// Режим "Транспортный тест"
{
	sh_ = sh[9];
	
	if (shr[9] < 1 || shr[9] > 36) goto L100;
	if (shr[9] < 10) goto L00;
	if (shr[9] < 20) goto L01;
	if (shr[9] < 30) goto L02;
	else goto L03;
	
L00:if (shr[9] == 1) goto L1;
	if (shr[9] == 2) goto L2;
	if (shr[9] == 3) goto L3;
	if (shr[9] == 4) goto L4;
	if (shr[9] == 5) goto L5;
	if (shr[9] == 6) goto L6;
	if (shr[9] == 7) goto L7;
	if (shr[9] == 8) goto L8;
	if (shr[9] == 9) goto L9;
L01:if (shr[9] == 10) goto L10;
	if (shr[9] == 11) goto L11;
	if (shr[9] == 12) goto L12;
	if (shr[9] == 13) goto L13;
	if (shr[9] == 14) goto L14;
	if (shr[9] == 15) goto L15;
	if (shr[9] == 16) goto L16;
	if (shr[9] == 17) goto L17;
	if (shr[9] == 18) goto L18;
	if (shr[9] == 19) goto L19;
L02:if (shr[9] == 20) goto L20;
	if (shr[9] == 21) goto L21;
	if (shr[9] == 22) goto L22;
	if (shr[9] == 23) goto L23;
	if (shr[9] == 24) goto L24;
	if (shr[9] == 25) goto L25;
	if (shr[9] == 26) goto L26;
	if (shr[9] == 27) goto L27;
	if (shr[9] == 28) goto L28;
	if (shr[9] == 29) goto L29;
L03:if (shr[9] == 30) goto L30;
	if (shr[9] == 31) goto L31;
	if (shr[9] == 32) goto L32;
	if (shr[9] == 33) goto L33;
	if (shr[9] == 34) goto L34;
	if (shr[9] == 35) goto L35;
	if (shr[9] == 36) goto L36;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[9] = sh_;
	if (sh[9] != 0) goto L100;	// sh_ != 0
	++shr[9];					// след. шаг сч.шр1
	if (shr[9] > 36) goto L0;	// число шагов режима
	sh[9] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 10;					// норма: "Транспортный тест завершен"
	shr[9] = 0;
	goto L100;
L1: PR_TRTEST = 0;					// непрерывный цикл
	N_PL = 0;
	sh_ = 0;
	goto L101;	
L2: OPRIJIM();						// прижим в Home
	goto L101;	
L3: Klapan(0,&PP);					// механизм прижима вниз
	goto L101;	
L4: sh_=0;
	goto L101;
L5:	VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету 
	goto L101;
L6:	VIDK_KAS(0,OTN,-par_t[5],0,10);	// кассета вниз на(h1)
	goto L101;
L7:	VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_)goto L101;
	if(!(nasmod[17])) 				// тр. тест с пластиной
	{
		shr[9] = 8;				// переход на шаг 8_1
		sh_	=1;
		goto L8_1;
	}
	goto L101;
L8:	if(!(zin[4]&0x4000))			// проверка нал. пл. перед кам.
	{
		diagn[8] |= 0x01;			// отказ: "Ман. не взял пластину из кассеты"
		goto L101;		
	}
	diagn[8] &= (~0x01);			// сброс диагностик МАН перемещения
L8_1:N_PL++;
	shr[9]=11;
	sh_=0;
	goto L101;
L9: sh_=0;
	goto L101;
L10: sh_=0;
	goto L101;
L11: sh_=0;
	goto L101;
L12:VIDK_POV(0,ABS,par_t[3],0,10);	// ман. пов. к камере
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9]=13;		//транспортный тест с пластиной // переход на шаг 14
	goto L101;
L13:if(!(zin[4]&0x8000))			// проверка нал. пл. перед кам.
	{
		diagn[8] |= 0x02;			// отказ: "Нет пластины в манипуляторе перед камерой"
		goto L101;		
	}
	diagn[8] &= (~0x02);			// сброс диагностик МАН перемещения	
	sh_	=0;
	goto L101;
L14:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в камеру
	goto L101;
L15:Klapan(1,&PP);					// подъемник вверх
	goto L101;
L16:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9]=17;		//транспортный тест с пластиной // переход на шаг 18
	goto L101;
L17:if(zin[4]&0x8000)			// проверка нал. пл. перед кам.
	{
		diagn[8] |= 0x04;			// отказ: "Манипулятор не загрузил пластину в камеру"
		goto L101;		
	}
	diagn[8] &= (~0x04);			// сброс диагностик МАН перемещения	
	sh_	=0;
	goto L101;
L18:Klapan(0,&PP);						// подъёмник вниз
	if(sh_) goto L101;
	CT_9=0;
	goto L101;
L19:if(CT_9<=1)goto L101;			//задержка
	sh_=0;
	goto L101;
L20:VPPRIJIM();						// механизм прижима вниз
	if(sh_) goto L101;
	CT_9=0;
	goto L101;
L21:if(CT_9 <= 5) goto L101;		// задержка
	sh_ = 0;
	goto L101;	
L22:OPRIJIM();						// прижим в HOME(вверх)
	goto L101;
L23:Klapan(1,&PP);					// подъемник вверх
	goto L101;
L24:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в кам.
	goto L101;	
L25:Klapan(0,&PP);					// подъемник вниз
	goto L101;
L26:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9] = 27;	// тр. тест с пластиной// переход на шаг 28
	sh_=0;
	goto L101;
L27:if(!(zin[4]&0x8000))
	{
		diagn[8] |= 0x08;			// отказ: "Ман. не выгр. пластину из кам."
		goto L101;
	}
	diagn[8] &= (~0x08);			// сброс диагностик МАН
	sh_ = 0;
	goto L101;
L28:VIDK_POV(0,0,0,1,10);			// ман. пов. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9] = 29;	// тр. тест с пластиной// переход на 30 шаг
	goto L101;
L29:if(!(zin[4]&0x4000))				// проверка отсутств. пласт. перед касс.
	{
		diagn[8] |= 0x10;			// отказ: "Нет пластины на манипулятор перед кассетой"
		goto L101;		
	}
	diagn[8] &= (~0x10);			// сброс диагностик МАН перемещения
	sh_ = 0;
	goto L101;
L30:VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету 
	goto L101;
L31:VIDK_KAS(0,OTN,par_t[5],0,10);	// перем. кас. вверх на (h1).
	goto L101;
L32:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))				// тр. тест с пластиной
	{
		shr[9] = 33;				// переход на 33_1 шаг
		sh_ = 1;
		goto L33_1;
	}
	goto L101;
L33:if((zin[4]&0x4000))				// проверка нал. пл. перед касс.
	{
		diagn[8] |= 0x20;			// отказ: "Ман. не выгр. пл. в кас."
		goto L101;		
	}
	diagn[8] &= (~0x20);			// сброс диагностик МАН перемещения
L33_1:if((N_PL<par[N_ST][20])&&(!PR_TRTEST))
	{
		CT_9=0;
		sh_=0;
		goto L101;
	}
	shr[9]=35;
	sh_=0;
	goto L101;
L34:if(!(CT_9<=5))sh_=0;
	goto L101;
L35:VIDK_KAS(0,OTN,par_t[4],0,10);	// кас. вверх на h1 отн.
	if(sh_) goto L101;
	sh_=0;
	shr[9]=4;
	goto L101;
L36:VIDK_KAS(0,0,0,1,10); 			// кассета в HOME
	if(sh_) goto L101;
	goto L0;
}
//---------------------------------------------------------------------------
void R_10 ()							// Режим "Открыть ЩЗ"
{
	sh_ = sh[10];
	
	if (shr[10] < 1 || shr[10] > 18) goto L100;
	if (shr[10] < 10) goto L00;
	goto L01;

L00:if (shr[10] == 1) goto L1;
	if (shr[10] == 2) goto L2;
	if (shr[10] == 3) goto L3;
	if (shr[10] == 4) goto L4;
	if (shr[10] == 5) goto L5;
	if (shr[10] == 6) goto L6;
	if (shr[10] == 7) goto L7;
	if (shr[10] == 8) goto L8;
	if (shr[10] == 9) goto L9;
L01:if (shr[10] == 10) goto L10;
	if (shr[10] == 11) goto L11;
	if (shr[10] == 12) goto L12;
	if (shr[10] == 13) goto L13;
	if (shr[10] == 14) goto L14;
	if (shr[10] == 15) goto L15;
	if (shr[10] == 16) goto L16;
	if (shr[10] == 17) goto L17;
	if (shr[10] == 18) goto L18;
	goto L100;
	// конечный диспетчер режима
L101:sh[10] = sh_;
	if (sh[10] != 0) goto L100;		// SH != 0
	++shr[10];						// след. шаг сч.шр5
	if (shr[10] > 18) goto L0;		// число шагов режима
	sh[10] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 25;						// норма: "Щелевой затвор открылся"
	shr[10] = 0;
	goto L100;
L1: shr[11] = 0;					// сброс активизации режима 11
	sh[11] = 0;
	diagn[9] &= (~0x0F);			// сброс диагностик ЩЗ
	sh_ = 0;
	goto L101;
L2:	if((zin[1] & 0x0C) == 0x04)		// ЩЗ открыт
	{
		diagn[9] &= (~0x04);		// сброс диагностики
		shr[10] = 18;				// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	if((zin[1] & 0x0C) == 0x08)		// ЩЗ закрыт
	{
		diagn[9] &= (~0x04);		// сброс диагностики
		sh_ = 0;
		goto L101;
	}
	diagn[9] |= 0x04;				// диагностика "Положение щелевого затвора не определено"
	goto L101;
L3:	Klapan(1,&KlD4);				// открыть Кл-Д4
	goto L101;
L4:	Klapan(1,&KlD5);				// открыть Кл-Д5
	goto L101;
L5:	if(diagnS[0]&0x08)					// пока нет связи с D4
		goto L101;
	if(D_D4 > UATM_D4 )				// проверка уровня вакуума в камере
	{
		sh_ = 0;
		goto L101;
	}
	shr[10] = 7;					// переход на 8 шаг
	sh_ = 0;
	goto L101;
L6:	if(!(zin[3]&0x4000))				// проверка уровня вакуума в шлюзе
	{
		SetOut(0,3,0xC00);			// закрыть Кл-Нап2, Кл-Нап3
		shr[10] = 17;				// на шаг 18
		sh_ = 0;
		goto L101;
	}
	sh_ = 0;
	goto L101;
L7:	Klapan(0,&KlShl);				// закрыть Кл-Шл
	if(sh_) goto L101;
	SetOut(1,3,0x800);				// открыть Кл-НАП3
	shr[10] = 5;					// возврат на шаг 6
	goto L101;
L8:	if(diagnS[0]&0x08)					// пока нет связи с D4
		goto L101;
	if(D_D4 > UVAKV_KAM)            // проверка уровня вакуума в камере
	{
		SetOut(0,2,0x100);			// закрыть Кл-Нап1
		sh_ = 0;
		goto L101;
	}
	shr[10] = 11;					// переход на шаг 12
	sh_ = 0;
	goto L101;
	
L9:	Klapan(0,&KlTmn);				// закрыть ФК-Тмн
	goto L101;
L10:Klapan(1,&FvnKam);				// включить ФВН-Кам
	goto L101;
L11:Klapan(1,&KlKam);				// открыть ФК-Кам
	if(sh_)goto L101;
	shr[10] = 7;
    sh_ = 0;
	goto L101;
L12:if(!(zin[3] & 0x20))// проверка уровня вакуума в шлюзе
	{
		shr[2] = 1;					// активизация режима 2
		sh[2] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[10] = 13;
	sh_ = 0;
	goto L101;
L13:if(shr[2]) goto L101;			// нет форвакуума в шлюзе
	sh_ = 0;
	goto L101;
L14:Klapan(0,&KlShl);				// закрыть ФК-Шл
	goto L101;
L15:if(zin[2]&0x1C00)				// есть вращение ТМН
	{
		sh_ = 0;
		goto L101;
	}
	shr[10] = 17;					// переход на шаг 18
    sh_ = 0;
	goto L101;
L16:Klapan(0,&KlKam);				// закрыть ФК-Кам
	goto L101;
L17:Klapan(1,&KlTmn);				// открыть ФК-ТМН
	goto L101;
L18:Klapan(1,&ShZatvor);			// открыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_11()							// Режим "Закрыть ЩЗ"
{
	sh_ = sh[11];

	if (shr[11] == 1) goto L1;
	if (shr[11] == 2) goto L2;
		else goto L100;				// выход

	// конечный диспетчер режима
L101:sh[11] = sh_;
	if (sh[11] != 0) goto L100;		// SH != 0
	++shr[11];						// след. шаг
	if (shr[11] > 2) goto L0;		// число шагов режима
	sh[11] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 26;						// норма: "Щелевой затвор закрылся"
	shr[11] = 0;
	goto L100;

L1:	shr[10] = 0;					// сброс активизации режима 10
	sh[10] = 0;
	diagn[15] &= (~0xF0);			// сброс диагностик ФВН
	diagn[10] &= (~0xFF);			// ФК-КАМ, ФК-Шл
	diagn[9] &= (~0xFF);			// щелевого затвора, ФК-ТМН
	diagn[6] &= (~0xFF);			// Кл-Д4, Кл-Д5
	sh_ = 0;
	goto L101;
L2:	Klapan(0,&ShZatvor);			// закрыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_12() // режим 12 "МАН в исходное"
{
	sh_ = sh[12];
	if((shr[12] < 1) || (shr[12] > 2)) goto L100; // на выход

L00:if(shr[12] == 1) goto L1;
	if(shr[12] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[12] = sh_;
	if (sh[12] != 0) goto L100;		// SH != 0
	shr[12]++;						// след.шаг
	if (shr[12] > 2) goto L0;		// число шагов режима
	sh[12] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 68;						// норма: "Мех. перем. в исходном"
	shr[12] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[13] = 0;							// сброс активации режима 13
	shr[13] = 0;
	diagn[5] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PER(par[0][16],0,0,1,60);				// перемещение манип. в исх.
	goto L101;
}
//---------------------------------------------------------------------------
void R_13() // режим 13 "МАН вперёд/назад"
{
	sh_ = sh[13];
	if ((shr[13] < 1) || (shr[13] > 2)) goto L100; // на выход

L00:if(shr[13] == 1) goto L1;
	if(shr[13] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[13] = sh_;
	if(sh[13] != 0) goto L100;		// SH != 0
	shr[13]++;						// след.шаг
	if(shr[13] > 2) goto L0;		// число шагов режима
	sh[13] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 69;					// норма: "Механизм. перемещения путь прошел"
	shr[13] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[12] = 0;							// сброс активации режима 12
	shr[12] = 0;
	diagn[5] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PER(par[0][16],OTN,par[0][15],0,60);// перемещение манип. вперед/назад
	goto L101;
}
//---------------------------------------------------------------------------
void VIDK_PER(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x01) return;		// нет связи с контроллером
	SetOut(0,1,0x02);				// снять Стоп механизмов
	PR_PER = 1;
	CT_PER = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x100))				// нет готовности привода
	{
		if(CT_PER >= 5)
			diagn[5] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[5] &= (~0x01);			// сброс диагностики
	OTVET_PER = 0;
	V_PER = a;
	TYPE_PER = b;
	PUT_PER = c;
	HOME_PER = d;
	KOM_PER = 1;
	CT_PER = 0;
    TEK_OTN_PER = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x01 || !OTVET_PER)	// есть диагностика нет связи или нет ответа
	{
		if(CT_PER >= 5)
			diagn[5] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[5] &= (~0x04);			// сброс диагностики
	KOM_PER = 0;
	if(!HOME_PER)					// не движение в HOME
	{
		SetOut(1,1,0x01);           // выдать движение
		CT_PER = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,1,0x04);          		// выдать движение в Home
	CT_PER = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x200)||(TEK_ABS_PER))				// механизм не пришел в HOME
	{
		if(CT_PER >= e)
			diagn[5] |= 0x08;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;		
	}
	diagn[5] &= (~0x08);			// сброс диагностики
	SetOut(0,1,0x04);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[4]&0x100))				// нет готовности привода
	{
		if(CT_PER >= 5)
		diagn[5] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[5] &= (~0x01);			// сброс диагностики
	PR_PER = 0;
	norma = 43;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[4]&0x100)				// есть готовность привода
	{
		if(CT_PER >= 5)
			diagn[5] |= 0x02;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[5] &= (~0x02);			// сброс диагностики
	SetOut(0,1,0x01);               // сбросить начало движение
	CT_PER = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[4]&0x100)||((TYPE_PER==ABS)&&(PUT_PER!=TEK_ABS_PER))||((TYPE_PER==OTN)&&(PUT_PER!=TEK_OTN_PER)))				// есть готовность привода
	{
		if(CT_PER >= e)
			diagn[5] |= 0x10;		// отказ: "Нет завершения движ. перемещ."
		return;		
	}
	diagn[5] &= (~0x10);			// сброс диагностики
	PR_PER = 0;
	norma = 44;						//"Манипулятор перемещения путь прошел"
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
void R_14() // режим 14 "МПВ в исходное"
{
	sh_ = sh[14];
	if((shr[14] < 1) || (shr[14] > 2)) goto L100; // на выход

L00:if(shr[14] == 1) goto L1;
	if(shr[14] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[14] = sh_;
	if (sh[14] != 0) goto L100;		// SH != 0
	shr[14]++;						// след.шаг
	if (shr[14] > 2) goto L0;		// число шагов режима
	sh[14] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 66;					// норма: "Мех. поворота в исходном"
	shr[14] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[8] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POV(par[0][16],0,0,1,60);				// поворот манип. в исх.
	goto L101;
}
//---------------------------------------------------------------------------
void R_15() // режим 15 "МПВ вправо/влево"
{
	sh_ = sh[15];
	if ((shr[15] < 1) || (shr[15] > 2)) goto L100; // на выход

L00:if(shr[15] == 1) goto L1;
	if(shr[15] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[15] = sh_;
	if(sh[15] != 0) goto L100;		// SH != 0
	shr[15]++;						// след.шаг
	if(shr[15] > 2) goto L0;		// число шагов режима
	sh[15] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 67;						// норма: "Механизм. поворота путь прошел"
	shr[15] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[14] = 0;							// сброс активации режима 14
	shr[14] = 0;
	diagn[8] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POV(par[0][16],OTN,par[0][17],0,60);// поворот манип. вперед/назад
	goto L101;
}
//---------------------------------------------------------------------------
void VIDK_POV(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. поворота
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x02) return;		// нет связи с контроллером
	SetOut(0,1,0x02);				// снять Стоп механизмов
	PR_POV = 1;
	CT_POV = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x800))				// нет готовности привода
	{
		if(CT_POV >= 5)
			diagn[26] |= 0x01;		// отказ: "Нет готовности привода повор."
		return;
	}
	diagn[26] &= (~0x01);			// сброс диагностики
	OTVET_POV = 0;
	V_POV = a;
	TYPE_POV = b;
	PUT_POV = c;
	HOME_POV = d;
	KOM_POV = 1;
	CT_POV = 0;
    TEK_OTN_POV = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x02 || !OTVET_POV)	// есть диагностика нет связи или нет ответа
	{
		if(CT_POV >= 5)
			diagn[26] |= 0x04;		// отказ: "Нет ответа на команду повор."
		return;
	}
	diagn[26] &= (~0x04);			// сброс диагностики
	KOM_POV = 0;
	if(!HOME_POV)					// не движение в HOME
	{
		SetOut(1,2,0x1000);           // выдать движение
		CT_POV = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,2,0x2000);              // выдать движение в Home
	CT_POV = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x1000)||(TEK_ABS_POV))			// механизм не пришел в HOME
	{
		if(CT_POV >= e)
			diagn[26] |= 0x08;		// отказ: "Мех. повор. не пришел в пол. HOME"
		return;		
	}
	diagn[26] &= (~0x08);			// сброс диагностики	
	SetOut(0,2,0x2000);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[4]&0x800))				// нет готовности привода
	{
		if(CT_POV >= 5)
			diagn[26] |= 0x01;		// отказ: "Нет готовности привода повор."
		return;
	}
	diagn[26] &= (~0x01);			// сброс диагностики
	PR_POV = 0;
	norma = 66;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[4]&0x800)				// есть готовность привода
	{
		if(CT_POV >= 5)
			diagn[26] |= 0x02;			// отказ: "Нет ответа на START движ. повор."
		return;
	}
	diagn[26] &= (~0x02);				// сброс диагностики
	SetOut(0,2,0x1000);               	// сбросить начало движение
	CT_POV = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[4]&0x800)||((TYPE_POV==ABS)&&(PUT_POV!=TEK_ABS_POV))||((TYPE_POV==OTN)&&(PUT_POV!=TEK_OTN_POV)))				// есть готовность привода
	{
		if(CT_POV >= e)
			diagn[26] |= 0x10;		// отказ: "Нет завершения движ. повор."
		return;		
	}
	diagn[26] &= (~0x10);			// сброс диагностики
	PR_POV = 0;
	norma = 67;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
void R_17 ()	             		// режим "Поддержание давления (заслонка)"
{
	sh_ = sh[17];
	if (shr[17] == 1) goto L1;
	if (shr[17] == 2) goto L2;
	if (shr[17] == 3) goto L3;
	else goto L100;      	 		// на выход

L101:sh[17] = sh_;	   			    // |                           |
	if ( sh[17] != 0) goto L100;    // |    sh_!= 0                |
	shr[17]++;		        		// |    след.шаг 	           |
	sh[17] = 1;		         		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: shr[18] = 0;                    // сброс активации режима 18
	sh[18] = 0;                     // 'Открыть заслонку'
	shr[19] = 0;                    // сброс активации режима 19
	sh[19] = 0;                     // 'Закрыть заслонку'
	VRDZASL = 0;               		// сброс признака выхода на режим заслонки
	diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xF0);
    SetOut(0,0,0x180);				// сброс выходов "Открыть ДЗ" и "Закрыть ДЗ"
	sh_ = 0;
	goto L101;
L2:	VIBPAR_DZASL();		     		// выбор параметра заслонки
	VIDK_DZASL(2,3,0x40,0); 	 		// выдать задание по давлению
	if(sh_!=0) goto L101;           // ожидание окончания выдачи задания
	ZPAR_DZASL = PAR_DZASL;	            // запоминание параметра задания давления
	CT_17 = 0;	           	 		// сброс
	CT17K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L3: VIBPAR_DZASL();		     		// выбор параметра заслонки
	if(PAR_DZASL == ZPAR_DZASL)			// параметр не изменился
	{
		sh_ = 0;					// обход задания
		goto L3_8;
	}
	VIDK_DZASL(2,3,0x40,0); 	 		// выдать задание по давлению
	if(sh_!=0) goto L101;           // ожидание окончания выдачи задания
	ZPAR_DZASL = PAR_DZASL;				// зап.парам.задания давления
L3_8:PDDZASL ();                   	// Подготовка аналоговых данных
	RLIMDZASL();	        			// расчет LIM для заслонки
	if (DELDZASL <= LIM1DZASL) goto L3_4;// модуль Ет <= LIM1
	if (VRDZASL == 0) goto L3_6;		// нет выхода на режим
	diagn[3] |= 0x04;		        // отказ: "нет регулирования заслонки"
	goto L3_5;	            		// на сброс диагн."больш.ош."
L3_4:diagn[3] &= (~0x04);	   		// сброс д."нет регулирования заслонки"
	if (DELDZASL <= LIM2DZASL) goto L3_5;// LIM2 (зона регулирования)
	if (VRDZASL == 0) goto L3_6;		// нет выхода на режим
	diagn[3] |= 0x02;		       	// отказ: "б.ош.регулирования заслонки"
	goto L3_7;
L3_5:diagn[3] &= (~0x02);	   		// сброс д."б.ош.регулирования заслонки"
	goto L3_7;
L3_6:CT17K1 = 0;
L3_7:if (CT_17 <= T_VRDZASL) goto L3_2;// Ттек <= Тзад
	if (VRDZASL != 0) goto L3_1;      // есть выход на режим
	diagn[3] |= 0x01;		        // отказ: "нет выхода на режим заслонки"
	goto L3_2;
L3_1:diagn[3] &= (~0x01);	       	// сброс д."нет выхода на режим заслонки"
L3_2:if (CT17K1 <= T_KDZASL) goto L3_3;// Т.K.тек <= Т.K.зад
	VRDZASL = 1;	               		// выход на режим
L3_3:shr[17] = 2;                   // Возврат на L2
	goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_DZASL ()					// подпрограмма "Выбор параметра для заслонки"
{
    PAR_DZASL = par[N_ST][7];
}
//---------------------------------------------------------------------------
void RLIMDZASL()						// подпрограмма "Расчет LIM для заслонки"
{
	if (PAR_DZASL == 0)	        	//если задание = 0, расшир.лимитов
	{
		LIM1DZASL = 10000;	    	// MAX доп.знач.по входу ап.ср.
		LIM2DZASL = LIM1DZASL / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2DZASL = PAR_DZASL / DOPDZASL;	// LIM2 (малый)
		LIM1DZASL = PAR_DZASL / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDDZASL ()						// подготовка аналоговых данных заслонки
{
	X_TDZASL = TEK_DAVL_DZASL;			// тек.значение
	E_TDZASL = PAR_DZASL - X_TDZASL;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TDZASL >= 0) DELDZASL = E_TDZASL;
	else  DELDZASL = E_TDZASL * (-1);	// вычисление модуля ошибки
}
//------------------------------------------------//
//--Подпрограмма выдачи команд на заслонку (MKS)--//
//------------------------------------------------//
void VIDK_DZASL ( int a, int b, int c, int d )
	// a - код команды к заслонке
	// b - номер байта массива диагностики DIAGM
	// c - номер бита в байте DIAGM
	// d - задание по положению (0...10000)
{
	switch ( sh_ )
	{
		case 1:
		{
			// если нет связи с заслонкой
			if ( diagnS[0] & 0x40 ) return;
			// обнуление признака положительного ответа
			PR_DZASL = 0;
			// обнуление кода ответа
			OTVET_DZASL = 0;
			// выдача заданной команды
			KOM_DZASL = a;
			// есть команда контроль давления
			if ( KOM_DZASL == 2 )
			{
				// выбрали параметр заслонки
				VIBPAR_DZASL();
				// установили параметр
				DATA_DZASL = PAR_DZASL;
			}
			// есть команда контроль положения
			else if ( KOM_DZASL == 1 )
			{
				// определили параметр из задания (по положению)
				DATA_DZASL = d;
			};
			// сбросили счетчик времени заслонки
			CT_DZASL = 0;
			// перешли на следующий шаг
			sh_ = 2;
		}; break;
		case 2:
		{
			// если нет связи с заслонкой или ответ не положительный
			if ( ( diagnS[0] & 0x40 ) || ( PR_DZASL == 0 ) )
				// сброс сч.времени заслонки
				CT_DZASL = 0;
			// есть связь с заслонкой и ответ положительный
			// и ответ заслонки НЕ соответствует искомому
			else if ( OTVET_DZASL != a )
			{
				// сравнение с контрольным временем и диагностика
				if ( CT_DZASL > 5 ) diagn[b] |= c;
			}
			// если все штатно
			else
			{
				// сброс диагностики
				diagn[b] &= ~c;
				// если команда НЕ опрос состояния заслонки
				if ( KOM_DZASL != 7 )
				{
					// запись кода команды - общий опрос
					KOM_DZASL = 7;
					// сброс признака положительного ответа
					PR_DZASL = 0;
				}
				// выход из подпрограммы
				sh_ = 0;
			}
		}; break;
		default: ;break;
	};
}
// Команды на заслонку
//             КК   диагн
// VIDK_DZASL ( 1, 3, 0x20,..)  - Задание положения (код положения)
// VIDK_DZASL ( 2, 3, 0x40, 0)  - Задание давление
// VIDK_DZASL ( 3, 3, 0x08, 0)  - Открыть заслонку
// VIDK_DZASL ( 4, 3, 0x10, 0)  - Закрыть заслонку
// VIDK_DZASL ( 7, 3, 0x80, 0)  - Опрос состояния заслонки
//---------------------------------------------------------------------------
void R_18() // режим 18 "Открыть заслонку"
{
	sh_ = sh[18];
	if ( shr[18] < 1 || shr[18] > 2 ) goto L100; // на выход

L00:if ( shr[18] == 1 ) goto L1;
	if ( shr[18] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[18] = sh_;
	if ( sh[18] != 0) goto L100;    // SH != 0
	shr[18]++;                      // след.шаг сч.шр1
	if ( shr[18] > 2) goto L0;      // число шагов режима
	sh[18] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 22;		           	    // норма: "Заслонка открылась"
	shr[18] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL = 7;                   // перевод в опрос состояния заслонки
    shr[17]  = 0;                   // сброс активации режима 17
	sh[17] = 0;                     // "Дросселирование"
	shr[19]  = 0;                   // сброс активации режима 19
	sh[19] = 0;                     // "Закрыть заслонку"
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xF0);
	sh_ = 0;
	goto L101;
L2: Klapan(1,&DZasl);				// открыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_19() // режим 19 "Закрыть заслонку"
{
	sh_ = sh[19];
	if ( shr[19] < 1 || shr[19] > 2 ) goto L100; // на выход

L00:if ( shr[19] == 1 ) goto L1; 
	if ( shr[19] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[19] = sh_;
	if ( sh[19] != 0 ) goto L100;   // SH != 0
	shr[19]++;                      // след.шаг сч.шр1
	if ( shr[19] > 2) goto L0;    	// число шагов режима
	sh[19] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 23;		           	    // норма: "Заслонка закрылась"
	shr[19] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL = 7;                   // перевод в опрос состояния заслонки
    shr[17]  = 0;                   // сброс активации режима 17
	sh[17] = 0;                     // "Дросселирование"
	shr[18] = 0;                    // сброс активации режима 18
	sh[18] = 0;                     // "Открыть заслонку"
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xF0);
	sh_ = 0;
	goto L101;
L2: Klapan(0,&DZasl);				// закрыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_20()							// РЕЖИМ 20 "Включить РРГ1"
{
	// выставление параметра РРГ
	ObjRRG[0]->parRRG = par[N_ST][0];

	// запуск режима
	RRGOn(ObjRRG[0],1);				// включение РРГ1
}
//---------------------------------------------------------------------------
void R_21()							// РЕЖИМ 21 "Включить РРГ2"
{
	// выставление параметра РРГ
	ObjRRG[1]->parRRG = par[N_ST][1];

	// запуск режима
	RRGOn(ObjRRG[1],1);				// включение РРГ2
}
//---------------------------------------------------------------------------
void R_22()							// РЕЖИМ 22 "Включить РРГ3"
{
	// выставление параметра РРГ
	ObjRRG[2]->parRRG = par[N_ST][2];

	// запуск режима
	RRGOn(ObjRRG[2],1);				// включение РРГ3
}
//---------------------------------------------------------------------------
void R_23()							// РЕЖИМ 23 "Включить РРГ4"
{
	// выставление параметра РРГ
	ObjRRG[3]->parRRG = par[N_ST][3];
	
	// запуск режима
	RRGOn(ObjRRG[3],1);				// включение РРГ4
}
//---------------------------------------------------------------------------
void R_24()							// РЕЖИМ 24 "Включить РРГ5"
{
	// выставление параметра РРГ
	ObjRRG[4]->parRRG = par[N_ST][4];

	// запуск режима
	RRGOn(ObjRRG[4],1);				// включение РРГ5
}
//---------------------------------------------------------------------------
void R_25()							// РЕЖИМ 25 "Включить РРГ6"
{
	// выставление параметра РРГ
	ObjRRG[5]->parRRG = par[N_ST][5];
	
	// запуск режима
	RRGOn(ObjRRG[5],1);				// включение РРГ6
}
//---------------------------------------------------------------------------
void R_26()							// РЕЖИМ 26 "Включить РРГ7"
{
	// выставление параметра РРГ
	if(shr[3]||shr[4]||shr[5])
	{
		ObjRRG[6]->parRRG = nasmod[2];
	}
	else
		ObjRRG[6]->parRRG = par[0][6];
	
	// запуск режима
	RRGOn(ObjRRG[6],PR_HEL);		          // включение РРГ7
}
//---------------------------------------------------------------------------
void R_27 ()	                    // режим "Вкл. ВЧГ стола (по мощн.)"
{
	sh_ = sh[27];
	if (shr[27] == 1) goto L1;
	if (shr[27] == 2) goto L2;
	if (shr[27] == 3) goto L3;
	if (shr[27] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[27] = sh_;					//  |                           |
	if(sh[27]) goto L100;			//	|    sh != 0                |
	shr[27]++;						//	|    след.шаг 	            |
	sh[27] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: VRGIS = 0;                      // сброс признака выхода на режим ВЧГ
	diagn[4] &= (~0xFF);			// сброс диагностики режима ВЧГ
    A_OUT(8,8192);                  // обнуление уставки
    shr[28] = 0;
    sh[28] = 0;
    VRR_GIS();						// выставить разр. работы ВЧГ
    goto L101;
L2: VIBPAR_GIS();                   // выбор параметров ВЧГ
    A_OUT(8,2*PAR_GIS+8192);        // выдача уставки на ВЧГ
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,1,0x200);				// включение выходной мощности ВЧГ
	CT_27 = 0;                      // очистка счетчиков
    CT27K1 = 0;                     // режима
    sh_=0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIS();                   // выбор параметров ВЧГ
    A_OUT(8,2*PAR_GIS+8192);        // выдача уставки на ВЧГ
	PDGIS ();                   	// Подготовка аналоговых данных
	RLIMGIS();	        			// новый расчет LIM для ВЧГ
	if (DELGIS <= LIM1GIS) goto L4_4;// модуль Ет <= LIM1
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[4] |= 0x04;		        // отказ: "нет регулирования ВЧГ"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[4] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ"
	if (DELGIS <= LIM2GIS) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[4] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ"
	goto L4_7;
L4_5:diagn[4] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ"
	goto L4_7;
L4_6:CT27K1 = 0;
L4_7:if (CT_27 <= T_VRGIS) goto L4_2;// Ттек <= Тзад
	if (VRGIS != 0) goto L4_1;      // есть выход на режим
	diagn[4] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ"
	goto L4_2;
L4_1:diagn[4] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ"
L4_2:if (CT27K1 <= T_KGIS) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIS = 1;	               		// выход на режим
    norma = 50;                     // норма: "ВЧГ п/д вышел на режим"
L4_3:shr[27]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
void VIBPAR_GIS ()				    // подпрограмма "Выбор параметра для ВЧГ по мощн"
{                                   // выбор из таблицы параметров
		PAR_GIS = par[N_ST][11];
}
//---------------------------------------------------------------------------
void RLIMGIS ()						// подпрограмма "Расчет LIM для ВЧГ"
{
    if (VRGIS == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIS = 15;                // допуск 66,6%
        LIM2GIS = (PAR_GIS * 10) / DOPGIS; // LIM2 (малый)
        LIM1GIS = (PAR_GIS*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIS <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIS = 30;           // допуск 33%
	    else  if ( PAR_GIS <= 276 ) // если зад. мощность <= 40Вт
		    DOPGIS = 40;            // допуск 25%
        else DOPGIS = 50;           // иначе допуск 20%

	    if (PAR_GIS == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIS = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIS = LIM1GIS / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIS = PAR_GIS * 10 / DOPGIS; // LIM2 (малый)
	        LIM1GIS = PAR_GIS / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIS ()						// подготовка аналоговых данных ВЧГ
{
	X_TGIS = aik[14];	            // тек.значение падающей мощности
	E_TGIS = PAR_GIS - X_TGIS;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIS >= 0) DELGIS = E_TGIS;
	else  DELGIS = E_TGIS * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void SBROSR_27 ()                    // "Откл. ВЧГ стола"
{
	shr[27] = 0;        // сброс активизации
	sh[27] = 0;         // режима 27 "Вкл. ВЧГ стола"
    shr[28] = 0;        // сброс активизации
	sh[28] = 0;         // режима 28 "Вкл. ВЧГ стола (смещ)"
	VRGIS = 0;          // сброс выхода ВЧГ на режим
	A_OUT(8,8192);      // сброс уставки вых. мощности ВЧГ
	SetOut(0,1,0x200);	// откл. вых. мощн.
	SetOut(0,3,0x04);	// откл. работу по мощн. и смещ.
	diagn[4]&=(~0xFF);	// сброс диагностик режимов "ВЧГ"
	norma = 52;			// норма: "Сброс режима ВЧГ п/д завершен"
}
//---------------------------------------------------------------------------
void R_28 ()	                    // режим "Вкл. ВЧГ стола(по смещ.)"
{
	sh_ = sh[28];
	if (shr[28] == 1) goto L1;
	if (shr[28] == 2) goto L2;
	if (shr[28] == 3) goto L3;
	if (shr[28] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[28] = sh_;					//  |                           |
	if(sh[28]) goto L100;			//	|    sh != 0                |
	shr[28]++;						//	|    след.шаг 	            |
	sh[28] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: VRGIS = 0;					// сброс признака выхода на режим ВЧГ стола
    diagn[4] &= (~0xFF);           // сброс диагностики режима ВЧГ стола
    A_OUT(8,8192);                  // обнуление уставки
    shr[27] = 0;
    sh[27] = 0;
    VRR_GIS();                       // выставить разр. работы ВЧГ стола
    goto L101;
L2: VIBPAR_GIS_SM();                   // выбор параметров ВЧГ стола
    A_OUT(8,2*PAR_GIS_SM+8192);        // выдача уставки на ВЧГ стола
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,1,0x200);				// включение выходной мощности ВЧГ
    SetOut(1,3,0x04);				// включение работы по смещению
    CT_28 = 0;                      // очистка счетчиков
    CT28K1 = 0;                     // режима
    sh_= 0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIS_SM();                   // выбор параметров ВЧГ стола
    A_OUT(8,2*PAR_GIS_SM+8192);        // выдача уставки на ВЧГ
	PDGIS_SM ();                   	// Подготовка аналоговых данных
	RLIMGIS_SM();	        			// новый расчет LIM для ВЧГ стола
	if (DELGIS_SM <= LIM1GIS_SM) goto L4_4;// модуль Ет <= LIM1
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[4] |= 0x04;		        // отказ: "нет регулирования ВЧГ стола"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[4] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ стола"
	if (DELGIS_SM <= LIM2GIS_SM) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[4] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ стола"
	goto L4_7;
L4_5:diagn[4] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ стола"
	goto L4_7;
L4_6:CT28K1 = 0;
L4_7:if (CT_28 <= T_VRGIS) goto L4_2;// Ттек <= Тзад
	if (VRGIS != 0) goto L4_1;      // есть выход на режим
	diagn[4] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ стола"
	goto L4_2;
L4_1:diagn[4] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ стола"
L4_2:if (CT28K1 <= T_KGIS) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIS = 1;	               		// выход на режим
    norma = 50;                     // норма: "ВЧГ п/д вышел на режим"
L4_3:shr[28]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_GIS_SM ()				    // подпрограмма "Выбор параметра для ВЧГ стола по смещ"
{
	PAR_GIS_SM = par[N_ST][12];
}
//---------------------------------------------------------------------------
void RLIMGIS_SM ()						// подпрограмма "Расчет LIM для ВЧГ стола"
{
    if (VRGIS == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIS_SM = 15;                // допуск 66,6%
        LIM2GIS_SM = (PAR_GIS_SM * 10) / DOPGIS_SM; // LIM2 (малый)
        LIM1GIS_SM = (PAR_GIS_SM*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIS_SM <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIS_SM = 28;           // допуск 33%
	    else  if ( PAR_GIS_SM <= 276 ) // если зад. мощность <= 40Вт
		    DOPGIS_SM = 40;            // допуск 25%
        else DOPGIS_SM = 50;           // иначе допуск 20%

	    if (PAR_GIS_SM == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIS_SM = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIS_SM = LIM1GIS_SM / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIS_SM = PAR_GIS_SM * 10 / DOPGIS_SM; // LIM2 (малый)
	        LIM1GIS_SM = PAR_GIS_SM / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIS_SM ()						// подготовка аналоговых данных ВЧГ стола
{
	X_TGIS_SM = aik[18];	            // тек.значение падающей мощности
	E_TGIS_SM = PAR_GIS_SM - X_TGIS_SM;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIS_SM >= 0) DELGIS_SM = E_TGIS_SM;
	else  DELGIS_SM = E_TGIS_SM * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void R_29 ()	                    // режим "Вкл. ВЧГ реактора"
{
	sh_ = sh[29];
	if (shr[29] == 1) goto L1;
	if (shr[29] == 2) goto L2;
	if (shr[29] == 3) goto L3;
	if (shr[29] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[29] = sh_;					//  |                           |
	if(sh[29]) goto L100;			//	|    sh != 0                |
	shr[29]++;						//	|    след.шаг 	            |
	sh[29] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: VRGIR = 0;                      // сброс признака выхода на режим ВЧГ реактора
	diagn[7] &= (~0xBF);            // сброс диагностики режима ВЧГ реактора
    A_OUT(7,8192);                  // обнуление уставки
    VRR_GIR();                      // выставить разр. работы ВЧГ реактора
    goto L101;
L2: VIBPAR_GIR();                   // выбор параметров ВЧГ реактора
    A_OUT(7,2*PAR_GIR+8192);        // выдача уставки на ВЧГ реактора
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,1,0x100);				// включение выходной мощности ВЧГ реактора
    CT_29 = 0;                      // очистка счетчиков
    CT29K1 = 0;                     // режима
    sh_ = 0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIR();                   // выбор параметров ВЧГ реактора
    A_OUT(7,2*PAR_GIR+8192);        // выдача уставки на ВЧГ
	PDGIR ();                   	// Подготовка аналоговых данных
	RLIMGIR();	        			// новый расчет LIM для ВЧГ реактора
	if (DELGIR <= LIM1GIR) goto L4_4;// модуль Ет <= LIM1
	if (VRGIR == 0) goto L4_6;		// нет выхода на режим
	diagn[7] |= 0x04;		        // отказ: "нет регулирования ВЧГ реактора"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[7] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ реактора"
	if (DELGIR <= LIM2GIR) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIR == 0) goto L4_6;		// нет выхода на режим
	diagn[7] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ реактора"
	goto L4_7;
L4_5:diagn[7] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ реактора"
	goto L4_7;
L4_6:CT29K1 = 0;
L4_7:if (CT_29 <= T_VRGIR) goto L4_2;// Ттек <= Тзад
	if (VRGIR != 0) goto L4_1;      // есть выход на режим
	diagn[7] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ реактора"
	goto L4_2;
L4_1:diagn[7] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ стола"
L4_2:if (CT29K1 <= T_KGIR) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIR = 1;	               		// выход на режим
    norma = 51;                     // норма: "ВЧГ ИП вышел на режим"
L4_3:shr[29]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_GIR ()				    // подпрограмма "Выбор параметра для ВЧГ реактора"
{
	PAR_GIR = par[N_ST][8];
}
//---------------------------------------------------------------------------
void RLIMGIR ()						// подпрограмма "Расчет LIM для ВЧГ реактора"
{
    if (VRGIR == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIR = 15;                // допуск 66,6%
        LIM2GIR = (PAR_GIR * 10) / DOPGIR; // LIM2 (малый)
        LIM1GIR = (PAR_GIR*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIR <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIR = 30;           // допуск 33%
	    else  if ( PAR_GIR <= 276 ) // если зад. мощность <= 40Вт
		    DOPGIR = 40;            // допуск 25%
        else DOPGIR = 50;           // иначе допуск 20%

	    if (PAR_GIR == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIR = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIR = LIM1GIR / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIR = PAR_GIR * 10 / DOPGIR; // LIM2 (малый)
	        LIM1GIR = PAR_GIR / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIR ()						// подготовка аналоговых данных ВЧГ реактора
{
	X_TGIR = aik[12];	            // тек.значение падающей мощности
	E_TGIR = PAR_GIR - X_TGIR;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIR >= 0) DELGIR = E_TGIR;
	else  DELGIR = E_TGIR * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void SBROSR_29()					// "Откл. ВЧГ реактора"
{
	shr[29] = 0;        // сброс активизации
	sh[29] = 0;         // режима 29 "Вкл. ВЧГ реактора"
	VRGIR = 0;          // сброс выхода ВЧГ на режим
	A_OUT(7,8192);      // сброс уставки вых. мощности ВЧГ
	SetOut(0,1,0x100);	// откл. вых. мощн.
	diagn[7]&=(~0xFF);	// сброс диагностик режимов "ВЧГ"
	norma = 59;			// норма: "Сброс режима ВЧГ ИП завершен"
}
//---------------------------------------------------------------------------
//--Режим "Автоподстройка (согласование) генератора ВЧГ реактора--// 
//---------------------------------------------------------------------------
void R_30 ()					// режим "Автоподстройка
{								//(согласование) генератора ВЧГ реактора"
	sh_ = sh[30];
	if ( shr[30] == 1 ) goto L1;
	if ( shr[30] == 2 ) goto L2;
	if ( shr[30] == 3 ) goto L3;
	if ( shr[30] == 4 ) goto L4;
	if ( shr[30] == 5 ) goto L5;
	if ( shr[30] == 6 ) goto L6;
	if ( shr[30] == 7 ) goto L7;
	if ( shr[30] == 8 ) goto L8;
	if ( shr[30] == 9 ) goto L9;
	else goto L100;             // на выход

							 	// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА  |
L101:sh[30] = sh_;				// |                            |
	if (sh[30] != 0) goto L100;	// |    SH != 0                 |
	shr[30]++;		         	// |    след.шаг сч.шр30        |
	sh[30] = 1;		         	// |                            |
L100:return;         		 	// |    возврат в "кольцо"      |

L1: NAPRS_GIR = 0;		 		// сброс направления - прямое (>)
    A_OUT(9,nasmod[4]);      	// Задание скорости УС ИП
	sh_ = 0;
	goto L101;
	// проверка отраженной мощности на 0
L2: if (aik[12] == 0) goto L2_1;	    // переход на сброс двигателей
	RKOEF_GIR();			       		// расчет тек.коэф-та согласования
	//SK_SU_GIR();						// расчет уставки скорости
	N_PRED_GIR = N_TEK_GIR;				// запоминание коэф-та согласования
	if(N_TEK_GIR >= nasmod[5]) goto L2_1;	// есть согласование
	diagn[7] |= 0x08;		            // отказ: "Нет согласования ВЧГ реактора"
	if (NAPRS_GIR == 0) goto L2_2;	    // направление - прямое
	goto L2_3;
L2_2:if(aik[16]>(par[N_ST][10]+DOP_DV_IP))   // переехал вперед
	{
		shr[30] = 4;                  	// переход на L4_1
		goto L4_1;
	}
	SetOut(0,1,0x0C00);			    	// прямое
	SetOut(1,1,0x0400); 	   		    // движение
	CT_30T = 0;		               	    // сброс сч.вр.режима
	shr[30] = 3;					    // переход на L4
	sh_ = 0;
	goto L101;							// через диспетчер
L2_3:if (aik[16]<(par[N_ST][10]-DOP_DV_IP))	// переехали назад
	{
		shr[30] = 6;                 	// переход на L6_1
		goto L6_1;
	}
	SetOut(0,1,0x0C00);			    	// обратное
	SetOut(1,1,0x0800); 	   		    // движение
	CT_30T = 0;	             	  	    // сброс сч.вр.режима
	sh_ = 0;
	shr[30] = 5;					    // переход на L6
	goto L101;							// через диспетчер
L2_1:SetOut(0,1,0x0C00);				// сброс движений
	CT_30T = 0;	                	    // сброс сч.вр.режима
	sh_ = 0;
	goto L101;
L3: if (CT_30T <= T_STOP) goto L101;	// задержка 0,5 сек на СТОП двигателей
	diagn[7] &= (~0x08);				// сброс диагн. "Нет согласования ВЧГ реактора"
	shr[30] = 1;					    // переход на L2
	sh_ = 0;
	goto L101;							// через диспетчер
L4: if (CT_30T <= T_DVIJ) goto L101;	// задержка 0,5 сек на движение
	if ( aik[16]<200 || aik[16]>3900 )	// есть ограничение движения УС реактора
	{
	    shr[30] = 7;				    // переход на L8
		sh_ = 0;
	    goto L101;                      // через диспетчер
	}
	if (aik[12] == 0)		          	// 0 отраженной мощности
	{
	    shr[30] = 1;				    // переход на L2_1 (сброс движений)
		goto L2_1;
	}
	RKOEF_GIR();			        	// расчет тек.коэф-та согласования
	//SK_SU_GIR();						// расчет уставки скорости
	if (N_TEK_GIR >= N_PRED_GIR)		// согласование лучше или такое же
	{
		NAPRS_GIR = 0;			   		// запоминание "лучшего" направления
	    shr[30] = 1;				    // переход на L2
	    sh_ = 0;
	    goto L101;}						// через диспетчер
	// согласование хуже
	N_PRED_GIR = N_TEK_GIR;				// запоминание коэф-та согласования
L4_1:SetOut(0,1,0x0C00);		    	// сброс движений
	CT_30T = 0;			                // сброс сч.вр.режима
	sh_ = 0;
	goto L101;
L5: if (CT_30T <= T_SM_NAPR) goto L101; // задержка 0,5сек на смену направл.
	shr[30] = 2;			            // переход на обратное движение
	goto L2_3;			                // (смена направления)
L6: if (CT_30T <= T_DVIJ) goto L101;  	// задержка 0,5сек на движение
	if ( aik[16]<200 || aik[16]>3900 )	// есть ограничение движения УС реактора
	{
	    shr[30] = 7;				    // переход на L8
		sh_ = 0;
	    goto L101;						// через диспетчер
	}
	if (aik[12] == 0)		          	// 0 отраженной мощности
	{
		shr[30] = 1;
		goto L2_1;	    				// переход на L2_1 (сброс движений)
	}
	RKOEF_GIR();			            // расчет тек.коэф-та согласования
	//SK_SU_GIR();						// расчет уставки скорости
	if (N_TEK_GIR >= N_PRED_GIR)		// согласование лучше или такое же
	{
		NAPRS_GIR = 1;		         	// запоминание "лучшего" направления
	    shr[30] = 1;				    // переход на L2
	    sh_ = 0;
	    goto L101;						// через диспетчер
	}
	// согласование хуже
	N_PRED_GIR = N_TEK_GIR;				// запоминание коэф-та согласования
L6_1:SetOut(0,1,0x0C00);	     		// сброс движений
	CT_30T = 0;			           	    // сброс сч.вр.режима
	sh_ = 0;
	goto L101;
L7: if (CT_30T <= T_SM_NAPR) goto L101; // задержка 0,5сек на смену направл.
	shr[30] = 2;			            // переход на прямое движение
	goto L2_2;			                // (смена направления)
L8: SetOut(0, 1, 0x0C00);		        // сброс движений
	diagn[15] |= 0x08;	            	// отказ: "Ограничение движения УС ВЧГ ИП(точно)"
	sh_ = 0;
	goto L101;
L9: goto L100;							// бесконечный режим
}
//---------------------------------------------------------------------------
void R_31 ()	// режим "Движение в точку согл. ВЧГ реактора(грубо)
{	
	sh_ = sh[31];
	if((shr[31] < 1)||(shr[31] > 3)) goto L100; // на выход

	if(shr[31] == 1) goto L1; 
	if(shr[31] == 2) goto L2;
	if(shr[31] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[31] = sh_;
	if(sh[31] != 0) goto L100;   // SH != 0
	shr[31]++;                      // след.шаг сч.шр1
	if(shr[31] > 3) goto L0;    	// число шагов режима
	sh[31] = 1;
L100:return;                  	    // возврат в "кольцо"

L0:	shr[31] = 0;
	goto L100;

L1:	prDvijGir_g = 1;		// выставить признак движения ИП реактора
	diagn[20]&=(~0x01);		// сброс диагностики
	CT_DVIJ_GIR_g = 0;		// сброс сч. времени движения УС конденсатора
	sh_ = 0;
	goto L101;
L2:	if(abs(aik[17]-par[N_ST][9])<DOP_SU) // проверка нахождения УС в точке
	{
		SetOut(0,1,0x3000);		// сброс направления
		A_OUT(10,8192);			// сброс скорости
		diagn[20]&=(~0x01);		// сброс диагностик
		prDvijGir_g = 0;		// снять признак движения ИП реактора
		norma = 39;				// норма: "Конд. ИП(грубо) пришел в заданную точку"
		prDvijGir_g = 0;		// снять признак движения ИП реактора
		shr[31] = 3;			// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	// УС не в точке + время вышло
	else if(CT_DVIJ_GIR_g > T_KDVIJ_SU)
	{
		SetOut(0,1,0x3000);		// сброс направления
		A_OUT(10,8192);         // сброс скорости
		diagn[20] |= 0x01;		// отказ "Конд. ИП(грубо) не пришел в зад. полож."
	}
	// положение УС меньше заданного
	else if(aik[17] < par[N_ST][9])
	{
		// если есть движение "назад"
		if(out[1]&0x2000)
		{
			SetOut(0,1,0x3000); // сброс направления
			A_OUT(10,8192);		// сброс скорости
			CT_SUT_g = 0;		// сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "назад"
		else
		{
			SetOut(1,1,0x1000); // движение "вперёд"
			A_OUT(10,nasmod[4]);// задать уставку скорости
		}
	}
	// положение УС больше заданного
	else
	{
		// если есть движение "вперед"
		if(out[1]&0x1000)
		{
			SetOut(0,1,0x3000); // сброс направления
			A_OUT(10,8192);     // сброс скорости
			CT_SUT_g = 0;         // сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "вперед"
		else
		{
			SetOut(1,1,0x2000); // движение "назад"
			A_OUT(10,nasmod[4]);// задать уставку скорости
		}
	}
	goto L101;
L3:	if(CT_SUT_g > T_KSUT)		// ожидание задержки на переключение
		shr[31] = 2;			// возврат на 2 шаг
    goto L101;
}
//---------------------------------------------------------------------------
void R_32 ()	// режим "Движение в точку согл. ВЧГ реактора(точно)
{
	sh_ = sh[32];
	if((shr[32] < 1)||(shr[32] > 3)) goto L100; // на выход

	if(shr[32] == 1) goto L1; 
	if(shr[32] == 2) goto L2;
	if(shr[32] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[32] = sh_;
	if(sh[32] != 0) goto L100;   // SH != 0
	shr[32]++;                      // след.шаг сч.шр1
	if(shr[32] > 3) goto L0;    	// число шагов режима
	sh[32] = 1;
L100:return;                  	    // возврат в "кольцо"

L0:	shr[32] = 0;
	goto L100;

L1:	prDvijGir_t = 1;		// выставить признак движения ИП реактора
	diagn[20]&=(~0x02);		// сброс диагностики
	CT_DVIJ_GIR_t = 0;		// сброс сч. времени движения УС конденсатора
	sh_ = 0;
	goto L101;
L2:	if(abs(aik[16]-par[N_ST][10])<DOP_SU) // проверка нахождения УС в точке
	{
		SetOut(0,1,0xC00);		// сброс направления
		A_OUT(9,8192);			// сброс скорости
		diagn[20]&=(~0x02);		// сброс диагностик
		prDvijGir_t = 0;		// снять признак движения ИП реактора
		norma = 40;				// норма: "Конд. ИП(точно) пришел в заданную точку"
		prDvijGir_t = 0;		// снять признак движения ИП реактора
		shr[32] = 3;			// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	// УС не в точке + время вышло
	else if(CT_DVIJ_GIR_t > T_KDVIJ_SU)
	{
		SetOut(0,1,0xC00);		// сброс направления
		A_OUT(9,8192);         // сброс скорости
		diagn[20] |= 0x02;		// отказ "Конд. ИП(точно) не пришел в зад. полож."
	}
	// положение УС меньше заданного
	else if(aik[16] < par[N_ST][10])
	{
		// если есть движение "назад"
		if(out[1]&0x800)
		{
			SetOut(0,1,0xC00); 	// сброс направления
			A_OUT(9,8192);		// сброс скорости
			CT_SUT_t = 0;		// сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "назад"
		else
		{
			SetOut(1,1,0x400); // движение "вперёд"
			A_OUT(9,nasmod[4]);// задать уставку скорости
		}
	}
	// положение УС больше заданного
	else
	{
		// если есть движение "вперед"
		if(out[1]&0x400)
		{
			SetOut(0,1,0xC00); // сброс направления
			A_OUT(9,8192);     // сброс скорости
			CT_SUT_t = 0;         // сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "вперед"
		else
		{
			SetOut(1,1,0x800); // движение "назад"
			A_OUT(9,nasmod[4]);// задать уставку скорости
		}
	}
	goto L101;
L3:	if(CT_SUT_t > T_KSUT)		// ожидание задержки на переключение
		shr[32] = 2;			// возврат на 2 шаг
    goto L101;
}
//---------------------------------------------------------------------------
void R_33 ()	             		// режим "Вкл. нагрева 1"
{
	sh_ = sh[33];
	if (shr[33] == 1) goto L1;
	if (shr[33] == 2) goto L2;
	if (shr[33] == 3) goto L3;
	if (shr[33] == 4) goto L4;
	if (shr[33] == 5) goto L5;
	if (shr[33] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[33] = sh_;	   				// |                           |
	if (sh[33] != 0) goto L100;	  	// |    SH != 0                |
	shr[33]++;		        		// |    след.шаг 	           |
	sh[33] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: SetOut(0,3,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,3,0x01);				// Вкл. пускатель нагревателя
    shr[34] = 0;					// режима 34
	sh[34] = 0;						// 'Откл. нагрева'
	VRTEMP1 = 0;               		// сброс признака выхода на режим БПН
	diagn[16] &= (~0xE7);      		// сброс диагностики режима БПН
	CT_33 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_33<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,3,0x01);			// вкл. силовое питание БПН
		CT_33 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[33] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_33<=T_VKL_BPN) goto L101;
		diagn[16]|=0x08;			// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,3,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[16]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP1();		     		// выбор параметра БПН
	VIDK_TEMP1(1,16,040,1);			// выдать задание по температуре
	if(sh_) goto L101;            	//
	ZPAR_TEMP1 = PAR_TEMP1;			// запоминание параметра задания температуры
	CT_33 = 0;	           			// сброс
	CT33K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP1();		     		// выбор параметра БПН
	if ( PAR_TEMP1 == ZPAR_TEMP1 )  // параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 	// обход задания
	VIDK_TEMP1(1,16,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;           //
	ZPAR_TEMP1 = PAR_TEMP1; 		// зап.парам.задания температуры
L6_8:	PDTEMP1 ();                 // Подготовка аналоговых данных
	RLIMTEMP1();	        		// расчет LIM для БПН
	if (DELTEMP1<=LIM1TEMP1)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[16] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[16] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP1<=LIM2TEMP1)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[16] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[16] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT33K1 = 0;
L6_7:if (CT_33<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP1 != 0) goto L6_1;     // есть выход на режим
	diagn[16] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[16] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT33K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP1 = 1;	               		// выход на режим
L6_3:shr[33]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_TEMP1 ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP1 = nasmod[11];            // 
}
//---------------------------------------------------------------------------
void RLIMTEMP1 ()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP1 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP1 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP1 = LIM1TEMP1 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP1 = PAR_TEMP1 / DOPTEMP1;	// LIM2 (малый)
		LIM1TEMP1 = PAR_TEMP1 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDTEMP1 ()						// подготовка аналоговых данных БПН
{
	X_TEMP1 = TEK_TEMP1;	           	// тек.значение температуры
	E_TEMP1 = PAR_TEMP1 - X_TEMP1;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP1 >= 0) DELTEMP1 = E_TEMP1;
	else  DELTEMP1 = E_TEMP1 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------//
//--Подпрограмма выдачи команд на ТЕРМОДАТ--//
//------------------------------------------//
void VIDK_TEMP1 ( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[0] & 0x20 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP1 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP1();			// выбор параметра температуры
						ZAD_TEMP1 = PAR_TEMP1;	// запись задания
					}
				}
				CT_TEMP1 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ((diagnS[0] & 0x20) || (!PR_TEMP))
			{
				if ( CT_TEMP1 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP1 ( 1 , 16 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP1 ( 1 , 16 , 0100 , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP1 ( 2 , 16 , 0200 , X )  - Опрос температуры
//---------------------------------------------------------------------------
void R_34() // режим 34 "Откл. нагрева 1"
{
	sh_ = sh[34];

L00:if (shr[34] == 1)  goto L1;        
	if (shr[34] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[34] = sh_;
	if (sh[34] != 0) goto L100;   // SH != 0
	shr[34]++;                    // след.шаг сч.шр1
	if (shr[34] > 2) goto L0;    	// число шагов режима
	sh[34] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[34] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[33]  = 0;                  // режима 33
	shr[33] = 0;                  // "Вкл. БПН"
	diagn[16] &= (~0xE7);		// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP1(1,16,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//---------------------------------------------------------------------------
void R_35 ()	             		// режим "Вкл. нагрева 2"
{
	sh_ = sh[35];
	if (shr[35] == 1) goto L1;
	if (shr[35] == 2) goto L2;
	if (shr[35] == 3) goto L3;
	if (shr[35] == 4) goto L4;
	if (shr[35] == 5) goto L5;
	if (shr[35] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[35] = sh_;	   					// |                           |
	if (sh[35] != 0) goto L100;	  	// |    SH != 0                |
	shr[35]++;		        		// |    след.шаг 	           |
	sh[35] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1:	SetOut(0,3,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,3,0x01);				// Вкл. пускатель нагревателя
	shr[36] = 0;                   	// режима 36
	sh[36] = 0;                     // 'Откл. нагрева'
	VRTEMP2 = 0;               		// сброс признака выхода на режим БПН
	diagn[17] &= (~0xE7);      		// сброс диагностики режима БПН
	CT_35 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_35<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,3,0x01);			// вкл. силовое питание БПН
		CT_35 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[35] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_35<=T_VKL_BPN) goto L101;
		diagn[16]|=0x08;				// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,3,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[16]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP2();		     		// выбор параметра БПН
	VIDK_TEMP2(1,17,040,1); 		// выдать задание по температуре
	if(sh_) goto L101;            //
	ZPAR_TEMP2 = PAR_TEMP2;			// запоминание параметра задания температуры
	CT_35 = 0;	           			// сброс
	CT35K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP2();		     		// выбор параметра БПН
	if(PAR_TEMP2 == ZPAR_TEMP2)   	// параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 		// обход задания
	VIDK_TEMP2(1,17,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;            //
	ZPAR_TEMP2 = PAR_TEMP2; 			// зап.парам.задания температуры
L6_8:PDTEMP2();                 	// Подготовка аналоговых данных
	RLIMTEMP2();	        			// расчет LIM для БПН
	if (DELTEMP2<=LIM1TEMP2)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP2 == 0) goto L6_6;		// нет выхода на режим
	diagn[17] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[17] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP2<=LIM2TEMP2)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP2 == 0) goto L6_6;		// нет выхода на режим
	diagn[17] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[17] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT35K1 = 0;
L6_7:if (CT_35<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP2 != 0) goto L6_1;     // есть выход на режим
	diagn[17] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[17] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT35K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP2 = 1;	               		// выход на режим
L6_3:shr[35]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_TEMP2()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP2 = nasmod[12];		// 
}
//---------------------------------------------------------------------------
void RLIMTEMP2()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP2 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP2 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP2 = LIM1TEMP2 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP2 = PAR_TEMP2 / DOPTEMP2;	// LIM2 (малый)
		LIM1TEMP2 = PAR_TEMP2 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDTEMP2()						// подготовка аналоговых данных БПН
{
	X_TEMP2 = TEK_TEMP2;	           	// тек.значение температуры
	E_TEMP2 = PAR_TEMP2 - X_TEMP2;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP2 >= 0) DELTEMP2 = E_TEMP2;
	else  DELTEMP2 = E_TEMP2 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------//
//--Подпрограмма выдачи команд на ТЕРМОДАТ--//
//------------------------------------------//
void VIDK_TEMP2( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[0] & 0x20 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP2 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP2();			// выбор параметра температуры
						ZAD_TEMP2 = PAR_TEMP2;	// запись задания
					}
				}
				CT_TEMP2 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ( ( diagnS[0] & 0x20 ) || ( PR_TEMP == 0 ) )
			{
				if ( CT_TEMP2 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP2 ( 1 , 17 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP2 ( 1 , 17 , 0100  , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP2 ( 2 , 17 , 0200 , X )  - Опрос температуры
//---------------------------------------------------------------------------
void R_36() // режим 36 "Откл. нагрев 2"
{
	sh_ = sh[36];

L00:if (shr[36] == 1)  goto L1;        
      if (shr[36] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[36] = sh_;
	if (sh[36] != 0) goto L100;   // SH != 0
	shr[36]++;                    // след.шаг сч.шр1
	if (shr[36] > 2) goto L0;    	// число шагов режима
	sh[36] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[36] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[35]  = 0;                  	// режима 35
	shr[35] = 0;                  	// "Вкл. БПН"
	diagn[17] &= (~0xE7);			// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP2(1,17,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//---------------------------------------------------------------------------
void R_37() // режим 37 "Прижим вверх"
{
	sh_ = sh[37];

	if (shr[37] == 1)  goto L1;
	else goto L100;// на выход

L101:sh[37] = sh_;
	if (sh[37] != 0) goto L100;		// SH != 0
	shr[37]++;						// след.шаг
	if (shr[37] > 1) goto L0;		// число шагов режима
	sh[37] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[37] = 0;
	goto L100;

L1: OPRIJIM();						// прижим вверх
	goto L101;
}
//---------------------------------------------------------------------------
void R_38() // режим 38 "Прижим вниз"
{
	sh_ = sh[38];

	if (shr[38] == 1)  goto L1;
	else goto L100;// на выход

L101:sh[38] = sh_;
	if (sh[38] != 0) goto L100;		// SH != 0
	shr[38]++;						// след.шаг
	if (shr[38] > 1) goto L0;		// число шагов режима
	sh[38] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[38] = 0;
	goto L100;

L1: VPPRIJIM();						// прижим вниз
	goto L101;
}
//---------------------------------------------------------------------------
void R_39() // режим 39 "МКС в исходное"
{
	sh_ = sh[39];
	if((shr[39] < 1) || (shr[39] > 2)) goto L100; // на выход

L00:if(shr[39] == 1) goto L1;
	if(shr[39] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[39] = sh_;
	if (sh[39] != 0) goto L100;		// SH != 0
	shr[39]++;			        // след.шаг
	if (shr[39] > 2) goto L0;		// число шагов режима
	sh[39] = 1;
L100: return;				        // возврат в "кольцо"

L0:	norma = 70;			        // норма: "Мех. кассеты в исходном"
	shr[39] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[40] = 0;			        // сброс активации режима 19
	shr[40] = 0;
	diagn[27] &= (~0xFF);		        // сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_KAS(par[0][16],0,0,1,60);		// механизм кассеты в исх.
	goto L101;
}
//---------------------------------------------------------------------------
void R_40() // режим 40 "МКС вверх/вниз"
{
	sh_ = sh[40];
	if ((shr[40] < 1) || (shr[40] > 2)) goto L100; // на выход

L00:if(shr[40] == 1) goto L1;
	if(shr[40] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[40] = sh_;
	if(sh[40] != 0) goto L100;		// SH != 0
	shr[40]++;			        // след.шаг
	if(shr[40] > 2) goto L0;		// число шагов режима
	sh[40] = 1;
L100:return;				        // возврат в "кольцо"

L0:	norma = 71;			        // норма: "Механизм. кассеты путь прошел"
	shr[40] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[39] = 0;			        // сброс активации режима 39
	shr[39] = 0;
	diagn[27] &= (~0xFF);		        // сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_KAS(par[0][16],OTN,par[0][18],0,60);     // механизм кассеты вверх/вниз
	goto L101;
}
//---------------------------------------------------------------------------
//---------  ПОДПРОГРАММЫ  --------------------------------------------------
//---------------------------------------------------------------------------
void SBROS_MEH() 				// режим "Сброс механизмов"
{
	// сброс режимов
	shr[9] 	= 0;				// транспортный тест	
	sh[9]  	= 0;
	shr[12] = 0;           		// МАН перемещения в исходное
	sh[12]  = 0;
	shr[13] = 0;           		// МАН перемещения вперед/назад
	sh[13]  = 0;
	shr[14] = 0;           		// МАН поворота в исходное
	sh[14]  = 0;
	shr[15]	= 0;				// МВП поворота вправо/влево
	sh[15]	= 0;	
	shr[37] = 0;				// Прижим в исходное
	sh[37]	= 0;
	shr[38]	= 0;				// Прижим вниз
	sh[38]	= 0;
	shr[39]	= 0;				// Кассета в HOME
	sh[39]	= 0;				
	shr[40]	= 0;				// Кассета вверх/вниз
	sh[40]	= 0;

	diagn[5] &=  (~0xFF);		// сброс диагностик МАН перемещения
	diagn[25] &= (~0xFF);		// сброс диагностик
    diagn[26] &= (~0xFF);		// сброс диагностик    
    diagn[27] &= (~0xFF);		// сброс диагностик
    diagn[28] &= (~0xFF);       // сброс диагностик
	
	SetOut(0,1,0x05);			// Отключение движения механизмов
	SetOut(0,2,0xF0C0);
	SetOut(1,1,0x02);			// СТОП движение
    PR_PER=0;
    PR_POV=0;
    PR_KAS=0;
    PR_PRIJ=0;
	norma = 45;					// сброс механизмов завершен
}
//---------------------------------------------------------------------------
void VIDK_KAS(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. кассеты
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x04) return;	// нет связи с контроллером
	SetOut(0,1,0x02);				// снять Стоп механизмов
	PR_KAS = 1;
	CT_KAS = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x20))				// нет готовности привода
	{
		if(CT_KAS >= 5)
			diagn[27] |= 0x01;		// отказ: "Нет готовности привода кассеты"
		return;
	}
	diagn[27] &= (~0x01);			// сброс диагностики
	OTVET_KAS = 0;
	V_KAS = a;
	TYPE_KAS = b;
	PUT_KAS = c;
	HOME_KAS = d;
	KOM_KAS = 1;
	CT_KAS = 0;
    TEK_OTN_KAS = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x04 || !OTVET_KAS)	// есть диагностика нет связи или нет ответа
	{
		if(CT_KAS >= 5)
			diagn[27] |= 0x04;		// отказ: "Нет ответа на команду кассеты"
		return;
	}
	diagn[27] &= (~0x04);			// сброс диагностики
	KOM_KAS = 0;
	if(!HOME_KAS)					// не движение в HOME
	{
		SetOut(1,2,0x4000);           // выдать движение
		CT_KAS = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,2,0x8000);              // выдать движение в Home
	CT_KAS = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x40)||(TEK_ABS_KAS))
    // механизм не пришел в HOME
	{
		if(CT_KAS >= e)
			diagn[27] |= 0x08;		// отказ: "Мех. кассеты не пришел в пол. HOME"
		return;		
	}
	diagn[27] &= (~0x08);			// сброс диагностики	
	SetOut(0,2,0x8000);              // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[4]&0x20))				// нет готовности привода
	{
		if(CT_KAS >= 5)
			diagn[27] |= 0x01;		// отказ: "Нет готовности привода кассеты"
		return;
	}
	diagn[27] &= (~0x01);			// сброс диагностики
	PR_KAS = 0;
	norma = 70;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[4]&0x20)				    // есть готовность привода
	{
		if(CT_KAS >= 5)
			diagn[27] |= 0x02;		// отказ: "Нет ответа на START движ. кассеты"
		return;
	}
	diagn[27] &= (~0x02);			// сброс диагностики
	SetOut(0,2,0x4000);               // сбросить начало движение
	CT_KAS = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[4]&0x20)||((TYPE_KAS==ABS)&&(PUT_KAS!=TEK_ABS_KAS))||((TYPE_KAS==OTN)&&(PUT_KAS!=TEK_OTN_KAS)))
    // есть готовность привода
	{
		if(CT_KAS >= e)
			diagn[27] |= 0x10;		// отказ: "Нет завершения движ. кассеты"
		return;
	}
	diagn[27] &= (~0x10);			// сброс диагностики
	PR_KAS = 0;
	norma = 71;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
void VPPRIJIM()						// подпрограмма "Прижим включить"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;			        	// выход
	
A1: PR_PRIJ = 1;
	SetOut(0,1,0x02);		        	// снять стоп
	CT_PRIJ = 0;
    sh_ = 2;
A2: if((!(zin[3]&0x800))||(!(zin[3]&0x2000)))	// есть готовность и отсутсвие аварии прижима
	{
		if(CT_PRIJ < T_KPRIJ) return; 	// время вышло
		diagn[25] |= 0x01;			  	// отказ:"Нет готов. механ. прижима"
		return;
	}
	diagn[25] &= (~0x01);				// сброс диагностики
	SetOut(1,2,0x40);					// пуск привода прижима
	CT_PRIJ = 0;
    sh_ = 3;
A3: if(zin[3]&0x800) 					// готовность пропала
	{
		if(CT_PRIJ < T_KPRST) return;	// время не вышло
		diagn[25] |= 0x02;				// отказ: "Нет старта мех. прижима"
		SetOut(1,1,0x02);				// вкл. стоп
        SetOut(0,2,0x40);
		return;
	}
	diagn[25] &= (~0x02);				// сброс диагностики
	SetOut(0,2,0x40);					// стоп привода прижима
	CT_PRIJ = 0;
    sh_ = 4;
A4: if(!(zin[3]&0x800)) 				// опрос готовности
	{
		if(CT_PRIJ < T_KPR) return;		// время вышло
		diagn[25] |= 0x04;				// отказ:"Нет завершения движ. мех. прижима"
		return;
	}
	diagn[25] &= (~0x04);				// сброс диагностики
	SetOut(1,1,0x02);					// вкл. стоп
	PR_PRIJ = 0;
	norma = 64;							//Прижим внизу
	sh_ = 0;
}
//---------------------------------------------------------------------------
void OPRIJIM()						// подпрограмма "Прижим отключить(HOME)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;			// выход
	
A1: SetOut(0,1,0x02);		// снять стоп
	PR_PRIJ = 1;
	CT_PRIJ = 0;
    sh_ = 2;
A2: if((!(zin[3]&0x2000))||(!(zin[3]&0x800)))	// есть готовности и отсутсвий аварий прижима
	{
		if(CT_PRIJ < T_KPRIJ) return; 	// время вышло
		diagn[25] |= 0x01;				// отказ:"Нет готов. механ. прижима"
		return;
	}	
	diagn[25] &= (~0x01);				// сброс диагностики
	SetOut(1,2,0x80);					// пуск приводов прижима в HOME
	CT_PRIJ = 0;
    sh_ = 3;
A3: if(!(zin[3]&0x1000)) 
	{
		if(CT_PRIJ < T_KPR) return;		// время не вышло
		diagn[25] |= 0x08;				// отказ: "Механизм прижима не пришел в HOME"
	    return;
	}
	diagn[25] &= (~0x08);				// сброс диагностики
	SetOut(0,2,0x80);					// стоп приводов прижима
	sh_ = 4;
A4: if(!(zin[3]&0x800)) 				// опрос готовности
	{
		diagn[25] |= 0x01;				// отказ:"Нет готовности мех. прижима"
		return;
	}
	diagn[25] &= (~0x01);				// сброс диагностики
	SetOut(1,1,0x02);					// вкл. стоп
	PR_PRIJ = 0;
	norma = 65;							//Прижим в положении HOME
	sh_ = 0;
}
//---------------------------------------------------------------------------
void RKOEF_GIR ()						// подпрограмма "Расчет текущего коэф-та согласования
										// ????-?? ???????????? ??? ????????
										// ????/????"
{
	if(aik[13] == 0) return;			// ???????? ????. ?? 0
	long T1 = (aik[12]*10) / aik[13];	// ??????????? ?? 10 ??? ???????? ????? ????? ","
	N_TEK_GIR = T1;						// K=P???.*10/P???.
}
//---------------------------------------------------------------------------
void VRR_GIS()						// подпрограмма "Выставить разр. работы ВЧГ стола"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(1,3,0x200);				// выставить разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[1] & 0x2000) == 0)		// разр.раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[4] |= 0x10;			// отказ:"Разр. работы ВЧГ не выставилось"
		return;
	}
	diagn[4] &= (~0x10);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------
void ORR_GIS()						// подпрограмма "Снять разр. работы ВЧГ стола"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(0,3,0x200);				// снять разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[1] & 0x2000) != 0)		// разр.раб. не снято
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[4] |= 0x20;			// отказ: "Разр. работы ВЧГ не снялось"
		return;
	}
	diagn[4] &= (~0x20);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------
void VRR_GIR()						// подпрограмма "Выставить разр. работы ВЧГ реактора"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(1,3,0x100);				// выставить разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[1] & 0x800) == 0)		// разр.раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[7] |= 0x10;			// отказ:"Разр. работы ВЧГ не выставилось"
		return;
	}
	diagn[7] &= (~0x10);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------
void ORR_GIR()						// подпрограмма "Снять разр. работы ВЧГ реактора"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(0,3,0x100);				// снять разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[1] & 0x800) != 0)		// разр.раб. не снято
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[7] |= 0x20;			// отказ: "Разр. работы ВЧГ не снялось"
		return;
	}
	diagn[7] &= (~0x20);			// сброс диагностики
	sh_ = 0;
}
//---------------------------------------------------------------------------
void VTMN()			// включить ТМН
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
    if (sh_ == 3) goto A3;
	else return;	// выход

A1: //SetOut(1,4,0x20);   // включить удаленное управление
    CT_TMN = 0;
    sh_ = 2;
A2: if(!(zin[2] & 0x2000))		// не выставилось
	{
		if(CT_TMN <= T_TMN) return;	// время не вышло
		diagn[23] |= 0x40;			// отказ: "Удаленное управление ТМН не выставилось"
		return;
	}
	diagn[23] &= (~0x40);			// сброс диагностики
    SetOut(1,3,0x40);   // включить ТМН
    CT_TMN = 0;
	sh_ = 3;
A3: if(!(zin[2] & 0x1800))		// нет разгона или нормы
	{
		if(CT_TMN <= T_TMN) return;	// время не вышло
		diagn[23] |= 0x80;			// отказ: "ТМН не включился"
		return;
	}
	diagn[23] &= (~0x80);			// сброс диагностики
	sh_ = 0;
}
//---------------------------------------------------------------------------
void OBPN()				// подпрограмма "Отключить БПН (сил. пит. на термодат)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;      // выход

A1:	SetOut(0,3,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	SetOut(1,3,0x02);		   	// выкл. силового питания БПН
	CT_IST = 0;			   		// сброс сч.времени
	sh_ = 2;
A2:	if (zin[0]&0x80)	   	// силовое питание включено
	{
		if (CT_IST<=T_VKL_BPN) return;// время не вышло
		diagn[16]|=0x10;	           // отказ:"Силовое питание БПН не выкл."
		return;
	}
	SetOut(0,3,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	diagn[16]&=(~0x10);		   	// сброс диагностики
	sh_ = 0;
	norma = 21;					// норма: "Силовое питание БПН отключено"
 }
//------------------------------------------------------------------------------
bool KasVPaze() 		// подпрограмма проверки нахождения кассеты между пазами
{
        int PAZ;
        for(int n = 0;n < 25;n++)
        {
                PAZ = par_t[0] - int(par_t[5]) + int(par_t[4]*n);
                if(((PAZ-1667)<TEK_ABS_KAS)&&((PAZ+1667)>TEK_ABS_KAS)) return true;
        }
        return false;
}
//------------------------------------------------------------------------------
void PUSK_TP ()						//Пуск ТП
{
	if(KOM_MOD&0x40)				//есть команда "Пуск ТП"
	{
		if(!shr[4])
		{
			shr[4]=1;				//активизировать режим 4
			sh[4]=1;				//"Технологический процесс"
		}
	}
	if(shr[4])
		OTVET_MOD |= 0x40;		//запись активизации режима 4
	else
		OTVET_MOD &= (~0x40);
}
//------------------------------------------------------------------------------
void OPROS_SOST ()			// подпрограмма "Опрос и запись состояния"
{
	if(zin[1]&0x40) OTVET_MOD |= 0x08;		//запись положения подъёмника
    else OTVET_MOD &= (~0x08);
    if(zin[1]&0x80) OTVET_MOD |= 0x10;
	else OTVET_MOD &= (~0x10);

	if(zin[3]&0x1000) OTVET_MOD |= 0x20;	//запись состояния прижима
	else OTVET_MOD &= (~0x20);

						//обнуление данных с 1-ых трёх битов
	if(!(diagnS[0]&0x08)&&(zin[0]&0x4000))   //есть связь с датчиком вакуума и Кл-Д4 открыт
	{
	    if (D_D4 <=nasmod[1])
            {
                OTVET_MOD |= 0x04;	// если давление меньше или равно рабочему вакууму
                OTVET_MOD &= (~0x03);
            }
            else if((D_D4>nasmod[1])&&(D_D4<=UVAKV_KAM))
            {
                OTVET_MOD |= 0x03;	// если давление больше рабочего вакуума и меньше или равно 8 ПА
                OTVET_MOD &= (~0x04);
            }
            else if((D_D4>UVAKV_KAM)&&(D_D4<=UATM_D4))
            {
                OTVET_MOD |= 0x02;// если давление больше 8 ПА и меньше или равно АТМ
                OTVET_MOD &= (~0x05);
            }
            else
            {
                OTVET_MOD |= 0x01; //иначе
                OTVET_MOD &= (~0x06);
            }
	}
    else OTVET_MOD &= (~0x07);

	OTVET_MOD|=0x80;
	for(int i=1;i<SHR_COUNT;i++)					//если нет активиз. режимов кроме
	{												//"Нагрев кам." и "Нагрев трубопровода"
		if((i!=33)&&(i!=34)&&(i!=35)&&(i!=36)&&(shr[i]))
		{	
			OTVET_MOD&=(~0x80);
			break;
		}
	}	
}
//------------------------------------------------------------------------------
void UPR()								// подъём/опускание штырей (управл.)
{
	if(((KOM_MOD&0x18)!=0x18)&&((KOM_MOD&0x18)!=0x00)) // если 4ый и 5ый биты не равны
	{
		if(KOM_MOD&0x08)
                {       // если 4ый бит 1 то подъёмник вверх
                        SetOut(1,0,0x200);
                        SetOut(0,0,0x400);
                }
		else		// иначе вниз
                {
                        SetOut(0,0,0x200);
                        SetOut(1,0,0x400);
                }
	}
}	