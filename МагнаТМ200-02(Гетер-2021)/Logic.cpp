//---------------------------------------------------------------------------
#pragma hdrstop
#include "Modules\Com\Com.cpp"
#include "Logic.h"
#include "Modules\AZdrive\AZdrive.cpp"

#include "Modules\RRG\RRG.cpp"
#include "Modules\Klapan\Klapan.cpp"
//---------------------------------------------------------------------------
#pragma package(smart_init)

void LogicMain ()
{
    KOLCO();                    // кольцо
    if ( shr[1] )               // Проверка
    {                           // активации
        R_1();                  // режима 1 "Откачка камеры"
    };
    if ( shr[2] )               // Проверка
    {                           // активации
        R_2();                  // режима 2 "Тренировка"
    };
	if ( shr[3] )               // Проверка
    {                           // активации
        R_3();                  // режима 3 "Рабочий цикл"
    };
	if ( shr[4] )               // Проверка
    {                           // активации
        R_4();                  // режима 4 "Технологический процесс"
    };
    if ( shr[5] )               // Проверка
    {                           // активации
        R_5();                  // режима 5 "Сброс РЦ"
    };
	if ( shr[6] )               // Проверка
    {                           // активации
        R_6();                  // режима 6 "Сбор(выгрузка) пластин"
    };
    if ( shr[7] )               // Проверка
    {                           // активации
        R_7();                  // режима 7 "Отключение установки"
    };
	if ( shr[8] )               // Проверка
    {                           // активации
        R_8();                  // режима 8 "Аварийное отключение установки"
    };
	if ( shr[9] )               // Проверка
    {                           // активации
        R_9();                  // режима 9 "Транспортный тест"
    };	
	if ( shr[10] )               // Проверка
    {                            // активации
        R_10();                  // режима 10 "Открыть ЩЗ"
    };
    if ( shr[11] )               // Проверка
    {                            // активации
        R_11();                  // режима 11 "Закрыть ЩЗ"
    };
	if ( shr[12] )               // Проверка
    {                            // активации
        R_12();                  // режима 12 "Ман. в исх"
    };
	if ( shr[13] )               // Проверка
    {                            // активации
        R_13();                  // режима 13 "Ман. вперед/назад"
    };
	if ( shr[14] )               // Проверка
    {                            // активации
        R_14();                  // режима 14 "Подъём п/д в кам"
    };
	if ( shr[15] )               // Проверка
    {                            // активации
        R_15();                  // режима 15 "Подъём п/д в HOME"
    };
    if ( shr[16] )               // Проверка
    {                            // активации
        R_16();                  // режима 16 "Вращение п/д (вкл)"
    };
	if ( shr[17] )               // Проверка
    {                            // активации
        R_17();                  // режима 17 "Вращение п/д (откл)"
    };
    if ( shr[18] )               // Проверка
    {                            // активации
        R_18();                  // режима 18 "Подъём п/д в рабочее положение"
    };
    if ( shr[19] )               // Проверка
    {                            // активации
        R_19();                  // режима 19 "Откачка шлюза"
    };
    if ( shr[20] )              // Проверка
    {                           // активации
        R_20();                 // режима 20 "РРГ1"
    };	
    if ( shr[21] )              // Проверка
    {                           // активации
        R_21();                 // режима 21 "РРГ2"
    };
    if ( shr[22] )              // Проверка
    {                           // активации
        R_22();                 // режима 22 "РРГ3"
    };
    if ( shr[23] )              // Проверка
    {                           // активации
        R_23();                 // режима 23 "РРГ4"
    };
	if ( shr[24] )              // Проверка
    {                           // активации
        R_24();                 // режима 24 "УУН"
    };
    if ( shr[25] )              // Проверка
    {                           // активации
        R_25();                 // режима 25 "Открыть ДЗ"
    };
    if ( shr[26] )              // Проверка
    {                           // активации
        R_26();                 // режима 26 "Закрыть ДЗ"
    };
    if ( shr[27] )              // Проверка
    {                           // активации
        R_27();                 // режима 27 "ДЗ на угол"
    };
    if ( shr[28] )              // Проверка
    {                           // активации
        R_28();                 // режима 28 "ВЧГ п/д (вкл)"
    };
   	if ( shr[29] )              // Проверка
    {                           // активации
        R_29();                 // режима 29 "Нагрев кам вкл"
    };
    if ( shr[30] )              // Проверка
    {                           // активации
        R_30();                 // режима 30 "Нагрев кам откл"
    };
	if ( shr[31] )              // Проверка
    {                           // активации
        R_31();                 // режима 31 "Нагрев п/д вкл"
    };
	if ( shr[32] )              // Проверка
    {                           // активации
        R_32();                 // режима 32 "Нагрев п/д откл"
    };
	if ( shr[33] )              // Проверка
    {                           // активации
        R_33();                 // режима 33 "БПИИ вкл"
    };
    if ( shr[34] )              // Проверка
    {                           // активации
        R_34();                 // режима 34 "БПИИ откл"
    };
    if ( shr[35] )              // Проверка
    {                           // активации
        R_35();                 // режима 35 "БПМ1 вкл"
    };
    if ( shr[36] )              // Проверка
    {                           // активации
        R_36();                 // режима 36 "БПМ2 вкл"
    };
	if ( shr[37] )              // Проверка
    {                           // активации
        R_37();                 // режима 37 "Сброс БПМов"
    };
	if ( shr[38] )              // Проверка
    {                           // активации
        R_38();                 // режима 38 "Чилер п/д вкл"
    };
    if ( shr[39] )              // Проверка
    {                           // активации
        R_39();                 // режима 39 "Чилер п/д откл"
    };
    if ( shr[40] )              // Проверка
    {                           // активации
        R_40();                 // режима 40 "Пуск КН"
    };
	if ( shr[41] )              // Проверка
    {                           // активации
        R_41();                 // режима 41 "СТОП КН"
    };
    if ( shr[42] )              // Проверка
    {                           // активации
        R_42();                 // режима 41 "подъём п/д в раб позицию ионной очистки"
    };


    POST();                     // дешифрация команд оператора
};
//---------------------------------------------------------------------------
void KOLCO()                    // подпрограмма "Кольцо"
{
	DIAGN_KOLCO();              // диагностика в кольце
    REAKCIA_KZM1();             // реакция на КЗ БПМ1
    REAKCIA_KZM2();             // реакция на КЗ БПМ2
    UPR_AVAR_OTKL();			// Управление аварийным отключением
    MEH_AVAR_CHK();				// слежение за авриями механизма
    OpenFK_TMN_CloseFK_SHL();	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
    AVAR_VODA_II();                 // реакция на отсутствие воды в ИИ
    AVAR_VODA_BM1();				// реакция на отсутствие воды в М1
    AVAR_VODA_BM2();				// реакция на отсутствие воды в М2
    AVAR_DAVL_KN();      // "Реакция на высокое давление в камере при работе КН"
    AVAR_DAVL();      // "Реакция на высокое давление в камере при работе ТМН"
    kl6_osush();                  //контроль кл6 для осушения
    vklpnevmo();                  //включение пневмораспределителя
    PderCheck();				// контроль вращения п/д
    DIAGN_KN();             // Диагностика крионасоса (КН)
    VID_DIAGN_GIS();        // выдача диагностики нет согласования ВЧГ п/д
}
//---------------------------------------------------------------------------
void POST()                     // Почта (приём и дешифрация команд)
{
    switch (qkk)
    {
        case 0:;break;          // проверка на KK = 0
        case 1:                 // проверка на KK = 1
        {
            if ( shr[1] == 0 )  // если режим ещё не активизирован
            {
                shr[1] = 1;     // активизируем
                sh[1]  = 1;     // режим 1 "Откачка камеры"
            }
        }; break;
        case 2:                 // проверка на KK = 2
        {
            if ( shr[2] == 0 )  // если режим ещё не активизирован
            {
                shr[2] = 1;     // активизируем
                sh[2]  = 1;     // режим 2 "Тренировка"
            }
        }; break;
        case 3:                 // проверка на KK = 3
        {
            if ( shr[3] == 0 )  // если режим ещё не активизирован
            {
                shr[3] = 1;     // активизируем
                sh[3]  = 1;     // режим 3 "Рабочий цикл"
            }
        }; break;
		case 5:                 // проверка на KK = 5
        {
            if ( shr[5] == 0 )  // если режим ещё не активизирован
            {
                shr[5] = 1;     // активизируем
                sh[5]  = 1;     // режим 5 "Сброс РЦ"
            }
        }; break;
        case 6:                 // проверка на KK = 6
        {
            if ( shr[6] == 0 )  // если режим ещё не активизирован
            {
                shr[6] = 1;     // активизируем
                sh[6]  = 1;     // режим 6 "Сбор пластин"
            }
        }; break;
		case 7:                 // проверка на KK = 7
        {
            if ( shr[7] == 0 )  // если режим ещё не активизирован
            {
                shr[7] = 1;     // активизируем
                sh[7]  = 1;     // режим 7 "Отключение установки"
            }
        }; break;
		
		case 9:                 // проверка на KK = 9
        {
            if ( shr[9] == 0 )  // если режим ещё не активизирован
            {
                shr[9] = 1;     // активизируем
                sh[9]  = 1;     // режим 9 "Транспортный тест"
            }
        }; break;		
		case 109:				// проверка на KK = 109
        {
            PR_TRTEST = 1;		// признак окончания транспортного теста
        }; break;
		case 10:				// проверка на KK = 10
        {
            if ( shr[10] == 0 )  // если режим ещё не активизирован
            {
                shr[10] = 1;     // активизируем
                sh[10]  = 1;     // режим 10 "Открыть ЩЗ"
            }
        }; break;
		case 11:                 // проверка на KK = 11
        {
            if ( shr[11] == 0 )  // если режим ещё не активизирован
            {
                shr[11] = 1;     // активизируем
                sh[11]  = 1;     // режим 11 "Закрыть ЩЗ"
            }
        }; break;
		case 12:                 // проверка на KK = 12
        {
            if ( shr[12] == 0 )  // если режим ещё не активизирован
            {
                shr[12] = 1;     // активизируем
                sh[12]  = 1;     // режим 12 "Мех. перем. в исх"
            }
        }; break;
		case 13:                 // проверка на KK = 13
        {
            if ( shr[13] == 0 )  // если режим ещё не активизирован
            {
                shr[13] = 1;     // активизируем
                sh[13]  = 1;     // режим 13 "Мех. перем. вперед/назад"
            }
        }; break;
		case 101:				// проверка на KK = 101
        {
            SBROS_MEH();		// сброс механизмов
        }; break;
		case 213:				// проверка на KK = 213
        {
            MEH_AVAR_SBROS();	// сброс аварий механизмов
        }; break;
		case 14:                 // проверка на KK = 14
        {
            if ( shr[14] == 0 )  // если режим ещё не активизирован
            {
                shr[14] = 1;     // активизируем
                sh[14]  = 1;     // режим 14 "Мех. пов. в HOME"
            }
        }; break;
		case 15:                 // проверка на KK = 15
        {
            if ( shr[15] == 0 )  // если режим ещё не активизирован
            {
                shr[15] = 1;     // активизируем
                sh[15]  = 1;     // режим 15 "Мех. пов. вправо/влево"
            }
        }; break;
        case 16:                 // проверка на KK = 16
        {
            if ( shr[16] == 0 )  // если режим ещё не активизирован
            {
                shr[16] = 1;     // активизируем
                sh[16]  = 1;     // режим 16 "Вращение п/д (вкл)"
            }
        }; break;
		case 17:                 // проверка на KK = 17
        {
            if ( shr[17] == 0 )  // если режим ещё не активизирован
            {
                shr[17] = 1;     // активизируем
                sh[17]  = 1;     // режим 17 "Дросселирование ДЗ"
            }
        }; break;
		case 18:                 // проверка на KK = 18
        {
            if ( shr[18] == 0 )  // если режим ещё не активизирован
            {
                shr[18] = 1;     // активизируем
                sh[18]  = 1;     // режим 18 "Открыть ДЗ"
            }
        }; break;
		case 19:                 // проверка на KK = 19
        {
            if ( shr[19] == 0 )  // если режим ещё не активизирован
            {
                shr[19] = 1;     // активизируем
                sh[19]  = 1;     // режим 19 "Закрыть ДЗ"
            }
        }; break;
		case 100:				// проверка на KK = 100
        {
            OSBROS();			// общий сброс
        }; break;
		case 20:                // проверка на KK = 20
        {

                shr[20] = 1;    // активизируем
                sh[20]  = 1;    // режим 20 "Вкл. РРГ1"


        }; break;

		case 120:                // проверка на KK = 120
        {
			RRGOff(ObjRRG[0]);	// отключение РРГ1
            if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
                SetOut(0,2,0x800);      //закрыть кл7
            PR_RG1  = 0;
		}; break;
		case 21:                // проверка на KK = 21
        {

                shr[21] = 1;    // активизируем
                sh[21]  = 1;    // режим 21 "Вкл. РРГ2"
                PR_RG2  = 0;

        }; break;

		case 121:                // проверка на KK = 121
        {
			RRGOff(ObjRRG[1]);	// отключение РРГ2
            if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
                SetOut(0,2,0x800);      //закрыть кл7
            PR_RG2  = 0;
		}; break;
		case 22:                // проверка на KK = 22
        {

                shr[22] = 1;    // активизируем
                sh[22]  = 1;    // режим 22 "Вкл. РРГ3"
                PR_RG3  = 0;
        }; break;

		case 122:                // проверка на KK = 122
        {
			RRGOff(ObjRRG[2]);	// отключение РРГ3
            if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
                SetOut(0,2,0x800);      //закрыть кл7
            PR_RG3  = 0;
		}; break;
		case 23:                // проверка на KK = 23
        {

                shr[23] = 1;    // активизируем
                sh[23]  = 1;    // режим 23 "Вкл. РРГ4"
                PR_RG4  = 0;

        }; break;
        case 223:                // проверка на KK = 223
        {

                shr[23] = 1;    // активизируем
                sh[23]  = 1;    // режим 23 "Вкл. РРГ4"
                PR_RG4  = 1;

        }; break;
		case 123:                // проверка на KK = 123
        {
			RRGOff(ObjRRG[3]);	// отключение РРГ4
            PR_RG4  = 0;
		}; break;
		case 24:                // проверка на KK = 24
        {
                if ( shr[24] == 0 ) // если режим ещё не активизирован
            {
                shr[24] = 1;    // активизируем
                sh[24]  = 1;    // режим 24 "УУН"
             }

        }; break;

		case 124:                // проверка на KK = 124
        {
			SBROSR_24();
            if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
                SetOut(0,2,0x800);      //закрыть кл7
		}; break;
        case 25:                // проверка на KK = 25
        {
            if ( shr[25] == 0 ) // если режим ещё не активизирован
            {
                shr[25] = 1;    // активизируем
                sh[25]  = 1;    // режим 25
            }
        }; break;
        case 26:                // проверка на KK = 26
        {
            if ( shr[26] == 0 ) // если режим ещё не активизирован
            {
                shr[26] = 1;    // активизируем
                sh[26]  = 1;    // режим 26
            }
        }; break;
        case 27:                // проверка на KK = 27
        {
            if ( shr[27] == 0 ) // если режим ещё не активизирован
            {
                shr[27] = 1;    // активизируем
                sh[27]  = 1;    // режим 27
            }
        }; break;
        case 28:                // проверка на KK = 28
        {
            if ( shr[28] == 0 ) // если режим ещё не активизирован
            {
                shr[28] = 1;    // активизируем
                sh[28]  = 1;    // режим 28
            }
        }; break;
        case 128:                // проверка на KK = 128
        {
            SBROSR_28();
        }; break;
		case 29:                // проверка на KK = 29
        {
            if ( shr[29] == 0 ) // если режим ещё не активизирован
            {
                shr[29] = 1;    // активизируем
                sh[29]  = 1;    // режим 29
            }
        }; break;

        case 30:                // проверка на KK = 30
        {
            if ( shr[30] == 0 ) // если режим ещё не активизирован
            {
                shr[30] = 1;    // активизируем
                sh[30]  = 1;    // режим 30
            }
        }; break;
		case 31:                // проверка на KK = 31
        {
            if ( shr[31] == 0 ) // если режим ещё не активизирован
            {
                shr[31] = 1;    // активизируем
                sh[31]  = 1;    // режим 31
            }
        }; break;
		case 32:                // проверка на KK = 32
        {
            if ( shr[32] == 0 ) // если режим ещё не активизирован
            {
                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32
            }
        }; break;
		case 33:                // проверка на KK = 33
        {
            if ( shr[33] == 0 ) // если режим ещё не активизирован
            {
                shr[33] = 1;    // активизируем
                sh[33]  = 1;    // режим 33
            }
        }; break;
		case 34:                // проверка на KK = 34
        {
            if ( shr[34] == 0 ) // если режим ещё не активизирован
            {
                shr[34] = 1;    // активизируем
                sh[34]  = 1;    // режим 34
            }
        }; break;
        case 35:                // проверка на KK = 35
        {
            if ( shr[35] == 0 ) // если режим ещё не активизирован
            {
                shr[35] = 1;    // активизируем
                sh[35]  = 1;    // режим 35
            }
        }; break;
        case 36:                // проверка на KK = 36
        {
            if ( shr[36] == 0 ) // если режим ещё не активизирован
            {
                shr[36] = 1;    // активизируем
                sh[36]  = 1;    // режим 36
            }
        }; break;
		case 37:                // проверка на KK = 37
        {
            if ( shr[37] == 0 ) // если режим ещё не активизирован
            {
                shr[37] = 1;    // активизируем
                sh[37]  = 1;    // режим 37
            }
        }; break;
		case 38:                // проверка на KK = 38
        {
            if ( shr[38] == 0 ) // если режим ещё не активизирован
            {
                shr[38] = 1;    // активизируем
                sh[38]  = 1;    // режим 38
            }
        }; break;
		case 39:                // проверка на KK = 39
        {
            if ( shr[39] == 0 ) // если режим ещё не активизирован
            {
                shr[39] = 1;    // активизируем
                sh[39]  = 1;    // режим 39
            }
        }; break;
		case 40:                // проверка на KK = 40
        {
            if ( shr[40] == 0 ) // если режим ещё не активизирован
            {
                shr[40] = 1;    // активизируем
                sh[40]  = 1;    // режим 40
            }
        }; break;
		case 41:                // проверка на KK = 41
        {
            if ( shr[41] == 0 ) // если режим ещё не активизирован
            {
                shr[41] = 1;    // активизируем
                sh[41]  = 1;    // режим 41
            }
        }; break;
        case 42:                // проверка на KK = 42
        {
            if ( shr[42] == 0 ) // если режим ещё не активизирован
            {
                shr[42] = 1;    // активизируем
                sh[42]  = 1;    // режим 42
            }
        }; break;
		case 110:                // проверка на KK = 110
        {
            SetOut(1,2,0x01);       //чиллер пуск
        }; break;
        case 111:                // проверка на KK = 111
        {
            SetOut(0,2,0x01);       //чиллер пуск
        }; break;
        default:                // любая другая команда
        {
            diagnS[0] |= 0x80;  // отказ: "неопознанная команда"
            return;             //
        };

    };
    qkk = 0;                    // сброс кода команды
    diagnS[0] &= ~(0x80);       // сброс диагностики
}
//---------------------------------------------------------------------------
void DIAGN_KOLCO()				// "Подпрограмма: "Диагностика в кольце"
{	
    if(!(zin[0]&0x01))
        diagn[13]|=0x02;            //отказ "Нет охлаждения ИИ"
    else
        diagn[13]&=(~0x02);         //сброс диагностики

    if(!(zin[0]&0x02))
        diagn[13]|=0x04;            //отказ "Нет охлаждения М1"
    else
        diagn[13]&=(~0x04);         //сброс диагностики

    if(!(zin[0]&0x04))
        diagn[13]|=0x08;            //отказ "Нет охлаждения М2"
    else
        diagn[13]&=(~0x08);         //сброс диагностики

    if(!(zin[0]&0x08))
        diagn[13]|=0x10;            //отказ "Нет охлаждения КН"
    else
        diagn[13]&=(~0x10);         //сброс диагностики

    if(!(zin[0]&0x10))
        diagn[13]|=0x20;            //отказ "Нет охлаждения форнасоса камеры"
    else
        diagn[13]&=(~0x20);         //сброс диагностики

    if(!(zin[0]&0x20))
        diagn[20]|=0x20;            //отказ "Нет охлаждения ТМН и камеры"
    else
        diagn[20]&=(~0x20);         //сброс диагностики

    if(!(zin[1]&0x04))
        diagn[13]|=0x40;            //отказ "Форнасос камеры: предупреждение"
    else
        diagn[13]&=(~0x40);         //сброс диагностики

    if(!(zin[1]&0x10))
        diagn[20]|=0x10;            //отказ "Нет давления в пневмосети "
    else
        diagn[20]&=(~0x10);         //сброс диагностики

    if((out[3]&0x08)&&(!(zin[1]&0x20)))
        diagn[13]|=0x01;            //отказ "Нет давления в пневмосети продувки п/д"
    else
        diagn[13]&=(~0x01);         //сброс диагностики

    if(zin[1]&0x1000)
        diagn[18]|=0x01;            //отказ "ВЧГ п/д: перегрев"
    else
        diagn[18]&=(~0x01);         //сброс диагностики

    if(zin[1]&0x2000)
        diagn[18]|=0x02;            //отказ "ВЧГ п/д: предупреждение"
    else
        diagn[18]&=(~0x02);         //сброс диагностики

    if(zin[1]&0x4000)
        diagn[18]|=0x04;            //отказ "ВЧГ п/д: авария"
    else
        diagn[18]&=(~0x04);         //сброс диагностики

    if((zin[2]&0x02))
        diagn[18]|=0x08;            //отказ "Чиллер п/д: предупреждение"
    else
        diagn[18]&=(~0x08);         //сброс диагностики

    if((zin[2]&0x04))
        diagn[18]|=0x10;            //отказ "Чиллер п/д: авария"
    else
        diagn[18]&=(~0x10);         //сброс диагностики

    if(!(zin[2]&0x80))
        diagn[18]|=0x20;            //отказ "Чиллер: авария"
    else
        diagn[18]&=(~0x20);         //сброс диагностики

    if(!(zin[3]&0x400))
        diagn[18]|=0x40;            //отказ "Авария привода манипулятора"
    else
        diagn[18]&=(~0x40);         //сброс диагностики

    if(!(zin[3]&0x2000))
        diagn[18]|=0x80;            //отказ "Авария привода вертикального перемещения п/д"
    else
        diagn[18]&=(~0x80);         //сброс диагностики


	
	//диагностики по перегреву воды//
	if(aik[0] > 901)			// T° > 30°C
		diagn[21] |=0x01 ;		// Отказ: "Высокая темп. воды охл. ИИ"
	else
		diagn[21] &=(~0x01) ;	// Сброс диагностики
	
	if(aik[1] > 901)			// T° > 30°C
		diagn[21] |= 0x02;		// Отказ: "Высокая темп. воды охл. М1"
	else
		diagn[21] &= ~(0x02);	// Сброс диагностики
	
	if(aik[2] > 901)			// T° > 30°C
		diagn[21] |=0x04 ;		// Отказ: "Высокая темп. воды охл. М2"
	else
		diagn[21] &=(~0x04) ;	// Сброс диагностики



}
//---------------------------------------------------------------------------
void TIME()			//  подпрограмма управления таймером
{					// (прерывание с периодом в 1 миллисекунду)

	CT_T1++;		// Сч.тиков (1 мсек=1кГц)
	
	// Счетчики тиковские (1 мсек) для устройств и режимов
    CT_REQUN ++;

	if(CT_T1 < 20) return;
	CT_T1 = 0;		// Сброс сч.тиков (1 мсек.)
	CT_T20++;		// Счетчик тиков (20мсек = 50Гц)

	// Счетчики тиковские (20 мсек) для устройств и режимов
	CT_SUT_g++;
	CT_SUT_t++;
    CT_DVIJ_GIR_g++;
	CT_DVIJ_GIR_t++;
    ctPderjDvij++;
    ctPderjCheck_0++;
    ctPderjCheck_1++;
    CT_VRUN++;
    CT_PR_UN++;
    
				    // (тик) сч.вр.режима 30

    CT_AVAR_OTKL++;
	if(CT_T20 < 50) return;
	CT_T20 = 0;		// Сброс сч.тиков (20 мсек.)

	// Счетчики секундные (1 сек)
    CT_KN++;

    CT_II++;
    CT_VODA_BM1++;
    CT_VODA_BM2++;
    CT_VODA_II++;
    CT_KZ1++;
    CT_KZ2++;

    CT_PER++;
    CT_POD++;
    CT_DZASL++;
    CT_TEMP1++;
    CT_TEMP2++;
    CT_VHG++;
    CT_IST++;
    CT_BM1++;
    CT_BM2++;
    
	// инкремент счетчиков механизмов
	//AZdrive_Time();

	// Счетчики времени режимов (секундные)
	CT_1++;
    CT_2++;
    CT_3++;
    CT_4++;
    CT_5++;
    CT_6++;
    CT_7++;
    CT_9++;
    CT_10++;
    CT_19++;
    CT_24++;
    CT24K1++;
    CT_27++;
    CT_28++;
    CT28K1++;
    CT_29++;
    CT29K1++;
    CT_31++;
    CT31K1++;
    CT_33++;
    CT33K1++;
    CT_35++;
    CT35K1++;
    CT_36++;
    CT36K1++;
    CT_38++;
    CT_39++;
    CT_40++;
    CT_41++;



	TimeRRG();
	TimeKlapan();
}

//---------------------------------------------------------------------------
//-------------------------------  РЕЖИМЫ  ----------------------------------
//---------------------------------------------------------------------------
void R_1 ()            // Режим "Откачка камеры"
{
	sh_ = sh[1];
	
	if (shr[1] < 1 || shr[1] > 68) goto L100;
	if (shr[1] < 10) goto L00;
	if (shr[1] < 20) goto L01;
	if (shr[1] < 30) goto L02;
	if (shr[1] < 40) goto L03;
    if (shr[1] < 50) goto L04;
    if (shr[1] < 60) goto L05;
	else goto L06;
	
L00:if (shr[1] == 1) goto L1;
	if (shr[1] == 2) goto L2;
	if (shr[1] == 3) goto L3;
	if (shr[1] == 4) goto L4;
	if (shr[1] == 5) goto L5;
	if (shr[1] == 6) goto L6;
	if (shr[1] == 7) goto L7;
	if (shr[1] == 8) goto L8;
	if (shr[1] == 9) goto L9;
L01:if (shr[1] == 10) goto L10;
	if (shr[1] == 11) goto L11;
	if (shr[1] == 12) goto L12;
	if (shr[1] == 13) goto L13;
	if (shr[1] == 14) goto L14;
	if (shr[1] == 15) goto L15;
	if (shr[1] == 16) goto L16;
	if (shr[1] == 17) goto L17;
	if (shr[1] == 18) goto L18;
	if (shr[1] == 19) goto L19;
L02:if (shr[1] == 20) goto L20;
	if (shr[1] == 21) goto L21;
	if (shr[1] == 22) goto L22;
	if (shr[1] == 23) goto L23;
	if (shr[1] == 24) goto L24;
	if (shr[1] == 25) goto L25;
	if (shr[1] == 26) goto L26;
	if (shr[1] == 27) goto L27;
	if (shr[1] == 28) goto L28;
	if (shr[1] == 29) goto L29;
L03:if (shr[1] == 30) goto L30;
	if (shr[1] == 31) goto L31;
	if (shr[1] == 32) goto L32;
	if (shr[1] == 33) goto L33;
	if (shr[1] == 34) goto L34;
	if (shr[1] == 35) goto L35;
	if (shr[1] == 36) goto L36;
	if (shr[1] == 37) goto L37;
	if (shr[1] == 38) goto L38;
    if (shr[1] == 39) goto L39;
L04:if (shr[1] == 40) goto L40;
	if (shr[1] == 41) goto L41;
	if (shr[1] == 42) goto L42;
	if (shr[1] == 43) goto L43;
    if (shr[1] == 44) goto L44;
    if (shr[1] == 45) goto L45;
    if (shr[1] == 46) goto L46;
    if (shr[1] == 47) goto L47;
    if (shr[1] == 48) goto L48;
    if (shr[1] == 49) goto L49;
L05:if (shr[1] == 50) goto L50;
    if (shr[1] == 51) goto L51;
    if (shr[1] == 52) goto L52;
    if (shr[1] == 53) goto L53;
    if (shr[1] == 54) goto L54;
    if (shr[1] == 55) goto L55;
    if (shr[1] == 56) goto L56;
    if (shr[1] == 57) goto L57;
    if (shr[1] == 58) goto L58;
    if (shr[1] == 59) goto L59;
L06:if (shr[1] == 60) goto L60;
    if (shr[1] == 61) goto L61;
    if (shr[1] == 62) goto L62;
    if (shr[1] == 63) goto L63;
    if (shr[1] == 64) goto L64;
    if (shr[1] == 65) goto L65;
    if (shr[1] == 66) goto L66;
    if (shr[1] == 67) goto L67;
    if (shr[1] == 68) goto L68;
	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[1] = sh_;
	if (sh[1] != 0) goto L100;	// sh_ != 0
	++shr[1];					// след. шаг сч.шр1
	if (shr[1] > 68) goto L0;	// число шагов режима
	sh[1] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 2;					// норма: "Откачка камеры завершена"
	shr[1] = 0;
	goto L100;
L1: SetOut(0,2,0x3700);         //закрыть кл1,2,3,4,5
    SetOut(0,3,0x03);           //закрыть кл6, кл Нап2
    SetOut(1,2,0x800);          //Открыть кл7
    if(zin[3]&0x200)            //ман в home?
        shr[1]=2;               //переход на шаг 3
    sh_=0;
    goto L101;
L2: OPMAN();                //Манипулятор в HOME
    goto L101;
L3: Klapan(0,&ShZatvor);						// Закрыть ЩЗ
    if(sh_)goto L101;
    shr[1]=67;
    if(zin[3]&0x1000)
        shr[1]=4;
    sh_=0;
    goto L101;
L4: VIDK_POD(0,0,0,1,10);//п/д в HOME
    goto L101;
L5: Klapan(0,&PP);						// Подъёмнки вниз
    goto L101;
L6: Klapan(1,&ZaslPD);						// Открыть заслонку п/д
    goto L101;
L7: Klapan(0,&ZaslII);						// Закрыть заслонку ИИ
    goto L101;
L8: Klapan(0,&ZaslM1);						// Закрыть заслонку М1
    goto L101;
L9: Klapan(0,&ZaslM2);						// Закрыть заслонку М2
    goto L101;
L10:Klapan(1,&FvnKam);						// Включить форнасос камеры
    if(sh_)goto L101;
    //SetOut(1,3,0x04);                      //Открыть кл8
    if(!(nasmod[19]))                      //есть разр раб с КН
        shr[1]=22;                         //переход на шаг 23
    sh_=0;
    goto L101;
L11:if(diagnS[2]&0x40)			// пока нет связи с КН
		goto L101;
    if((OTVET_KN_M[0]&0x900) != 0x900)	// КН не включен
	{
        sh_=0;
        goto L101;
    }
    shr[1]=22;
    sh_=0;
    goto L101;
L12:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L13:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6<=UVAK_KN)
    {
        shr[1]=17;
        goto L17_1;
    }
    sh_=0;
    goto L101;
L14:Klapan(0,&KlKam);						// Закрыть Фк-Кам
    goto L101;
L15:Klapan(0,&KlTmn);						// Закрыть Фк-ТМН
    goto L101;
L16:Klapan(1,&KlKN);						// Открыть Фк-КН
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L17:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6<=UVAK_KN)
    {
        diagn[21]&=(~0x08);                //сброс диагностики
L17_1:  shr[40]=1;
        sh[40]=1;
        shr[1]=21;
        sh_=0;
        goto L101;
    }
    if(!(out[4]&0x40))
    {
        shr[1]=18;
        goto L18_1;
    }
    sh_=0;
    goto L101;
L18:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5<=UVAKN_TMN)
    {
L18_1:  if(CT_1>T_K_KN)
            diagn[21]|=0x08;                //отказ "медленная фороткачка КН"
        shr[1]=16;
    }
    sh_=0;
    goto L101;
L19:Klapan(0,&KlKN);						// Закрыть Фк-КН
    goto L101;
L20:Klapan(1,&KlTmn);						// Открыть Фк-ТМН
    goto L101;
L21:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5>UVAKV_TMN)goto L101;
    shr[1]=14;
    sh_=0;
    goto L101;
L22:if(shr[40])goto L101;
    CT_KN=0;
    sh_=0;
    goto L101;
L23:Klapan(0,&KlKN);						// Закрыть Фк-КН
    goto L101;
L24:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=UVAK_KAM)
    {
        shr[1]=33;
    }
    sh_=0;
    goto L101;
L25:Klapan(0,&DZasl);					// закрыть ДЗ
    goto L101;
L26:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L27:Klapan(0,&KlTmn);						// Закрыть Фк-ТМН
    goto L101;
L28:Klapan(1,&KlKam);						// Открыть Фк-Кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L29:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=UVAK_KAM)
    {
        diagn[21]&=(~0x10);             //сброс диагностики
        shr[1]=33;
        sh_=0;
        goto L101;
    }
    if(!(out[4]&0x40))
    {
        shr[1]=30;
        goto L30_1;
    }
    sh_=0;
    goto L101;
L30:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5<=UVAKN_TMN)
    {
L30_1:  if(CT_1>T_K_KN)
            diagn[21]|=0x10;        //отказ "медленная фороткачка камеры"
        shr[1]=28;
    }
    sh_=0;
    goto L101;
L31:Klapan(0,&KlKam);						// Закрыть Фк-Кам
    goto L101;
L32:Klapan(1,&KlTmn);						// Открыть Фк-ТМН
    goto L101;
L33:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5>UVAKV_TMN) goto L101;
    shr[1]=26;
    sh_=0;
    goto L101;
L34:Klapan(0,&KlKam);						// Закрыть Фк-Кам
    if(sh_) goto L101;
    SetOut(1,3,0x04);                      //Открыть кл8
    goto L101;
L35:Klapan(1,&KlTmn);						// Открыть Фк-ТМН
    if(sh_) goto L101;
    CT_1=0;
    goto L101;
L36:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5<=UVAKV_TMN)
    {
        diagn[21]&=(~0x20);           //сброс диагностики
        shr[1]=66;
        sh_=0;
        goto L101;
    }
    if(CT_1>=T_KTMN)
        diagn[21]|=0x20;            //отказ "Медленная фороткачка ТМН"
    goto L101;
L36_1:SetOut(1,4,0x40);         //вкл ТМН
    CT_1=0;
    sh_=0;
    goto L101;
L37:if(zin[4]&0x20)             //ТМН норма?
    {
        diagn[21]&=(~0x40);           //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_1>T_KTMN_RAZGON)
        diagn[21]|=0x40;            //отказ "медленный выход на режим ТМН"
    goto L101;
L38:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=UVAK_KAM)
        shr[1]=47;
    sh_=0;
    goto L101;
L39:Klapan(0,&DZasl);					// закрыть ДЗ
    goto L101;
L40:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L41:Klapan(0,&KlTmn);						// Закрыть Фк-ТМН
    goto L101;
L42:Klapan(1,&KlKam);						// Открыть Фк-Кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L43:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=UVAK_KAM)
    {
        diagn[21]&=(~0x10);           //сброс диагностики
        shr[1]=47;
        sh_=0;
        goto L101;
    }
    if(!(out[4]&0x40))
    {
        shr[1]=44;
        goto L44_1;
    }
    sh_=0;
    goto L101;
L44:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L44_1:if(CT_1>T_K_KAM)
        diagn[21]|=0x10;            //отказ "Медленная фороткачка Камеры"
    shr[1]=42;
    sh_=0;
    goto L101;
L45:Klapan(0,&KlKam);						// Закрыть Фк-Кам
    goto L101;
L46:Klapan(1,&KlTmn);						// Открыть Фк-ТМН
    goto L101;
L47:if(diagnS[0]&0x10)			// пока нет связи с Д5
		goto L101;
    if(D_D5>UVAKV_TMN)goto L101;
    shr[1]=40;
    sh_=0;
    goto L101;
L48:Klapan(0,&KlKam);						// Закрыть Фк-Кам
    goto L101;
L49:Klapan(1,&KlTmn);						// Открыть Фк-ТМН
    if(sh_)goto L101;
    if((!(shr[2]))&&(!(shr[3])))
    {
        if((nasmod[4]==1)&&(nasmod[5]))
        {
            shr[29]=1;
            sh[29]=1;
        }
        else
        {
            shr[30]=1;
            sh[30]=1;
        }
    }
    if(nasmod[19]==1)
    {
        if(nasmod[0]<nasmod[1])
        {
            shr[1]=52;
            sh_=0;
            goto L101;
        }
    }
    sh_=0;
    goto L101;
L50:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L51:Klapan(1,&DZasl);					// Открыть ДЗ
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L52:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=nasmod[0])
    {
        diagn[21]&=(~0x80);           //сброс диагностики
        shr[1]=60;
        sh[1]=0;
        goto L101;
    }
    if(CT_1>=T_KKAM_V)
        diagn[21]|=0x80;            //отказ "медленная Высоковакуумная откачка камеры"
    goto L101;
L53:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=nasmod[1])
        shr[1]=56;
    sh_=0;
    goto L101;
L54:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L55:Klapan(1,&DZasl);					// Открыть ДЗ
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L56:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4<=nasmod[1])
    {
        diagn[21]&=(~0x80);          //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_1>=T_KKAM_V)
        diagn[21]|=0x80;            //отказ "медленная Высоковакуумная откачка камеры"
    goto L101;
L57:if(OTVET_KN_M[3]<=nasmod[20])
    {
        diagn[22]&=(~0x01);          //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_KN>=T_OTK_KN)
        diagn[22]|=0x01;            //отказ "Длительное время разгона КН"
    goto L101;
L58:Klapan(0,&DZasl);					// Закрыть ДЗ
    if(sh_) goto L101;
    SetOut(0,2,0x800);              //Закрыть кл7
    if(shr[29]) // есть режим нагрева
    {
        shr[30] = 1; // активировать режим 30
        sh[30] = 1;
    }
    goto L101;
L59:Klapan(1,&Zatvor);						// Открыть затвор
    goto L101;
L60:if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4>nasmod[0])goto L101;
    sh_=0;
    goto L101;
L61:VRR_GIS();//вкл разр раб вчг п/д
    if(sh_)goto L101;
    if(nasmod[7]!=1)
    {
        shr[1]=62;
        sh_=1;
        goto L62_1;
    }
    sh_=0;
    goto L101;
L62:VIDK_II(014000,04000,1,25,010);//вкл ИИ
    if(sh_)goto L101;
L62_1:if(nasmod[8]!=1)
    {
        shr[1]=63;
        sh_=1;
        goto L63_1;
    }
    goto L101;
L63:VIDK_BM1(014004 , 04000,1,6,010);//вкл БПМ1
    if(sh_)goto L101;
L63_1:if(nasmod[9]!=1)
    {
        shr[1]=64;
        sh_=1;
        goto L64_1;
    }
    goto L101;
L64:VIDK_BM2(014004 , 04000,1,8,010);//вкл БПМ2
    if(sh_)goto L101;
L64_1:if(!(shr[29]))
        shr[1]=65;
    sh_=0;
    goto L101;
L65:if(VRTEMP1!=1)
        goto L101;
    shr[30]=1;
    sh[30]=1;
    sh_=0;
    goto L101;
L66:if(shr[30])goto L101;
    shr[1]=68;
    sh_=0;
    goto L101;
L67:vkl_dist_tmn();//вкл дистанц управление ТМН
    if(sh_)goto L101;
    shr[1]=36;
    goto L36_1;
L68:pderj_v_ish();
    if(sh_)goto L101;
    shr[1]=3;
    goto L101;
}
//---------------------------------------------------------------------------
void R_2 ()            // Режим "Откачка шлюза"
{
	sh_ = sh[2];

	if (shr[2] == 1) goto L1;   if (shr[2] == 2) goto L2;
	if (shr[2] == 3) goto L3;   if (shr[2] == 4) goto L4;
	if (shr[2] == 5) goto L5;   if (shr[2] == 6) goto L6;
	if (shr[2] == 7) goto L7;   if (shr[2] == 8) goto L8;
    if (shr[2] == 9) goto L9;   if (shr[2] == 10) goto L10;
    if (shr[2] == 11) goto L11; if (shr[2] == 12) goto L12;
    if (shr[2] == 13) goto L13; if (shr[2] == 14) goto L14;
    if (shr[2] == 15) goto L15; if (shr[2] == 16) goto L16;
    if (shr[2] == 17) goto L17; if (shr[2] == 18) goto L18;
    if (shr[2] == 19) goto L19; if (shr[2] == 20) goto L20;
    if (shr[2] == 21) goto L21; if (shr[2] == 22) goto L22;
    if (shr[2] == 23) goto L23; if (shr[2] == 24) goto L24;
    if (shr[2] == 25) goto L25; if (shr[2] == 26) goto L26;
    if (shr[2] == 27) goto L27; if (shr[2] == 28) goto L28;
    if (shr[2] == 29) goto L29; if (shr[2] == 30) goto L30;
    if (shr[2] == 31) goto L31; if (shr[2] == 32) goto L32;
    if (shr[2] == 33) goto L33; if (shr[2] == 34) goto L34;
    if (shr[2] == 35) goto L35; if (shr[2] == 36) goto L36;

	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[2] = sh_;
	if (sh[2] != 0) goto L100;	// sh_ != 0
	++shr[2];					// след. шаг сч.шр2
	if (shr[2] > 36) goto L0;	// число шагов режима
	sh[2] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 1;					// норма: "Откачка шлюза завершена"
	shr[2] = 0;
	goto L100;
	
L1:	T_PROC=0;
    shr[1]=1;
    sh[1]=1;
    sh_=0;
    goto L101;
L2: if(shr[1])goto L101;
    sh_=0;
    goto L101;
L3: Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L4: Klapan(1,&DZasl);					// Открыть ДЗ
    goto L101;
L5: Klapan(0,&ZaslPD);//закрыть заслонку п/д
    if(sh_)goto L101;
    if((par[10][6])&&(par[10][12])&&(nasmod[8]==1))
    {
        N_ST=10;
        sh_=0;
        goto L101;
    }
    shr[2]=14;
    goto L14_1;
L6: Klapan(1,&ZaslM1);;//открыть заслонку М1
    if(sh_)goto L101;
    shr[27]=1;
    sh[27]=1;
    goto L101;
L7: if(VRDZASL!=1)goto L101;
    shr[24]=1;
    sh[24]=1;
    sh_=0;
    goto L101;
L8: if(VRUN!=1)goto L101;
    shr[35]=1;
    sh[35]=1;
    sh_=0;
    goto L101;
L9: if(VRBM1!=1)goto L101;
    CT_2=0;
    sh_=0;
    goto L101;
L10:if(CT_2<=par[N_ST][12])
    {
        T_PROC=CT_2;
        goto L101;
    }
    shr[37]=1;
    sh[37]=1;
    sh_=0;
    goto L101;
L11:if(shr[37])goto L101;
    sh_=0;
    goto L101;
L12:Klapan(0,&ZaslM1);;//закрыть заслонку М1
    if(sh_)goto L101;
    SBROSR_24();
    shr[25]=1;
    sh[25]=1;
    sh_=0;
    goto L101;
L13:if(shr[25])goto L101;
    sh_=0;
    goto L101;
L14:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))goto L101;
    T_PROC=0;
L14_1:if((par[11][7]==0)||(par[11][12]==0)||(nasmod[9]!=1))
    {
        shr[2]=23;
        sh_=1;
        goto L23_1;
    }
    N_ST=11;
    sh_=0;
    goto L101;
L15:Klapan(1,&ZaslM2);;//открыть заслонку М2
    if(sh_)goto L101;
    shr[27]=1;
    sh[27]=1;
    sh_=0;
    goto L101;
L16:if(VRDZASL!=1)goto L101;
    shr[24]=1;
    sh[24]=1;
    sh_=0;
    goto L101;
L17:if(VRUN!=1)goto L101;
    shr[36]=1;
    sh[36]=1;
    sh_=0;
    goto L101;
L18:if(VRBM2!=1)goto L101;
    CT_2=0;
    sh_=0;
    goto L101;
L19:if(CT_2<=par[N_ST][12])
    {
        T_PROC=CT_2;
        goto L101;
    }
    shr[37]=1;
    sh[37]=1;
    sh_=0;
    goto L101;
L20:if(shr[37])goto L101;
    sh_=0;
    goto L101;
L21:Klapan(0,&ZaslM2);;//закрыть заслонку М2
    if(sh_)goto L101;
    SBROSR_24();
    shr[25]=1;
    sh[25]=1;
    sh_=0;
    goto L101;
L22:if(shr[25])goto L101;
    sh_=0;
    goto L101;
L23:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))
        goto L101;
L23_1:T_PROC=0;
    if((par[12][6]==0)||(par[12][7]==0)||(par[12][12]==0)||(nasmod[8]!=1)||(nasmod[9]!=1))
    {
        shr[2]=34;
        sh_=1;
        goto L34_1;
    }
    N_ST=12;
    sh_=0;
    goto L101;
L24:Klapan(1,&ZaslM1);;//Открыть заслонку М1
    goto L101;
L25:Klapan(1,&ZaslM2);;//Открыть заслонку М2
    if(sh_)goto L101;
    shr[27]=1;
    sh[27]=1;
    sh_=0;
    goto L101;
L26:if(VRDZASL!=1)goto L101;
    shr[24]=1;
    sh[24]=1;
    sh_=0;
    goto L101;
L27:if(VRUN!=1)goto L101;
    shr[35]=1;
    sh[35]=1;
    shr[36]=1;
    sh[36]=1;
    sh_=0;
    goto L101;
L28:if((VRBM1!=1)||(VRBM2!=1))
        goto L101;
    CT_2=0;
    sh_=0;
    goto L101;
L29:if(CT_2<=par[N_ST][12])
    {
        T_PROC=CT_2;
        goto L101;
    }
    shr[37]=1;
    sh[37]=1;
    sh_=0;
    goto L101;
L30:if(shr[37])goto L101;
    sh_=0;
    goto L101;
L31:Klapan(0,&ZaslM1);//закрыть заслонку М1
    goto L101;
L32:Klapan(0,&ZaslM2);//закрыть заслонку М2
    if(sh_)goto L101;
    SBROSR_24();
    shr[25]=1;
    sh[25]=1;
    sh_=0;
    goto L101;
L33:if(shr[25])goto  L101;
    sh_=0;
    goto L101;
L34:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))
        goto L101;
    T_PROC=0;
L34_1:if((nasmod[19]!=1)||(nasmod[0]>=nasmod[1]))
    {
        shr[2]=36;
    }
    sh_=0;
    goto L101;
L35:Klapan(0,&DZasl);					// Закрыть ДЗ
    goto L101;
L36:Klapan(1,&Zatvor);						// Открыть затвор
    goto L101;

}
//---------------------------------------------------------------------------
void R_3 ()            // Режим "Рабочий цикл"
{
	sh_ = sh[3];

	if (shr[3] < 1 || shr[3] > 56) goto L100;
	if (shr[3] < 10) goto L00;
	if (shr[3] < 20) goto L01;
	if (shr[3] < 30) goto L02;
	if (shr[3] < 40) goto L03;
	goto L04;

L00:if (shr[3] == 1) goto L1;		if (shr[3] == 2) goto L2;
	if (shr[3] == 3) goto L3;		if (shr[3] == 4) goto L4;
	if (shr[3] == 5) goto L5;		if (shr[3] == 6) goto L6;
	if (shr[3] == 7) goto L7;		if (shr[3] == 8) goto L8;
	if (shr[3] == 9) goto L9;
L01:if (shr[3] == 10) goto L10;		if (shr[3] == 11) goto L11;
	if (shr[3] == 12) goto L12;		if (shr[3] == 13) goto L13;
	if (shr[3] == 14) goto L14;		if (shr[3] == 15) goto L15;
	if (shr[3] == 16) goto L16;		if (shr[3] == 17) goto L17;
	if (shr[3] == 18) goto L18;		if (shr[3] == 19) goto L19;
L02:if (shr[3] == 20) goto L20;		if (shr[3] == 21) goto L21;
	if (shr[3] == 22) goto L22;		if (shr[3] == 23) goto L23;
	if (shr[3] == 24) goto L24;		if (shr[3] == 25) goto L25;
	if (shr[3] == 26) goto L26;		if (shr[3] == 27) goto L27;
	if (shr[3] == 28) goto L28;		if (shr[3] == 29) goto L29;
L03:if (shr[3] == 30) goto L30;		if (shr[3] == 31) goto L31;
	if (shr[3] == 32) goto L32;		if (shr[3] == 33) goto L33;
	if (shr[3] == 34) goto L34;		if (shr[3] == 35) goto L35;
	if (shr[3] == 36) goto L36;		if (shr[3] == 37) goto L37;
	if (shr[3] == 38) goto L38;		if (shr[3] == 39) goto L39;
L04:if (shr[3] == 40) goto L40;		if (shr[3] == 41) goto L41;
	if (shr[3] == 42) goto L42;		if (shr[3] == 43) goto L43;
	if (shr[3] == 44) goto L44;		if (shr[3] == 45) goto L45;
	if (shr[3] == 46) goto L46;		if (shr[3] == 47) goto L47;
	if (shr[3] == 48) goto L48;		if (shr[3] == 49) goto L49;
	if (shr[3] == 50) goto L50;		if (shr[3] == 51) goto L51;
	if (shr[3] == 52) goto L52;     if (shr[3] == 53) goto L53;
    if (shr[3] == 54) goto L54;     if (shr[3] == 55) goto L55;
    if (shr[3] == 56) goto L56;
	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[3] = sh_;
	if (sh[3] != 0) goto L100;		// sh_ != 0
	++shr[3];						// след. шаг сч.шр2
	if (shr[3] > 56) goto L0;		// число шагов режима
	sh[3] = 1;
L100:return;						// возврат в "кольцо"

L0: norma = 3;						// норма: "РЦ завершен"
	shr[3] = 0;
    sh[3] = 0;
	goto L100;

L1: N_ST=0;
    T_PROC=0;
    PR_OTP=0;
    shr[1]=1;
    sh[1]=1;
    sh_=0;
    goto L101;
L2: if(shr[1])goto L101;
    if((nasmod[3]==0)&&(nasmod[6]!=0))
    {
        if(nasmod[6]==1)
        {
            if(nasmod[4]==1)
            {
                shr[31]=1;
                sh[31]=1;
            }
        }
        else
        {
            shr[38]=1;
            sh[38]=1;
        }
    }
    sh_=0;
    goto L101;
L3: Klapan(0,&KlShl);				// закрыть ФК-Шл
	if(sh_) goto L101;
    if(!(zin[2]&0x8000))
    {
        shr[3]=6;
        sh_=1;
        goto L6_1;
    }
    SetOut(1,4,0x8000);              //Открыть Кл Нап1
    CT_3=0;
    sh_=0;
    goto L101;
L4: if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
	if(D_D1>UATM_D1)
    {
        diagn[22]&=(~0x02);               //сброс диагностики
        sh_=0;
        CT_3=0;
        goto L101;
    }
    if(CT_3>=T_KNAP)
        diagn[22]|=0x02;                //отказ Медленный напуск в шлюз
    goto L101;
L5:if(CT_3<=T_NAPUSK)goto L101;
    sh_=0;
    //SetOut(1,2,0x08);               //вкл звонок
    goto L101;
L6: if(zin[2]&0x8000)goto L101;
    SetOut(0,2,0x08);                //выкл звонок
    SetOut(0,4,0x8000);                 //Закрыть Кл Нап1
L6_1:otvet=0;
    sh_=0;
    goto L101;
L7:if(!(zin[2]&0x8000))goto L101;
    if(otvet==0)goto L101;
    shr[19]=1;
    sh[19]=1;
    sh_=0;
    goto L101;
L8:if(shr[19])goto L101;
    if(otvet==2)
    {
        shr[3]=46;
        sh_=0;
        goto L101;
    }
    shr[3]=10;
    sh_=0;
    goto L101;
L9:sh_=0;
    goto L101;
L10:sh_=0;
    goto L101;
L11:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if(D_D4>nasmod[0])goto L101;
    sh_=0;
    goto L101;
L12:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L13:Klapan(1,&DZasl);					// Открыть ДЗ
    goto L101;
L14:Klapan(0,&KlShl);			// закрыть ФК-Шл
	goto L101;
L15:Klapan(1,&ShZatvor);			// открыть ШЗ
	goto L101;
L16:VPMAN();                //Манипулятор в Камеру
    goto L101;
L17:Klapan(1,&PP);			// подёмник вверх
	goto L101;
L18:OPMAN();                //Манипулятор в HOME
    goto L101;
L19:Klapan(0,&ShZatvor);			// закрыть ШЗ
	goto L101;
L20:Klapan(0,&FvnShl);//отключить форнасос шлюза
	goto L101;
L21:Klapan(0,&PP);			// подёмник вниз
	goto L101;
L22:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4<nasmod[0])||(D_D4<nasmod[1]))
        sh_=0;
    goto L101;
L23:if(nasmod[19]!=1)
        shr[3]=27;
    sh_=0;
    goto L101;
L24:if(nasmod[0]>=nasmod[1])
        shr[3]=27;
    sh_=0;
    goto L101;
L25:Klapan(0,&DZasl);					// Закрыть ДЗ
    goto L101;
L26:Klapan(1,&Zatvor);						// Открыть затвор
    goto L101;
L27:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if(D_D4>nasmod[0])goto L101;
        sh_=0;
    goto L101;
L28:Klapan(0,&Zatvor);						// Закрыть затвор
    goto L101;
L29:Klapan(1,&DZasl);					// Открыть ДЗ
    if(sh_)goto L101;
    if(nasmod[3]==1)
    {
        PR_NALADKA=1;
        sh_=0;
        goto L101;
    }
    shr[4]=1;
    sh[4]=1;
    shr[3]=30;
    sh_=0;
    goto L101;
L30:if(nasmod[3]==1)goto L101;
    PR_NALADKA=0;
    shr[3]=31;
    sh_=1;
    goto L31_1;
L31:if(shr[4])goto L101;
L31_1:if(shr[33])
    {
        shr[34]=1;
        sh[34]=1;
    }
    if(shr[36])
    {
        shr[37]=1;
        sh[37]=1;
    }
    SBROSR_28();
    RRGOff(ObjRRG[0]);				//сброс РРГ1
    RRGOff(ObjRRG[1]);				//сброс РРГ2
    RRGOff(ObjRRG[2]);				//сброс РРГ3
    RRGOff(ObjRRG[3]);				//сброс РРГ4
    SetOut(0,2,0x800);              //закрыть кл7
    SBROSR_24();
    sh_=0;
    goto L101;
L32:if((shr[37])||(shr[34]))goto L101;
    sh_=0;
    goto L101;
L33:Klapan(0,&ZaslII);;//Закрыть заслонку ИИ
    goto L101;
L34:Klapan(0,&ZaslM1);//Закрыть заслонку М1
    goto L101;
L35:Klapan(0,&ZaslM2);//Закрыть заслонку М2
    if(sh_) goto L101;
    if(shr[16])
    {
        shr[17]=1;
        sh[17]=1;
        sh_=0;
        goto L101;
    }
    shr[3]=53;
    sh_=0;
    goto L101;
L36:if(shr[17])goto L101;
    shr[3]=53;
    sh_=0;
    goto L101;
L37:VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    if (sh_) goto L101;
    shr[25]=1;
    sh[25]=1;
    goto L101;
L38:if(shr[25])goto L101;
    shr[19] = 1; // активизация "Откачка шлюза"
    sh[19] = 1;
    sh_=0;
    goto L101;
L39:if(diagnS[0]&0x08) goto L101;// пока нет связи с D4
    if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1])) goto L101;
    sh_=0;
    goto L101;
L40:if(shr[19]) goto L101;
    sh_=0;
    goto L101;
L41:Klapan(0,&KlShl);			// Закрыть ФК-Шл
	goto L101;
L42:Klapan(1,&ShZatvor);			// Открыть ШЗ
	goto L101;
L43:Klapan(1,&PP);			// подёмник вверх
	goto L101;
L44:VPMAN();                //Манипулятор в камеру
    if(sh_) goto L101;
    shr[3] = 55; // переход на шаг 56
    goto L101;
L45:Klapan(0,&PP);			// подёмник вниз
	goto L101;
L46:OPMAN();                //Манипулятор в HOME
    if(sh_)goto L101;
    shr[3]=54;              //переход на шаг 55
    goto L101;
L47:Klapan(0,&KlShl);			// Закрыть ФК-Шл
	goto L101;
L48:Klapan(0,&FvnShl);			// Откл фвн шл
	if(sh_)goto L101;
    if(shr[38])
    {
        shr[39]=1;
        sh[39]=1;
    }
    sh_=0;
    goto L101;
L49:if(shr[39])goto L101;
    if(shr[31])
    {
        shr[32]=1;
        sh[32]=1;
    }
    sh_=0;
    goto L101;
L50:if(shr[32])goto L101;
    N_ST=0;
    if(nasmod[19]==1)
    {
        if(nasmod[0]<nasmod[1])
        {
            sh_ = 0;
            goto L101;
        }
    }
    goto L0;                        // ВЫХОД !!!
L51:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if(D_D4>=nasmod[1])goto L101;
        sh_=0;
    goto L101;
L52:Klapan(0,&DZasl);					// Закрыть ДЗ
    goto L101;
L53:Klapan(1,&Zatvor);						// Открыть затвор
    if(sh_)goto L101;
    goto L0;                        // ВЫХОД !!!
L54:pderj_v_ish();
    if(sh_)goto L101;
    shr[3]=36;
    goto L101;
L55:Klapan(0,&ShZatvor);			// закрыть ШЗ
    if(sh_)goto L101;
    shr[3]=2;                       //переход на шаг 3
    goto L101;
L56:Klapan(0,&FvnShl); //отключить форнасос шлюза
    if(sh_) goto L101;
    shr[3] = 44; // переход на шаг 45
    goto L101;
}
//---------------------------------------------------------------------------
void R_4()			//Режим "Технологический процесс"
{
	sh_ = sh[4];

    if (shr[4] < 1 || shr[4] > 88) goto L100;
	if (shr[4] < 10) goto L00;
	if (shr[4] < 20) goto L01;
    if (shr[4] < 30) goto L02;
    if (shr[4] < 40) goto L03;
    if (shr[4] < 50) goto L04;
    if (shr[4] < 60) goto L05;
    if (shr[4] < 70) goto L06;
    if (shr[4] < 80) goto L07;
	else goto L08;

L00:if (shr[4] == 1) goto L1;
	if (shr[4] == 2) goto L2;
	if (shr[4] == 3) goto L3;
	if (shr[4] == 4) goto L4;
	if (shr[4] == 5) goto L5;
	if (shr[4] == 6) goto L6;
	if (shr[4] == 7) goto L7;
	if (shr[4] == 8) goto L8;
	if (shr[4] == 9) goto L9;
L01:if (shr[4] == 10) goto L10;
	if (shr[4] == 11) goto L11;
	if (shr[4] == 12) goto L12;
	if (shr[4] == 13) goto L13;
	if (shr[4] == 14) goto L14;
	if (shr[4] == 15) goto L15;
	if (shr[4] == 16) goto L16;
	if (shr[4] == 17) goto L17;
	if (shr[4] == 18) goto L18;
	if (shr[4] == 19) goto L19;
L02:if (shr[4] == 20) goto L20;
	if (shr[4] == 21) goto L21;
	if (shr[4] == 22) goto L22;
	if (shr[4] == 23) goto L23;
	if (shr[4] == 24) goto L24;
	if (shr[4] == 25) goto L25;
	if (shr[4] == 26) goto L26;
	if (shr[4] == 27) goto L27;
	if (shr[4] == 28) goto L28;
	if (shr[4] == 29) goto L29;
L03:if (shr[4] == 30) goto L30;
	if (shr[4] == 31) goto L31;
	if (shr[4] == 32) goto L32;
	if (shr[4] == 33) goto L33;
	if (shr[4] == 34) goto L34;
	if (shr[4] == 35) goto L35;
	if (shr[4] == 36) goto L36;
	if (shr[4] == 37) goto L37;
	if (shr[4] == 38) goto L38;
	if (shr[4] == 39) goto L39;
L04:if (shr[4] == 40) goto L40;
	if (shr[4] == 41) goto L41;
	if (shr[4] == 42) goto L42;
	if (shr[4] == 43) goto L43;
	if (shr[4] == 44) goto L44;
	if (shr[4] == 45) goto L45;
	if (shr[4] == 46) goto L46;
	if (shr[4] == 47) goto L47;
	if (shr[4] == 48) goto L48;
	if (shr[4] == 49) goto L49;
L05:if (shr[4] == 50) goto L50;
	if (shr[4] == 51) goto L51;
	if (shr[4] == 52) goto L52;
	if (shr[4] == 53) goto L53;
	if (shr[4] == 54) goto L54;
	if (shr[4] == 55) goto L55;
	if (shr[4] == 56) goto L56;
	if (shr[4] == 57) goto L57;
	if (shr[4] == 58) goto L58;
	if (shr[4] == 59) goto L59;
L06:if (shr[4] == 60) goto L60;
	if (shr[4] == 61) goto L61;
	if (shr[4] == 62) goto L62;
	if (shr[4] == 63) goto L63;
    if (shr[4] == 64) goto L64;
    if (shr[4] == 65) goto L65;
    if (shr[4] == 66) goto L66;
    if (shr[4] == 67) goto L67;
    if (shr[4] == 68) goto L68;
    if (shr[4] == 69) goto L69;
L07:if (shr[4] == 70) goto L70;
	if (shr[4] == 71) goto L71;
	if (shr[4] == 72) goto L72;
	if (shr[4] == 73) goto L73;
    if (shr[4] == 74) goto L74;
    if (shr[4] == 75) goto L75;
    if (shr[4] == 76) goto L76;
    if (shr[4] == 77) goto L77;
    if (shr[4] == 78) goto L78;
    if (shr[4] == 79) goto L79;
L08:if (shr[4] == 80) goto L80;
	if (shr[4] == 81) goto L81;
	if (shr[4] == 82) goto L82;
	if (shr[4] == 83) goto L83;
    if (shr[4] == 84) goto L84;
    if (shr[4] == 85) goto L85;
    if (shr[4] == 86) goto L86;
    if (shr[4] == 87) goto L87;
    if (shr[4] == 88) goto L88;

	goto L100;				//выход
	
	// конечный диспетчер режима	
L101:sh[4] = sh_;
	if (sh[4] != 0) goto L100;	// sh_ != 0	
	++shr[4];					// след. шаг сч.шр1
	if (shr[4] > 88) goto L0;	// число шагов режима
	sh[4] = 1;
L100:return;					//возврат в "кольцо"

L0:	norma = 8;					//норма: "Тех.процесс завершен"	
	shr[4] = 0;
    sh[4] = 0;
	goto L100;					

L1: if(shr[31])
    {
        sh_=0;
        goto L101;
    }
    shr[4]=2;
    goto L2_1;
L2: if(VRTEMP2!=1)goto L101;
L2_1:if(shr[38])
    {
        sh_=0;
        goto L101;
    }
    shr[4]=3;
    goto L3_1;
L3: if(!(zin[2]&0x10))
        goto L101;
L3_1:if(par[1][12])
    {
        N_ST=1;
        CT_4=0;
        shr[4]=5;
        sh_=0;
        goto L101;
    }
    shr[4]=6;
    goto L6_1;
L4: if(!(ObjRRG[3]->vRRG))goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L5: if(CT_4<=T_SBROSHE)goto L101;
L5_1:    SetOut(0,2,0x2000);             //закрыть кл5
    SetOut(1,2,0x1000);             //открыть кл4
    PR_RG4=0;
L6: if(CT_4<=par[N_ST][12])
    {
        T_PROC=CT_4;
        goto L101;
    }
    T_PROC=0;
L6_1:if((par[2][12])&&(par[2][8]))
    {
        N_ST=2;
        sh_=0;
        goto L101;
    }
    shr[4]=13;
    goto L13_1;
L7: Klapan(1,&ZaslPD);//открыть заслонку п/д
    if(sh_)goto L101;
    shr[27]=1;
    sh[27]=1;
    sh_=0;
    goto L101;
L8: if(VRDZASL!=1)goto L101;
    shr[24]=1;
    sh[24]=1;
    sh_=0;
    goto L101;
L9: if(VRUN!=1)goto L101;
    shr[28]=1;
    sh[28]=1;
    sh_=0;
    goto L101;
L10:if(VRGIS!=1)goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L11:if(CT_4<=par[N_ST][12])
    {
        T_PROC=CT_4;
        goto L101;
    }
    SBROSR_28();
    SBROSR_24();
    shr[25]=1;
    sh[25]=1;
    sh_=0;
    goto L101;
L12:if(shr[25])goto L101;
    sh_=0;
    goto L101;
L13:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))goto L101;
    T_PROC=0;
L13_1:if((!(par[3][12]))||(!(par[3][0]))||(!(par[3][5]))||(nasmod[7]!=1))
    {
        shr[4]=24;
        goto L24_1;
    }
    N_ST=3;
    sh_=0;
    goto L101;
L14:Klapan(1,&ZaslPD);//открыть заслонку п/д
    if(sh_)goto L101;
    shr[4]=63;
    goto L101;
L15:VIDK_POD(0,ABS,nasmod[21],0,10);//подъём п/д в раб поз
    if(sh_)goto L101;
    shr[16]=1;
    sh[16]=1;
    sh_=0;
    goto L101;
L16:Klapan(1,&ZaslII);//открыть заслонку ии
    if(sh_)goto L101;
    shr[27]=1;
    sh[27]=1;
    sh_=0;
    goto L101;
L17:if(VRDZASL!=1)goto L101;
    shr[20]=1;
    sh[20]=1;
    sh_=0;
    goto L101;
L18:if(ObjRRG[0]->vRRG!=1)goto L101;
    shr[33]=1;
    sh[33]=1;
    sh_=0;
    goto L101;
L19:if(VRII!=1)goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L20:if(CT_4<=par[N_ST][12])
    {
       T_PROC =CT_4;
        goto L101;
    }
    shr[34]=1;
    sh[34]=1;
    sh_=0;
    goto L101;
L21:if(shr[34])goto L101;
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7
    sh_=0;
    goto L101;
L22:Klapan(0,&ZaslII);//закрыть заслонку ии
    if(sh_)goto L101;
    shr[25]=1;
    sh[25]=1;
    sh_=0;
    goto L101;
L23:if(shr[25])goto L101;
    sh_=0;
    goto L101;
L24:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))goto L101;
    T_PROC=0;
L24_1:N_ST=4;
L24_2:if((par[N_ST][12])&&(((par[N_ST][6])&&(nasmod[8]))||((par[N_ST][7])&&(nasmod[9]))))
    {
        if(!(par[N_ST][14]))
        {
            shr[4]=43;
            sh_=0;
            goto L101;
        }
        PR_OTP=1;
        if(nasmod[22])
        {
            shr[4]=67;              //переход на шаг 68
            sh_=0;
            goto L101;
        }
        if(shr[16])
        {
            shr[17]=1;
            sh[17]=1;
            sh_=0;
            goto L101;
        }
        shr[4]=64;            //переход на шаг 65
        sh_=0;
        goto L101;

    }
    shr[4]=88;                      //выход
    sh_=0;
    goto L101;
L25:if(shr[17])goto L101;
    sh_=0;
    shr[4]=64;
    goto L101;
L26:VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    goto L101;
L27:Klapan(0,&ZaslPD);//закрыть заслонку п/д
    if(sh_)goto L101;
    shr[27]=1;
    sh[27]=1;
    sh_=0;
    goto L101;
L28:if(VRDZASL!=1)goto L101;
    if(par[N_ST][1])
    {
        shr[21]=1;
        sh[21]=1;
        sh_=0;
        goto L101;
    }
    shr[4]=29;
    goto L29_1;
L29:if(ObjRRG[1]->vRRG!=1)goto L101;
L29_1:shr[24]=1;
    sh[24]=1;
    sh_=0;
    goto L101;
L30:if(VRUN!=1)goto L101;
    if((par[N_ST][6])&&(par[N_ST][7]))
    {
        sh_=0;
        goto L101;
    }
    if(par[N_ST][6])
    {
        shr[4]=33;
        sh_=0;
        goto L101;
    }
    shr[4]=35;
    sh_=0;
    goto L101;
L31:Klapan(1,&ZaslM1);//открыть заслонку М1
    goto L101;
L32:Klapan(1,&ZaslM2);//открыть заслонку М2
    if(sh_) goto L101;
    shr[35]=1;
    sh[35]=1;
    shr[36]=1;
    sh[36]=1;
    sh_=0;
    goto L101;
L33:if((VRBM1!=1)||(VRBM2!=1))goto L101;
    shr[4]=37;
    goto L37_1;
L34:Klapan(1,&ZaslM1);//открыть заслонку М1
    if(sh_)goto L101;
    shr[35]=1;
    sh[35]=1;
    sh_=0;
    goto L101;
L35:if(VRBM1!=1)goto L101;
    shr[4]=37;
    goto L37_1;
L36:Klapan(1,&ZaslM2);//открыть заслонку М2
    if(sh_)goto L101;
    shr[36]=1;
    sh[36]=1;
    sh_=0;
    goto L101;
L37:if(VRBM2!=1)goto L101;
L37_1:CT_4=0;
    sh_=0;
    goto L101;
L38:if(CT_4<=par[N_ST][14])
    {
      T_PROC  =CT_4;
        goto L101;
    }
    shr[37]=1;
    sh[37]=1;
    sh_=0;
    goto L101;
L39:if(shr[37])goto L101;
    RRGOff(ObjRRG[1]);	// отключение РРГ2

    SBROSR_24();
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7
    sh_=0;
    goto L101;
L40:Klapan(0,&ZaslM1);//закрыть заслонку М1
    goto L101;
L41:Klapan(0,&ZaslM2);//закрыть заслонку М2
    if(sh_)goto L101;
    shr[25]=1;
    sh[25]=1;
    sh_=0;
    goto L101;
L42:if(shr[25])goto L101;
    sh_=0;
    goto L101;
L43:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))goto L101;
    T_PROC=0;
    PR_OTP=0;
    sh_=0;
    goto L101;
L44:Klapan(1,&ZaslPD);//открыть заслонку п/д
    if(sh_)goto L101;
    if(shr[16])
    {
        shr[17]=1;
        sh[17]=1;
        sh_=0;
        goto L101;
    }
    shr[4]=65;
    sh_=0;
    goto L101;
L45:if(shr[17])goto L101;
    sh_=0;
    shr[4]=65;
    goto L101;
L46:VIDK_POD(0,ABS,nasmod[16],0,10);//подъём п/д в раб поз
    if(sh_)goto L101;
    if(nasmod[2])
    {
        if(shr[23])
        {
            shr[4]=5;               //переход на шаг 5_1
            goto L5_1;
        }
        PR_RG4=1;
        shr[23]=1;
        sh[23]=1;
        shr[4]=3;                   //переход на шаг 4
        sh_=0;
        goto L101;
    }
    shr[16]=1;
    sh[16]=1;
    shr[27]=1;
    sh[27]=1;
    sh_=0;
    goto L101;
L47:if(VRDZASL!=1)goto L101;
    if(par[N_ST][1])
    {
        shr[21]=1;
        sh[21]=1;
    }
    else
        ObjRRG[1]->vRRG=1;
    if(par[N_ST][2])
    {
        shr[22]=1;
        sh[22]=1;
    }
    else
        ObjRRG[2]->vRRG=1;
    sh_=0;
    goto L101;
L48:if((ObjRRG[1]->vRRG==1)&&(ObjRRG[2]->vRRG==1))
    {
        shr[24]=1;
        sh[24]=1;
        sh_=0;
        goto L101;
    }
    goto L101;
L49:if(VRUN!=1)goto L101;
    if(par[N_ST][8])
    {
        shr[28]=1;
        sh[28]=1;
    }
    else VRGIS=1;
    if((par[N_ST][6])&&(par[N_ST][7]))
    {
        sh_=0;
        goto L101;
    }
    if(par[N_ST][6])
    {
        shr[4]=52;
        sh_=0;
        goto L101;
    }
    shr[4]=54;
    sh_=0;
    goto L101;
L50:Klapan(1,&ZaslM1);//Открыть заслонку М1
    goto L101;
L51:Klapan(1,&ZaslM2);//Открыть заслонку М2
    if(sh_) goto L101;
    shr[35]=1;
    sh[35]=1;
    shr[36]=1;
    sh[36]=1;
    sh_=0;
    goto L101;
L52:if((VRBM1!=1)||(VRBM2!=1))goto L101;
    shr[4]=56;
    sh_=0;
    goto L101;
L53:Klapan(1,&ZaslM1);//открыть заслонку М1
    if(sh_)goto L101;
    shr[35]=1;
    sh[35]=1;
    sh_=0;
    goto L101;
L54:if(VRBM1!=1)goto L101;
    shr[4]=56;
    sh_=0;
    goto L101;
L55:Klapan(1,&ZaslM2);//Открыть заслонку М2
    if(sh_) goto L101;
    shr[36]=1;
    sh[36]=1;
    sh_=0;
    goto L101;
L56:if(VRBM2!=1)goto L101;
    sh_=0;
    goto L101;
L57:if(VRGIS!=1)goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L58:if(CT_4<=par[N_ST][12])
    {
       T_PROC =CT_4;
        goto L101;
    }
    SetOut(0,1,0x50); // закрыть заслонки М1 и М2
    SetOut(1,1,0xA0);
    CT_4 = 0;
    shr[4] = 66; // переход на шаг 67
    sh_=0;
    goto L101;
L59:if(shr[37])goto L101;
    SBROSR_28();
    SBROSR_24();
    RRGOff(ObjRRG[1]);	// отключение РРГ2
    RRGOff(ObjRRG[2]);	// отключение РРГ3
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7
    sh_=0;
    goto L101;
L60:Klapan(0,&ZaslM1);//Закрыть заслонку М1
    goto L101;
L61:Klapan(0,&ZaslM2);//Закрыть заслонку М2
    if (sh_) goto L101;
    shr[25]=1;
    sh[25]=1;
    goto L101;
L62:if(shr[25])goto L101;
    if(shr[23])
    {
        PR_RG4=1;
        SetOut(1,2,0x2000);             //открыть кл5
        SetOut(0,2,0x1000);             //закрыть кл4
    }
    sh_=0;
    goto L101;
L63:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))goto L101;
    if(shr[23])
    {
        PR_RG4=0;
        SetOut(0,2,0x2000);             //закрыть кл5
        SetOut(1,2,0x1000);             //открыть кл4
    }
    T_PROC=0;
    N_ST++;
    if(N_ST>N_ST_MAX)
    {
        goto L0; // ВЫХОД!!!
    }
    shr[4]=24;
    goto L24_2;
L64:pderj_v_ish();//Вращение п/д в исх
    if(sh_)goto L101;
    shr[4]=14;
    goto L101;
L65:pderj_v_ish();//Вращение п/д в исх
    if(sh_)goto L101;
    shr[4]=25;
    goto L101;
L66:pderj_v_ish();//Вращение п/д в исх
    if(sh_)goto L101;
    shr[4]=45;
    goto L101;
L67:if(CT_4 <= 3) goto L101;
    shr[37]=1;
    sh[37]=1;
    shr[4] = 58; // переход на шаг 59
    sh_ = 0;
    goto L101;
L68:if(TEK_ABS_POD==nasmod[16])
    {
        shr[4]=72;
        goto L72_1;         //переход на шаг 72_1
    }
    if(shr[16])
    {
        shr [17]=1;         //активиз. режима 17
        sh  [17]=1;         //"Отключение вращения п/д"
        sh_=0;
        goto L101;
    }
    shr[4]=69;              //переход на шаг 70
    sh_=0;
    goto L101;
L69:if(shr[17])goto L101;
    sh_=0;
    goto L101;
L70:pderj_v_ish();//Вращение п/д в исх
    goto L101;
L71:Klapan(1,&ZaslPD);//Открыть заслонку п/д
    goto L101;
L72:VIDK_POD(0,ABS,nasmod[16],0,10);//Подъём п/д в рабоч. позицию напыления
    if(sh_)goto L101;
L72_1:if(nasmod[2]==0)
    {
        shr [16]=1;         //аткивиз. режима 16
        sh  [16]=1;         //"Вращение п/д"
        shr [27]=1;         //активиз. режима 27
        sh  [27]=1;         //"ДЗ на угол"
        shr [4]=74;         //переход на шаг 75
        sh_=0;
        goto L101;
    }
    if(!(shr[23]))
    {
        PR_RG4=1;
        shr [23]=1;         //активиз режим 23
        sh  [23]=1;         //"РРГ4"
        CT_4=0;
        sh_=0;
        goto L101;
    }
    SetOut(0,2,0x2000);     //Закрыть Кл5
    SetOut(1,2,0x1000);     //Открыть Кл4
    PR_RG4=0;
    shr [16]=1;         //аткивиз. режима 16
    sh  [16]=1;         //"Вращение п/д"
    shr [27]=1;         //активиз. режима 27
    sh  [27]=1;         //"ДЗ на угол"
    shr [4]=74;         //переход на шаг 75
    sh_=0;
    goto L101;
L73:if(ObjRRG[3]->vRRG!=1)goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L74:if(CT_4<=T_SBROSHE)goto L101;
    SetOut(0,2,0x2000);     //Закрыть Кл5
    SetOut(1,2,0x1000);     //Открыть Кл4
    PR_RG4=0;
    shr [16]=1;         //аткивиз. режима 16
    sh  [16]=1;         //"Вращение п/д"
    shr [27]=1;         //активиз. режима 27
    sh  [27]=1;         //"ДЗ на угол"
    sh_=0;
    goto L101;
L75:if(VRDZASL!=1)goto L101;
    if(par[N_ST][1])
    {
        shr[21]=1;
        sh[21]=1;
    }
    else
        ObjRRG[1]->vRRG=1;
    if(par[N_ST][2])
    {
        shr[22]=1;
        sh[22]=1;
    }
    else
        ObjRRG[2]->vRRG=1;
    sh_=0;
    goto L101;
L76:if((ObjRRG[1]->vRRG==1)&&(ObjRRG[2]->vRRG==1))
    {
        shr[24]=1;
        sh[24]=1;
        sh_=0;
        goto L101;
    }
    goto L101;
L77:if(VRUN!=1)goto L101;
    if(par[N_ST][8])
    {
        shr[28]=1;
        sh[28]=1;
    }
    else VRGIS=1;
    sh_=0;
    goto L101;
L78:if(VRGIS!=1)goto L101;
    if((par[N_ST][6])&&(par[N_ST][7]))
    {
        sh_=0;
        goto L101;
    }
    if(par[N_ST][6])
    {
        shr[4]=81;
        sh_=0;
        goto L101;
    }
    shr[4]=83;
    sh_=0;
    goto L101;
L79:Klapan(0,&ZaslM1);//закрыть заслонку М1
    goto L101;
L80:Klapan(0,&ZaslM2);//закрыть заслонку М2
    if(sh_) goto L101;
    shr [35]=1;
    sh  [35]=1;
    shr [36]=1;
    sh  [36]=1;
    sh_=0;
    goto L101;
L81:if((VRBM1!=1)||(VRBM2!=1))goto L101;
    CT_4=0;
    shr[4]=85;          //переход на шаг 86
    sh_=0;
    goto L101;
L82:Klapan(0,&ZaslM1);//Закрыть заслонку М1
    if(sh_)goto L101;
    shr [35]=1;
    sh  [35]=1;
    sh_=0;
    goto L101;
L83:if(VRBM1!=1)goto L101;
    CT_4=0;
    shr[4]=85;
    sh_=0;
    goto L101;
L84:Klapan(0,&ZaslM2);//Закрыть заслонку М2
    if(sh_)goto L101;
    shr [36]=1;
    sh  [36]=1;
    goto L101;
L85:if(VRBM2!=1)goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L86:if(CT_4<=par[N_ST][14])
    {
      T_PROC  =CT_4;
        goto L101;
    }
    PR_OTP=0;
    if(shr[35])
    {
        SetOut(1,1,0x10);       //Открыть заслонку М1
        SetOut(0,1,0x20);
    }
    if(shr[36])
    {
        SetOut(1,1,0x40);       //Открыть заслонку М2
        SetOut(0,1,0x80);
    }
    if(shr[35])
    {
        sh_=0;
        goto L101;
    }
    sh_=1;
    shr[4]=87;
    goto L87_1;
L87:Klapan(1,&ZaslM1);//Открыть заслонку М1
    if(sh_)goto L101;
L87_1:if(shr[36])
    {
        sh_=0;
        goto L101;
    }
    CT_4=0;
    shr[4]=57;              //переход на шаг 58
    sh_=0;
    goto L101;
L88:Klapan(1,&ZaslM2);//Открыть заслонку М2
    if(sh_)goto L101;
    CT_4=0;
    shr[4]=57;              //переход на шаг 58
    goto L101;

}
//---------------------------------------------------------------------------
void R_5()            // Режим "Сброс РЦ"
{
	sh_ = sh[5];

    if (shr[5] < 1 || shr[5] > 38) goto L100;
	if (shr[5] < 10) goto L00;
	if (shr[5] < 20) goto L01;
    if (shr[5] < 30) goto L02;
    goto L03;

L00:if (shr[5] == 1) goto L1;
	if (shr[5] == 2) goto L2;
	if (shr[5] == 3) goto L3;
	if (shr[5] == 4) goto L4;
	if (shr[5] == 5) goto L5;
	if (shr[5] == 6) goto L6;
	if (shr[5] == 7) goto L7;
    if (shr[5] == 8) goto L8;
    if (shr[5] == 9) goto L9;
L01:if (shr[5] == 10) goto L10;
    if (shr[5] == 11) goto L11;
	if (shr[5] == 12) goto L12;
	if (shr[5] == 13) goto L13;
	if (shr[5] == 14) goto L14;
	if (shr[5] == 15) goto L15;
	if (shr[5] == 16) goto L16;
	if (shr[5] == 17) goto L17;
    if (shr[5] == 18) goto L18;
    if (shr[5] == 19) goto L19;
L02: if (shr[5] == 20) goto L20;
    if (shr[5] == 21) goto L21;
	if (shr[5] == 22) goto L22;
	if (shr[5] == 23) goto L23;
	if (shr[5] == 24) goto L24;
	if (shr[5] == 25) goto L25;
	if (shr[5] == 26) goto L26;
    if (shr[5] == 27) goto L27;
    if (shr[5] == 28) goto L28;
    if (shr[5] == 29) goto L29;
L03: if (shr[5] == 30) goto L30;
    if (shr[5] == 31) goto L31;
	if (shr[5] == 32) goto L32;
	if (shr[5] == 33) goto L33;
	if (shr[5] == 34) goto L34;
	if (shr[5] == 35) goto L35;
	if (shr[5] == 36) goto L36;
    if (shr[5] == 37) goto L37;
    if (shr[5] == 38) goto L38;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[5] = sh_;
	if (sh[5] != 0) goto L100;		// sh_ != 0
	++shr[5];						// след. шаг сч.шр2
	if (shr[5] > 38) goto L0;		// число шагов режима
	sh[5] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 4;						// норма: "Сброс РЦ завершен"
	shr[5] = 0;
	goto L100;

L1: if(shr[2])PR_TREN=1;
    if((PR_PER==0)&&(PR_POD==0))
    {
        shr[5]=3;
        goto L3_1;
    }
    CT_5=0;
    sh_=0;
    goto L101;
L2: if(PR_PER==1)
    {
        if(CT_5<T_DVIJ)goto L101;
        diagn[23]|=0x01;                    //отказ: "Отказ движения манипулятора"
        PR_PER=0;
        PR_POD=0;
        shr[5]=3;
        goto L3_1;
    }
    sh_=0;
    goto L101;
L3:if(PR_POD==1)
    {
        if(CT_5<T_DVIJ)goto L101;
        diagn[23]|=0x02;                    //отказ: "Отказ механизма подъёма п/д"
        PR_PER=0;
        PR_POD=0;
    }
L3_1:SBROS_MEH();
    SetOut(0,2,0x08);                  //выключить звонок
    SetOut(0,3,0x01);                  //закрыть кл нап 2
    SetOut(0,4,0x8000);                //закрыть кл нап 1
    zshr3=shr[3];
    shr[2]=0;
    sh[2]=0;
    shr[3]=0;
    sh[3]=0;
    shr[4]=0;
    sh[4]=0;
    shr[19]=0;
    sh[19]=0;
    for(int i=0;i<DIAGN_COUNT;i++)                          //исправить
        if((i != 14)&&(i != 23)) diagn[i] = 0;// сброс диагностик кроме аварийных  и отказ мех подъёма п/д и манипулятора
    SBROSR_28();
    if(shr[1])
    {
        shr[5]=38;
        sh_=0;
        goto L101;              //выход
    }
    if(shr[33])
    {
        shr[34]=1;
        sh[34]=1;
    }
    if((shr[35])||(shr[36]))
    {
        shr[37]=1;
        sh[37]=1;

    }
    shr[5]=4;
    sh_=0;
    goto L101;
L4: sh_=0;
    goto L101;
L5:if((shr[37])||(shr[34]))goto L101;

    SBROSR_24();
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    RRGOff(ObjRRG[1]);	// отключение РРГ2
    RRGOff(ObjRRG[2]);	// отключение РРГ3
    RRGOff(ObjRRG[3]);	// отключение РРГ4
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7
    if(shr[31])
    {
        shr[32]=1;
        sh[32]=1;
    }
    sh_=0;
    goto L101;
L6: if(shr[32])goto L101;
    sh_=0;
    shr[5]=37;
    goto L101;
L7:Klapan(0,&ZaslII);//закрыть заслонку ии
    goto L101;
L8:Klapan(0,&ZaslM1);//закрыть заслонку М1
    goto L101;
L9:Klapan(0,&ZaslM2);//закрыть заслонку М2
    if(sh_) goto L101;
    if(shr[38])
    {
        shr[39]=1;
        sh[39]=1;
    }
    shr[5]=34;
    sh_=0;
    goto L101;
L10:if(shr[25])goto L101;
    sh_=0;
    goto L101;
L11:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if((D_D4>=nasmod[0])&&(D_D4>=nasmod[1]))goto L101;
    if((PR_TREN==1)||((zshr3>=47)&&(zshr3<=53)))
    {
        shr[5]=38;                //выход
        sh_=0;
        goto L101;
    }
    if(shr[16])
    {
        shr[17]=1;
        sh[17]=1;
    }
    sh_=0;
    goto L101;
L12:if(shr[17])goto L101;
    shr[5]=36;
    sh_=0;
    goto L101;
L13:VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    if(sh_) goto L101;
    if(zin[2]&0x8000)
    {
        if(zshr3<=15)
        {
            sh_=0;
            goto L101;
        }
        if(zshr3==16)
        {
            shr[5]=15;
            sh_=0;
            goto L101;
        }
        if(zshr3==17)
        {
            shr[5]=16;
            sh_=0;
            goto L101;
        }
        if(zshr3==18)
        {
            shr[5]=17;
            sh_=0;
            goto L101;
        }
        if((zshr3>44)&&(zshr3!=54))
        {
            shr[5]=16;
            sh_=0;
            goto L101;
        }
        if((zin[2]&0x3000)==0x1000)
        {
            shr[5]=20;
            sh_=0;
            goto L101;
        }
        shr[5]=22;
        sh_=0;
        goto L101;
    }
    shr[5]=30;
    goto L30_1;
L14:Klapan(0,&ShZatvor);//закрыть ЩЗ
    if(sh_)goto L101;
    otvet=0;
    goto L101;
L15:if(otvet==0)goto L101;
    if(otvet==1)
    {
        shr[5]=26;
        sh_=0;
        goto L101;
    }
    shr[5]=30;
    goto L30_1;
L16:OPMAN();                //Манипулятор в HOME
    if(sh_) goto L101;
    shr[5]=13;
    goto L101;
L17:Klapan(0,&PP);//подъёмник вниз
    if(sh_)goto L101;
    shr[5]=15;
    goto L101;
L18:OPMAN();                //Манипулятор в HOME
    goto L101;
L19:Klapan(1,&PP);//подъёмник вверх
    goto L101;
L20:VPMAN();                //Манипулятор в камеру
    if(sh_) goto L101;
    shr[5]=16;
    goto L101;
L21:OPMAN();                //Манипулятор в HOME
    goto L101;
L22:Klapan(1,&PP);//подъёмник вверх
    if(sh_)goto L101;
    shr[5]=19;
    goto L101;
L23:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
	if(D_D1<UVAK_SHL)
    {
        shr[5]=24;
        sh_=0;
        goto L101;
    }
    shr[19]=1;
    sh[19]=1;
    sh_=0;
    goto L101;
L24:if(shr[19])goto L101;
    sh_=0;
    goto L101;
L25:Klapan(0,&KlShl);//закрыть фк шл
    goto L101;
L26:Klapan(1,&ShZatvor);//открыть ЩЗ
    if(sh_)goto L101;
    shr[5]=21;
    goto L101;
L27:Klapan(0,&KlShl);//закрыть фк шл
    if(sh_) goto L101;
    SetOut(1,4,0x8000);         //Вкл Кл-НАП1
    CT_5=0;
    goto L101;
L28:if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
	if(D_D1>UATM_D1)
    {
        diagn[22]&=(~0x02);             //сброс диагностики
        sh_=0;
        CT_5=0;
        goto L101;
    }
    if(CT_5>=T_KNAP)
        diagn[22]|=0x02;                //отказ " медленный напуск в шлюз"
    goto L101;
L29:if(CT_5<T_NAPUSK) goto L101;
    //SetOut(1,2,0x08);               //вкл звонок
    sh_=0;
    goto L101;
L30:if(zin[2]&0x8000)goto L101;
L30_1:SetOut(0,2,0x08);               //откл звонок
    SetOut(0,4,0x8000);             //Закрыть Кл нап1
    otvet=0;
    sh_=0;
    goto L101;
L31:if(!(zin[2]&0x8000))goto L101;
    if(otvet==0)goto L101;
    shr[19]=1;
    sh[19]=1;
    sh_=0;
    goto L101;
L32:if(shr[19])goto L101;
    sh_=0;
    goto L101;
L33:Klapan(0,&KlShl);//закрыть фк шл
    goto L101;
L34:Klapan(0,&FvnShl);//отключить форнасос шлюза
    if(sh_) goto L101;
    shr[5]=38;                                  //выход
    goto L101;
L35:if(shr[39])goto L101;
    N_ST=0;
    T_PROC=0;
    PR_OTP=0;
    if(shr[8])
    {
        shr[5]=38;                              //выход
        sh_=0;
        goto L101;
    }
    sh_=0;
    goto L101;
L36:Klapan(0,&Zatvor);//закрыть затвор
    if(sh_) goto L101;
    shr[25]=1;
    sh[25]=1;
    shr[5]=9;
    goto L101;
L37:pderj_v_ish();
    if(sh_)goto L101;
    shr[5]=12;
    goto L101;
L38:Klapan(1,&ZaslPD);//открыть заслонку п/д
    if(sh_)goto L101;
    shr[5]=6;           //переход на шаг 7
    goto L101;

}
//---------------------------------------------------------------------------
void R_6 ()            // Режим "Сбор/выгрузка пластин"
{
	sh_ = sh[6];

	if (shr[6] < 1 || shr[6] > 20) goto L100;
	if (shr[6] < 10) goto L00;
	else goto L01;

L00:if (shr[6] == 1) goto L1;
	if (shr[6] == 2) goto L2;
	if (shr[6] == 3) goto L3;
	if (shr[6] == 4) goto L4;
	if (shr[6] == 5) goto L5;
	if (shr[6] == 6) goto L6;
	if (shr[6] == 7) goto L7;
	if (shr[6] == 8) goto L8;
	if (shr[6] == 9) goto L9;
L01:if (shr[6] == 10) goto L10;
	if (shr[6] == 11) goto L11;
	if (shr[6] == 12) goto L12;
	if (shr[6] == 13) goto L13;
	if (shr[6] == 14) goto L14;
	if (shr[6] == 15) goto L15;
	if (shr[6] == 16) goto L16;
	if (shr[6] == 17) goto L17;
	if (shr[6] == 18) goto L18;
	if (shr[6] == 19) goto L19;
    if (shr[6] == 20) goto L20;

	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[6] = sh_;
	if (sh[6] != 0) goto L100;			// sh_ != 0
	++shr[6];							// след. шаг сч.шр1
	if (shr[6] > 20) goto L0;			// число шагов режима
	sh[6] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma = 11;							// норма: "Сбор пластин завершен"
	shr[6] = 0;
	goto L100;
	
L1: SetOut(0,2,0x3F00);                 //закрыть кл 1,2,3,4,5,7
    SetOut(0,3,0x01);                   //закрыть клНап2
    SetOut(0,4,0x8000);                 //закрыть клНап1
    if(zin[3]&0x200)
    {
        shr[6]=3;
        goto L3_1;
    }
    sh_=0;
    goto L101;
L2: sh_=0;
    goto L101;
L3: OPMAN();                //Манипулятор в HOME
    if(sh_)goto L101;
L3_1:otvet=0;
    sh_=0;
    goto L101;
L4:if(otvet==0)goto L101;
    if(otvet==1)
    {
        sh_=0;
        goto L101;
    }
    shr[10]=1;
    sh[10]=1;
    shr[6]=13;
    sh_=0;
    goto L101;
L5: Klapan(0,&ShZatvor);//закрыть ЩЗ
    goto L101;
L6: Klapan(0,&KlShl);//закрыть фк шл
    if(sh_) goto L101;
    SetOut(1,4,0x8000);             //открыть клнап1
    CT_6=0;
    sh_=0;
    goto L101;
L7: if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1>UATM_D1)
    {
        diagn[22]&=(~0x02);             //сброс диагностики
        CT_6=0;
        sh_=0;
        goto L101;
    }
    if(CT_6>=T_KNAP)
        diagn[22]|=0x02;                //диагностика " медленный напуск в шлюз"
    goto L101;
L8: if(CT_6<=T_NAPUSK)goto L101;
    //SetOut(1,2,0x08);               //включить звонок
    sh_=0;
    goto L101;
L9: if(zin[2]&0x8000)goto L101;
    SetOut(0,2,0x08);               //отключить звонок
    SetOut(0,4,0x8000);             //закрыть клнап1
    otvet=0;
    sh_=0;
    goto L101;
L10:if(!(zin[2]&0x8000))goto L101;
    if(otvet==0)goto L101;
    if(otvet==1)
    {
        shr[19]=1;
        sh[19]=1;
        sh_=0;
        goto L101;
    }
    shr[6]=20;                      //выход
    sh_=0;
    goto L101;
L11:if(shr[19])goto L101;
    sh_=0;
    goto L101;
L12:Klapan(0,&KlShl);//закрыть фк шл
    goto L101;
L13:Klapan(0,&FvnShl);//откл форнасоса шл
    if(sh_)goto L101;
    shr[6]=20;
    goto L101;
L14:if(shr[10])goto L101;
    if(zin[3]&0x1000)
    {
        shr[6]=15;
        sh_=0;
        goto L101;
    }
    shr[6]=19;
    sh_=0;
    goto L101;
L15:VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    goto L101;
L16:Klapan(1,&PP);//подъёмник вверх
    goto L101;
L17:VPMAN();                //Манипулятор в камеру
    goto L101;
L18:Klapan(0,&PP);//подъёмник вниз
    goto L101;
L19:OPMAN();                //Манипулятор в HOME
    if(sh_)goto L101;
    shr[6]=4;
    sh_=0;
    goto L101;
L20:pderj_v_ish();
    if(sh_)goto L101;
    shr[6]=14;
    goto L101;

}
//---------------------------------------------------------------------------
void R_7 ()							// Режим "Отключение установки"
{
	sh_ = sh[7];

    if (shr[7] < 1 || shr[7] > 31) goto L100;
	if (shr[7] < 10) goto L00;
    if (shr[7] < 20) goto L01;

	else goto L02;


L00:if (shr[7] == 1) goto L1;
	if (shr[7] == 2) goto L2;
	if (shr[7] == 3) goto L3;
	if (shr[7] == 4) goto L4;
	if (shr[7] == 5) goto L5;
	if (shr[7] == 6) goto L6;
	if (shr[7] == 7) goto L7;
	if (shr[7] == 8) goto L8;
	if (shr[7] == 9) goto L9;
L01:if (shr[7] == 10) goto L10;
	if (shr[7] == 11) goto L11;
	if (shr[7] == 12) goto L12;
	if (shr[7] == 13) goto L13;
	if (shr[7] == 14) goto L14;
	if (shr[7] == 15) goto L15;
	if (shr[7] == 16) goto L16;
	if (shr[7] == 17) goto L17;
	if (shr[7] == 18) goto L18;
	if (shr[7] == 19) goto L19;
L02:if (shr[7] == 20) goto L20;
	if (shr[7] == 21) goto L21;
	if (shr[7] == 22) goto L22;
	if (shr[7] == 23) goto L23;
    if (shr[7] == 24) goto L24;
    if (shr[7] == 25) goto L25;
    if (shr[7] == 26) goto L26;
    if (shr[7] == 27) goto L27;
    if (shr[7] == 28) goto L28;
    if (shr[7] == 29) goto L29;
    if (shr[7] == 30) goto L30;
    if (shr[7] == 31) goto L31;
	else goto L100;			// выход

	// конечный диспетчер режима
L101:sh[7] = sh_;
	if (sh[7] != 0) goto L100;			// SH != 0
	++shr[7];							// след. шаг сч.шр5
	if (shr[7] > 31) goto L0;			// число шагов режима
	sh[7] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma 	= 6;						// норма: "Отключение установки завершено"
	shr[7] 	= 0;
	goto L100;
	
L1: SetOut(0,2,0x3F00);                 //закрыть кл1-8, клНап1,2
    SetOut(0,3,0x07);
    SetOut(0,4,0x8000);
    shr[1]=0;
    sh[1]=0;
    sh_=0;
    goto L101;
L2: ORR_GIS();//Снять разрешение работы вчг п/д
    if(sh_)goto L101;
    SetOut(0,4,0x1500);                 //снять внешнее управление бпмов
    if(zin[3]&0x200)
    {
        shr[7]=4; // переход на шаг 4_1
        sh_=1;
        goto L4_1;
    }
    shr[7] = 3; // переход на шаг 4
    sh_ = 0;
    goto L101;
L3: Klapan(0,&Zatvor);//закрыть затвор
    if(sh_) goto L101;
    shr[7] = 17; // переход на шаг 18
    sh_ = 0;
    goto L101;
L4: OPMAN();                //Манипулятор в HOME
    if (sh_) goto L101;
L4_1:if(shr[16])
    {
        shr[17]=1;
        sh[17]=1;
    }
    sh_=0;
    goto L101;
L5:if(shr[17])goto L101;
    sh_=0;
    shr[7]=30;
    goto L101;
L6: VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    goto L101;
L7: Klapan(0,&ShZatvor);//закрыть ЩЗ
    goto L101;
L8: Klapan(0,&PP);//механизм подъёма вниз
    goto L101;
L9: Klapan(0,&ZaslPD);//закрыть заслонку п/д
    goto L101;
L10:Klapan(0,&KlKam);//закрыть фк кам
    goto L101;
L11:Klapan(0,&KlShl);//закрыть фк шл
    if(sh_) goto L101;
    shr[26]=1;
    sh[26]=1;
    goto L101;
L12:if(shr[26])goto L101;
    if(out[4]&0x40)
    {
        if(diagn[14]&0x60)          //есть диагностики аварии форнасоса
        {
            shr[7]=13;
            sh_=1;
            SetOut(0,0,0x02);       //Закрыть ФК-ТМН
            goto L13_1;             //переход на шаг 13_1
        }
        sh_=0;
        goto L101;
    }
    shr[7]=15;
    sh_=0;
    goto L101;
L13:Klapan(1,&KlTmn);//открыть фк тмн
    if(sh_) goto L101;
L13_1:    SetOut(0,4,0x40);               //снять сигнал старт ТМН
    CT_7=0;
    sh_=0;
    goto L101;
L14:if(CT_7<=5)goto L101;
    sh_=0;
    goto L101;
L15:if(aik[15]>=POROG_OST_TMN)goto L101;
    sh_=0;
    goto L101;
L16:Klapan(0,&KlTmn);//закрыть фк ТМН
    goto L101;
L17:Klapan(0,&FvnKam);// откл форнасоса камеры
    if(sh_) goto L101;
    shr[7] = 2; // переход на шаг 3
    goto L101;
L18:Klapan(0,&KlKN);//закрыть фк кн
    if(sh_) goto L101;
    if(!PR_KN)
    {
        shr[7]=19;
        goto L101;
    }
    shr[41]=1;
    sh[41]=1;
    goto L101;
L19:if(shr[41])goto L101;
    sh_=0;
    goto L101;
L20:Klapan(0,&ZaslII);//закрыть заслонку ии
    goto L101;
L21:Klapan(0,&ZaslM1);//закрыть заслонку М1
    goto L101;
L22:Klapan(0,&ZaslM2);//Закрыть заслонку М2
    goto L101;
L23:Klapan(0,&FvnShl);//Откл. форнасоса шлюза
    if(sh_)goto L101;
    if(shr[29])
    {
        shr[30]=1;
        sh[30]=1;
    }
    goto L101;
L24:if(shr[30])goto L101;
    if(shr[31])
    {
        shr[32]=1;
        sh[32]=1;
    }
    sh_=0;
    goto L101;
L25:if(shr[32])goto L101;
    if(shr[38])
    {
        shr[39]=1;
        shr[39]=1;
    }
    sh_=0;
    goto L101;
L26:if(shr[39])goto L101;
    sh_=0;
    goto L101;
L27:OBPN();											// отключение БПН
    if(sh_) goto L101;
    if(nasmod[7]==1)
    {
        sh_=0;
        goto L101;
    }
    shr[7]=28;
    goto L28_1;
L28:VIDK_II(010000,04000,0,25,020);//отключить БПИИ
    if(sh_) goto L101;
    if(nasmod[8]==1)
    {
        sh_=0;
        goto L101;
    }
L28_1:if(nasmod[9]==1)
    {
        shr[7]=29;
        sh_=0;
        goto L101;
    }
    shr[7]=31;
    sh_=0;
    goto L101;
L29:VIDK_BM1(010004 , 04000,0,6,020);//откл БПМ1
    if(sh_)goto L101;
    shr[7]=28;
    goto L28_1;
L30:VIDK_BM2(010004 , 04000,0,8,020);//Откл БПМ2
    if(sh_)goto L101;
    shr[7]=31;
    goto L101;
L31:pderj_v_ish();
    if(sh_)goto L101;
    shr[7]=5;
    goto L101;
}
//---------------------------------------------------------------------------
void R_8 ()							// Режим "Аварийное отключение установки"
{
	sh_ = sh[8];

	if (shr[8] == 1) goto L1;
	if (shr[8] == 2) goto L2;
	if (shr[8] == 3) goto L3;
	if (shr[8] == 4) goto L4;
    if (shr[8] == 5) goto L5;
    if (shr[8] == 6) goto L6;
    if (shr[8] == 7) goto L7;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[8] = sh_;
	if (sh[8] != 0) goto L100;		// SH != 0
	++shr[8];						// след. шаг сч.шр5
	if (shr[8] > 7) goto L0;		// число шагов режима
	sh[8] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 9;						// норма: "Авар. откл. установки завершено"
	shr[8] = 0;
	goto L100;
	
L1: SetOut(0,0,0x28);               //закрыть дз и затвор
    SetOut(1,0,0x50);
    if(diagn[14]&0x60)          //есть диагностики аварии форнасоса
    {
        SetOut(0,0,0x02);       //Закрыть ФК-ТМН
    }
    if(shr[5])
    {
        shr[8]=6;
        sh_=0;
        goto L101;
    }
    if((!(shr[2]))&&(!(shr[3])))
    {
        if(shr[33])
        {
            shr[34]=1;
            sh[34]=1;
        }
        if((shr[35])||(shr[36]))
        {
            shr[37]=1;
            sh[37]=1;

        }
        sh_=0;
        goto L101;
    }
    shr[5]=1;
    sh[5]=1;
    shr[8]=6;
    sh_=0;
    goto L101;
L2:if((shr[37])||(shr[34]))goto L101;
    SBROSR_24();
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    RRGOff(ObjRRG[1]);	// отключение РРГ2
    RRGOff(ObjRRG[2]);	// отключение РРГ3
    RRGOff(ObjRRG[3]);	// отключение РРГ4
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7
    SBROSR_28();
    if(shr[29])
    {
        shr[30]=1;
        sh[30]=1;
    }
    sh_=0;
    goto L101;
L3: if(shr[30])goto L101;
    if(shr[31])
    {
        shr[32]=1;
        sh[32]=1;
    }
    sh_=0;
    goto L101;
L4: if(shr[32])goto L101;
    if(shr[38])
    {
        shr[39]=1;
        sh[39]=1;
    }
    sh_=0;
    goto L101;
L5: if(shr[39])goto L101;
    shr[1]=0;
    sh[1]=0;
    shr[19]=0;
    sh[19]=0;
    shr[6]=0;
    sh[6]=0;
    shr[10]=0;
    sh[10]=0;
    shr[11]=0;
    sh[11]=0;
    SetOut(0,2,0x08);               //отключить звонок
    SBROS_MEH();
     for(int i=0;i<DIAGN_COUNT;i++)                          //исправить
        if((i != 14)&&(i != 22)) diagn[i] = 0;// сброс диагностик кроме аварийных
L5_1:if(!(shr[7]))
    {
        shr[7]=1;
        sh[7]=1;
    }
    sh_=0;
    goto L101;
L6: if(shr[7])goto L101;
    sh_=0;
    shr[8]=7;
    goto L101;
L7: if(shr[5])goto L101;
    shr[8]=5;
    goto L5_1;




}
//---------------------------------------------------------------------------
void R_9 ()							// Режим "Транспортный тест"
{
	sh_ = sh[9];

	if (shr[9] < 1 || shr[9] > 16) goto L100;
	if (shr[9] < 10) goto L00;

	else goto L01;

L00:if (shr[9] == 1) goto L1;
	if (shr[9] == 2) goto L2;
	if (shr[9] == 3) goto L3;
	if (shr[9] == 4) goto L4;
	if (shr[9] == 5) goto L5;
	if (shr[9] == 6) goto L6;
	if (shr[9] == 7) goto L7;
	if (shr[9] == 8) goto L8;
	if (shr[9] == 9) goto L9;
L01:if (shr[9] == 10) goto L10;
	if (shr[9] == 11) goto L11;
	if (shr[9] == 12) goto L12;
	if (shr[9] == 13) goto L13;
	if (shr[9] == 14) goto L14;
	if (shr[9] == 15) goto L15;
    if (shr[9] == 16) goto L16;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[9] = sh_;
	if (sh[9] != 0) goto L100;	// sh_ != 0
	++shr[9];					// след. шаг сч.шр1
	if (shr[9] > 16) goto L0;	// число шагов режима
	sh[9] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 10;					// норма: "Транспортный тест завершен"
	shr[9] = 0;
	goto L100;
	
L1: PR_TRTEST=0;
    Klapan(1,&ZaslPD);//открыть заслонку п/д
    goto L101;
L2: Klapan(0,&PP);//механизм подъёма вниз
    goto L101;
L3: VPMAN();                //Манипулятор в камеру
    goto L101;
L4: Klapan(1,&PP);//механизм подъёма вверх
    goto L101;
L5: OPMAN();                //Манипулятор в HOME
    goto L101;
L6: Klapan(0,&PP);//механизм подъёма вниз
    if(sh_)goto L101;
    shr[9]=15;
    goto L101;
L7: VIDK_POD(0,ABS,nasmod[16],0,10);//подъём п/д в раб позиц
    if(sh_) goto L101;
    shr[16]=1;
    sh[16]=1;
    CT_9=0;
    goto L101;
L8: if(CT_9<=5)goto L101;
    shr[17]=1;
    sh[17]=1;
    sh_=0;
    goto L101;
L9: if(shr[17])goto L101;
    sh_=0;
    goto L101;
L10:VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    goto L101;
L11:Klapan(1,&PP);//мех подъёма вверх
    goto L101;
L12:VPMAN();                //Манипулятор в камеру
    goto L101;
L13:Klapan(0,&PP);//механизм подъёма вниз
    goto L101;
L14:OPMAN();                //Манипулятор в HOME
    if(sh_) goto L101;
    if(PR_TRTEST==0)
    {
        CT_9=0;
        goto L101;
    }
    sh_=0;
    shr[9]=16;
    goto L101;
L15:if(CT_9<=5) goto L101;
    shr[9]=2;
    sh_=0;
    goto L101;
L16:pderj_v_ish();
    if(sh_)goto L101;
    shr[9]=6;
    goto L101;


}	
//---------------------------------------------------------------------------
void R_10 ()							// Режим "Открыть ЩЗ"
{
	sh_ = sh[10];

	if (shr[10] < 1 || shr[10] > 16) goto L100;
	if (shr[10] < 10) goto L00;
	goto L01;

L00:if (shr[10] == 1) goto L1;
	if (shr[10] == 2) goto L2;
	if (shr[10] == 3) goto L3;
	if (shr[10] == 4) goto L4;
	if (shr[10] == 5) goto L5;
	if (shr[10] == 6) goto L6;
	if (shr[10] == 7) goto L7;
	if (shr[10] == 8) goto L8;
	if (shr[10] == 9) goto L9;
L01:if (shr[10] == 10) goto L10;
	if (shr[10] == 11) goto L11;
	if (shr[10] == 12) goto L12;
	if (shr[10] == 13) goto L13;
	if (shr[10] == 14) goto L14;
    if (shr[10] == 15) goto L15;
    if (shr[10] == 16) goto L16;
	goto L100;
	// конечный диспетчер режима
L101:sh[10] = sh_;
	if (sh[10] != 0) goto L100;		// SH != 0
	++shr[10];						// след. шаг сч.шр5
	if (shr[10] > 16) goto L0;		// число шагов режима
	sh[10] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 25;						// норма: "Щелевой затвор открылся"
	shr[10] = 0;
    sh[10] = 0;
	goto L100;

L1: shr[11]=0;
    sh[11]=0;
    diagn[9]&=(~0x0F);                 //сброс диагностик щелевого затвора
    sh_=0;
    goto L101;
L2: if((zin[2]&0x3000)==0x1000)
    {
        diagn[9]&=(~0x04);             //сброс диагностики
        goto L0;                                        // ВЫХОД!!!
    }
    if((zin[2]&0x3000)==0x2000)
    {
        diagn[9]&=(~0x04);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[9]|=0x04;                    //отказ "положение ЩЗ не определено"
    goto L101;
L3: if(diagnS[0]&0x08)					// пока нет связи с D4
		goto L101;
	if(D_D4>UATM_D4)
    {
        sh_=0;
        goto L101;
    }
    shr[10]=5;
    sh_=0;
    goto L101;
L4:if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1<=UATM_D1)
    {
        sh_=0;
        goto L101;
    }
    shr[10]=14;     //переход на шаг 15
    CT_10=0;
    sh_=0;
    goto L101;
L5: Klapan(0,&KlShl);//закрыть фк шл
    if(sh_)goto L101;
    SetOut(1,4,0x8000);                 //открыть клнап1
    SetOut(1,3,0x01);                 //открыть клнап2
    shr[10]=3;
    sh_=0;
    goto L101;
L6: if(diagnS[0]&0x08)					// пока нет связи с D4
		goto L101;
	if(D_D4>UVAK_KAM)
    {
        SetOut(0,2,0x800);              //закрыть кл7
        SetOut(0,3,0x01);               //закрыть клнап2
        sh_=0;
        goto L101;
    }
    if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1>UVAK_SHL)
    {
        shr[19]=1;
        sh[19]=1;
        shr[10]=9;
        sh_=0;
        goto L101;
    }
    shr[10]=10;
    sh_=0;
    goto L101;
L7: Klapan(0,&KlTmn);//закрыть ФК ТМН
    goto L101;
L8: Klapan(1,&FvnKam);//Вкл форнасос кам
    goto L101;
L9: Klapan(1,&KlKam);//открыть фк кам
    if(sh_) goto L101;
    shr[10]=5;
    sh_=0;
    goto L101;
L10:if(shr[19])goto L101;
    sh_=0;
    goto L101;
L11:Klapan(0,&KlShl);//закрыть фк-шл
    if(sh_)goto L101;
    if(out[4]&0x40)goto L101;
    shr[10]=13;
    goto L101;
L12:Klapan(0,&KlKam);//закрыть фк кам
    goto L101;
L13:Klapan(1,&KlTmn);//открыть фк ТМН
    goto L101;
L14:Klapan(1,&ShZatvor);//Открыть ЩЗ
    if(sh_)goto L101;
    shr[10] = 15; // переход на шаг 16
    goto L101;
L15:if(CT_10<T_NAPUSK)
        goto L101;
    sh_=0;
    SetOut(0,4,0x8000);                 //закрыть клНАП1
    SetOut(0,3,0x01);                 //закрыть клнап2
    shr[10]=13;             //переход на шаг 14
    goto L101;
L16:Klapan(0,&FvnShl);//Откл. форнасоса шлюза
    goto L101;
}
//---------------------------------------------------------------------------
void R_11()							// Режим "Закрыть ЩЗ"
{
	sh_ = sh[11];

	if (shr[11] == 1) goto L1;
	if (shr[11] == 2) goto L2;
		else goto L100;				// выход

	// конечный диспетчер режима
L101:sh[11] = sh_;
	if (sh[11] != 0) goto L100;		// SH != 0
	++shr[11];						// след. шаг
	if (shr[11] > 2) goto L0;		// число шагов режима
	sh[11] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 26;						// норма: "Щелевой затвор закрылся"
	shr[11] = 0;
	goto L100;

L1:	shr[10] = 0;					// сброс активизации режима 10
	sh[10] = 0;
	diagn[15] &= (~0x30);			// сброс диагностик ФВН                 //испра  вить
	diagn[10] &= (~0xFF);			// ФК-КАМ, ФК-Шл
	diagn[9] &= (~0xFF);			// щелевого затвора, ФК-ТМН

	sh_ = 0;
	goto L101;
L2:	Klapan(0,&ShZatvor);			// закрыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_12() // режим 12 "МАН в исходное"
{
	sh_ = sh[12];

	if (shr[12] == 1)  goto L1;
	else goto L100;// на выход

L101:sh[12] = sh_;
	if (sh[12] != 0) goto L100;		// SH != 0
	shr[12]++;						// след.шаг
	if (shr[12] > 1) goto L0;		// число шагов режима
	sh[12] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[12] = 0;
	goto L100;

L1: OPMAN();						// Ман в HOME
	goto L101;
}
//---------------------------------------------------------------------------
void R_13() // режим 13 "МАН вперёд/назад"
{
	sh_ = sh[13];

	if (shr[13] == 1)  goto L1;
	else goto L100;// на выход

L101:sh[13] = sh_;
	if (sh[13] != 0) goto L100;		// SH != 0
	shr[13]++;						// след.шаг
	if (shr[13] > 1) goto L0;		// число шагов режима
	sh[13] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[13] = 0;
	goto L100;

L1: VPMAN();						// Ман в камеру
	goto L101;
}
//---------------------------------------------------------------------------
void R_14() // режим 14 "подъём п/д в HOME"
{
	sh_ = sh[14];
	if((shr[14] < 1) || (shr[14] > 3)) goto L100; // на выход

L00:if(shr[14] == 1) goto L1;
	if(shr[14] == 2) goto L2;
    if(shr[14] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[14] = sh_;
	if (sh[14] != 0) goto L100;		// SH != 0
	shr[14]++;						// след.шаг
	if (shr[14] > 3) goto L0;		// число шагов режима
	sh[14] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 67;					// норма: "Мех. поворота в исходном"
	shr[14] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[26] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: pderj_v_ish();
    goto L101;
L3: VIDK_POD(par[0][10],0,0,1,10);				// поворот манип. в исх.
	goto L101;
}
//---------------------------------------------------------------------------
void R_15() // режим 15 "подъём п/д СТАРТ"
{
	sh_ = sh[15];
	if ((shr[15] < 1) || (shr[15] > 3)) goto L100; // на выход

L00:if(shr[15] == 1) goto L1;
	if(shr[15] == 2) goto L2;
    if(shr[15] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[15] = sh_;
	if(sh[15] != 0) goto L100;		// SH != 0
	shr[15]++;						// след.шаг
	if(shr[15] > 3) goto L0;		// число шагов режима
	sh[15] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 71;						// норма: "Механизм. поворота путь прошел"
	shr[15] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[14] = 0;							// сброс активации режима 14
	shr[14] = 0;
	diagn[26] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: pderj_v_ish();
    goto L101;
L3: VIDK_POD(par[0][11],OTN,par[0][10],0,10);// поворот манип. вперед/назад
	goto L101;
}
//---------------------------------------------------------------------------
void R_16 ()                    // режим 16 "Вкл. вращ. п/держ"
{
	sh_ = sh[16];
	if(shr[16] == 1) goto L1;
	else goto L100;	//Выход

// Конечный диспетчер режима
L101:sh[16] = sh_;
	if(sh[16] != 0) goto L100;			// SH != 0
L100:return;							// Возврат в "кольцо"

L1:	GoPderjatel();						// Вращение заслонки
	goto L101;
}
//---------------------------------------------------------------------------
void R_17 ()                    // режим 17 "Откл. вращ. п/держ"
{
	sh_ = sh[17];
    if(shr[17] == 1) goto L1;
	goto L100;// на выход
L101:sh[17] = sh_;						//    |                           |
	if (sh[17] != 0) goto L100;			//    |    SH != 0                |
	shr[17]++;							//    |    след.шаг сч.шр 26      |
    if (shr[17] > 1) goto L0;
	sh[17] = 1;							//    |                           |
L100:return;							//    |    возврат в "кольцо"     |

L0:	shr[17] = 0;
	goto L100;

L1: sh[16] = 0;           	// дезактивизировать режим 16
    shr[16] = 0;          	// "Вращ. п/держ."
    sh_ = sh[17];
    StopPderjatel();   	 	// откл. вращ. п/держ.
    goto L101;
}
//---------------------------------------------------------------------------
void R_18 ()                    // режим 18 "подъём п/д в раб полож"
{
  	sh_ = sh[18];
	if((shr[18] < 1) || (shr[18] > 3)) goto L100; // на выход

L00:if(shr[18] == 1) goto L1;
	if(shr[18] == 2) goto L2;
    if(shr[18] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[18] = sh_;
	if (sh[18] != 0) goto L100;		// SH != 0
	shr[18]++;						// след.шаг
	if (shr[18] > 3) goto L0;		// число шагов режима
	sh[18] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 66;					// норма: "Мех. поворота в исходном"
	shr[18] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[26] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: pderj_v_ish();
    goto L101;
L3: VIDK_POD(par[0][11],ABS,nasmod[16],0,10);// поворот манип. вперед/назад
	goto L101;

}
//---------------------------------------------------------------------------
void R_19 ()							// Режим "Открыть ЩЗ"
{
	sh_ = sh[19];

    if (shr[19] == 1) goto L1;
	if (shr[19] == 2) goto L2;
	if (shr[19] == 3) goto L3;
	if (shr[19] == 4) goto L4;
	if (shr[19] == 5) goto L5;


	goto L100;
	// конечный диспетчер режима
L101:sh[19] = sh_;
	if (sh[19] != 0) goto L100;		// SH != 0
	++shr[19];						// след. шаг сч.шр5
	if (shr[19] > 5) goto L0;		// число шагов режима
	sh[19] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 39 ;						// норма: "Откачка шлюза завершена"
	shr[19] = 0;
	goto L100;

L1: SetOut(0,4,0x8000);             //закрыть кл НАП1
    sh_=0;
    goto L101;
L2: Klapan(1,&FvnShl);//вкл форнасоса шлюза
    if(sh_)goto L101;
    SetOut(1,0,0x200);              //Открыть фк шл мягк
    CT_19=0;
    goto L101;
L3: if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1<UVAK_SHL_MO)
    {
        diagn[12]&=(~0x04);                 //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_19>T_KSHL_MO)
        diagn[12]|=0x04;                    //отказ "Медленная мягкая откачка шлюза"
    goto L101;
L4: Klapan(1,&KlShl);//открыть фк шл
    if(sh_) goto L101;
    CT_19=0;
    sh_=0;
    goto L101;
L5: if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1<UVAK_SHL)
    {
        diagn[15]&=(~0x04);                 //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_19>T_KSHL)
        diagn[15]|=0x04;                    //отказ "Медленная откачка шлюза"
    goto L101;





}
//---------------------------------------------------------------------------
void R_20()							// РЕЖИМ 20 "Включить РРГ1"
{
	// выставление параметра РРГ
	ObjRRG[0]->parRRG = par[N_ST][0];

	// запуск режима
	RRGOn(ObjRRG[0],1);				// включение РРГ1
    SetOut(1,2,0x800);              //открыть кл7
}
//---------------------------------------------------------------------------
void R_21()							// РЕЖИМ 21 "Включить РРГ2"
{
	// выставление параметра РРГ
	ObjRRG[1]->parRRG = par[N_ST][1];

	// запуск режима
	RRGOn(ObjRRG[1],1);				// включение РРГ2
    SetOut(1,2,0x800);              //открыть кл7
}
//---------------------------------------------------------------------------
void R_22()							// РЕЖИМ 22 "Включить РРГ3"
{
	// выставление параметра РРГ
	ObjRRG[2]->parRRG = par[N_ST][2];

	// запуск режима
	RRGOn(ObjRRG[2],1);				// включение РРГ2
    SetOut(1,2,0x800);              //открыть кл7
}
//---------------------------------------------------------------------------
void R_23()							// РЕЖИМ 23 "Включить РРГ4"
{   // выставление параметра РРГ
    if(shr[4])
	    ObjRRG[3]->parRRG = nasmod[2];
    else
        ObjRRG[3]->parRRG = par[N_ST][3];

	// запуск режима
	RRGOn(ObjRRG[3],PR_RG4);				// включение РРГ4
}
//---------------------------------------------------------------------------
void R_24()								// режим "УУН"
{										// индекс устройства UN
	sh_ = sh[24];
	if (shr[24] == 1) goto L1;
	if (shr[24] == 2) goto L2;
	if (shr[24] == 3) goto L3;
	else goto L100;						// на выход

										//    | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[24] = sh_;						//    |                           |
	if (sh[24] != 0) goto L100;			//    |    SH != 0                |
	shr[24]++;							//    |    след.шаг сч.шр 26      |
	sh[24] = 1;							//    |                           |
L100:return;							//    |    возврат в "кольцо"     |

L1:	VRUN = 0;							// сброс признака выхода на режим УУН
	A_OUT(0,8192);						// обнуление уставки РРГ1
	diagn[0] &= (~0x07);				// сброс диагностик режима УУН(РРГ1)
	SetOut(1,2,0x900);					//открыть клапан Кл1 РРГ1

	CT_24 = 0;							// обнуление сч.вр.режима УУН
	sh_ = 0;
	goto L101;
L2:	if(CT_24 <= 3) goto L101;			//задержка 3сек на откачку магистрали РРГ2
	CT_24 = 0;							// обнуление сч.вр.режима УУН
	sh_ = 0;
	goto L101;
L3:	RABUN();							// работа УУН
	goto L101;
}

////////////////////////////////////////////////////////////////////////////////
void RABUN()							// подпрограмма "Работа УУН"
{
	long T1;
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else goto A100;						// на выход
	// расчет приращений LIMU при пробое
A1:	PORCPR_UN = LIMUUN / T_VPRB_UN;		// расчет порции
	LIMUPR_UN = LIMUUN % T_VPRB_UN;		// остаток-нач.ограничение
	// по уставке при пробое
	// расчет приращений LIMU при выходе на режим
	PORCNV_UN = LIMUUN / T_VREJ_UN;		// расчет порции
	LIMU_UN = LIMUUN % T_VREJ_UN;		// остаток-нач.ограничение по
	// уставке при выходе на реж.
	CT_VRUN = 0;						// обнуление счетчика выхода на режим
	E_PUN = 0;							// обнуление предыдущей ошибки,
	SOUN = 0;							// сумматора остатков,
	U_PUN = 0;							// предыдущей уставки,
	VRUN = 0;							// признака выхода на режим УУН
	PROBUN = 0;							// признак отработки пробоя
	sh_ = 2;
	// выход на режим УУН
A2:	VIBPAR_UN();						// выбор параметра УУН
	REQUN();							// регулятор УУН
	if (CT_VRUN == 0) goto A100;		// пров. CT.VR на ноль (время не вышло)
	T1 = CT_VRUN; T1 *= PORCNV_UN;
	if (T1 > LIMUUN) goto S1;			// MAX достигнут
	LIMU_UN = T1;						// выдача текущего LIMU
A100:return;							// выход
S1:	LIMU_UN = LIMUUN;					// выдача MAX LIMU
	CT24K1 = 0;							// сброс счетчика к.времени опред.ошибки
	CT_24 = 0;							// и выхода на режим
	sh_ = 3;
	// анализ выхода на режим УУН
A3:	UN_G();								// регулятор УУН с отработкой пробоя
	if (DELUN < LIM2UN) goto S2;		// Тош < LIM
	CT24K1 = 0;
	if (CT_24 > T_VRUN)					// время выхода на режим вышло
	diagn[30] |= 0x10;					// отказ: "нет выхода на режим УУН"
	goto S3;
S2:	if (CT24K1 <= T_KUN) goto S4;		// Т.K.тек <= Т.K.зад
	diagn[30] &= (~0x10);				// сброс д."нет выхода на режим УУН"
	VRUN = 1;							// признак выхода на режим УУН
	goto S3;
S4:	VRUN = 0;							// сброс признака выхода на режим УУН
S3:	if (VRUN == 0) goto S5;				// нет выхода на режим УУН
	CT_24 = 0;							// сброс счетчика режима УУН
	sh_ = 4;
	goto A100;
S5:	diagn[30] &= (~0x60);				// сброс д."нет рег.УУН" и "б.ош.рег.УУН"
	goto A100;
A4:	UN_G();								// регулятор УУН с отработкой пробоя
	goto A100;
}
//----------------------------------------------------------------------------
void UN_G()								// подпрограмма "рег.УУН с отработкой пробоя"
{
	long T1;
	// определение пробоя УУН
	// if ((ZIN2 & 01400) != 0) goto S3;// пробой: перегрузка или дуга
	if(PROBUN == 0						// нет отработки пробоя
		|| CT_PR_UN == 0) goto S2;
	// расчет и выдача текущей LIMU_UN
	T1 = CT_PR_UN; T1 *= PORCPR_UN;
	if (T1 > LIMUUN) goto S1;			// MAX достигнут
	LIMU_UN = T1;						// выдача текущей LIMU
	goto S2;
S1:	LIMU_UN = LIMUUN;					// выдача MAX LIMU
	PROBUN = 0;							// сброс признака отработки пробоя
	goto S2;
	// начальная отработка пробоя
S3:	PROBUN = 1;							// признак отработки пробоя УУН
	LIMU_UN = LIMUPR_UN;				// выдать начальное ограничение
	CT_PR_UN = 0;						// сброс сч.пробоя
S2:	UN_D();
}
//----------------------------------------------------------------------------
void UN_D()								// подпрограмма "рег.УУН с диагностикой"
{
	VIBPAR_UN();						// выбор параметра УУН
	REQUN();							// регулятор УУН
	RLIMUN();							// расчет LIM1,LIM2 для УУН
	if(DELUN <= LIM1UN) goto S1;		// модуль Ет <= LIM1
	diagn[30] |= 0x40;					// отказ: "нет регулирования УУН"
	goto S2;
S1:	diagn[30] &= (~0x40);				// сброс д."нет регулирования УУН"
	if (DELUN <= LIM2UN) goto S2;		// LIM2 (зона регулирования)
	diagn[30] |= 0x20;					// отказ: "большая ошибка рег.УУН"
	goto A100;
S2:	diagn[30] &= (~0x20);				// сброс д."большая ошибка рег.УУН"
A100:return;
}
//----------------------------------------------------------------------------
void RLIMUN()							// подпрограмма "Расчет LIM для УУН"
{
	if (PAR_UN == 0)					// если задание = 0, расшир.лимитов
	{
		LIM1UN = 7000;					// MAX доп.знач.по входу ап.ср.
		LIM2UN = LIM1UN / 5;			// LIM2 = 0,2 LIM1
	}
	else
	{
		LIM2UN = PAR_UN / DOPUN;		// LIM2 (малый)
		LIM1UN = PAR_UN / 5;			// LIM1 (большой) - 20%
	}
}
//----------------------------------------------------------------------------
void REQUN()							// подпрограмма "Регулятор УУН"
{
	long T1,PPSUN,PISUN;
	int PSUN,ISUN,INVSOUN;

	if (CT_REQUN <= T_REQUN) return;	// ограничение регулятора УУН
	CT_REQUN=0;							// по быстродействию
	PDUN();								// подготовка аналоговых данных УУН
	VBKUN();							// выбор коэф-тов регулятора УУН
	// расчет пропорциональной составляющей регулятора
	T1 = K_PUN;							// расширение коэф-та до типа LONG
	PPSUN = T1 * (E_TUN - E_PUN);		// полная Р-сост.=Кр * (Етек - Епред)
	PSUN = PPSUN / 100;					// P-составляющая регулятора со смещением
	// проверка Р-составляющей на лимит
	if (PSUN < 0) goto S1;				// если "-"
	if (PSUN > LIMPUN) PSUN = LIMPUN;	// если > LIM
	goto S0;
S1: if ((PSUN + LIMPUN) > 0) goto S0;
	PSUN = LIMPUN * (-1);				// если < (-LIM)
	// расчет интегральной составляющей регулятора
S0: T1 = K_IUN;							// расширение коэф-та до типа LONG
	PISUN = T1 * E_TUN;					// полная I-сост.= Ки * Етек
	ISUN = PISUN / 100;					// I-составляющая регулятора со смещением
	{ // суммирование остатков
		SOUN += PISUN % 100;			// прибав.остатка деления к сумматору
		if (SOUN < 0) goto S1_1;		// сумматор меньше нуля
		if (SOUN < LOUN) goto S1_3;		// сравнение с лимитом остатков
		ISUN = ISUN + 1;				// увеличение I-сост.на (...)
		goto S1_2;
S1_1:	INVSOUN = SOUN * (-1);			// изменение знака сумматора остатков
		if (INVSOUN < LOUN) goto S1_3;
		ISUN = ISUN - 1;				// уменьшение I-сост.на (...)
S1_2:	SOUN = 0;						// обнуление сумматора
	}
	// проверка I-составляющей на лимит
S1_3:if (ISUN < 0) goto S2;				// если "-"
	if (ISUN > LIMIUN) ISUN = LIMIUN;	// если > LIM
	goto S3;
S2:	if ((ISUN + LIMIUN) > 0) goto S3;
	ISUN = LIMIUN * (-1);				// если < (-LIM)
S3:	U_PUN += (PSUN + ISUN);				// уставка = Uпред + (P-сост + I-сост)
	// ограничение по уставке
	if (U_PUN < 0) goto S4;				// < 0
	if (U_PUN > LIMU_UN) U_PUN = LIMU_UN; // LIMU_UN - переменный
	goto S5;
S4:	U_PUN = 0;
S5:	E_PUN = E_TUN;						// запоминание ошибки
	A_VIH = U_PUN+8192;					// выдача уставки (уст+8192+4095(5в))
	A_OUT (0,A_VIH);					// со смещением для платы DA8
}
//----------------------------------------------------------------------------
void PDUN()								// подготовка аналоговых данных УУН
{
	X_TUN = D_D3;						// тек.значение давления
	E_TUN = PAR_UN - X_TUN;				// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TUN >= 0) DELUN = E_TUN;
	else  DELUN = E_TUN * (-1);			// вычисление модуля ошибки
}
//----------------------------------------------------------------------------
void VBKUN()							// выбор коэф-тов регулятора УУН
{
	int i;
	for (i = 0; i <= 8; i++)
		if (DELUN > MZRUN[i]) {} else break;// опред.зоны регулирования
	K_PUN = MKPUN[i]; K_IUN = MKIUN[i];	// коэф-ты для P- и I- сост.
}
//----------------------------------------------------------------------------
void VIBPAR_UN ()						// подпрограмма "Выбор параметра УУН"
{

		PAR_UN = par[N_ST][4];				// ручной
        
        if(pow(10,(float)PAR_UN/1000.0-3.5)<=0.5)
            T_REQUN=160;
        else if(pow(10,(float)PAR_UN/1000.0-3.5)<=0.8)
           T_REQUN=120;
        else
            T_REQUN=80;
}
//------------------------------------------------------------------------------
void SBROSR_24()						// "Сброс режима 24 <УУН> (РРГ1)"
{
	shr[24] = 0;						// сброс активизации режима "УУН"
	sh[24] = 0;
	diagn[30] &= (~0xF0);				// сброс диагностик
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
                SetOut(0,2,0x800);      //закрыть кл7
    SetOut(0,2,0x100);	// закрытие кл 1

	A_OUT(0,8192);						// сброс уставки
	PAR_UN = 0;							// сброс параметра
	norma = 59;							// норма: "Сброс УУН завершен"


}
//---------------------------------------------------------------------------
void R_25() // режим 25 "Открыть заслонку"
{
	sh_ = sh[25];
	if ( shr[25] < 1 || shr[25] > 2 ) goto L100; // на выход

L00:if ( shr[25] == 1 ) goto L1;
	if ( shr[25] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[25] = sh_;
	if ( sh[25] != 0) goto L100;    // SH != 0
	shr[25]++;                      // след.шаг сч.шр1
	if ( shr[25] > 2) goto L0;      // число шагов режима
	sh[25] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 22;		           	    // норма: "Заслонка открылась"
	shr[25] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL = 7;                   // перевод в опрос состояния заслонки
    shr[26]  = 0;                   // сброс активации режима 26
	sh[26] = 0;                     // "Закрыть заслонку"
	shr[27]  = 0;                   // сброс активации режима 27
	sh[27] = 0;                     // "ДЗ на угол"
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xF8);
	sh_ = 0;
	goto L101;
L2: Klapan(1,&DZasl);				// открыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_26() // режим 26 "Закрыть заслонку"
{
	sh_ = sh[26];
	if ( shr[26] < 1 || shr[26] > 2 ) goto L100; // на выход

L00:if ( shr[26] == 1 ) goto L1;
	if ( shr[26] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[26] = sh_;
	if ( sh[26] != 0 ) goto L100;   // SH != 0
	shr[26]++;                      // след.шаг сч.шр1
	if ( shr[26] > 2) goto L0;    	// число шагов режима
	sh[26] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 23;		           	    // норма: "Заслонка закрылась"
	shr[26] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL = 7;                   // перевод в опрос состояния заслонки
    shr[25]  = 0;                   // сброс активации режима 25
	sh[25] = 0;                     // "Открыть заслонку"
	shr[27] = 0;                    // сброс активации режима 27
	sh[27] = 0;                     // "ДЗ на угол"
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xF8);
	sh_ = 0;
	goto L101;
L2: Klapan(0,&DZasl);				// закрыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_27 ()            // Режим "Повернуть ДЗ на угол"
 {
  sh_ = sh[27];
  if (shr[27] == 1) goto L1;
  if (shr[27] == 2) goto L2;
  if (shr[27] == 3) goto L3;
  if (shr[27] == 4) goto L4;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[27] = sh_;
	if (sh[27] != 0) goto L100;    // SH != 0
	++shr[27];                     // след. шаг сч.шр5
	if (shr[27] > 4) goto L0;     // число шагов режима
	sh[27] = 1;
L100:return;                    // возврат в "кольцо"

L0:	norma = 24;                   // норма: "ДЗ пришла в позицию"
	shr[27] = 0;
	goto L100;

L1:	shr[25] = 0;				// сброс активизации режима 25
	sh[25] = 0;
	shr[26] = 0;				// сброс активизации режима 26
	sh[26] = 0;
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xF8);
L1_1:   VRDZASL = 0;
        VIBPAR_DZASL();		     		// выбор параметра заслонки
	sh_ = 0;
	goto L101;
L2:	VIDK_DZASL(1,3,0x20,PAR_DZASL);    // открыть ДЗ на угол
	CT_27 = 0;
	goto L101;
L3:	if(TEK_POZ_DZASL != PAR_DZASL)
	{
		if(CT_27 >= T_VRDZASL)
			diagn[2] |= 0x08;		// диагностика "ДЗ не пришла в заданное положение"
		goto L101;
	}
	diagn[2] &= (~0x08);          // сброс диагностики
	VRDZASL = 1;
	ZPAR_DZASL = PAR_DZASL;
	sh_ = 0;
	goto L101;
L4: VIBPAR_DZASL();		     		// выбор параметра заслонки
    if(PAR_DZASL == ZPAR_DZASL) // задание не изменилось
		goto L101;
	shr[27] = 1;
	goto L1_1;						// возврат на шаг 1_1
}
//---------------------------------------------------------------------------
void R_28 ()	                    // режим "Вкл. ВЧГ стола"
{
	sh_ = sh[28];
	if (shr[28] == 1) goto L1;
	if (shr[28] == 2) goto L2;
	if (shr[28] == 3) goto L3;
	if (shr[28] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[28] = sh_;					//  |                           |
	if(sh[28]) goto L100;			//	|    sh != 0                |
	shr[28]++;						//	|    след.шаг 	            |
	sh[28] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: VRGIS = 0;                      // сброс признака выхода на режим ВЧГ стола
	diagn[4] &= (~0xBF);            // сброс диагностики режима ВЧГ стола
    A_OUT(4,8192);                  // обнуление уставки
    VRR_GIS();                      // выставить разр. работы ВЧГ стола
    goto L101;
L2: VIBPAR_GIS();                   // выбор параметров ВЧГ стола
    A_OUT(4,2*PAR_GIS+8192);        // выдача уставки на ВЧГ стола
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,5,0x08);				// включение выходной мощности ВЧГ стола
    CT_28 = 0;                      // очистка счетчиков
    CT28K1 = 0;                     // режима
    sh_ = 0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIS();                   // выбор параметров ВЧГ стола
    A_OUT(4,2*PAR_GIS+8192);        // выдача уставки на ВЧГ
	PDGIS ();                   	// Подготовка аналоговых данных
	RLIMGIS();	        			// новый расчет LIM для ВЧГ стола
	if (DELGIS <= LIM1GIS) goto L4_4;// модуль Ет <= LIM1
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[4] |= 0x04;		        // отказ: "нет регулирования ВЧГ п/д"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[4] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ п/д"
	if (DELGIS <= LIM2GIS) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[4] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ п/д"
	goto L4_7;
L4_5:diagn[4] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ п/д"
	goto L4_7;
L4_6:CT28K1 = 0;
L4_7:if (CT_28 <= T_VRGIS) goto L4_2;// Ттек <= Тзад
	if (VRGIS != 0) goto L4_1;      // есть выход на режим
	diagn[4] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ п/д"
	goto L4_2;
L4_1:diagn[4] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ стола"
L4_2:if (CT28K1 <= T_KGIS) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIS = 1;	               		// выход на режим
    norma = 50;                     // норма: "ВЧГ п/д вышел на режим"
L4_3:shr[28]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void R_29 ()	             		// режим "Вкл. нагрева 1"
{
	sh_ = sh[29];
	if (shr[29] == 1) goto L1;
	if (shr[29] == 2) goto L2;
	if (shr[29] == 3) goto L3;
	if (shr[29] == 4) goto L4;
	if (shr[29] == 5) goto L5;
	if (shr[29] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[29] = sh_;	   				// |                           |
	if (sh[29] != 0) goto L100;	  	// |    SH != 0                |
	shr[29]++;		        		// |    след.шаг 	           |
	sh[29] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: SetOut(0,4,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,4,0x01);				// Вкл. пускатель нагревателя
    shr[30] = 0;					// режима 34
	sh[30] = 0;						// 'Откл. нагрева'
	VRTEMP1 = 0;               		// сброс признака выхода на режим БПН
	diagn[16] &= (~0xE7);      		// сброс диагностики режима БПН
	CT_29 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_29<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,4,0x01);			// вкл. силовое питание БПН
		CT_29 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[29] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_29<=T_VKL_BPN) goto L101;
		diagn[16]|=0x08;			// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,4,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[16]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP1();		     		// выбор параметра БПН
	VIDK_TEMP1(1,16,040,1);			// выдать задание по температуре
	if(sh_) goto L101;            	//
	ZPAR_TEMP1 = PAR_TEMP1;			// запоминание параметра задания температуры
	CT_29 = 0;	           			// сброс
	CT29K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP1();		     		// выбор параметра БПН
	if ( PAR_TEMP1 == ZPAR_TEMP1 )  // параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 	// обход задания
	VIDK_TEMP1(1,16,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;           //
	ZPAR_TEMP1 = PAR_TEMP1; 		// зап.парам.задания температуры
L6_8:	PDTEMP1 ();                 // Подготовка аналоговых данных
	RLIMTEMP1();	        		// расчет LIM для БПН
	if (DELTEMP1<=LIM1TEMP1)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[16] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[16] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP1<=LIM2TEMP1)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[16] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[16] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT29K1 = 0;
L6_7:if (CT_29<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP1 != 0) goto L6_1;     // есть выход на режим
	diagn[16] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[16] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT29K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP1 = 1;	               		// выход на режим
L6_3:shr[29]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void R_30() // режим 30 "Откл. нагрева 1"
{
	sh_ = sh[30];

L00:if (shr[30] == 1)  goto L1;
	if (shr[30] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[30] = sh_;
	if (sh[30] != 0) goto L100;   // SH != 0
	shr[30]++;                    // след.шаг сч.шр1
	if (shr[30] > 2) goto L0;    	// число шагов режима
	sh[30] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[30] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[29]  = 0;                  // режима 33
	shr[29] = 0;                  // "Вкл. БПН"
	diagn[16] &= (~0xE7);		// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP1(1,16,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//---------------------------------------------------------------------------
void R_31 ()	             		// режим "Вкл. нагрева 2"
{
	sh_ = sh[31];
	if (shr[31] == 1) goto L1;
	if (shr[31] == 2) goto L2;
	if (shr[31] == 3) goto L3;
	if (shr[31] == 4) goto L4;
	if (shr[31] == 5) goto L5;
	if (shr[31] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[31] = sh_;	   					// |                           |
	if (sh[31] != 0) goto L100;	  	// |    SH != 0                |
	shr[31]++;		        		// |    след.шаг 	           |
	sh[31] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1:	SetOut(0,4,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,4,0x01);				// Вкл. пускатель нагревателя
	shr[32] = 0;                   	// режима 36
	sh[32] = 0;                     // 'Откл. нагрева'
	VRTEMP2 = 0;               		// сброс признака выхода на режим БПН
	diagn[17] &= (~0xE7);      		// сброс диагностики режима БПН

	CT_31 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_31<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,4,0x01);			// вкл. силовое питание БПН
		CT_31 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[31] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_31<=T_VKL_BPN) goto L101;
		diagn[16]|=0x08;				// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,4,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[16]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_NAGR();                   // выбор параметров нагрева
	VIDK_TEMP2(1,17,040,1); 		// выдать задание по температуре
	if(sh_) goto L101;            //
	ZPAR_TEMP2 = PAR_TEMP2;			// запоминание параметра задания температуры
	CT_31 = 0;	           			// сброс
	CT31K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_NAGR();                   // выбор параметров нагрева
	if(PAR_TEMP2 == ZPAR_TEMP2)   	// параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 		// обход задания
	VIDK_TEMP2(1,17,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;            //
	ZPAR_TEMP2 = PAR_TEMP2; 			// зап.парам.задания температуры
L6_8:PDTEMP2();                 	// Подготовка аналоговых данных
	RLIMTEMP2();	        			// расчет LIM для БПН
	if (DELTEMP2<=LIM1TEMP2)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP2 == 0) goto L6_6;		// нет выхода на режим
	diagn[17] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[17] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP2<=LIM2TEMP2)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP2 == 0) goto L6_6;		// нет выхода на режим
	diagn[17] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[17] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT31K1 = 0;
L6_7:if (CT_31<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP2 != 0) goto L6_1;     // есть выход на режим
	diagn[17] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[17] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT31K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP2 = 1;	               		// выход на режим
L6_3:shr[31]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void R_32() // режим 32 "Откл. нагрев 2"
{
	sh_ = sh[32];

L00:if (shr[32] == 1)  goto L1;
      if (shr[32] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[32] = sh_;
	if (sh[32] != 0) goto L100;   // SH != 0
	shr[32]++;                    // след.шаг сч.шр1
	if (shr[32] > 2) goto L0;    	// число шагов режима
	sh[32] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[32] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[31]  = 0;                  	// режима 35
	shr[31] = 0;                  	// "Вкл. БПН"
	diagn[17] &= (~0xEF);			// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP2(1,17,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//----------------------------------------------------------------------------
void R_33()							// режим "ИИ"
{
	sh_ = sh[33];
	if (shr[33] == 1) goto L1;
	if (shr[33] == 2) goto L2;
	if (shr[33] == 3) goto L3;
	if (shr[33] == 4) goto L4;
	if (shr[33] == 5) goto L5;
	if (shr[33] == 6) goto L6;
    else goto L100;              // на выход

				                 // | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[33] = sh_;	   	             // |                           |
	if (sh[33] != 0) goto L100;     //	|    SH != 0                |
	shr[33]++;		                 //	|    след.шаг 	            |
	sh[33] = 1;		             //	|			                |
L100:return;			         // |    возврат в "кольцо"	    |

L1: VRII = 0;                    // сброс признака выхода на режим ИИ
	diagn[25] &= (~0x7F);         // сброс диагностики режима ИИ

// Проверка включения и включение подсистем ИИ
L2: if (PR_SV_II == 0) goto L101;// Нет готовности связи ИИ
    if((OTVET_II[8]&04000) != 0)// Блок включен
     {
      shr[33]=4;
      goto L4_1;               // Переход на L4_1
     }
    sh_ = 0;
    goto L101;
L3: VIDK_II(014000,04000,1,25,010);// Вкл. блок ИИ
    if(sh_!= 0) goto L101;
    CT_33 = 0;                    // сброс счетчика времени режима
    goto L101;
L4: if(CT_33 <= 2) goto L101;  // задержка 2 сек на включение Uвых
L4_1:SetOut(0,4,0x2000);			// снять блокировку мощности БПИИ
	VIBPAR_II();		         // выбор параметра ИИ
    RLIMII();	  	             // задание LIM для ИИ
	SetOut(0,4,0x2000);			// снять блокировку мощности ИИ1
    sh_ = 0;
    goto L101;
// выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_II (0104000,010000,0,25,040);// вкл. Uвых ИИ
    if(sh_!=0) goto L101;
    CT_33 = 0;	            	 // сброс
    CT33K1 = 0;	            	 // счетчиков
    goto L101;
// выход на режим и диагностика
L6: VIBPAR_II();		         // выбор параметра ИИ
    VIDK_II (0104000,010000,0,25,040);// выдать уставку ИИ
    if(sh_!=0) goto L101;         // (Вкл.Uвых.)
    PDII ();                     // Подготовка аналоговых данных
    RLIMII();	        	     // новый расчет LIM для ИИ
    if(DELII <= LIM1II) goto L6_4;// модуль Ет <= LIM1
    if(VRII == 0) goto L6_6;	 // нет выхода на режим
    diagn[25] |= 0x04;		         // отказ: "нет регулирования ИИ"
    goto L6_5;	            	 // на сброс диагн."больш.ош."
L6_4:diagn[25] &= (~0x04);	         // сброс д."нет регулирования ИИ"
    if(DELII <= LIM2II) goto L6_5;// LIM2 (зона регулирования)
    if(VRII == 0) goto L6_6;	 // нет выхода на режим
    diagn[25] |= 0x02;		         // отказ: "б.ош.регулирования ИИ"
    goto L6_7;
L6_5:diagn[25] &= (~0x02);	         // сброс д."б.ош.регулирования ИИ"
    goto L6_7;
L6_6:CT33K1 = 0;
L6_7:if(CT_33 <= T_VRII) goto L6_2;// Ттек <= Тзад
    if (VRII != 0) goto L6_1;    // есть выход на режим
    diagn[25] |= 0x01;		         // отказ: "нет выхода на режим ИИ"
    goto L6_2;
L6_1:diagn[25] &= (~0x01);	         // сброс д."нет выхода на режим ИИ"
L6_2:if (CT33K1 <= T_KII) goto L6_3;// Т.K.тек <= Т.K.зад
    VRII = 1;	               	 // выход на режим
L6_3:shr[33]=5;                     // Возврат на L6
    goto L101;
}
//----------------------------------------------------------------------------
void VIBPAR_II()				// подпрограмма "Выбор параметра для ИИ"
{

		PAR_II = par[N_ST][5];

}
//----------------------------------------------------------------------------
void RLIMII ()		             // подпрограмма "Расчет LIM для ИИ"
{
	if (PAR_II == 0)	         // если задание = 0, расшир.лимитов
    {
        LIM1II = 4095;		     // MAX доп.знач.по входу ап.ср.
	    LIM2II = LIM1II / 2;     // LIM2 = 0,5 LIM1
    }
    else
    {
        LIM2II = PAR_II/DOPII;	 // LIM2 (малый)
	    LIM1II = PAR_II / 2;     // LIM1 (большой)
    }
}
//----------------------------------------------------------------------------
void PDII ()			         // подготовка аналоговых данных ИИ
{
    long T1;
	T1 = OTVET_II[5];            // I - ток ИИ
	T1=(T1*4095)/999;            // поправочный коэф. на тек.мощн. 4095/999=4.1
	X_TII = T1 ;		         // тек.значение мощности
	E_TII = PAR_II - X_TII;	     // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TII >= 0) DELII = E_TII;
	else  DELII = E_TII * (-1);	 // вычисление модуля ошибки
}
//---------------------------------------------------------------------------
// Подпрограмма выдачи команд на ИИ
//---------------------------------------------------------------------------
void VIDK_II(int a, int b, int c, int d, int e)
     // a - код команды (восьмеричный)
     // b - номер бита в байте состояния
     // c - значение бита в байте состояния (0 или 1)
     // d - номер байта массива диагностики
     // e - номер бита массива диагностики
{
    int x;
    if (sh_ == 1) goto A1;
    if (sh_ == 2) goto A2;
    else return;                   // выход
A1: SetOut(1,4,0x1000);             // Вкл.дист. управление
    if(diagnS[2] & 0x20) return;   // Есть диагностика "Нет связи с ИИ"
    PR_SV_II = 0;                  // Обнуление признака положительного
				   // ответа от ИИ
	                           // Формирование массива заданий
    KOM_II[0] = PAR_II;            // Ion.(0,5А)     - R1
    KOM_II[1] = 4095;              // Uon.(3000В)    - R2   
    KOM_II[2] = 4095;              // Pon.(0-1000Вт) - R3
    KOM_II[3] = 0;                 // (нет)          - R4
    KOM_II[4] = a;                 // Код команды    - R5
    CT_II = 0;                     // Сброс сч. времени
    sh_ = 2;
A2: if((diagnS[2] & 0x20) || (PR_SV_II == 0)) // Есть диагностика
                                   // "Нет связи с ИИ" или нет признака
				   // положительного ответа от ИИ
    {
        CT_II = 0;                 // Сброс сч. времени
        return;
    }
    x = ( OTVET_II[8] & b );       // Ожидание ответа на команду
    if( x != 0 ) x = 1;            // проверяемый бит = 1
    else x = 0;			           // проверяемый бит = 0
    if(x != c)			           // Нет ответа от ИИ
    {
        if (CT_II <= TK_OJ_OTV) return;    // Время не вышло (5 сек.)
        diagn[d] |= e;             // Отказ: "..."
        sh_ = 1;
        return;
    }
    diagn[d] &= (~e);              // Сброс диагностики
    sh_ = 0;
}
// Команды на ИИ
// VIDK_II ( 014000 , 04000  , 1 , 25 , 010  ) - Включить блок ИИ
// VIDK_II ( 010000 , 04000  , 0 , 25 , 020  ) - Выключить блок ИИ
// VIDK_II ( 0104000 , 010000 , 0 , 25 , 040  ) - Включить вых.напряжение ИИ
// VIDK_II ( 014000 , 010000 , 1 , 25 , 0100 ) - Выключить вых.напряжение ИИ
//---------------------------------------------------------------------------
void R_34 ()                        // Сброс ИИ
{
  sh_ = sh[34];
  if (shr[34] == 1)  goto L1;
  if (shr[34] == 2)  goto L2;
  else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[34] = sh_;
  if (sh[34] != 0) goto L100;   // SH != 0
  shr[34]++;                    // след.шаг сч.шр33
  if (shr[34] > 2) goto L0;     // число шагов режима
  sh[34] = 1;
L100: return;                   // возврат в "кольцо"

L0:norma = 64;                  // норма: "Сброс ИИ завершен"
  shr[34] = 0;
  goto L100;

L1:	shr[33] = 0;					// сброс режима 31 "Вкл. БПИИ"
	sh[33] = 0;
	SetOut(1,4,0x2000);           	// выставить блокировку Uвых БПИИ
    sh_ = 0;
	goto L101;
L2:	VIDK_II(014000,010000,1,25,0100);	// выкл. Uвых БПИИ
	if(sh_!=0) goto L101;
	PAR_II = 0;						// сброс параметра
	diagn[25] &= (~0x7F);			// сброс диагностик ИИ
	goto L101;
}
//------------------------------------------------------------------------------
void R_35 ()	                    // режим "М1"
{
	sh_ = sh[35];
	if (shr[35] == 1) goto L1;
	if (shr[35] == 2) goto L2;
	if (shr[35] == 3) goto L3;
	if (shr[35] == 4) goto L4;
	if (shr[35] == 5) goto L5;
	if (shr[35] == 6) goto L6;
    else goto L100;              // на выход

										// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[35] = sh_;	   	            	// |                           |
    if (sh[35] != 0) goto L100;      	// |    SH != 0                |
    shr[35]++;		            		// |    след.шаг 	           |
    sh[35] = 1;		            		// |						   |
L100:return;			    			// |    возврат в "кольцо"	   |

L1: VRBM1 = 0;                      	 // сброс признака выхода на режим БПМ1
    diagn[6] &= (~0x7F);           	 // сброс диагностик режима БПМ1
// Проверка включения и включение подсистем БПМ1
    if (PR_SV_BM1 == 0) goto L101;   	 // Нет готовности связи БПМ1
    if((OTVET_BM1[8]&04000) != 0)   	 // Блок включен
    {
        shr[35] = 3;
        sh_ = 0;
        goto L101;                  	// Переход на L4
    }
    sh_ = 0;
    goto L101;
L2: VIDK_BM1(014004 , 04000,1,6,010);  	// Вкл. блок БПМ1
    if(sh_) goto L101;
    CT_35 = 0;                      	// сброс счетчика времени режима
    goto L101;
L3: if(CT_35 <= 2) goto L101;      	 	// задержка 2 сек на включение пускателя БПМ1
    sh_ = 0;
    goto L101;
L4: SetOut(0,4,0x200);        			// снятие блокировки Uвых БПМ1
    VIBPAR_BM1();		    		// выбор параметра БПМ1
    RLIMBM1();	  	            		// задание LIM для БПМ1
	sh_ = 0;
    goto L101;
// выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_BM1(004004 , 010000,0,6,040);    // Вкл. Uвых. БПМ1
    if(sh_) goto L101;
    CT_35 = 0;	            	       // сброс
    CT35K1 = 0;	            	       // счетчиков
    goto L101;
// выход на режим и диагностика
L6: VIBPAR_BM1();		     		    // выбор параметра БПМ1
    VIDK_BM1(004004 , 010000,0,6,040);     // выдать уставку БПМ1
    if(sh_) goto L101;           	    // (Вкл.Uвых.)
    PDBM1 ();                           // Подготовка аналоговых данных
    RLIMBM1();	        	    		// новый расчет LIM для БПМ1
    if (DELBM1 <= LIM1BM1) goto L6_4; 	// модуль Ет <= LIM1
    if (VRBM1 == 0) goto L6_6;	    	// нет выхода на режим
    diagn[6] |= 0x04;		    		// отказ: "нет регулирования БПМ1"
    goto L6_5;	            	    	// на сброс диагн."больш.ош."
L6_4:diagn[6] &= (~0x04);	    		// сброс д."нет регулирования БПМ1"
    if (DELBM1 <= LIM2BM1) goto L6_5; 	// LIM2 (зона регулирования)
    if (VRBM1 == 0) goto L6_6;	    	// нет выхода на режим
	diagn[6] |= 0x02;		    		// отказ: "б.ош.регулирования БПМ1"
    goto L6_7;
L6_5:diagn[6] &= (~0x02);	    		// сброс д."б.ош.регулирования БПМ1"
    goto L6_7;
L6_6:CT35K1 = 0;
L6_7:if(CT_35 <= T_VRBM) goto L6_2; 	// Ттек <= Тзад
    if(VRBM1 != 0) goto L6_1;        	// есть выход на режим
    diagn[6] |= 0x01;		    		// отказ: "нет выхода на режим БПМ1"
    goto L6_2;
L6_1:diagn[6] &= (~0x01);	    		// сброс д."нет выхода на режим БПМ1"
L6_2:if(CT35K1 <= T_KBM) goto L6_3; 	// Т.K.тек <= Т.K.зад
    VRBM1 = 1;	               	    	// выход на режим
L6_3:shr[35] = 5;                   	// Возврат на L6
    goto L101;
}
//------------------------------------------------------------------------------

void R_36 ()	                    // режим "М2"
{
	sh_ = sh[36];
	if (shr[36] == 1) goto L1;
	if (shr[36] == 2) goto L2;
	if (shr[36] == 3) goto L3;
	if (shr[36] == 4) goto L4;
	if (shr[36] == 5) goto L5;
	if (shr[36] == 6) goto L6;
    else goto L100;              // на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[36] = sh_;	   	            // |                           |
    if (sh[36] != 0) goto L100;   	// |    	 SH != 0           |
    shr[36]++;		            	// |    	 след.шаг 	       |
    sh[36] = 1;		            	// |			   			   |
L100:return;			    		// |    возврат в "кольцо"	   |

L1: VRBM2 = 0;                       // сброс признака выхода на режим БПМ2
    diagn[8] &= (~0x7F);            // сброс диагностик режима БПМ2
// Проверка включения и включение подсистем БПМ2
    if (PR_SV_BM2 == 0) goto L101;   // Нет готовности связи БПМ2
    if((OTVET_BM2[8]&04000) != 0)    // Блок включен
    {
        shr[36] = 3;
        sh_ = 0;
        goto L101;                  // Переход на L4
    }
    sh_ = 0;
    goto L101;
L2: VIDK_BM2(014004 , 04000,1,8,010);  // Вкл. блок БПМ2
    if(sh_) goto L101;
    CT_36 = 0;                      // сброс счетчика времени режима
    goto L101;
L3: if(CT_36 <= 2) goto L101;       // задержка 2 сек на включение пускателя БПМ2
    sh_ = 0;
    goto L101;
L4: SetOut(0,4,0x800);        		// снятие блокировки Uвых БПМ2
    VIBPAR_BM2();					// выбор параметра М2
    RLIMBM2();						// задание LIM для БПМ2
	sh_=0;
    goto L101;
// выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_BM2(004004 , 010000,0,8,040);  // Вкл. Uвых. БПМ2
    if(sh_) goto L101;
    CT_36 = 0;	            	    // сброс
    CT36K1 = 0;	            	    // счетчиков
    goto L101;
// выход на режим и диагностика
L6: VIBPAR_BM2();					 	// выбор параметра М2
    VIDK_BM2(004004 , 010000,0,8,040);  	// выдать уставку БПМ2
    if(sh_) goto L101;           	 	// (Вкл.Uвых.)
    PDBM2 ();                        	// Подготовка аналоговых данных
    RLIMBM2();	        	    	 	// новый расчет LIM для БПМ2
    if (DELBM2 <= LIM1BM2) goto L6_4; 	// модуль Ет <= LIM1
    if (VRBM2 == 0) goto L6_6;	    	// нет выхода на режим
	diagn[8] |= 0x04;		    		// отказ: "нет регулирования БПМ2"
    goto L6_5;	            	    	// на сброс диагн."больш.ош."
L6_4:diagn[8] &= (~0x04);	    		// сброс д."нет регулирования БПМ2"
    if (DELBM2 <= LIM2BM2) goto L6_5;  	// LIM2 (зона регулирования)
    if (VRBM2 == 0) goto L6_6;	    	// нет выхода на режим
    diagn[8] |= 0x02;		    		// отказ: "б.ош.регулирования БПМ2"
    goto L6_7;
L6_5:diagn[8] &= (~0x02);	    	 	// сброс д."б.ош.регулирования БПМ2"
    goto L6_7;
L6_6:CT36K1 = 0;
L6_7:if(CT_36 <= T_VRBM) goto L6_2; 	// Ттек <= Тзад
    if(VRBM2 != 0) goto L6_1;        	// есть выход на режим
    diagn[8] |= 0x01;		    		// отказ: "нет выхода на режим БПМ2"
    goto L6_2;
L6_1:diagn[8] &= (~0x01);	    		// сброс д."нет выхода на режим БПМ2"
L6_2:if(CT36K1 <= T_KBM) goto L6_3; 	// Т.K.тек <= Т.K.зад
    VRBM2 = 1;	               	    	// выход на режим
L6_3:shr[36] = 5;                   	// Возврат на L6
    goto L101;
}
//------------------------------------------------------------------------------
void VIBPAR_BM2 ()		    // подпрограмма "Выбор параметра для БПМ2"
{

		PAR_BM2 = par[N_ST][7];

}
//------------------------------------------------------------------------------
void RLIMBM2 ()		            // подпрограмма "Расчет LIM для БПМ2"
{
    if (PAR_BM2 == 0)	            // если задание = 0, расшир.лимитов
     {
      LIM1BM2 = 4095;		    // MAX доп.знач.по входу ап.ср.
      LIM2BM2 = LIM1BM2 / 2;          // LIM2 = 0,5 LIM1
     }
    else
     {
      LIM2BM2 = PAR_BM2/DOPBM2;	    // LIM2 (малый)
      LIM1BM2 = PAR_BM2 / 2;         // LIM1 (большой)
     }
}
//------------------------------------------------------------------------------
void PDBM2 ()			    // подготовка аналоговых данных БПМ2
{
    long T1;
    T1 = OTVET_BM2[6];       // P - тек.мощность магнетрона
    T1=(T1*34)/10;          // поправочный коэф. на тек.мощн.
                           //Pзад.=К*Ртек.
                           // К=(4095/3600)*(3072/1023)=3,4
    X_TBM2 = T1 ;		    // тек.значение мощности
    E_TBM2 = PAR_BM2 - X_TBM2;	    // Хзад - Хтек = Етек (тек.ошибка)
    if (E_TBM2 >= 0) DELBM2 = E_TBM2;
    else  DELBM2 = E_TBM2 * (-1);	    // вычисление модуля ошибки
}
 //-----------------------------------------------------------------------------------
void R_37()							// РЕЖИМ 37 "Сброс БПМов"
{
	sh_ = sh[37];
	if (shr[37] < 1 || shr[37] > 4) goto L100; // на выход

    if (shr[37] == 1)  goto L1;        if (shr[37] == 2) goto L2;
	if (shr[37] == 3)  goto L3;        if (shr[37] == 4) goto L4;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[37] = sh_;
	if (sh[37] != 0) goto L100;   	// SH != 0
	shr[37]++;                    	// след.шаг сч.шр1
	if (shr[37] > 4) goto L0;    	// число шагов режима
	sh[37] = 1;
L100: return;  	                	// возврат в "кольцо"

L0: shr[37] = 0;
    norma = 65;                 // "Сброс БПМ завершен"
	goto L100;

L1:	shr[35] = 0;					// сброс активизации режима R_35
	sh[35] = 0;					// "М1"
	shr[36] = 0;					// сброс активизации режима R_36
	sh[36] = 0;					// "М2"
    SetOut(1,4,0xA00);
	if(!nasmod[8])				// нет РР БПМ1
    {
        shr[37] = 2;
		goto L2_1;
    }
	sh_ = 0;
	goto L101;
L2:	VIDK_BM1(014004 , 010000,1,6,0100); // команда "Выкл. Uвых БПМ1"
	if(sh_) goto L101;			// ожидание завершения
	diagn[6] &= (~0x7F);		// сброс диагностик реж. БПМ1
L2_1:if(!nasmod[9])				// нет РР БПМ2
	{
		shr[37] = 3;        // переход на шаг 4
	}
	sh_ = 0;
	goto L101;
L3:	VIDK_BM2(014004 , 010000,1,8,0100); // команда "Выкл. Uвых БПМ2"
	if(sh_) goto L101;			// ожидание завершения
	diagn[8] &= (~0x7F);		// сброс диагностик реж. БПМ2
    sh_=0;
	goto L101;
L4:
    PAR_BM1 = 0;				// сброс параметров М1, М2
	PAR_BM2 = 0;
    sh_=0;
    goto L101;
}
//---------------------------------------------------------------------------
void R_38() // режим "Чилер п/д вкл"
{
	sh_ = sh[38];
	if (shr[38] == 1) goto L1;
	if (shr[38] == 2) goto L2;
	if (shr[38] == 3) goto L3;
	else goto L100; // на выход

L101:sh[38] = sh_;
	if(sh[38]) goto L100;
	shr[38]++;
	sh[38] = 1;
L100:return;

L1: diagn[19] &= (~0x06);            // сброс диагностики режима ВЧГ стола
    A_OUT(7,8192);                  // обнуление уставки
    if(zin[2]&0x08)                                 //есть удалённый доступ?
    {
        sh_=0;
        diagn[19]&=(~0x02);                          //сброс диагностики
        SetOut(1,4,0x4000);                     //выдача пуска чилера п/д
    }
    else diagn[19]|=0x02;                           //отказ "Нет удалённого доступа чиллера п/д"
    CT_38=0;
    goto L101;
L2: if(zin[2]&0x01)
    {
        diagn[19]&=(~0x04); //сброс диагностики
    }
    else
    {
        if(CT_38>5)
            diagn[19]|=0x04; //отказ "Чиллер п/д не включился"
        goto L101;
    }
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: CT_38 = 0; // очистка счетчиков
    VIBPAR_NAGR(); // выбор параметров нагрева
    A_OUT(7,PAR_OHL+8192); // выдача уставки на ВЧГ стола
    goto L101;
}
//------------------------------------------------------------------------------
void R_39 ()	                    // режим "Чилер п/д откл"
{
	sh_ = sh[39];
	if (shr[39] == 1) goto L1;
    if (shr[39] == 2) goto L2;
	else goto L100; // на выход

L101:sh[39] = sh_;
	if(sh[39]) goto L100;
	shr[39]++;
    if (shr[39] > 2) goto L0;
	sh[39] = 1;
L100:return;

L0:	shr[39] = 0;
	goto L100;

L1: shr[38]=0;
    sh[38]=0;
	diagn[19] &= (~0x0E); // сброс диагностики режима ВЧГ стола
    A_OUT(7,8192); // обнуление уставки
    sh_=0;

    SetOut(0,4,0x4000); //снятие пуска чилера п/д
    goto L101;
L2: if(!(zin[2]&0x01))
    {
        diagn[19]&=(~0x08); //сброс диагностики
    }
    else
    {
        if(CT_39>5)
            diagn[19]|=0x08; //отказ "Чиллер п/д не отключился"
        goto L101;
    }
    shr[39] = 0;
    sh_ = 0; // выход
    goto L101;
}
//------------------------------------------------------------------------------
void VIBPAR_NAGR ()		    // подпрограмма "выбор параметров нагрева"
{

		if((shr[3])&&(nasmod[3]==0)&&(par[1][12])&&(N_ST>=0)&&(N_ST<=3))
        {
            PAR_TEMP2=par[1][15];
            PAR_OHL=par[1][15];
        }
        else if((shr[3])&&(nasmod[3]==0)&&(par[1][12]==0)&&(N_ST>=0)&&(N_ST<=4))
        {
            PAR_TEMP2=par[4][15];
            PAR_OHL=par[4][15];
        }
        else
        {
            PAR_TEMP2=par[N_ST][15];
            PAR_OHL=par[N_ST][15];
        }

}
//------------------------------------------------------------------------------
void R_40()					// Режим "Пуск КН"
{
    sh_ = sh[40];

	if (shr[40] == 1) goto L1;
	if (shr[40] == 2) goto L2;
	if (shr[40] == 3) goto L3;
	else goto L101;	// выход

L101:sh[40] = sh_;
	if (sh[40] != 0) goto L100;		// SH != 0
	++shr[40];						// след. шаг
	if (shr[40] > 3) goto L0;		// число шагов режима
	sh[40] = 1;
L100:return;

L0:	shr[40] = 0;
	goto L100;

L1: VIDK_KN(1,1,28,0x10);       	// команда "Пуск КН"
	goto L101;
L2:	VIDK_KN(3,3,28,0x40);       	// команда "Опрос состояния КН"
	if(sh_) goto L101;
	CT_40 = 0;                  // сброс сч. времени режима
	goto L101;
L3:	if(diagnS[2]&0x40)   		// есть диагностика "Нет связи с КН"
	{
		CT_40 = 0;				// сброс сч. режима 34
		goto L101;
	}
	// Проверка включения КУ и повления сигнала "Пуск БКО1"
	if((OTVET_KN_M[0]&0x900) != 0x900)
	{
		if(CT_40<5) goto L101;	// время не вышло (5 сек)
		diagn[28] |= 0x01;			// отказ: "Нет включения КН"
		goto L101;
	}
	diagn[28] &= (~0x01);      	// сброс диагностики
	PR_KN = 1;				  	// выставить признак пуска КН (работает)
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_41()					// Режим "Стоп КН"
{
	sh_ = sh[41];

	if (shr[41] == 1) goto L1;
	if (shr[41] == 2) goto L2;
	if (shr[41] == 3) goto L3;
	if (shr[41] == 4) goto L4;
	else goto L101;	// выход

L101:sh[41] = sh_;
	if (sh[41] != 0) goto L100;		// SH != 0
	++shr[41];						// след. шаг
	if (shr[41] > 4) goto L0;		// число шагов режима
	sh[41] = 1;
L100:return;

L0:	shr[41] = 0;
	goto L100;

L1:	VIDK_KN(2,2,28,0x20);     // команда "Стоп КН"
	goto L101;
L2:	VIDK_KN(3,3,28,0x40);     // команда "Опрос состояния КН"
	if(sh_) goto L101;
	CT_41 = 0;				// сброс сч.времени режима
	goto L101;
L3:	if(diagnS[2]&0x40)			// есть диагностика "Нет связи с КН"
	{
		CT_41 = 0;            // сброс сч. времени режима
		goto L101;
	}
	// Нет отключения КУ и появления сигнала "БКО1 отключился"
	if((OTVET_KN_M[0]&0x920) != 0x820)
	{
		if(CT_41 < 5) goto L101; // время не вышло
		diagn[28] |= 0x04;           // отказ: "КН не вышел на режим отключения"
		goto L101;
	}
	diagn[28] &= (~0x04);    // сброс диагностики
	CT_41 = 0;              // сброс сч.времени режима
	sh_ = 0;
	goto L101;
L4: if(diagnS[2]&0x40) // есть диагностика "Нет связи с КН"
	{
		CT_41 = 0;            // сброс сч.времени режима
		goto L101;
	}
	// Проверка отключения КН и появления сигнала "БКО1 отключится"
	if((OTVET_KN_M[0]&0x920) != 0)
	{
		if(CT_41 < 130) goto L101; // время не вышло (130 сек.)
		diagn[28] |= 0x02;     // отказ: "Нет отключения КН"
		goto L101;
	}
	diagn[28] &= (~0x02);    // сброс диагностики
	PR_KN = 0;				// сброс признака пуска КН
	sh_ = 0;
	goto L101;	
}
//---------------------------------------------------------------------------
void SBROS_KN()		// Подпрограмма "Сброс КН"
{
	shr[40] = 0;
	sh[40] = 0;
	shr[41] = 0;
	sh[41] = 0;
	diagn[27] &= (~0x7F);    // сброс диагностик режимов
	diagn[28] &= (~0x77);    // сброс диагностик режимов
	KOM_KN = 3;
}
//---------------------------------------------------------------------------
// Подпрограмма выдачи команд на КН
void VIDK_KN(int a, int b, int c, int d )
	 // a - код команды к КН
	 // b - код ответа от КН
	 // c - номер байта DIAGM
	 // d - номер бита в байте DIAGM
{
	if(sh_ == 1) goto A1;
	if(sh_ == 2) goto A2;
	else return;         			// выход
A1:	if(diagnS[2]&0x40) return; 	// есть диагностик "Нет связи с КН"
	PR_SV_KN = 0;	       	     	// обнуление признака полож.ответа от КН
	OTVET_KN = 0;	                // обнуление кода ответа от КН
	KOM_KN = a;	                	// запись кода команды от КН
	CT_KN = 0;                    	// сброс сч.времени
	sh_ = 2;
	// есть диагностика "Нет связи с КН" или нет признака полож. ответа от КН
A2:	if((diagnS[2]&0x40)||(!PR_SV_KN))
	{
		CT_KN = 0;                 	// сброс сч.времени
		return;
	}
	// ожидание ответа от КН
	if(OTVET_KN != b)            // нет ответа от КН
	{
		if(CT_KN <= 5) return;    // время вышло (5 сек)
		diagn[c] |= d;             // отказ: "..."
		sh_ = 1;
		return;
	}
	diagn[c] &= (~d);             // сброс диагностики
	KOM_KN = 3;                   // выдача команды "Проверка тек.статуса КН"
	sh_ = 0;
}
//     Команды на КН
// VIDK_KN (1,1,28,0x10)     - Старт (Пуск)
// VIDK_KN (2,2,28,0x20)     - СТОП
// VIDK_KN (3,3,28,0x40)     - Опрос состояния (комбинированная с запросом температуры крионасоса)
////////////////////////////////////////////////////////////////////////////////
void R_42 ()                    // режим 42 "подъём п/д в раб полож ионной очистки"
{
  	sh_ = sh[42];
	if((shr[42] < 1) || (shr[42] > 3)) goto L100; // на выход

L00:if(shr[42] == 1) goto L1;
	if(shr[42] == 2) goto L2;
    if(shr[42] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[42] = sh_;
	if (sh[42] != 0) goto L100;		// SH != 0
	shr[42]++;						// след.шаг
	if (shr[42] > 3) goto L0;		// число шагов режима
	sh[42] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 70;					// норма: "Мех. поворота в исходном"
	shr[42] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[26] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: pderj_v_ish();
    goto L101;
L3: VIDK_POD(par[0][11],ABS,nasmod[21],0,60);// поворот манип. вперед/назад
	goto L101;

}







//---------------------------------------------------------------------------
//---------  ПОДПРОГРАММЫ  --------------------------------------------------
//---------------------------------------------------------------------------
void AVAR_DAVL()      // "Реакция на высокое давление в камере при работе ТМН"
{
 if(out[4]&0x40)             // есть входной сигнал ТМН
  if((zin[2] & 0x300) != 0x200)	        // ДЗ не закрыт
   if((zin[0] & 0xC000) != 0x8000)		// Кл-D4 не закрыт
    if((diagnS[0] & 0x08) == 0)         // есть свяь с D4
     if(D_D4 >= POROG_DAVL)             // давление больше 100 Па
      {
		SetOut(0,0,0x18);				// закрыть ДЗ
		SetOut(1,0,0x10);				// закрыть ДЗ


       diagn[14] |= 0x04;               // "Авария: высокое давление в камере"

       shr[1] = 0;                      // сброс активизации режимов
       sh[1] = 0;                       // "Откачка"
	   shr[2] = 0;
       sh[2] = 0;                       // "Откачка шлюза"
       shr[3] = 0;
       sh[3] = 0;                       // "РЦ"
	   shr[4] = 0;
       sh[4] = 0;                       // "Тех. процесс"
       shr[5] = 0;
       sh[5] = 0;                       // "Сброс РЦ"
	   shr[6] = 0;
       sh[6] = 0;                       // "Сбор пластин"
	   shr[7] = 0;
       sh[7] = 0;                       // "Отключение установки"

	   shr[10] = 0;
       sh[10] = 0;						// "Открыть ЩЗ"
	   shr[11] = 0;
       sh[11] = 0;						// "Закрыть ЩЗ"


       shr[19] = 0;
       sh[19] = 0;                      // "Закрыть ДЗ"
       shr[25] = 0;
       sh[25] = 0;
       shr[26] = 0;
       sh[26] = 0;
       shr[27] = 0;
       sh[27] = 0;

       SBROSR_28();						// ВЧГ реактора
        SBROS_MEH();						// сброс движений


       SetOut(1,4,0x2A00);                //выдать выкл бмпов



	   RRGOff(ObjRRG[0]);				// отключение РРГ1
	   RRGOff(ObjRRG[1]);				// отключение РРГ2
       RRGOff(ObjRRG[2]);				// отключение РРГ3
	   RRGOff(ObjRRG[3]);				// отключение РРГ4
       if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7



       for(int i=0;i<DIAGN_COUNT;i++)
            if((i != 14)&&(i != 14)) diagn[i] = 0;// сброс диагностик кроме аварийных

       KOM_DZASL = 7;                    // "Общий опрос" заслонке
       if(shr[33])
       {
            shr[34]=1;
            sh[34]=1;
       }
       if((shr[35])||(shr[36]))
       {
            shr[37]=1;
            sh[37]=1;
       }
       if(shr[31])
       {
            shr[32]=1;
            sh[32]=1;
       }
       if(shr[38])
       {
            shr[39]=1;
            sh[39]=1;
       }
       if(shr[29])
       {
            shr[30]=1;
            sh[30]=1;
       }
       if(shr[16])
       {
            shr[17]=1;
            sh[17]=1;
       }

      }
}
//---------------------------------------------------------------------------
void AVAR_DAVL_KN()      // "Реакция на высокое давление в камере при работе КН"
{
    if(diagnS[2]&0x40)return;           //Нет связи с КН
    if((OTVET_KN_M[0]&0x900)==0)return; //КН выключен
    if((zin[2]&0xC00)==0x800)return;    //затвор закрыт
    if((diagnS[0] & 0x08))return;      //нет связи с D4
    if(D_D4 < POROG_DAVL)return;
    SetOut(0,0,0x20);       //закрыть затвор
    SetOut(1,0,0x40);       //закрыть затвор
    diagn[14]|=0x04;            //отказ "высокое давление в камере"
    shr[1] = 0;                      // сброс активизации режимов
       sh[1] = 0;                       // "Откачка"
	   shr[2] = 0;
       sh[2] = 0;                       // "Откачка шлюза"
       shr[3] = 0;
       sh[3] = 0;                       // "РЦ"
	   shr[4] = 0;
       sh[4] = 0;                       // "Тех. процесс"
       shr[5] = 0;
       sh[5] = 0;                       // "Сброс РЦ"
	   shr[6] = 0;
       sh[6] = 0;                       // "Сбор пластин"
	   shr[7] = 0;
       sh[7] = 0;                       // "Отключение установки"

	   shr[10] = 0;
       sh[10] = 0;						// "Открыть ЩЗ"
	   shr[11] = 0;
       sh[11] = 0;						// "Закрыть ЩЗ"


       shr[19] = 0;
       sh[19] = 0;                      // "Закрыть ДЗ"
       shr[25] = 0;
       sh[25] = 0;
       shr[26] = 0;
       sh[26] = 0;
       shr[27] = 0;
       sh[27] = 0;

       SBROSR_28();						// ВЧГ реактора
        SBROS_MEH();						// сброс движений


       SetOut(1,4,0x2A00);                //выдать выкл бмпов



	   RRGOff(ObjRRG[0]);				// отключение РРГ1
	   RRGOff(ObjRRG[1]);				// отключение РРГ2
       RRGOff(ObjRRG[2]);				// отключение РРГ3
	   RRGOff(ObjRRG[3]);				// отключение РРГ4
       if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7



       for(int i=0;i<DIAGN_COUNT;i++)
            if((i != 14)&&(i != 14)) diagn[i] = 0;// сброс диагностик кроме аварийных

       KOM_DZASL = 7;                    // "Общий опрос" заслонке
       if(shr[33])
       {
            shr[34]=1;
            sh[34]=1;
       }
       if((shr[35])||(shr[36]))
       {
            shr[37]=1;
            sh[37]=1;
       }
       if(shr[31])
       {
            shr[32]=1;
            sh[32]=1;
       }
       if(shr[38])
       {
            shr[39]=1;
            sh[39]=1;
       }
       if(shr[29])
       {
            shr[30]=1;
            sh[30]=1;
       }
       if(shr[16])
       {
            shr[17]=1;
            sh[17]=1;
       }




}
//---------------------------------------------------------------------------
void AVAR_VODA_BM1()				// реакция на отсутствие воды в М1
{
	// есть активизация режимов М1
	if(shr[35])
	{
		if(zin[0]&0x02) CT_VODA_BM1 = 0;// есть охлаждение магнетр.
		else if(CT_VODA_BM1 >= T_VODA)// время вышло (5 сек)
		{
			diagn[14] |= 0x01;	// Авария:"Нет охлаждения M1"
			if((shr[2])||((shr[3])&&!PR_NALADKA))			// есть активизации режима 2
			{
				sh[5] = 1;		// активизация режима 5
				shr[5] = 1;
			}
			else
			{

					shr[37] = 1;	// активизация 42 режима
					sh[37] = 1;

			}
		}
	}
	else
		CT_VODA_BM1 = 0;
}
//---------------------------------------------------------------------------
void AVAR_VODA_BM2()				// реакция на отсутствие воды в М2
{
	// есть активизация режимов М1
	if(shr[36])
	{
		if(zin[0]&0x04) CT_VODA_BM2 = 0;// есть охлаждение магнетр.
		else if(CT_VODA_BM2 >= T_VODA)// время вышло (5 сек)
		{
			diagn[14] |= 0x02;	// Авария:"Нет охлаждения M2"
			if((shr[2])||((shr[3])&&!PR_NALADKA))			// есть активизации режима 2
			{
				sh[5] = 1;		// активизация режима 5
				shr[5] = 1;
			}
			else
			{

					shr[37] = 1;	// активизация 42 режима
					sh[37] = 1;

			}
		}
	}
	else
		CT_VODA_BM2 = 0;
}
//---------------------------------------------------------------------------
void AVAR_VODA_II()				// реакция на отсутствие воды в ИИ
{
    if((!(shr[33]))||((zin[0]&0x01)))
    {
        CT_VODA_II=0;
        return;
    }
    if(CT_VODA_II>=T_VODA)
    {
        diagn[14]|=0x10;            //отказ: "Авария: нет охлаждения ИИ"
        if((shr[3])&&!PR_NALADKA)
        {
            shr[5]=1;
            sh[5]=1;
        }
        else
        {
            shr[34]=1;
            sh[34]=1;
        }
    }


}
//---------------------------------------------------------------------------
void OpenFK_TMN_CloseFK_SHL()	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
{
	if(out[4]&0x40 )				// если есть вращение ТМН

	  if((diagnS[0] & 0x10) == 0)		// есть свяь с D5
	   if(D_D5 >= UVAK_ZTMN)			// давление больше 40 Па
		if((zin[0]&0xC00)!=0x400)		// ФК-ТМН не открыт
		{
			if(((zin[0]&0x300)==0x200)&&((zin[0]&0x3000)==0x2000))	// ФК-КАМ и ФК-КН строго закрыт
				SetOut(1,0,0x02);		// открыть ФК-ТМН
			else
				SetOut(0,0,0x05);		// закрыть ФК-КАМ и ФК-КН
		}
}
//---------------------------------------------------------------------------
void MEH_AVAR_CHK()				// слежение за авриями механизма
{
	// если нет аварии механизма
	if((zin[3]&0x2000)&&(zin[3]&0x400))
		SetOut(0,3,0x8000);		// сбросить сигнал "Сброс аварий"
}
//---------------------------------------------------------------------------
void MEH_AVAR_SBROS()			// сброс аварий механизма (не в кольце)
{
	SetOut(1,3,0x8000);			// выдать сигнал "Сброс аварий"(по кнопке)
}
//---------------------------------------------------------------------------
void OSBROS()					// подпрограмма Общий сброс
{

    PR_OTP=0;
	PR_NALADKA = 0;
	N_ST = 0;
	KOM_DZASL = 7;


	shr[1] 	= 0;					// сброс активизации режима 1
	sh[1] 	= 0;					// "Откачка камеры"

	shr[5] 	= 0;					// сброс активизации режима 5
	sh[5] 	= 0;					// "Сброс РЦ"
	shr[6] 	= 0;					// сброс активизации режима 6
	sh[6] 	= 0;					// "Сбор пластин"
	shr[7] 	= 0;					// сброс активизации режима 7
	sh[7] 	= 0;					// "Отключение установки"
	shr[8] 	= 0;					// сброс активизации режима 8
	sh[8] 	= 0;					// "Аварийное отключение установки"

	shr[10] = 0;					// сброс активизации режима 10
	sh[10] 	= 0;					// "Открыть ЩЗ"
	shr[11] = 0;					// сброс активизации режима 11
	sh[11] 	= 0;					// "Закрыть ЩЗ"

	shr[19] = 0;					// сброс активизации режима 19
	sh[19] 	= 0;					// "Закрыть ДЗ"

    shr[25] = 0;					// сброс активизации режима 25
	sh[25] 	= 0;
    shr[26] = 0;					// сброс активизации режима 26
	sh[26] 	= 0;
    shr[27] = 0;					// сброс активизации режима 27
	sh[27] 	= 0;
    shr[30] = 0;					// сброс активизации режима 30
	sh[30] 	= 0;
    shr[32] = 0;					// сброс активизации режима 32
	sh[32] 	= 0;
    shr[34] = 0;					// сброс активизации режима 34
	sh[34] 	= 0;
    shr[37] = 0;					// сброс активизации режима 37
	sh[37] 	= 0;
    shr[39] = 0;					// сброс активизации режима 39
	sh[39] 	= 0;
    SBROSR_24();
	SBROSR_28();
	RRGOff(ObjRRG[0]);			// отключение РРГ1
	RRGOff(ObjRRG[1]);			// отключение РРГ2
	RRGOff(ObjRRG[2]);			// отключение РРГ3
	RRGOff(ObjRRG[3]);			// отключение РРГ4
    if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7


        shr[16]=0;
        sh[16]=0;
        shr[17]=0;
        sh[17]=0;
        diagn[20]&=(~0x01);
        SetOut(0,4,0x10);
        A_OUT(8,8192);

    SetOut(1,4,0x2A00);
	SBROS_MEH();				// сброс движений
    SBROS_KN();		// Подпрограмма "Сброс КН"
	for(int i=0;i<DIAGN_COUNT;i++) // сброс всех диагностик
	diagn[i] = 0;

	SetOut(0,2,0x08);			// отключить звонок
    SetOut(0,3,0x4000);


	norma = 7;					// норма: общий сброс завершен
}

//---------------------------------------------------------------------------
void SBROS_MEH() 				// режим "Сброс механизмов"
{
	// сброс движения МАН
	// сброс режимов
	shr[9] 	= 0;				// транспортный тест
	sh[9]  	= 0;
	shr[12] = 0;           		// МАН перемещения в исходное
	sh[12]  = 0;
	shr[13] = 0;           		// МАН перемещения вперед/назад
	sh[13]  = 0;
	shr[14] = 0;           		// подъём п/д в HOME
	sh[14]  = 0;
	shr[15]	= 0;				// подъём п/д вверх/вниз
	sh[15]	= 0;
    shr[18]	= 0;				// подъём п/д в раб позиц
	sh[18]	= 0;
    shr[42]=0;
    sh[42]=0;
	diagn[5] &=  (~0xFF);		// сброс диагностик МАН перемещения

    diagn[26] &= (~0xFF);		// сброс диагностик
	
	SetOut(0,3,0xF00);			// Отключение движения механизмов
	SetOut(1,3,0x4000);			// СТОП движение
    PR_PER=0;
    PR_POD=0;
    POL_PER=0;
	norma = 45;					// сброс механизмов завершен
}
//---------------------------------------------------------------------------
void UPR_AVAR_OTKL()			// Управление аварийным отключением
{
	if(out[4] & 0x40)  						// ТМН работает
	{
		if (!(zin[4] & 0x40))
			diagn[14] |= 0x08;					// авария ТМН
		else if (zin[1] & 0x02) goto A_1;  		// ФВН сухой включен
		else diagn[14] |= 0x40;					// диагностика: "Авария: Отключение ФВН"
        if(shr[8])return;
        shr[8]=1;
        sh[8]=1;
        return;
	}
	else
	{
A_1:    if((out[4]&0x04)&&(!(zin[1]&0x08)))	// ФВН камеры включен и есть авария
		{
            diagn[14] |= 0x20;				// диагностика: "Авария: ФВН камеры"
			if(shr[8] == 0)						// режим R_8 не активизирован
			{
				shr[8] = 1;						// активизация режима R_8
				sh[8] = 1;
			}
            return;
		}
        else
        {
            if(diagn[27]&0x7F)          //есть хотя бы одна из диагностик КН
            {
                diagn[14]|=0x80;        //отказ "авария КН"
                if(!(shr[8]))
                {
                    shr[8]=1;
                    sh[8]=1;
                }
            }
        }
	}
}
//---------------------------------------------------------------------------
void REAKCIA_KZM1()							// реакция на КЗ БПМ1
{
	if(!(diagn[20]&0x04))	// нет диагностик КЗ БПМ1
	{
		if((shr[35]>5))
		// запущен хоть один режим БПМ1
		{
			if(PR_KZ1)
			{
				if(CT_KZ1 > 3)
				{
					SetOut(0,4,0x200);		// вкл. вых. мощность БПМ1
					N_KZ1++;
					if(N_KZ1 >= 3)
					{
						if(shr[35])
							diagn[20] |= 0x04; // Отказ: КЗ БПМ1
						N_KZ1 = 0;
						if(!shr[5])			// не запущен "Сброс РЦ"
						{
							if(shr[2]||(shr[3]&&!PR_NALADKA)) 		// запущен РЦ не в наладке или тренировка
							{
								shr[5] = 1;// запустить Сброс РЦ
								sh[5] = 1;
							}
							else if(!shr[37])// не запущен сброс БПМ
							{
								shr[37] = 1;// запустить Сброс БПМ
								sh[37] = 1;
							}
						}
					}
					else
						PR_KZ1 = 0;
				}
			}
			else
			{
				if(!(OTVET_BM1[9]&0x04))	// есть КЗ
				{
					PR_KZ1 = 1;
					CT_KZ1 = 0;
					SetOut(1,4,0x200);		// выкл. вых. мощность БПМ1
				}
				else
                {
					PR_KZ1 = 0;
                    N_KZ1 = 0;
                }
			}
		}
		else
			PR_KZ1 = 0;
	}
	else
		PR_KZ1 = 0;
}
//---------------------------------------------------------------------------
void REAKCIA_KZM2()							// реакция на КЗ БПМ2
{
	if(!(diagn[20]&0x08))	// нет диагностик КЗ БПМ2
	{
		if((shr[36]>5))
		// запущен хоть один режим БПМ2
		{
			if(PR_KZ2)
			{
				if(CT_KZ2 > 3)
				{
					SetOut(0,4,0x400);		// вкл. вых. мощность БПМ2
					N_KZ2++;
					if(N_KZ2 >= 3)
					{
						if(shr[36])
							diagn[20] |= 0x08; // Отказ: КЗ БПМ2
						N_KZ2 = 0;
						if(!shr[5])			// не запущен "Сброс РЦ"
						{
							if(shr[2]||(shr[3]&&!PR_NALADKA)) 		// запущен РЦ не в наладке или тренировка
							{
								shr[5] = 1;// запустить Сброс РЦ
								sh[5] = 1;
							}
							else if(!shr[37])// не запущен сброс БПМ
							{
								shr[37] = 1;// запустить Сброс БПМ
								sh[37] = 1;
							}
						}
					}
					else
						PR_KZ2 = 0;
				}
			}
			else
			{
				if(!(OTVET_BM2[9]&0x04))	// есть КЗ
				{
					PR_KZ2 = 1;
					CT_KZ2 = 0;
					SetOut(1,4,0x400);		// выкл. вых. мощность БПМ2
				}
				else
                {
					PR_KZ2 = 0;
                    N_KZ2 = 0;
                }
			}
		}
		else
			PR_KZ2 = 0;
	}
	else
		PR_KZ2 = 0;
}
//---------------------------------------------------------------------------
//--Вращение п/держателя--//
//---------------------------------------------------------------------------
void GoPderjatel()
{
    switch (sh_)
    {

        case 1:
        {
            VRPD = 0;               // сброс выхода на режим п/держателя
            A_OUT(8,8192 +nasmod[17]);       // выдать минимальную скорость на п/держ.
            SetOut(1,4,0x10);     	// вкл. вращ. п/держ. вперёд
            ctPderjDvij = 0;        // сброс сч. вр. вращ. п/держателя
            sh_ = 2;
        }; break;
        case 2:
        {
            // время разгона вышло?
            if ( ctPderjDvij > tkPderjRazgon )
            {
                VRPD = 1;           // установить выход на режим п/держателя
                norma = 53;          // есть вращение п/держателя
            }
            // пересчитать и выдать новую уставку скорости
            if ( ctPderjDvij < tkPderjRazgon )
                A_OUT(8,8192+ nasmod[17] + (nasmod[18] - nasmod[17]) * ctPderjDvij / tkPderjRazgon);
            else
                A_OUT(8,8192+nasmod[18]);
        }; break;
        
    }
}
//---------------------------------------------------------------------------
//--Останов п/держателя--//
//---------------------------------------------------------------------------
void StopPderjatel()
{
    switch (sh_)
    {

        case 1:
        {
            A_OUT(8,8192+nasmod[18]);   // выставить максимальную скорость вращения
            SetOut(1,4,0x10);     // вкл. вращ. п/держ. вперёд
            ctPderjDvij = 0;       // сброс сч. вр. движения п/держателя
            sh_ = 2;                // переход на след. шаг
        }; break;
        case 2:
        {
            if(zin[3] & 0x80)       // п/д в исходном
            {
                // сброс диагностики
                diagn[20] &= (~0x01);
                // сброс сч.вр. п/держателя
                ctPderjDvij = 0;
                // переход на след. шаг
                sh_ = 3;
            }
            // время движ. п/держ. в исх. вышло?
            else if ( ctPderjDvij > tkPderjIsh )
                diagn[20] |= 0x01;  	// отказ: "П/держ. не пришёл в исх"
        }; break;
        case 3:
        {
            // время торможения НЕ вышло
            if ( ctPderjDvij < tkPderjRazgon )
                A_OUT(8,8192+ nasmod[18] - (nasmod[18] - nasmod[17]) * ctPderjDvij / tkPderjRazgon );
            // время торможения вышло
            else
            {
                // сброс сч.вр. п/держателя
                ctPderjDvij = 0;
                sh_ = 4;           // перейти на след. шаг
            }
        }; break;
        case 4:
        {
            if(zin[3] & 0x80)    // п/держ. в исходном
            {
                // сброс диагностики
                diagn[20] &= (~0x01);
                // сброс направления движ. п/держателя
                SetOut(0,4,0x10);
                // сброс уставки скорости
                A_OUT(8,8192);
                // норма: "П/держ. остановился"
                norma = 54;
                // сброс подпрограммы
                sh_ = 0;
            }
            // время движ. п/держ в исх. вышло
            else if ( ctPderjDvij > tkPderjIsh )
                diagn[20] |= 0x01;  // отказ: "п/держ. не пришел в исх."
        }; break;

    }
}
//---------------------------------------------------------------------------
void pderj_v_ish()        //вращение п/д в HOME
{
    switch(sh_)
    {
        case 0:return;break;
        case 1:
        {
            if(zin[3]&0x80)           //п/д в HOME ?
            {
                sh_=0;

                return;
            }
            A_OUT(8,8192+nasmod[17]);       	// выставить минимальную скорость вращения
            SetOut(1,4,0x10);       //включить вращение п/д
            ctPderjDvij = 0;        // сброс сч. вр. движения п/держателя
             sh_ = 2;                 // переход на след. шаг
        }break;
        case 2:
        {
            if(zin[3]&0x80)           //п/д в HOME ?
            {
                diagn[20]&=(~0x01);         //сброс диагностики
                A_OUT(8,8192);       	//снять минимальную скорость вращения
                SetOut(0,4,0x10);       // откл. вращ. п/держ. вперёд
                sh_=0;
                return;
            }
            if(ctPderjDvij>10*50)
                diagn[20]|=0x01;            //отказ "Привод вращения п/д не пришёл в HOME"
        }break;
        default: sh_=0;
    }
    
}
////////////////////////////////////////////////////////////////////////////////
 void vkl_dist_tmn()    //включить дистанционное управление ТМН
 {
    switch(sh_)
    {
        case 0: return;
        case 1:
        {
            SetOut(1,4,0x20);           //вкл дистанц управление
            CT_1=0;
            sh_=2;
        };break;
        case 2:
        {
            if(zin[4]&0x80)             //дистанц управление включено
            {
                diagn[19]&=(~0x01);         //сброс диагностики
                sh_=0;
                return;
            }
            if(CT_1>=5)
                diagn[19]|=0x01;            //отказ: "Дистанционное управление ТМН не включилось"
        };break;
        default: sh_=0;break;


    }

 }
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
void VIDK_POD(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x02) return;		// нет связи с контроллером
	SetOut(0,3,0x4000);				// снять Стоп механизмов
	PR_POD = 1;
	CT_POD = 0;
	sh_ = 2;
A2:	if(!(zin[3]&0x800))				// нет готовности привода
	{
		if(CT_POD >= 5)
			diagn[26] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[26] &= (~0x01);			// сброс диагностики
	OTVET_POD = 0;
	V_POD = a;
	TYPE_POD = b;
	PUT_POD = c;
	HOME_POD = d;
	KOM_POD = 1;
	CT_POD = 0;
    TEK_OTN_POD = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x02 || !OTVET_POD)	// есть диагностика нет связи или нет ответа
	{
		if(CT_POD >= 5)
			diagn[26] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[26] &= (~0x04);			// сброс диагностики
	KOM_POD = 0;
	if(!HOME_POD)					// не движение в HOME
	{
		SetOut(1,3,0x400);           // выдать движение
		CT_POD = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,3,0x800);          		// выдать движение в Home
	CT_POD = 0;
	sh_ = 4;
A4:	if(!(zin[3]&0x1000)||(TEK_ABS_POD))				// механизм не пришел в HOME
	{
		if(CT_POD >= e)
			diagn[26] |= 0x08;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;
	}
	diagn[26] &= (~0x08);			// сброс диагностики
	SetOut(0,3,0x800);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[3]&0x800))				// нет готовности привода
	{
		if(CT_POD >= 5)
		diagn[26] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[26] &= (~0x01);			// сброс диагностики
	PR_POD = 0;
	norma = 67;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,3,0x4000);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[3]&0x800)				// есть готовность привода
	{
		if(CT_POD >= 5)
			diagn[26] |= 0x02;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[26] &= (~0x02);			// сброс диагностики
	SetOut(0,3,0x400);               // сбросить начало движение
	CT_POD = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[3]&0x800)||((TYPE_POD==ABS)&&(PUT_POD!=TEK_ABS_POD))||((TYPE_POD==OTN)&&(PUT_POD!=TEK_OTN_POD)))				// есть готовность привода
	{
		if(CT_POD >= e)
			diagn[26] |= 0x10;		// отказ: "Нет завершения движ. перемещ."
		return;
	}
	diagn[26] &= (~0x10);			// сброс диагностики
	PR_POD = 0;
	norma = 69;						//"Манипулятор перемещения путь прошел"
    SetOut(1,3,0x4000);				// выставить Стоп механизмов
	sh_ = 0;
}
//---------------------------------------------------------------------------










void VID_DIAGN_GIS()			// выдача диагностики нет согласования НЧГ стола
{
    if ((shr[28])&&				// есть активизация режима НЧГ стола
        (VRGIS)&&				// есть выход на режим ВЧГ стола
        (aik[11]))				// отраженная мощность не 0
    {
        N_TEK_GIS=aik[10]*10/aik[11];// текущий коэф. согласования
        if(N_TEK_GIS >= nasmod[14])
            diagn[4] &=(~0x08) ;// снять диагностику
        else
            diagn[4] |=0x08 ;	// диагн.: "нет согл. НЧГ  реактора"
    }
    else
    {
        diagn[4] &=(~0x08) ;// снять диагностику
        N_TEK_GIS = 0;
    }
}

//---------------------------------------------------------------------------
void VIBPAR_DZASL ()					// подпрограмма "Выбор параметра для заслонки"
{
    if(PR_OTP)
        PAR_DZASL = par[N_ST][13];
    else
        PAR_DZASL = par[N_ST][9];
}
//---------------------------------------------------------------------------
void RLIMDZASL()						// подпрограмма "Расчет LIM для заслонки"
{
	if (PAR_DZASL == 0)	        	//если задание = 0, расшир.лимитов
	{
		LIM1DZASL = 10000;	    	// MAX доп.знач.по входу ап.ср.
		LIM2DZASL = LIM1DZASL / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2DZASL = PAR_DZASL / DOPDZASL;	// LIM2 (малый)
		LIM1DZASL = PAR_DZASL / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDDZASL ()						// подготовка аналоговых данных заслонки
{
	X_TDZASL = TEK_DAVL_DZASL;			// тек.значение
	E_TDZASL = PAR_DZASL - X_TDZASL;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TDZASL >= 0) DELDZASL = E_TDZASL;
	else  DELDZASL = E_TDZASL * (-1);	// вычисление модуля ошибки
}
//------------------------------------------------//
//--Подпрограмма выдачи команд на заслонку (MKS)--//
//------------------------------------------------//
void VIDK_DZASL ( int a, int b, int c, int d )
	// a - код команды к заслонке
	// b - номер байта массива диагностики DIAGM
	// c - номер бита в байте DIAGM
	// d - задание по положению (0...10000)
{
	switch ( sh_ )
	{
		case 1:
		{
			// если нет связи с заслонкой
			if ( diagnS[0] & 0x40 ) return;
			// обнуление признака положительного ответа
			PR_DZASL = 0;
			// обнуление кода ответа
			OTVET_DZASL = 0;
			// выдача заданной команды
			KOM_DZASL = a;
            //снятие дискреты выхода
            SetOut(0,0,0x18);
			// есть команда контроль давления
			if ( KOM_DZASL == 2 )
			{
				// выбрали параметр заслонки
				VIBPAR_DZASL();
				// установили параметр
				DATA_DZASL = PAR_DZASL;
			}
			// есть команда контроль положения
			else if ( KOM_DZASL == 1 )
			{
				// определили параметр из задания (по положению)
				DATA_DZASL = d;
			};
			// сбросили счетчик времени заслонки
			CT_DZASL = 0;
			// перешли на следующий шаг
			sh_ = 2;
		}; break;
		case 2:
		{
			// если нет связи с заслонкой или ответ не положительный
			if ( ( diagnS[0] & 0x40 ) || ( PR_DZASL == 0 ) )
				// сброс сч.времени заслонки
				CT_DZASL = 0;
			// есть связь с заслонкой и ответ положительный
			// и ответ заслонки НЕ соответствует искомому
			else if ( OTVET_DZASL != a )
			{
				// сравнение с контрольным временем и диагностика
				if ( CT_DZASL > 5 ) diagn[b] |= c;
			}
			// если все штатно
			else
			{
				// сброс диагностики
				diagn[b] &= ~c;
				// если команда НЕ опрос состояния заслонки
				if ( KOM_DZASL != 7 )
				{
					// запись кода команды - общий опрос
					KOM_DZASL = 7;
					// сброс признака положительного ответа
					PR_DZASL = 0;
				}
				// выход из подпрограммы
				sh_ = 0;
			}
		}; break;
		default: ;break;
	};
}
// Команды на заслонку
//             КК   диагн
// VIDK_DZASL ( 1, 3, 0x20,..)  - Задание положения (код положения)
// VIDK_DZASL ( 2, 3, 0x40, 0)  - Задание давление
// VIDK_DZASL ( 3, 3, 0x08, 0)  - Открыть заслонку
// VIDK_DZASL ( 4, 3, 0x10, 0)  - Закрыть заслонку
// VIDK_DZASL ( 7, 3, 0x80, 0)  - Опрос состояния заслонки
//---------------------------------------------------------------------------
void SBROSR_28()					// "Откл. ВЧГ стола"
{
	shr[28] = 0;        // сброс активизации
	sh[28] = 0;         // режима 29 "Вкл. ВЧГ реактора"
	VRGIS = 0;          // сброс выхода ВЧГ на режим
	A_OUT(4,8192);      // сброс уставки вых. мощности ВЧГ
	SetOut(0,5,0x08);	// откл. вых. мощн.
	diagn[4]&=(~0xFF);	// сброс диагностик режимов "ВЧГ"
	norma = 52;			// норма: "Сброс режима ВЧГ ИП завершен"
}
/////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
void VIBPAR_TEMP1 ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP1 = nasmod[5];            //
}
//---------------------------------------------------------------------------
void RLIMTEMP1 ()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP1 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP1 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP1 = LIM1TEMP1 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP1 = PAR_TEMP1 / DOPTEMP1;	// LIM2 (малый)
		LIM1TEMP1 = PAR_TEMP1 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDTEMP1 ()						// подготовка аналоговых данных БПН
{
	X_TEMP1 = TEK_TEMP1;	           	// тек.значение температуры
	E_TEMP1 = PAR_TEMP1 - X_TEMP1;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP1 >= 0) DELTEMP1 = E_TEMP1;
	else  DELTEMP1 = E_TEMP1 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------//
//--Подпрограмма выдачи команд на ТЕРМОДАТ--//
//------------------------------------------//
void VIDK_TEMP1 ( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x10 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP1 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP1();			// выбор параметра температуры
						ZAD_TEMP1 = PAR_TEMP1;	// запись задания
					}
				}
				CT_TEMP1 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ((diagnS[2] & 0x10) || (!PR_TEMP))
			{
				if ( CT_TEMP1 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP1 ( 1 , 16 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP1 ( 1 , 16 , 0100 , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP1 ( 2 , 16 , 0200 , X )  - Опрос температуры
void VIDK_TEMP2( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x40 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP2 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_NAGR();			// выбор параметра температуры
						ZAD_TEMP2 = PAR_TEMP2;	// запись задания
					}
				}
				CT_TEMP2 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ( ( diagnS[2] & 0x40 ) || ( PR_TEMP == 0 ) )
			{
				if ( CT_TEMP2 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP2 ( 1 , 17 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP2 ( 1 , 17 , 0100  , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP2 ( 2 , 17 , 0200 , X )  - Опрос температуры
//---------------------------------------------------------------------------
void PDTEMP2()						// подготовка аналоговых данных БПН
{
	X_TEMP2 = TEK_TEMP2;	           	// тек.значение температуры
	E_TEMP2 = PAR_TEMP2 - X_TEMP2;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP2 >= 0) DELTEMP2 = E_TEMP2;
	else  DELTEMP2 = E_TEMP2 * (-1);	// вычисление модуля ошибки
}
void RLIMTEMP2()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP2 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP2 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP2 = LIM1TEMP2 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP2 = PAR_TEMP2 / DOPTEMP2;	// LIM2 (малый)
		LIM1TEMP2 = PAR_TEMP2 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------

void VIBPAR_GIS ()				    // подпрограмма "Выбор параметра для ВЧГ реактора"
{
	PAR_GIS = par[N_ST][8];
}
//---------------------------------------------------------------------------
void RLIMGIS ()						// подпрограмма "Расчет LIM для ВЧГ реактора"
{
    if (VRGIS == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIS = 15;                // допуск 66,6%
        LIM2GIS = (PAR_GIS * 10) / DOPGIS; // LIM2 (малый)
        LIM1GIS = (PAR_GIS*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIS <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIS = 30;           // допуск 33%
	    else  if ( PAR_GIS <= 276 ) // если зад. мощность <= 41Вт
		    DOPGIS = 40;            // допуск 25%
        else DOPGIS = 50;           // иначе допуск 20%

	    if (PAR_GIS == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIS = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIS = LIM1GIS / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIS = PAR_GIS * 10 / DOPGIS; // LIM2 (малый)
	        LIM1GIS = PAR_GIS / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIS ()						// подготовка аналоговых данных ВЧГ реактора
{
	X_TGIS = aik[10];	            // тек.значение падающей мощности
	E_TGIS = PAR_GIS - X_TGIS;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIS >= 0) DELGIS = E_TGIS;
	else  DELGIS = E_TGIS * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void VRR_GIS()						// подпрограмма "Выставить разр. работы ВЧГ стола"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
    if (sh_ == 3) goto A3;
	else return;	// выход

A1:	SetOut(1,5,0x02);				// выставить разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[1] & 0x400) == 0)		// разр.раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[7] |= 0x10;			// отказ:"Разр. работы ВЧГ не выставилось"
		return;
	}
	diagn[7] &= (~0x10);			// сброс диагностики
    CT_VHG = 0;
	sh_ = 3;
A3: if(!(zin[1]&0x800))              //Есть готовность ВЧГ реактора ИП
    {
        if(CT_VHG>T_VHG)            //время не вышло
            diagn[15]|=0x08;        //отказ:"Нет готовности ВЧГ генератора ИП"
        return;
    }
    diagn[15]&=(~0x08);             //сброс диагностики
    SetOut(1,5,0x04);              //Выдача сигнала дистанц. управления
    sh_=0;
    return;
}
//------------------------------------------------------------------------------
void ORR_GIS()						// подпрограмма "Снять разр. работы ВЧГ стола"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(0,5,0x02);				// снять разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[1] & 0x400) != 0)		// разр.раб. не снято
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[7] |= 0x20;			// отказ: "Разр. работы ВЧГ не снялось"
		return;
	}
	diagn[7] &= (~0x20);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------

void OBPN()				// подпрограмма "Отключить БПН (сил. пит. на термодат)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;      // выход

A1:	SetOut(0,4,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	SetOut(1,4,0x02);		   	// выкл. силового питания БПН
	CT_IST = 0;			   		// сброс сч.времени
	sh_ = 2;
A2:	if (zin[0]&0x80)	   	// силовое питание включено
	{
		if (CT_IST<=T_VKL_BPN) return;// время не вышло
		diagn[16]|=0x10;	           // отказ:"Силовое питание БПН не выкл."
		return;
	}
	SetOut(0,4,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	diagn[16]&=(~0x10);		   	// сброс диагностики
	sh_ = 0;
	norma = 21;					// норма: "Силовое питание БПН отключено"
 }
//------------------------------------------------------------------------------
void VIBPAR_BM1 ()		    // подпрограмма "Выбор параметра для БПМ1"
{

		PAR_BM1 = par[N_ST][6];

}
//------------------------------------------------------------------------------
void RLIMBM1 ()		            // подпрограмма "Расчет LIM для БПМ1"
{
    if (PAR_BM1 == 0)	            	// если задание = 0, расшир.лимитов
     {
      LIM1BM1 = 4095;		    		// MAX доп.знач.по входу ап.ср.
      LIM2BM1 = LIM1BM1 / 2;          	// LIM2 = 0,5 LIM1
     }
    else
     {
      LIM2BM1 = PAR_BM1/DOPBM1;	    	// LIM2 (малый)
      LIM1BM1 = PAR_BM1 / 2;         	// LIM1 (большой)
     }
}
//------------------------------------------------------------------------------
void PDBM1 ()			    // подготовка аналоговых данных БПМ1
{
    long T1;
    T1 = OTVET_BM1[6];       	// P - тек.мощность магнетрона
    T1=(T1*34)/10;          	// поправочный коэф. на тек.мощн.
								// Pзад.=К*Ртек.
								// К=(4095/3600)*(3072/1023)=3,4
    X_TBM1 = T1 ;		    	// тек.значение мощности
    E_TBM1 = PAR_BM1 - X_TBM1;	// Хзад - Хтек = Етек (тек.ошибка)
    if (E_TBM1 >= 0) DELBM1 = E_TBM1;
    else  DELBM1 = E_TBM1 * (-1);	    // вычисление модуля ошибки
}
//------------------------------------------------------------------------------
void VIDK_BM1(int a, int b, int c, int d, int e)
     // a - код команды (восьмеричный)
     // b - номер бита в байте состояния
     // c - значение бита в байте состояния (0 или 1)
     // d - номер байта массива диагностики
     // e - номер бита массива диагностики
{
    int x;
    if (sh_ == 1) goto A1;
    if (sh_ == 2) goto A2;
    else return;                   	// выход
A1: SetOut(1,4,0x100);              // Вкл.дист. управление
    if(diagnS[2] & 0x04) return;  	// Есть диагностика "Нет связи с БПМ"
    PR_SV_BM1 = 0;                 	// Обнуление признака положительного
                                    // ответа от БПМ1
	                               	// Формирование массива заданий
    KOM_BM1[0] = 4095;              // Ion.(15А)      - R1
    if(shr[35])
    KOM_BM1[1] = nasmod[10];         // Uon.(650В)     - R2
    else KOM_BM1[1] = 0;

    if(shr[35])            // БПМ1
    KOM_BM1[2] = PAR_BM1;
    else KOM_BM1[2] = 0;

    if(shr[35])
    KOM_BM1[3] = nasmod[12];        // Fon.           - R4
    else KOM_BM1[3] = 0;            // Fon.           - R4

    KOM_BM1[4] = a;                	// Код команды    - R5
    if(shr[35]&&nasmod[12])
        KOM_BM1[4]|=01000;
    else
       KOM_BM1[4]&=(~01000);
    CT_BM1 = 0;                    	// Сброс сч. времени
    sh_ = 2;
A2: if ((diagnS[2] & 0x04) || (PR_SV_BM1 == 0)) // Есть диагностика
					// "Нет связи с БПМ" или нет признака
					// положительного ответа от БПМ
    {
        CT_BM1 = 0;                	// Сброс сч. времени
        return;
    }
    x = ( OTVET_BM1[8] & b );   // Ожидание ответа на команду
    if( x != 0 ) x = 1;         // проверяемый бит = 1
    else x = 0;			        // проверяемый бит = 0
    if(x != c)			        // Нет ответа от БПМ
    {
        if (CT_BM1 <= 5) return;  	// Время не вышло (5 сек.)
        diagn[d] |= e;             	// Отказ: "..."
        sh_ = 1;
        return;
    }
    diagn[d] &= (~e);                   // Сброс диагностики
    sh_ = 0;
}
// Команды на БПМ1
// VIDK_BM1 ( 014004 , 04000  , 1 , 6 , 010  ) - Включить блок БПМ1
// VIDK_BM1 ( 010004 , 04000  , 0 , 6 , 020  ) - Выключить блок БПМ1
// VIDK_BM1 ( 004004 , 010000 , 0 , 6 , 040  ) - Включить вых.напряжение БПМ1
// VIDK_BM1 ( 014004 , 010000 , 1 , 6 , 0100 ) - Выключить вых.напряжение БПМ1
//------------------------------------------------------------------------------
void VIDK_BM2(int a, int b, int c, int d, int e)
     // a - код команды (восьмеричный)
     // b - номер бита в байте состояния
     // c - значение бита в байте состояния (0 или 1)
     // d - номер байта массива диагностики
     // e - номер бита массива диагностики
{
    int x;
    if (sh_ == 1) goto A1;
    if (sh_ == 2) goto A2;
    else return;                   	// выход
A1: SetOut(1,4,0x400);             // Вкл.дист. управление
    if(diagnS[2] & 0x08) return;  	// Есть диагностика "Нет связи с БПМ"
    PR_SV_BM2 = 0;                 	// Обнуление признака положительного
                                    // ответа от БПМ1
	                               	// Формирование массива заданий
    KOM_BM2[0] = 4095;              // Ion.(15А)      - R1
    if(shr[36])
    KOM_BM2[1] = nasmod[11];         // Uon.(650В)     - R2
    else KOM_BM2[1] = 0;

    if(shr[36])            // БПМ2
    KOM_BM2[2] = PAR_BM2;
    else KOM_BM2[2] = 0;

    if(shr[36])
    KOM_BM2[3] = nasmod[13];        // Fon.           - R4
    else KOM_BM2[3] = 0;            // Fon.           - R4

    KOM_BM2[4] = a;                	// Код команды    - R5
    if(shr[36]&&nasmod[13])
        KOM_BM2[4]|=01000;
    else
       KOM_BM2[4]&=(~01000);
    CT_BM2 = 0;                    	// Сброс сч. времени
    sh_ = 2;
A2: if ((diagnS[2] & 0x08) || (PR_SV_BM2 == 0)) // Есть диагностика
					// "Нет связи с БПМ" или нет признака
					// положительного ответа от БПМ2
    {
        CT_BM2 = 0;                	// Сброс сч. времени
        return;
    }
    x = ( OTVET_BM2[8] & b );   // Ожидание ответа на команду
    if( x != 0 ) x = 1;         // проверяемый бит = 1
    else x = 0;			        // проверяемый бит = 0
    if(x != c)			        // Нет ответа от БПМ
    {
        if (CT_BM2 <= 5) return;  	// Время не вышло (5 сек.)
        diagn[d] |= e;             	// Отказ: "..."
        sh_ = 1;
        return;
    }
    diagn[d] &= (~e);                   // Сброс диагностики
    sh_ = 0;
}
// Команды на БПМ1
// VIDK_BM2 ( 014004 , 04000  , 1 , 8 , 010  ) - Включить блок БПМ2
// VIDK_BM2 ( 010004 , 04000  , 0 , 8 , 020  ) - Выключить блок БПМ2
// VIDK_BM2 ( 004004 , 010000 , 0 , 8 , 040  ) - Включить вых.напряжение БПМ2
// VIDK_BM2 ( 014004 , 010000 , 1 , 8 , 0100 ) - Выключить вых.напряжение БПМ2
//------------------------------------------------------------------------------
void VPMAN()						// подпрограмма "Манипулятор включить"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;			        	// выход
	
A1: PR_PER = 1;
    POL_PER=1;
	SetOut(0,3,0x4000);		        	// снять стоп
	CT_PER = 0;
    sh_ = 2;
A2: if((!(zin[3]&0x100))||(!(zin[3]&0x400)))	// есть готовность и отсутсвие аварии прижима
	{
		if(CT_PER < T_KPER) return; 	// время вышло
		diagn[5] |= 0x01;			  	// отказ:"Нет готов. механ. ман"
		return;
	}
	diagn[5] &= (~0x01);				// сброс диагностики
	SetOut(1,3,0x100);					// пуск привода прижима
	CT_PER = 0;
    sh_ = 3;
A3: if(zin[3]&0x100) 					// готовность пропала
	{
		if(CT_PER < T_KPRST) return;	// время не вышло
		diagn[5] |= 0x02;				// отказ: "Нет старта мех. прижима"
		SetOut(1,3,0x4000);				// вкл. стоп
        SetOut(0,3,0x100);
		return;
	}
	diagn[5] &= (~0x02);				// сброс диагностики
	SetOut(0,3,0x100);					// стоп привода прижима
	CT_PER = 0;
    sh_ = 4;
A4: if(!(zin[3]&0x100)) 				// опрос готовности
	{
		if(CT_PER < T_KPR) return;		// время вышло
		diagn[5] |= 0x04;				// отказ:"Нет завершения движ. мех. прижима"
		return;
	}
	diagn[5] &= (~0x04);				// сброс диагностики
	SetOut(1,3,0x4000);					// вкл. стоп
	PR_PER = 0;
	norma = 44;							//Прижим внизу
    POL_PER=3;
	sh_ = 0;
}
//---------------------------------------------------------------------------
void OPMAN()						// подпрограмма "Манипулятор отключить(HOME)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;			// выход
	
A1: SetOut(0,3,0x4000);		// снять стоп
	PR_PER = 1;
    POL_PER=2;
	CT_PER = 0;
    sh_ = 2;
A2: if((!(zin[3]&0x100))||(!(zin[3]&0x400)))	// есть готовности и отсутсвий аварий прижима
	{
		if(CT_PER < T_KPER) return; 	// время вышло
		diagn[5] |= 0x01;				// отказ:"Нет готов. механ. прижима"
		return;
	}	
	diagn[5] &= (~0x01);				// сброс диагностики
	SetOut(1,3,0x200);					// пуск приводов прижима в HOME
	CT_PER = 0;
    sh_ = 3;
A3: if(!(zin[3]&0x200))
	{
		if(CT_PER < T_KPR) return;		// время не вышло
		diagn[5] |= 0x08;				// отказ: "Механизм прижима не пришел в HOME"
	    return;
	}
	diagn[5] &= (~0x08);				// сброс диагностики
	SetOut(0,3,0x200);					// стоп приводов прижима
	sh_ = 4;
A4: if(!(zin[3]&0x100)) 				// опрос готовности
	{
		diagn[5] |= 0x01;				// отказ:"Нет готовности мех. прижима"
		return;
	}
	diagn[5] &= (~0x01);				// сброс диагностики
	SetOut(1,3,0x4000);					// вкл. стоп
	PR_PER = 0;
	norma = 43;							//Прижим в положении HOME
    POL_PER=0;
	sh_ = 0;
}
//  контроль кл6 для осушения

void kl6_osush()
{
    if(shr[38])
    {
        if((PAR_OHL>=-1638)&&(PAR_OHL<409))
        {
            SetOut(1,3,0x02);
            return;
        }
    }
    SetOut(0,3,0x02);
}
//включение пневмораспределителя
void vklpnevmo()
{
    if(shr[31])
    {
        if(TEK_TEMP2>PAR_TEMP2+DOPUSK_VENT)
        {
            SetOut(1,3,0x08);
            return;
        }
        if(TEK_TEMP2>PAR_TEMP2)
            return;
    }
    SetOut(0,3,0x08);
}
 void PderCheck()						// контроль вращения п/д
{
    if(shr[16])
    {
		if(zin[3]&0x80)
			ctPderjCheck_0 = 0;
		else
			ctPderjCheck_1 = 0;
		
		if((ctPderjCheck_0 > tkPderjIsh) || (ctPderjCheck_1 > tkPderjDvij))
			diagn[23] |= 0x80;          // выставить "Нет вращения п/держателя"
		else
			diagn[23] &= (~0x80);		// сброс диагностики

        return;
    }
    ctPderjCheck_0 = 0;
	ctPderjCheck_1 = 0;
	diagn[23] &= (~0x80);   // сброс диагностики
}
void DIAGN_KN()  //Диагностика крионасоса (КН)
{
    if(!PR_KN)
    {
        diagn[27] &= (~0x7f);
        return;
    }

	if(diagnS[2]&0x40) return;	// есть диагностика "Нет связи с КН"
	
	if(OTVET_KN_M[1]&0x10)		// есть сигнал "Перегрузка"
		diagn[27] |= 0x01;			// отказ "КН: Перегрузка"
	else
		diagn[27] &= (~0x01);   // сброс диагностики

	if(OTVET_KN_M[1]&0x8000)		// есть сигнал "Перефазировка"
		diagn[27] |= 0x02;			// отказ "КН: Перефазировка"
	else
		diagn[27] &= (~0x02);   // сброс диагностики
	
	if(OTVET_KN_M[0]&0x01)		// есть сигнал "Перегрев БКО1"
		diagn[27] |= 0x04;			// отказ "КН: Перегрев БКО1"
	else
		diagn[27] &= (~0x04);   // сброс диагностики

	if(OTVET_KN_M[0]&0x08)		// есть сигнал "Перегрев Т1"
		diagn[27] |= 0x08;			// отказ "КН: Перегрев Т1"
	else
		diagn[27] &= (~0x08);   // сброс диагностики
	
	if(OTVET_KN_M[0]&0x10)		// есть сигнал "Перегрев Т2"
		diagn[27] |= 0x10;			// отказ "КН: Перегрев Т2"
	else
		diagn[27] &= (~0x10);   // сброс диагностики
	
	if((shr[2]||shr[3])&&(OTVET_KN_M[3] > 400))
		diagn[27] |= 0x20;			// отказ "Т° КН выше 40°К"
	else
		diagn[27] &= (~0x20);   // сброс диагностики
	
	if(OTVET_KN_M[2]&0x100)		// есть сигнал "Нет связи с ИТЗ БКО1"
		diagnS[2] |= 0x80;			// отказ "Нет связи с ИТЗ БКО1 КН"
	else
		diagnS[2] &= (~0x80);   // сброс диагностики
	
	if(shr[41]) return;
	
	// был запуск КН и нет сигналов "Пуск БКО1" и "Пуск КУ"
	if(PR_KN&&(!((OTVET_KN_M[0]&0x800)&&(OTVET_KN_M[0]&0x100))))
		diagn[27] |= 0x40;			// отказ "Останов КН"
	else
		diagn[27] &= (~0x40);   // сброс диагностики
}











