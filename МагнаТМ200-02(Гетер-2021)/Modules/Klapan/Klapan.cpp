//---------------------------------------------------------------------------
//--Файл описания шаблонных функций--//
//---------------------------------------------------------------------------
#include "Klapan.h"
//---------------------------------------------------------------------------
//--Функция инкрементации счетчика объекта--//
//---------------------------------------------------------------------------
void SKlapan::Time()
{
    ctObject++;
}
//---------------------------------------------------------------------------
//--Функция управления объектами через дискретные входы-выходы--//
//---------------------------------------------------------------------------
void Klapan(bool action, SKlapan *object)
{
    switch ( object -> type )
    {
        case 11: DoAction11(action, object); break;
        case 12: DoAction12(action, object); break;
        case 21: DoAction21(action, object); break;
        case 22: DoAction22(action, object); break;
        // неверный тип объекта
        default: diagn[0] |= 0x01; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 1 входом--//
//---------------------------------------------------------------------------
void DoAction11(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 2 входами--//
//---------------------------------------------------------------------------
void DoAction12(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 1 входом--//
//---------------------------------------------------------------------------
void DoAction21(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 2 входами--//
//---------------------------------------------------------------------------
void DoAction22(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция инкремента счетчиков--//
//---------------------------------------------------------------------------
void TimeKlapan()
{
	FvnKam.Time();

	FvnShl.Time();
	KlShl.Time();
	KlTmn.Time();
	KlKam.Time();
    KlKN.Time();
    DZasl.Time();
	PP.Time();
    ShZatvor.Time();
    Zatvor.Time();
	ZaslPD.Time();
    ZaslII.Time();
    ZaslM1.Time();
    ZaslM2.Time();

}
//---------------------------------------------------------------------------
//--Функция инициализации объектов с дискретным управлением и дискретной обратной связью--//
//---------------------------------------------------------------------------
void InitObjectsKl()
{
	// описание форнасоса камеры
	FvnKam.type = 11;					// тип 1/1
	// нормы объекта
	FvnKam.normaNmb[0] = 37;				// код нормы включения
	FvnKam.normaNmb[1] = 38;				// код нормы отключения
	// контрольные времена объекта
	FvnKam.tkAction[0] = 2;				// к.время открытия
	FvnKam.tkAction[1] = 15;				// к.время закрытия
	FvnKam.tkAction[2] = 30;				// к.время задержки после открытия
	FvnKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnKam.diagnObject[0].x = 15;			// номер байта диагностики "не открылся"
	FvnKam.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	FvnKam.diagnObject[1].x = 15;			// номер байта диагностики "не закрылся"
	FvnKam.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	FvnKam.diagnObject[2].x = 15;			// номер байта диагностики "не определено"
	FvnKam.diagnObject[2].y = 0x20;		// маска бита диагностики "не определено"
	FvnKam.diagnObject[3].x = 15;			// номер байта диагностики "неоднозначно"
	FvnKam.diagnObject[3].y = 0x20;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnKam.zinOut[0].x = 4;				// номер байта упр. выходного сигнала на "открытие"
	FvnKam.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	FvnKam.zinOut[1].x = 4;				// номер байта упр. выходного сигнала на "закрытие"
	FvnKam.zinOut[1].y = 0x04;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnKam.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	FvnKam.zinIn[0].y = 0x02;			// маска бита ответного входного сигнала об "открытии"
	FvnKam.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	FvnKam.zinIn[1].y = 0x02;			// маска бита ответного входного сигнала о "закрытии"

	// описание форнасоса шлюза
	FvnShl.type = 11;					// тип 1/1
	// нормы объекта
	FvnShl.normaNmb[0] = 41;				// код нормы включения
	FvnShl.normaNmb[1] = 42;				// код нормы отключения
	// контрольные времена объекта
	FvnShl.tkAction[0] = 5;				// к.время открытия
	FvnShl.tkAction[1] = 5;				// к.время закрытия
	FvnShl.tkAction[2] = 2;				// к.время задержки после открытия
	FvnShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnShl.diagnObject[0].x = 15;			// номер байта диагностики "не открылся"
	FvnShl.diagnObject[0].y = 0x40;		// маска бита диагностики "не открылся"
	FvnShl.diagnObject[1].x = 15;			// номер байта диагностики "не закрылся"
	FvnShl.diagnObject[1].y = 0x80;		// маска бита диагностики "не закрылся"
	FvnShl.diagnObject[2].x = 15;			// номер байта диагностики "не определено"
	FvnShl.diagnObject[2].y = 0x80;		// маска бита диагностики "не определено"
	FvnShl.diagnObject[3].x = 15;			// номер байта диагностики "неоднозначно"
	FvnShl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnShl.zinOut[0].x = 4;				// номер байта упр. выходного сигнала на "открытие"
	FvnShl.zinOut[0].y = 0x08;			// маска бита упр. выходного сигнала  на "открытие"
	FvnShl.zinOut[1].x = 4;				// номер байта упр. выходного сигнала на "закрытие"
	FvnShl.zinOut[1].y = 0x08;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnShl.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	FvnShl.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	FvnShl.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	FvnShl.zinIn[1].y = 0x01;			// маска бита ответного входного сигнала о "закрытии"

	
	// описание Кл-Шл
	KlShl.type = 12;						// тип 1/2
	// нормы объекта
	KlShl.normaNmb[0] = 29;				// код нормы включения
	KlShl.normaNmb[1] = 30;				// код нормы отключения
	// контрольные времена объекта
	KlShl.tkAction[0] = 2;				// к.время открытия
	KlShl.tkAction[1] = 2;				// к.время закрытия
	KlShl.tkAction[2] = 2;				// к.время задержки после открытия
	KlShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlShl.diagnObject[0].x = 10;			// номер байта диагностики "не открылся"
	KlShl.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlShl.diagnObject[1].x = 10;			// номер байта диагностики "не закрылся"
	KlShl.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlShl.diagnObject[2].x = 10;			// номер байта диагностики "не определено"
	KlShl.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlShl.diagnObject[3].x = 10;			// номер байта диагностики "неоднозначно"
	KlShl.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlShl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlShl.zinOut[0].y = 0x300;			// маска бита упр. выходного сигнала  на "открытие"
	KlShl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlShl.zinOut[1].y = 0x300;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlShl.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlShl.zinIn[0].y = 0x4000;			// маска бита ответного входного сигнала об "открытии"
	KlShl.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlShl.zinIn[1].y = 0x8000;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание Кл-ТМН
	KlTmn.type = 12;					// тип 1/2
	// нормы объекта
	KlTmn.normaNmb[0] = 31;				// код нормы включения
	KlTmn.normaNmb[1] = 32;				// код нормы отключения
	// контрольные времена объекта
	KlTmn.tkAction[0] = 2;				// к.время открытия
	KlTmn.tkAction[1] = 2;				// к.время закрытия
	KlTmn.tkAction[2] = 2;				// к.время задержки после открытия
	KlTmn.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlTmn.diagnObject[0].x = 9;			// номер байта диагностики "не открылся"
	KlTmn.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlTmn.diagnObject[1].x = 9;			// номер байта диагностики "не закрылся"
	KlTmn.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlTmn.diagnObject[2].x = 9;			// номер байта диагностики "не определено"
	KlTmn.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlTmn.diagnObject[3].x = 9;			// номер байта диагностики "неоднозначно"
	KlTmn.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlTmn.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlTmn.zinOut[0].y = 0x02;			// маска бита упр. выходного сигнала  на "открытие"
	KlTmn.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlTmn.zinOut[1].y = 0x02;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlTmn.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlTmn.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	KlTmn.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlTmn.zinIn[1].y = 0x800;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание Кл-Кам
	KlKam.type = 12;					// тип 1/2
	// нормы объекта
	KlKam.normaNmb[0] = 27;				// код нормы включения
	KlKam.normaNmb[1] = 28;				// код нормы отключения
	// контрольные времена объекта
	KlKam.tkAction[0] = 2;				// к.время открытия
	KlKam.tkAction[1] = 2;				// к.время закрытия
	KlKam.tkAction[2] = 2;				// к.время задержки после открытия
	KlKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlKam.diagnObject[0].x = 10;			// номер байта диагностики "не открылся"
	KlKam.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlKam.diagnObject[1].x = 10;			// номер байта диагностики "не закрылся"
	KlKam.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlKam.diagnObject[2].x = 10;			// номер байта диагностики "не определено"
	KlKam.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlKam.diagnObject[3].x = 10;			// номер байта диагностики "неоднозначно"
	KlKam.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlKam.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlKam.zinOut[0].y = 0x01;			// маска бита упр. выходного сигнала  на "открытие"
	KlKam.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlKam.zinOut[1].y = 0x01;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlKam.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlKam.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	KlKam.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlKam.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание Кл-кн
	KlKN.type = 12;						// тип 1/2
	// нормы объекта
	KlKN.normaNmb[0] = 46;				// код нормы включения
	KlKN.normaNmb[1] = 47;				// код нормы отключения
	// контрольные времена объекта
	KlKN.tkAction[0] = 2;				// к.время открытия
	KlKN.tkAction[1] = 2;				// к.время закрытия
	KlKN.tkAction[2] = 2;				// к.время задержки после открытия
	KlKN.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlKN.diagnObject[0].x = 19;			// номер байта диагностики "не открылся"
	KlKN.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlKN.diagnObject[1].x = 19;			// номер байта диагностики "не закрылся"
	KlKN.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlKN.diagnObject[2].x = 19;			// номер байта диагностики "не определено"
	KlKN.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlKN.diagnObject[3].x = 19;			// номер байта диагностики "неоднозначно"
	KlKN.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlKN.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlKN.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	KlKN.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlKN.zinOut[1].y = 0x04;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlKN.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlKN.zinIn[0].y = 0x1000;			// маска бита ответного входного сигнала об "открытии"
	KlKN.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlKN.zinIn[1].y = 0x2000;			// маска бита ответного входного сигнала о "закрытии"

	// описание ДЗ
	DZasl.type = 22;						// тип 1/2
	// нормы объекта
	DZasl.normaNmb[0] = 22;				// код нормы включения
	DZasl.normaNmb[1] = 23;				// код нормы отключения
	// контрольные времена объекта
	DZasl.tkAction[0] = 10;				// к.время открытия
	DZasl.tkAction[1] = 10;				// к.время закрытия
	DZasl.tkAction[2] = 2;				// к.время задержки после открытия
	DZasl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	DZasl.diagnObject[0].x = 2;			// номер байта диагностики "не открылся"
	DZasl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	DZasl.diagnObject[1].x = 2;			// номер байта диагностики "не закрылся"
	DZasl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	DZasl.diagnObject[2].x = 2;			// номер байта диагностики "не определено"
	DZasl.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	DZasl.diagnObject[3].x = 2;			// номер байта диагностики "неоднозначно"
	DZasl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	DZasl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	DZasl.zinOut[0].y = 0x08;			// маска бита упр. выходного сигнала  на "открытие"
	DZasl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	DZasl.zinOut[1].y = 0x10;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	DZasl.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	DZasl.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	DZasl.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	DZasl.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание ЩЗ
	ShZatvor.type = 22;						// тип 2/2
	// нормы объекта
	ShZatvor.normaNmb[0] = 25;				// код нормы включения
	ShZatvor.normaNmb[1] = 26;				// код нормы отключения
	// контрольные времена объекта
	ShZatvor.tkAction[0] = 4;				// к.время открытия
	ShZatvor.tkAction[1] = 4;				// к.время закрытия
	ShZatvor.tkAction[2] = 1;				// к.время задержки после открытия
	ShZatvor.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ShZatvor.diagnObject[0].x = 9;			// номер байта диагностики "не открылся"
	ShZatvor.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	ShZatvor.diagnObject[1].x = 9;			// номер байта диагностики "не закрылся"
	ShZatvor.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	ShZatvor.diagnObject[2].x = 9;			// номер байта диагностики "не определено"
	ShZatvor.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	ShZatvor.diagnObject[3].x = 9;			// номер байта диагностики "неоднозначно"
	ShZatvor.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ShZatvor.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	ShZatvor.zinOut[0].y = 0x400;			// маска бита упр. выходного сигнала  на "открытие"
	ShZatvor.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	ShZatvor.zinOut[1].y = 0x800;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ShZatvor.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	ShZatvor.zinIn[0].y = 0x1000;			// маска бита ответного входного сигнала об "открытии"
	ShZatvor.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	ShZatvor.zinIn[1].y = 0x2000;			// маска бита ответного входного сигнала о "закрытии"

	// описание подъёмник
	PP.type = 22;					// тип 2/2
	// нормы объекта
	PP.normaNmb[0] = 35;				// код нормы включения
	PP.normaNmb[1] = 36;				// код нормы отключения
	// контрольные времена объекта
	PP.tkAction[0] = 4;				// к.время открытия
	PP.tkAction[1] = 4;				// к.время закрытия
	PP.tkAction[2] = 1;				// к.время задержки после открытия
	PP.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	PP.diagnObject[0].x = 11;			// номер байта диагностики "не открылся"
	PP.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	PP.diagnObject[1].x = 11;			// номер байта диагностики "не закрылся"
	PP.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	PP.diagnObject[2].x = 11;			// номер байта диагностики "не определено"
	PP.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	PP.diagnObject[3].x = 11;			// номер байта диагностики "неоднозначно"
	PP.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	PP.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	PP.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	PP.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	PP.zinOut[1].y = 0x08;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	PP.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	PP.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	PP.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	PP.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"

	// описание затвор
	Zatvor.type = 22;						// тип 2/2
	// нормы объекта
	Zatvor.normaNmb[0] = 62;				// код нормы включения
	Zatvor.normaNmb[1] = 63;				// код нормы отключения
	// контрольные времена объекта
	Zatvor.tkAction[0] = 10;				// к.время открытия
	Zatvor.tkAction[1] = 10;				// к.время закрытия
	Zatvor.tkAction[2] = 1;					// к.время задержки после открытия
	Zatvor.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	Zatvor.diagnObject[0].x = 22;			// номер байта диагностики "не открылся"
	Zatvor.diagnObject[0].y = 0x10;			// маска бита диагностики "не открылся"
	Zatvor.diagnObject[1].x = 22;			// номер байта диагностики "не закрылся"
	Zatvor.diagnObject[1].y = 0x20;			// маска бита диагностики "не закрылся"
	Zatvor.diagnObject[2].x = 22;			// номер байта диагностики "не определено"
	Zatvor.diagnObject[2].y = 0x40;			// маска бита диагностики "не определено"
	Zatvor.diagnObject[3].x = 22;			// номер байта диагностики "неоднозначно"
	Zatvor.diagnObject[3].y = 0x80;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	Zatvor.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	Zatvor.zinOut[0].y = 0x20;			// маска бита упр. выходного сигнала  на "открытие"
	Zatvor.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	Zatvor.zinOut[1].y = 0x40;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	Zatvor.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	Zatvor.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	Zatvor.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	Zatvor.zinIn[1].y = 0x800;			// маска бита ответного входного сигнала о "закрытии"

    // описание заслонка п/д
	ZaslPD.type = 22;						// тип 2/2
	// нормы объекта
	ZaslPD.normaNmb[0] = 74;				// код нормы включения
	ZaslPD.normaNmb[1] = 75;				// код нормы отключения
	// контрольные времена объекта
	ZaslPD.tkAction[0] = 10;				// к.время открытия
	ZaslPD.tkAction[1] = 10;				// к.время закрытия
	ZaslPD.tkAction[2] = 1;					// к.время задержки после открытия
	ZaslPD.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	ZaslPD.diagnObject[0].x = 24;			// номер байта диагностики "не открылся"
	ZaslPD.diagnObject[0].y = 0x10;			// маска бита диагностики "не открылся"
	ZaslPD.diagnObject[1].x = 24;			// номер байта диагностики "не закрылся"
	ZaslPD.diagnObject[1].y = 0x20;			// маска бита диагностики "не закрылся"
	ZaslPD.diagnObject[2].x = 24;			// номер байта диагностики "не определено"
	ZaslPD.diagnObject[2].y = 0x40;			// маска бита диагностики "не определено"
	ZaslPD.diagnObject[3].x = 24;			// номер байта диагностики "неоднозначно"
	ZaslPD.diagnObject[3].y = 0x80;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZaslPD.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ZaslPD.zinOut[0].y = 0x01;			// маска бита упр. выходного сигнала  на "открытие"
	ZaslPD.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ZaslPD.zinOut[1].y = 0x02;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZaslPD.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	ZaslPD.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	ZaslPD.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	ZaslPD.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"


     // описание заслонки ии
	ZaslII.type = 22;						// тип 2/1
	// нормы объекта
	ZaslII.normaNmb[0] = 76;				// код нормы включения
	ZaslII.normaNmb[1] = 77;				// код нормы отключения
	// контрольные времена объекта
	ZaslII.tkAction[0] = 10;				// к.время открытия
	ZaslII.tkAction[1] = 10;				// к.время закрытия
	ZaslII.tkAction[2] = 1;					// к.время задержки после открытия
	ZaslII.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	ZaslII.diagnObject[0].x = 29;			// номер байта диагностики "не открылся"
	ZaslII.diagnObject[0].y = 0x01;			// маска бита диагностики "не открылся"
	ZaslII.diagnObject[1].x = 29;			// номер байта диагностики "не закрылся"
	ZaslII.diagnObject[1].y = 0x02;			// маска бита диагностики "не закрылся"
	ZaslII.diagnObject[2].x = 29;			// номер байта диагностики "не определено"
	ZaslII.diagnObject[2].y = 0x04;			// маска бита диагностики "не определено"
	ZaslII.diagnObject[3].x = 29;			// номер байта диагностики "неоднозначно"
	ZaslII.diagnObject[3].y = 0x08;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZaslII.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ZaslII.zinOut[0].y = 0x100;			// маска бита упр. выходного сигнала  на "открытие"
	ZaslII.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ZaslII.zinOut[1].y = 0x200;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZaslII.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	ZaslII.zinIn[0].y = 0x04;			// маска бита ответного входного сигнала об "открытии"
	ZaslII.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	ZaslII.zinIn[1].y = 0x20;			// маска бита ответного входного сигнала о "закрытии"
    
    // описание заслонки М1
	ZaslM1.type = 22;						// тип 2/1
	// нормы объекта
	ZaslM1.normaNmb[0] = 78;				// код нормы включения
	ZaslM1.normaNmb[1] = 79;				// код нормы отключения
	// контрольные времена объекта
	ZaslM1.tkAction[0] = 10;				// к.время открытия
	ZaslM1.tkAction[1] = 10;				// к.время закрытия
	ZaslM1.tkAction[2] = 1;					// к.время задержки после открытия
	ZaslM1.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	ZaslM1.diagnObject[0].x = 29;			// номер байта диагностики "не открылся"
	ZaslM1.diagnObject[0].y = 0x10;			// маска бита диагностики "не открылся"
	ZaslM1.diagnObject[1].x = 29;			// номер байта диагностики "не закрылся"
	ZaslM1.diagnObject[1].y = 0x20;			// маска бита диагностики "не закрылся"
	ZaslM1.diagnObject[2].x = 29;			// номер байта диагностики "не определено"
	ZaslM1.diagnObject[2].y = 0x40;			// маска бита диагностики "не определено"
	ZaslM1.diagnObject[3].x = 29;			// номер байта диагностики "неоднозначно"
	ZaslM1.diagnObject[3].y = 0x80;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZaslM1.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ZaslM1.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	ZaslM1.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ZaslM1.zinOut[1].y = 0x20;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZaslM1.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	ZaslM1.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	ZaslM1.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	ZaslM1.zinIn[1].y = 0x08;			// маска бита ответного входного сигнала о "закрытии"

    // описание заслонки М2
	ZaslM2.type = 22;						// тип 2/1
	// нормы объекта
	ZaslM2.normaNmb[0] = 80;				// код нормы включения
	ZaslM2.normaNmb[1] = 81;				// код нормы отключения
	// контрольные времена объекта
	ZaslM2.tkAction[0] = 10;				// к.время открытия
	ZaslM2.tkAction[1] = 10;				// к.время закрытия
	ZaslM2.tkAction[2] = 1;					// к.время задержки после открытия
	ZaslM2.tkAction[3] = 1;					// к.время задержки после закрытия
	// диагностики объекта
	ZaslM2.diagnObject[0].x = 30;			// номер байта диагностики "не открылся"
	ZaslM2.diagnObject[0].y = 0x01;			// маска бита диагностики "не открылся"
	ZaslM2.diagnObject[1].x = 30;			// номер байта диагностики "не закрылся"
	ZaslM2.diagnObject[1].y = 0x02;			// маска бита диагностики "не закрылся"
	ZaslM2.diagnObject[2].x = 30;			// номер байта диагностики "не определено"
	ZaslM2.diagnObject[2].y = 0x04;			// маска бита диагностики "не определено"
	ZaslM2.diagnObject[3].x = 30;			// номер байта диагностики "неоднозначно"
	ZaslM2.diagnObject[3].y = 0x08;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZaslM2.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	ZaslM2.zinOut[0].y = 0x40;			// маска бита упр. выходного сигнала  на "открытие"
	ZaslM2.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	ZaslM2.zinOut[1].y = 0x80;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZaslM2.zinIn[0].x = 3;				// номер байта ответного входного сигнала об "открытии"
	ZaslM2.zinIn[0].y = 0x02;			// маска бита ответного входного сигнала об "открытии"
	ZaslM2.zinIn[1].x = 3;				// номер байта ответного входного сигнала о "закрытии"
	ZaslM2.zinIn[1].y = 0x10;			// маска бита ответного входного сигнала о "закрытии"
    



}