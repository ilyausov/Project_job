//---------------------------------------------------------------------------
#ifndef LogicH
#define LogicH
//---------------------------------------------------------------------------
#include "Math.h"
//---------------------------------------------------------------------------
//--ДЕКЛАРИРОВАНИЕ ПЕРЕМЕННЫХ--//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
//--Норма и диагностики--//
//---------------------------------------------------------------------------
#define DIAGN_COUNT   31
#define DIAGN_S_COUNT  3
#define ZIN_COUNT      5
#define OUT_COUNT      6
#define AIK_COUNT      2
#define AOUT_COUNT    3
#define SHR_COUNT     42
#define PAR_ROW       21
#define PAR_COUNT     21
#define PAR_TRANS     6
#define NASMOD_COUNT  22

unsigned char
	norma = 0,			  // (ПРД) норма
	qkk = 0,			  // (ПРM) код команды
	diagn[DIAGN_COUNT],   // (ПРД) диагностики общие, обнуление перед main
	diagnOld[DIAGN_COUNT],// диагностики архивные
	diagnS[DIAGN_S_COUNT],// (ПРД) диагностики связей с устройствами по RS
	diagnSOld[DIAGN_S_COUNT];// диагностики связей с устройствами архивные

// счетчик кол-ва успешных сеансов связи с СС-10
//unsigned int
//    SS10ConnectCount = 0;
//---------------------------------------------------------------------------
//--Дискретные входы-выходы--//
//---------------------------------------------------------------------------
unsigned int
    out[OUT_COUNT]={0},
    zin[ZIN_COUNT]={0},			// (ПРД) дискретные входы, 0 - свободный
    out_Z[OUT_COUNT]={0}, // запоминание для отображения
	zin_Z[ZIN_COUNT]={0}, // запоминание для отображения
    aik[AIK_COUNT * 8] = {0},             // (ПРД) аналоговые входы
    aout[AOUT_COUNT * 4] = {8192},
    aoutKon[AOUT_COUNT * 4] = {8192},

//---------------------------------------------------------------------------
//--Уровни вакуума--//
//---------------------------------------------------------------------------
 	// текущий уровень вакуума (Д1,Д2,Д3,Д4,Д5)
	D_D1 = 0, D_D2 = 0, D_D3 = 0, D_D4 = 0, D_D5 = 0,D_D6 = 0,
    //UVAK_OTK_D1 = 60,       // прокачка камеры по баратрону
    //UVAK_OTK_D2 = 5938,     // прокачка камеры по СС-10 (1*10-3)
    //UVAK_OTK_D3 = 6787,     // прокачка камеры по конвектрону (5*10-2)
    //UATM = 8845,            // атмосфера по ПМТ (925)
    //UVAK_TMN_V = 7889,      // 8Па порог включения ВВ насоса (конвектрон)
    //UVAK_TMN_N = 8137,      // 25Па порог включения ВВ насоса (конвектрон)
    //UVAK_ATM = 9850,        // Уровень атмосферы по азоту при напуске (СС-10)
    UVAK_KAM = 6018,        // 5Па по мрт200

    POROG_DAVL = 6799,      // 100Па порог превышения давления в камере (мрт200)
    UVAK_KN=4199,              //5 Па ррт200

    UVAKN_TMN = 4898,       // 25Па по ррт200
    UVAKV_TMN = 4403,       // 8Па по ррт200
    UVAK_SHL = 4677,        // 15Па по ррт200
    UVAK_SHL_MO = 6977,     // 3000Па по ррт200
    DOPUSK_VENT=50,
    UVAK_ZTMN = 5477,       // 40Па по ррт200
    //UATM_D1 = 8496,         // атмосфера по ррт200
    UATM_D1 = 7580,          // 1.2e+4 атмосфера по азоту по ррт200
    POROG_OST_TMN=100,
    UATM_D4 = 8597;         // атмосфера по мрт200
//---------------------------------------------------------------------------
//--Настроечные и управляющие массивы--//
//---------------------------------------------------------------------------
unsigned int nasmod[NASMOD_COUNT+1] = {0};

/////////////////////////////////////////////////////////////////////////////////////////////////
// массив рабочих параметров
int par[PAR_ROW][PAR_COUNT]      = {0};
int par_V[PAR_ROW][3]= {0};
// массив параметпров для управления манипуляторами
long par_t[PAR_TRANS]            = {0};
//	ПЕР в Касс - par_t[1]
//	ПЕР в Кам - par_t[2]
//	ПОВ к Кам - par_t[3]
//	КАСС на шаг(h) - par_t[4]
//	КАСС на шаг переукл.(h1) - par_t[5]
//---------------------------------------------------------------------------
//--Контрольные времена воздействий--//
//---------------------------------------------------------------------------
// времена и счетчики даны в секундах, если нет обратных комментариев
unsigned int

	// текущее время для процессов
	T_VHG			= 5,	// к.время выставления р/р ВЧГ
	T_ZAD_DVS		= 25,  // (тик)(0.5сек.) задержка на вкл.кнопок
	T_PROC			= 0,	 // время технологического процесса
	T_KTMN_RAZGON	= 430, // к.время разгона ТМН
	T_VKL_BPN     	= 3,   // задержка на вкл/откл реле и пускат. в БПН и БПМ
	T_KKAM_V	= 650, // 650 сек. контр. время ВВ откачки камеры
	T_VODA			= 5,   // сек. реакция на пропадание воды
	T_STOP			= 25,  // (тик) время на стоп двигателей УС
	T_DVIJ			= 25,  // (тик) время на переключение направл. двигателей УС
	T_KDVIJ_SU		= 3000,  // (20 мс тик) 60 сек контрольное время движения УС конденсатора
	T_KSUT			= 30,  // (20мс тик.) 0,6 сек. задержка УС на переключение движения
	T_KKAM			= 900,
	T_KTMN			= 900,
    T_KPER         = 3,
    T_KPRST         = 5,
    T_KPR           = 15,
	T_KSHL			= 230, // к.время фороткачки шлюза
	T_KNAP			= 120, // к.время напуска в шлюз
	T_NAPUSK		= 30,
    T_SBROSHE       = 20,  // задержка на сброс HE
    T_KSHL_MO       = 180,
    T_K_KN          = 300,
    T_K_KAM         =300,
    T_OTK_KN        =5400,
    T_TMN = 2,
    T_AVAR_OTKL                 =50,   // (тик) 1 сек контрольное время аварийного отключения установки
	// контрольные счетчики времени
	CT_VHG = 0,
	CT_VODA_STOL = 0,		// отстутствия воды в столе
    CT_VODA_IP = 0,      	        // отстутствия воды в ип
    CT_PER = 0,
    CT_POD = 0,
    CT_POV=0,
    CT_BM1=0,
    CT_BM2=0,
    CT_TEMP1 = 0,			// счетчик Нагрева 1
	CT_TEMP2 = 0,			// счетчик Нагрева 2
    CT_TMN = 0,
	CT_IST = 0,
    CT_VODA_BM1=0,
    CT_VODA_BM2 = 0,
    CT_VODA_II=0,
    CT_KZ1=0,
    CT_KZ2=0,
	CT_DVIJ_GIR_g = 0,		// (20 мс тик)счетчик двигателя УС реактора(грубо)
	CT_DVIJ_GIR_t = 0,		// (20 мс тик)счетчик двигателя УС реактора(точно)
	CT_SUT_g = 0,			// (20 мс тик)счетчик на переключение напр.(грубо)
	CT_SUT_t = 0,			// (20 мс тик)счетчик на переключение напр.(точно)
        CT_AVAR_OTKL=0,

	// счетчики времен
    CT_T1, 			        // 1мс
    CT_T20,     			// 20 мс

	// контрольные счетчики режимов, сек
	CT_1,
    CT_2,
    CT_3,
    CT_4,
    CT_5,
    CT_6,
    CT_7,
    CT_9,
    CT_10,
    CT_19,
    CT_24,
    CT24K1,
    CT_27,
    CT_28,
    CT28K1,
    CT_29,
    CT29K1,
    CT_31,
    CT31K1,
    CT_33,
    CT33K1,
    CT_35,
    CT35K1,
    CT_36,
    CT36K1,
    CT_38,
    CT_39,
    CT_40,
    CT_41;


//---------------------------------------------------------------------------

//--ОТВЕТЫ--//
unsigned char
	otvet;	  // диалоговый ответ оператора
	
//---------------------------------------------------------------------------
//--Шаги и контрольные параметры подпрограмм--//
//---------------------------------------------------------------------------
unsigned char
	sh_   = 0,         		// общая переменная передачи шага
	// (ПРД) локальная для режима переменная шага
	shr[SHR_COUNT+1],
	// локальная для режима переменная подшага
	sh[SHR_COUNT+1];
unsigned char
        zshr3;
unsigned char
		PR_TRTEST = 0,			// признак окончания транспортного теста
		PR_OTK = 0,
        PR_OTP=0,

        PR_TREN=0,
		PR_FK_KAM = 0,
		PR_NASOS = 0,
		PR_NALADKA = 0,
                PR_NPL = 0,
                PR_PRIJ = 0,
		N_PL = 0,
		N_ST_MAX = 7,
		N_ST = 0;
unsigned int N_ZICL = 0;
int PAR_OHL=0;
//int     h = 792; //79167;
bool    PR_RG1 = 0,				// признак работы РРГ1
        PR_RG2 = 0,				// признак работы РРГ2
        PR_RG3 = 0,				// признак работы РРГ3
        PR_RG4 = 0,				// признак работы РРГ4
        PR_HEL = 0,				// признак работы РРГ7
        PR_KLASTER=1,
        PR_SBROS_RRG=0;
//---------------------------------------------------------------------------
//--Дроссельная заслонка--//
//---------------------------------------------------------------------------
bool
	PR_DZASL = 0;		    		// признак наличия полодительного ответа заслонки
unsigned char
	OTVET_DZASL = 0;
unsigned int
    VRZASL=0,
	CT_DZASL = 0,
	DAVL_DZASL = 0,
	DATA_DZASL = 0,		    		// уставка задания заслонка (в ПРД)
	PAR_DZASL  = 0,	            	// параметр заслонки
	ZPAR_DZASL = 0;               	// зап. параметра давления заслонки
	int X_TDZASL;                 	// текущее значение давления
	unsigned char VRDZASL = 0;    	// 1 - признак выхода на режим заслонки
	int E_TDZASL;		    		// текущая ошибка
	int DELDZASL;		    		// модуль текущей ошибки
	unsigned int LIM1DZASL;	    	// предел ошибки регулирования (большой)
	unsigned int LIM2DZASL;	    	// предел ошибки регулирования (малый)
	unsigned int T_VRDZASL=10;   	// контрольное время выхода на режим (сек.)
	unsigned int T_KDZASL = 2;    	// контрольное время определения ошибки(сек.)
	int DOPDZASL = 10;	    		// допустимая погрешность 10%
	unsigned char KOM_DZASL = 0; 	//код команды заслонки
    int TEK_DAVL_DZASL;
    unsigned int TEK_POZ_DZASL;
//----------------------------------------------------------------------------
//-- НЧГ стола  --//
//---------------------------------------------------------------------------
    unsigned char
	    VRGIS = 0,      // 1 - признак выхода на режим ВЧГ стола
	    K_SOGL_GIS= 67,  // заданный коэф-т согласования ВЧГ стола (~15%)
		NAPRS_GIS= 0;   // направление движения согласования ВЧГ стола
						// 0-прямое(>); 1-обратное(<)
	int
		X_TGIS,             // текущее значение падающей мощности
		E_TGIS,		    // текущая ошибка
		DELGIS,		    // модуль текущей ошибки
        DOPGIS = 5,	    // допустимая погрешность
		PAR_GIS = 0;	    // параметр ВЧГ стола
    unsigned int
		N_TEK_GIS,    	    // текущий коэф-т согласования ген.ВЧГ стола
        LIM1GIS,	    // предел ошибки регулирования (большой)
		LIM2GIS,	    // предел ошибки регулирования (малый)
		T_VRGIS=10,         // контрольное время выхода на режим (сек.)
		T_KGIS = 2;         // контрольное время определения ошибки(сек.)
//---------------------------------------------------------------------------
//-- ВЧГ стола (по смещ.) --//
//---------------------------------------------------------------------------
  /*  int
        X_TGIS_SM,			// текущее значение
	    E_TGIS_SM,			// текущая ошибка
	    DELGIS_SM,			// модуль текущей ошибки
        DOPGIS_SM = 5,		// допустимая погрешность
	    PAR_GIS_SM = 0;	    // параметр ВЧГ стола
    unsigned int
	    N_TEK_GIS_SM,		// текущий коэф-т согласования ген.ВЧГ
        LIM1GIS_SM,	        // предел ошибки регулирования (большой)
	    LIM2GIS_SM,	        // предел ошибки регулирования (малый)
	    T_VRGIS_SM=10,		// контрольное время выхода на режим (сек.)
	    T_KGIS_SM = 2;		// контрольное время определения ошибки(сек.)
                                                                         */
//---------------------------------------------------------------------------
//--БПН (Включение нагрева)  индекс устройства TEMP (нагрев по Т)
//-----------------------------------------------------------------------
unsigned char
	KOM_TEMP = 5;		    	// команда опроса статуса ТЕРМОДАТА
bool
    PR_TEMP = 0;		    	// признак положительного ответа ТЕРМОДАТА
unsigned int
	ZAD_TEMP1 = 0,		    	// уставка задания по температуре ТЕРМОДАТА
	PAR_TEMP1  = 0,	    	        // параметр БПН
	ZPAR_TEMP1 = 0;		    	// зап. параметра температуры БПН1
	int X_TEMP1;                     // текущее значение температуры
	unsigned char VRTEMP1 = 0;       // 1 - признак выхода на режим БПН
	int E_TEMP1;		        // текущая ошибка
	int DELTEMP1;		    	// модуль текущей ошибки
	unsigned int LIM1TEMP1;	        // предел ошибки регулирования (большой)
	unsigned int LIM2TEMP1;	        // предел ошибки регулирования (малый)
	int DOPTEMP1 = 5;				// допустимая погрешность 20%
	unsigned int TEK_TEMP1;		// текущая температура по каналу 1 (в ПРД)

unsigned int
	ZAD_TEMP2 = 0,		    	// уставка задания по температуре ТЕРМОДАТА
	PAR_TEMP2  = 0,	    	        // параметр БПН
	ZPAR_TEMP2 = 0;		    	// зап. параметра температуры БПН1
	int X_TEMP2;                     // текущее значение температуры
	unsigned char VRTEMP2 = 0;       // 1 - признак выхода на режим БПН
	int E_TEMP2;		        // текущая ошибка
	int DELTEMP2;		    	// модуль текущей ошибки
	unsigned int LIM1TEMP2;	        // предел ошибки регулирования (большой)
	unsigned int LIM2TEMP2;	        // предел ошибки регулирования (малый)
	int DOPTEMP2 = 5;				// допустимая погрешность 20%	
	unsigned int TEK_TEMP2;		// текущая температура по каналу 2 (в ПРД)
	
	unsigned int T_VRTEMP= 1200;       // контрольное время выхода на режим (сек.)
	unsigned int T_KTEMP = 3;       // контрольное время определения ошибки(сек.)

unsigned int
    ZAD_TEMP3 = 0,
    ZAD_TEMP4 = 0,
    TEK_TEMP3,
    TEK_TEMP4;
//---------------------------------------------------------------------------
//--Связь между транспортом и модулем--//
//---------------------------------------------------------------------------
unsigned int
	OTVET_MOD,
	KOM_MOD;	
//---------------------------------------------------------------------------
//--Механизм перемещения--//
//---------------------------------------------------------------------------
	unsigned char
	KOM_PER = 0,	// команда
	OTVET_PER = 0,	// ответ
	V_PER = 0,		// скорость	
	TYPE_PER = 0,	// тип движения
    POL_PER=0;      //положение манипулятора
    /*
    0 исходник,
    1 движение в камеру,
    2 движение в исходник,
    3 в камере
    */
	
	bool
	PR_PER = 0,		// признак механизма
	HOME_PER = 0;	// признак движения в Home

	int
	PUT_PER = 0,	// абсолютный путь
	TEK_ABS_PER = 0,
	TEK_OTN_PER = 0;
//---------------------------------------------------------------------------
//--Механизм подъёма п/д--//
//---------------------------------------------------------------------------
	unsigned char
	KOM_POD = 0,	// команда
	OTVET_POD = 0,	// ответ
	V_POD = 0,		// скорость
	TYPE_POD = 0;	// тип движения

	bool
	PR_POD = 0,		// признак механизма
	HOME_POD = 0;	// признак движения в Home

	int
	PUT_POD = 0,	// абсолютный путь
	TEK_ABS_POD = 0,
	TEK_OTN_POD = 0;
//---------------------------------------------------------------------------
//--П/ДЕРЖАТЕЛЬ--//
//---------------------------------------------------------------------------
unsigned char
	VRPD = 0;
bool
    prMVPvRabPol = false;
unsigned char
    pderjCounter = 0,   // кол-во вращений п/держателем
    pderjInIsh = true;  // п/держ в исходном
unsigned int
    PDVmin = 8192 + 8192 / 10 * 1.55,       // (1,55В) минимальная скорость вр. п/держателя
    PDVmax = 8192 + 8192 / 10 * 3;          // (3В) максимальная скорость вр. п/держателя
unsigned int
    tkPderjIsh = 650,               // (тик) 13 сек к.вр.движ.п/держ. до исх.
    tkPderjDvij = 100,              // (тик) 2 сек к.вр.движ.п/держ.
    tkPderjRazgon = 100,            // (тик) 2 сек разгон/торможение п/держ.
    ctPderjDvij = 0,                // (тик) сч.вр. движения п/держателя
	ctPderjCheck_0 = 0,				// (тик) Счетчик контроля вращ. п/д (нахожд. не в исх)
	ctPderjCheck_1 = 0;				// (тик) Счетчик контроля вращ. п/д (нахожд. в исх)
//----------------------------------------------------------------------------
//--УУН (UN - индекс устройства)--//
//----------------------------------------------------------------------------
unsigned char
	VRUN = 0;				// 1 - признак выхода на режим УУН
int
    X_TUN,		        // текущее значение давления в магратронах
    E_TUN,		        // текущая ошибка
    DELUN,		        // модуль текущей ошибки
    E_PUN,		        // предыдущая ошибка
    K_PUN,		        // коэффициент P     ж  выбираются
    K_IUN,		        // коэффициент I     ж  из таблицы
    U_PUN,		        // предыдущая уставка
    A_VIH = 0;                  // выдача уставки
unsigned int
	LIMPUN=4095,            // верхний предел P-составляющей регулятора
	LIMIUN=4095,            // верхний предел I-составляющей регулятора
	LIM1UN,	                // предел ошибки регулирования (большой)
	LIM2UN,	                // предел ошибки регулирования (малый)
	LIMUUN=4095,            // ограничение по уставке	(5 вольт)
	LIMU_UN,	        // нач.ограничение уставки при выходе на реж.
	LIMUPR_UN;              // нач.ограничение уставки после пробоя
	int PORCNV_UN;		// приращение нач.плавного выхода на режим
	int PORCPR_UN;		// приращение плавного выхода при пробое
unsigned char
	PROBUN = 0;             // признак отработки пробоя
unsigned int
	T_VRUN = 30,            // контр.время выхода на режим УУН (сек.)
	T_KUN = 3,              // контр.время определения ошибки (сек.)
	T_VREJ_UN=50,           // время плавного выхода на режим
					    // (в 20мс тиках)
	T_VPRB_UN=50,           // время плавного выхода при пробое
				            // (в 20мс тиках)
	T_REQUN = 40,           // время ограничения регулятора
					    // по быстродействию (в 1 мс тиках)
	CT_VRUN,	        // счетчик вр.выхода на режим
                                           // (в 20мс тиках)
	CT_PR_UN,	        // счетчик вр.выхода при пробое
					   // (в 20мс тиках)
	CT_REQUN;	        // счетчик ограничения регулятора
					   // по быстродействию (в 1 мс тиках)
int
	SOUN,		        // сумматор остатков
	LOUN = 2000,	        // лимит остатков
	MZRUN[] =		// массивы для УУН:
	{1,5,10,50,100,200,500,1000,2000,7000},// зон регулирования
	MKPUN[] = {20,30,30,30,30,30,30,30,30,30},// коэффициентов P
	MKIUN[] = {30,25,20,10,8,7,7,5,3,2},		    // коэффициентов I
	DOPUN = 200,	        // допустимая погрешность(0.5%)
	PAR_UN = 0;	        // параметр УУН
//------------------------------------------------------------------------------
//--БПМ (BM1 - для М1, BM2 - для М2)--//
//------------------------------------------------------------------------------
bool	VRBM1 = 0;	// 1 - признак выхода БПМ на режим
					// массив ответов от БПМ1
unsigned int	OTVET_BM1[10] = {0,0,0,0,0,0,0,0,0,0};
bool	PR_SV_BM1 = 0,	// признак полож. ответа по RS-каналу
                PR_NAP1 = 0;
int
	UST_BM1,		    // уставка (расчитывается при ремпинге)
	X_TBM1,		        // текущее значение мощности
	E_TBM1,			    // текущая ошибка
	DELBM1,			    // модуль текущей ошибки
	DOPBM1 = 5,		    // допустимая погрешность
	PAR_BM1 = 0;		// параметр БПМ3

unsigned int
	LIM1BM1,		    // предел ошибки регулирования (большой)
	LIM2BM1,		    // предел ошибки регулирования (малый)
	T_VRBM =10,	        //контрольное время выхода на режим (сек.)
	T_KBM  =3,	        //контрольное время определения
	KOM_BM1[5] = {4095,4095,0,0,010404};	// массив заданий для БПМ
//------------------------------------------------------------------------------
bool	VRBM2 = 0;	// 1 - признак выхода БПМ на режим
				// массив ответов от БПМ1
unsigned int	OTVET_BM2[10] = {0,0,0,0,0,0,0,0,0,0};
bool	PR_SV_BM2 = 0,	// признак полож. ответа по RS-каналу
                PR_NAP2 = 0;
int
	UST_BM2,	        // уставка (расчитывается при ремпинге)
	X_TBM2,		        // текущее значение мощности
	E_TBM2,		        // текущая ошибка
	DELBM2,		        // модуль текущей ошибки
	DOPBM2 = 5,	        // допустимая погрешность
	PAR_BM2 = 0;	    // параметр БПМ3

unsigned int
	LIM1BM2,		// предел ошибки регулирования (большой)
	LIM2BM2,		// предел ошибки регулирования (малый)
	KOM_BM2[5] = {4095,4095,0,0,010404};	// массив заданий для БПМ

unsigned int
        T_KOTS_PROB = 3,        // время отсутствия пробоев
        PR_KZ1 = 0,
        N_KZ1 = 0,
		PR_KZ2 = 0,
        N_KZ2 = 0,
        N_PROB = 5;             // макс. количество пробоев
//------------------------------------------------------------------------------
//--ИИ (II - индекс устройства)--//
//------------------------------------------------------------------------------
bool    VRII = 0;               // 1 - признак выхода ИИ на режим
                            // массив ответов от ИИ
unsigned int	OTVET_II[10] = {0,0,0,0,0,0,0,0,0,0};
bool    PR_SV_II = 0;           // признак полож. ответа по RS-каналу
int
    X_TII,                      // текущее значение мощности
    E_TII,		                // текущая ошибка
    DELII,		                // модуль текущей ошибки
    DOPII = 5,		            // допустимая погрешность
    PAR_II = 0;	                // параметр ИИ
unsigned int                    // массив команд к ИИ
    LIM1II,	                    // предел ошибки регулирования (большой)
    LIM2II,	                    // предел ошибки регулирования (малый)
    T_VRII = 10,                // контрольное время выхода на режим (сек.)
    CT_II   = 0,			// время источника ионов 1
    TK_OJ_OTV = 5,          // (сек.) К.вр. ожидания ответа
    T_KII = 3,                  // контрольное время определения ошибки(сек.)
    KOM_II[5] = {0,4095,4095,0,010000};
//---------------------------------------------------------------------------
//---- Крионасос (КН) --------
bool
	PR_KN = 0,
	PR_PER0_KN = 0,
	PR_SV_KN = 0;
unsigned char
	KOM_KN = 0,
	OTVET_KN = 0;
unsigned int
	CT_KN = 0,
	OTVET_KN_M[8] = {0};
//------------------------------------------------------------------------------
//----------------Прототипы---------------------------------------------------
//------------------------------------------------------------------------------
void R_1();                  // режима 1 "Откачка камеры"
void R_2();                  // режима 2 "Откачка шлюза"
void R_3();                  // режима 3 "Рабочий цикл"
void R_4();                  // режима 4 "Технологический процесс"
void R_5();                  // режима 5 "Сброс РЦ"
void R_6();                  // режима 6 "Сбор пластин"
void R_7();                  // режима 7 "Отключение установки"
void R_8();                  // режима 8 "Аварийное отключение установки"
void R_9();                  // режима 9 "Транспортный тест"
void R_10();                 // режима 10 "Открыть ЩЗ"
void R_11();                 // режима 11 "Закрыть ЩЗ"
void R_12();                 // режима 12 "Ман. перем. в исх"
void R_13();                 // режима 13 "Ман. перем. вперед/назад"
void R_14();                 // режима 14 "Ман. пов. в исх"
void R_15();                 // режима 15 "Ман. пов. влево/вправо"
void R_16();
void R_17();                 // режима 18 "Дросселирование ДЗ"
void R_18();                 // режима 18 "Открыть ДЗ"
void R_19();                 // режима 19 "Закрыть ДЗ"
void R_20();                 // режима 20 "РРГ1"
void R_21();                 // режима 21 "РРГ2"
void R_22();                 // режима 22 "РРГ3"
void R_23();                 // режима 23 "РРГ4"
void R_24();                 // режима 24 "РРГ5"
void R_25();
void R_26();
void R_27();
void R_28();
void R_29();                 // режима 29 "Вкл. ВЧГ ИП"
void SBROSR_24();            // сброс ВЧГ ИП
void SBROSR_28();            // сброс ВЧГ ИП
void R_30();                 // режима 30 "Автосогл. ВЧГ ИП(точно)"
void R_31();                 // режима 31 "Движ. в точку ВЧГ ИП(грубо)"
void R_32();                 // режима 32 "Движ. в точку ВЧГ ИП(точно)"
void R_33();                 // режима 33 "Вкл. нагрев 1"
void R_34();                 // режима 34 "Откл. нагрев 1"
void R_35();
void R_36();
void R_37();                 // режима 37 "Прижим вверх"
void R_38();                 // режима 38 "Прижим вниз"
void R_39();                 // режима 39 "Кассета в исх"
void R_40();                 // режима 40 "Кассета вверх/вниз"
void R_41();                 // режима 41 "НЧГ стола (вкл.)"
void R_42();                 // режима 42 "НЧГ стола (выкл.)"
//---------------------------------------------------------------------------
//--ФУНКЦИИ КОЛЬЦА--//
//---------------------------------------------------------------------------
void KOLCO();   		// подпрограмма кольцо (диагн., реакция на аварии)

void OSBROS();			// общий сброс
void TIME ();			// таймеры
void POST ();   		// приём и дешифрация команд

void DIAGN_KOLCO();             // диагностика в кольце
void AVAR_VODA_STOL();	        // реакция на пропадание воды в п/держ
void AVAR_VODA_IP();	        // реакция на пропадание воды в ИП
void AVAR_DAVL();	            // "Реакция на высокое давление в камере при работе ТМН"
void UPR_AVAR_OTKL();		    // управление аварийным отключением
void VID_DIAGN_GIS();           // выдача диагностики нет согласования ВЧГ п/д
void ZashDD();                  // подпрограмма защиты датчика
void OpenFK_TMN_CloseFK_SHL();	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
void MEH_AVAR_CHK();	        // слежение за авриями механизмов
void MEH_AVAR_SBROS();
void Vkl_FK_TMN();		        // включение ТМН
void REAKCIA_KZM1();             // реакция на КЗ БПМ1
void REAKCIA_KZM2();             // реакция на КЗ БПМ2
void AVAR_VODA_II();				// реакция на отсутствие воды в ИИ
void AVAR_VODA_BM1();				// реакция на отсутствие воды в М1
void AVAR_VODA_BM2();				// реакция на отсутствие воды в М2
void AVAR_DAVL_KN();      // "Реакция на высокое давление в камере при работе КН"
void kl6_osush();                  //контроль кл6 для осушения
void vklpnevmo();                  //включение пневмораспределителя
void PderCheck();
void DIAGN_KN();  //Диагностика крионасоса (КН)
//---------------------------------------------------------------------------
//--ФУНКЦИИ УСТРОЙСТВ--//
//---------------------------------------------------------------------------
void VIBPAR_DZASL();		    // подпрограмма "Выбор параметра для заслонки"
void PDDZASL();			    // подготовка аналоговых данных заслонки
void RLIMDZASL();	        	// расчет LIM для заслонки

void VRR_GIS();						// подпрограмма "Выставить разр. работы ВЧГ стола"
void ORR_GIS();						// подпрограмма "Снять разр. работы ВЧГ стола"
void VIBPAR_GIS ();				    // подпрограмма "Выбор параметра для ВЧГ реактора"
void PDGIS ();						// подготовка аналоговых данных ВЧГ реактора
void RLIMGIS ();						// подпрограмма "Расчет LIM для ВЧГ реактора"

void VIBPAR_TEMP1();
void RLIMTEMP1();
void PDTEMP1();

void VPMAN();						// подпрограмма "Манипулятор включить"
void OPMAN();						// подпрограмма "Манипулятор отключить(HOME)"

void VIBPAR_TEMP2();
void RLIMTEMP2();
void PDTEMP2();
void VIBPAR_NAGR ();		    // подпрограмма "выбор параметров нагрева"

void RLIMII ();		             // подпрограмма "Расчет LIM для ИИ"
void VIBPAR_II();				// подпрограмма "Выбор параметра для ИИ"
void PDII ();			         // подготовка аналоговых данных ИИ

void pderj_v_ish();        //вращение п/д в HOME
void GoPderjatel();        //вращение п/д вкл
void StopPderjatel();      //вращение п/д выкл

void OBPN();			// отключить пускатель БПН

void RABUN();							// подпрограмма "Работа УУН"
void UN_G();								// подпрограмма "рег.УУН с отработкой пробоя"
void UN_D();								// подпрограмма "рег.УУН с диагностикой"
void RLIMUN();							// подпрограмма "Расчет LIM для УУН"
void REQUN();							// подпрограмма "Регулятор УУН"
void PDUN();							// подготовка аналоговых данных УУН
void VBKUN();							// выбор коэф-тов регулятора УУН
void VIBPAR_UN ();						// подпрограмма "Выбор параметра УУН"

 void vkl_dist_tmn();    //включить дистанционное управление ТМН

void VIBPAR_BM1 ();		    // подпрограмма "Выбор параметра для БПМ1"
void RLIMBM1 ();		            // подпрограмма "Расчет LIM для БПМ1"
void PDBM1 ();			    // подготовка аналоговых данных БПМ1

void VIBPAR_BM2 ();		    // подпрограмма "Выбор параметра для БПМ2"
void RLIMBM2 ();		            // подпрограмма "Расчет LIM для БПМ2"
void PDBM2 ();			    // подготовка аналоговых данных БПМ2
//---------------------------------------------------------------------------
//--RS-функции--//
//---------------------------------------------------------------------------
void VIDK_DZASL(int,int,int,int);					// ДЗ
void VIDK_TEMP1(int,int,int,int);
void VIDK_TEMP2(int,int,int,int);
void VIDK_KN(int , int , int , int  );
void VIDK_BM1(int , int , int , int , int );
void VIDK_BM2(int , int , int , int , int );

void VIDK_POD(unsigned char,unsigned char,int,bool,unsigned int);

void VIDK_II(int , int , int , int , int );
//---------------------------------------------------------------------------
//--Транспортные функции--//
//---------------------------------------------------------------------------
void SBROS_MEH();       	// сброс механики

extern
    void A_OUT(unsigned int Nmb, unsigned int Value);   // задание аналогового выхода
extern
    void SetOut(bool, unsigned char, unsigned int);     // управление дискретным сигналом

#define PER 0
#define POV 1
#define KAS 1
#define ABS 1
#define OTN 2

#endif