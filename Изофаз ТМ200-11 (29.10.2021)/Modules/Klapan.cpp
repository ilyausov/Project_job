//---------------------------------------------------------------------------
//--Файл описания шаблонных функций--//
//---------------------------------------------------------------------------
#include "Klapan.h"
//---------------------------------------------------------------------------
//--Функция инкрементации счетчика объекта--//
//---------------------------------------------------------------------------
void SKlapan::Time()
{
    ctObject++;
}
//---------------------------------------------------------------------------
//--Функция управления объектами через дискретные входы-выходы--//
//---------------------------------------------------------------------------
void Klapan(bool action, SKlapan *object)
{
    switch ( object -> type )
    {
        case 11: DoAction11(action, object); break;
        case 12: DoAction12(action, object); break;
        case 21: DoAction21(action, object); break;
        case 22: DoAction22(action, object); break;
        // неверный тип объекта
        default: diagn[0] |= 0x01; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 1 входом--//
//---------------------------------------------------------------------------
void DoAction11(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 2 входами--//
//---------------------------------------------------------------------------
void DoAction12(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 1 входом--//
//---------------------------------------------------------------------------
void DoAction21(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 2 входами--//
//---------------------------------------------------------------------------
void DoAction22(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция инкремента счетчиков--//
//---------------------------------------------------------------------------
void TimeKlapan()
{	
	FvnKam.Time();
	FvnShl.Time();
	KlShl.Time();
	KlTmn.Time();
	KlKam.Time();
	KlD4.Time();
	KlD2.Time();
	ShZatvor.Time();
	DZasl.Time();
	PP.Time();
	ZIP.Time();
	Zatvor.Time();
}
//---------------------------------------------------------------------------
//--Функция инициализации объектов с дискретным управлением и дискретной обратной связью--//
//---------------------------------------------------------------------------
void InitObjectsKl()
{
	// описание форнасоса камеры(сухой)
	FvnKam.type = 11;					// тип 1/1
	// нормы объекта
	FvnKam.normaNmb[0] = 37;				// код нормы включения
	FvnKam.normaNmb[1] = 38;				// код нормы отключения
	// контрольные времена объекта
	FvnKam.tkAction[0] = 2;					// к.время открытия
	FvnKam.tkAction[1] = 15;				// к.время закрытия
	FvnKam.tkAction[2] = 30;					// к.время задержки после открытия
	FvnKam.tkAction[3] = 2;					// к.время задержки после закрытия
	// диагностики объекта
	FvnKam.diagnObject[0].x = 15;			// номер байта диагностики "не открылся"
	FvnKam.diagnObject[0].y = 0x10;			// маска бита диагностики "не открылся"
	FvnKam.diagnObject[1].x = 15;			// номер байта диагностики "не закрылся"
	FvnKam.diagnObject[1].y = 0x20;			// маска бита диагностики "не закрылся"
	FvnKam.diagnObject[2].x = 15;			// номер байта диагностики "не определено"
	FvnKam.diagnObject[2].y = 0x20;			// маска бита диагностики "не определено"
	FvnKam.diagnObject[3].x = 15;			// номер байта диагностики "неоднозначно"
	FvnKam.diagnObject[3].y = 0x20;			// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnKam.zinOut[0].x = 4;					// номер байта упр. выходного сигнала на "открытие"
	FvnKam.zinOut[0].y = 0x10;				// маска бита упр. выходного сигнала  на "открытие"
	FvnKam.zinOut[1].x = 4;					// номер байта упр. выходного сигнала на "закрытие"
	FvnKam.zinOut[1].y = 0x10;				// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnKam.zinIn[0].x = 2;					// номер байта ответного входного сигнала об "открытии"
	FvnKam.zinIn[0].y = 0x02;				// маска бита ответного входного сигнала об "открытии"
	FvnKam.zinIn[1].x = 2;					// номер байта ответного входного сигнала о "закрытии"
	FvnKam.zinIn[1].y = 0x02;				// маска бита ответного входного сигнала о "закрытии"

	// описание форнасоса шлюза
	FvnShl.type = 11;					// тип 1/1
	// нормы объекта
	FvnShl.normaNmb[0] = 41;			// код нормы включения
	FvnShl.normaNmb[1] = 42;			// код нормы отключения
	// контрольные времена объекта
	FvnShl.tkAction[0] = 2;				// к.время открытия
	FvnShl.tkAction[1] = 2;				// к.время закрытия
	FvnShl.tkAction[2] = 2;				// к.время задержки после открытия
	FvnShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnShl.diagnObject[0].x = 15;		// номер байта диагностики "не открылся"
	FvnShl.diagnObject[0].y = 0x40;		// маска бита диагностики "не открылся"
	FvnShl.diagnObject[1].x = 15;		// номер байта диагностики "не закрылся"
	FvnShl.diagnObject[1].y = 0x80;		// маска бита диагностики "не закрылся"
	FvnShl.diagnObject[2].x = 15;		// номер байта диагностики "не определено"
	FvnShl.diagnObject[2].y = 0x80;		// маска бита диагностики "не определено"
	FvnShl.diagnObject[3].x = 15;		// номер байта диагностики "неоднозначно"
	FvnShl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnShl.zinOut[0].x = 4;				// номер байта упр. выходного сигнала на "открытие"
	FvnShl.zinOut[0].y = 0x20;			// маска бита упр. выходного сигнала  на "открытие"
	FvnShl.zinOut[1].x = 4;				// номер байта упр. выходного сигнала на "закрытие"
	FvnShl.zinOut[1].y = 0x20;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnShl.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	FvnShl.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	FvnShl.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	FvnShl.zinIn[1].y = 0x01;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание Кл-Шл
	KlShl.type = 12;					// тип 1/2
	// нормы объекта
	KlShl.normaNmb[0] = 29;				// код нормы включения
	KlShl.normaNmb[1] = 30;				// код нормы отключения
	// контрольные времена объекта
	KlShl.tkAction[0] = 2;				// к.время открытия
	KlShl.tkAction[1] = 2;				// к.время закрытия
	KlShl.tkAction[2] = 2;				// к.время задержки после открытия
	KlShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlShl.diagnObject[0].x = 10;		// номер байта диагностики "не открылся"
	KlShl.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlShl.diagnObject[1].x = 10;		// номер байта диагностики "не закрылся"
	KlShl.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlShl.diagnObject[2].x = 10;		// номер байта диагностики "не определено"
	KlShl.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlShl.diagnObject[3].x = 10;		// номер байта диагностики "неоднозначно"
	KlShl.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlShl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlShl.zinOut[0].y = 0x03;			// маска бита упр. выходного сигнала  на "открытие"
	KlShl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlShl.zinOut[1].y = 0x03;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlShl.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlShl.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	KlShl.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlShl.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"	
	
	// описание Кл-ТМН
	KlTmn.type = 12;					// тип 1/2
	// нормы объекта
	KlTmn.normaNmb[0] = 31;				// код нормы включения
	KlTmn.normaNmb[1] = 32;				// код нормы отключения
	// контрольные времена объекта
	KlTmn.tkAction[0] = 2;				// к.время открытия
	KlTmn.tkAction[1] = 2;				// к.время закрытия
	KlTmn.tkAction[2] = 2;				// к.время задержки после открытия
	KlTmn.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlTmn.diagnObject[0].x = 9;			// номер байта диагностики "не открылся"
	KlTmn.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlTmn.diagnObject[1].x = 9;			// номер байта диагностики "не закрылся"
	KlTmn.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlTmn.diagnObject[2].x = 9;			// номер байта диагностики "не определено"
	KlTmn.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlTmn.diagnObject[3].x = 9;			// номер байта диагностики "неоднозначно"
	KlTmn.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlTmn.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlTmn.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	KlTmn.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlTmn.zinOut[1].y = 0x04;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlTmn.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlTmn.zinIn[0].y = 0x1000;			// маска бита ответного входного сигнала об "открытии"
	KlTmn.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlTmn.zinIn[1].y = 0x2000;			// маска бита ответного входного сигнала о "закрытии"	
	
	// описание Кл-Кам
	KlKam.type = 12;					// тип 1/2
	// нормы объекта
	KlKam.normaNmb[0] = 27;				// код нормы включения
	KlKam.normaNmb[1] = 28;				// код нормы отключения
	// контрольные времена объекта
	KlKam.tkAction[0] = 2;				// к.время открытия
	KlKam.tkAction[1] = 2;				// к.время закрытия
	KlKam.tkAction[2] = 2;				// к.время задержки после открытия
	KlKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlKam.diagnObject[0].x = 10;		// номер байта диагностики "не открылся"
	KlKam.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlKam.diagnObject[1].x = 10;		// номер байта диагностики "не закрылся"
	KlKam.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlKam.diagnObject[2].x = 10;		// номер байта диагностики "не определено"
	KlKam.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlKam.diagnObject[3].x = 10;		// номер байта диагностики "неоднозначно"
	KlKam.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlKam.zinOut[0].x = 4;				// номер байта упр. выходного сигнала на "открытие"
	KlKam.zinOut[0].y = 0x4000;			// маска бита упр. выходного сигнала  на "открытие"
	KlKam.zinOut[1].x = 4;				// номер байта упр. выходного сигнала на "закрытие"
	KlKam.zinOut[1].y = 0x4000;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlKam.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlKam.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	KlKam.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlKam.zinIn[1].y = 0x800;			// маска бита ответного входного сигнала о "закрытии"	
	
	// описание Кл-Д4
	KlD4.type = 12;						// тип 1/2
	// нормы объекта
	KlD4.normaNmb[0] = 46;				// код нормы включения
	KlD4.normaNmb[1] = 47;				// код нормы отключения
	// контрольные времена объекта
	KlD4.tkAction[0] = 2;				// к.время открытия
	KlD4.tkAction[1] = 2;				// к.время закрытия
	KlD4.tkAction[2] = 2;				// к.время задержки после открытия
	KlD4.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlD4.diagnObject[0].x = 6;			// номер байта диагностики "не открылся"
	KlD4.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlD4.diagnObject[1].x = 6;			// номер байта диагностики "не закрылся"
	KlD4.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlD4.diagnObject[2].x = 6;			// номер байта диагностики "не определено"
	KlD4.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlD4.diagnObject[3].x = 6;			// номер байта диагностики "неоднозначно"
	KlD4.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlD4.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlD4.zinOut[0].y = 0x08;			// маска бита упр. выходного сигнала  на "открытие"
	KlD4.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlD4.zinOut[1].y = 0x08;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlD4.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlD4.zinIn[0].y = 0x4000;			// маска бита ответного входного сигнала об "открытии"
	KlD4.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlD4.zinIn[1].y = 0x8000;			// маска бита ответного входного сигнала о "закрытии"	

	// описание Кл-Д2
	KlD2.type = 12;						// тип 1/2
	// нормы объекта
	KlD2.normaNmb[0] = 48;				// код нормы включения
	KlD2.normaNmb[1] = 49;				// код нормы отключения
	// контрольные времена объекта
	KlD2.tkAction[0] = 2;				// к.время открытия
	KlD2.tkAction[1] = 2;				// к.время закрытия
	KlD2.tkAction[2] = 2;				// к.время задержки после открытия
	KlD2.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlD2.diagnObject[0].x = 6;			// номер байта диагностики "не открылся"
	KlD2.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlD2.diagnObject[1].x = 6;			// номер байта диагностики "не закрылся"
	KlD2.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlD2.diagnObject[2].x = 6;			// номер байта диагностики "не определено"
	KlD2.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlD2.diagnObject[3].x = 6;			// номер байта диагностики "неоднозначно"
	KlD2.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlD2.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlD2.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	KlD2.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlD2.zinOut[1].y = 0x10;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlD2.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	KlD2.zinIn[0].y = 0x01;				// маска бита ответного входного сигнала об "открытии"
	KlD2.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	KlD2.zinIn[1].y = 0x02;				// маска бита ответного входного сигнала о "закрытии"
	
	// описание ЩЗ
	ShZatvor.type = 22;					// тип 2/2
	// нормы объекта
	ShZatvor.normaNmb[0] = 25;			// код нормы включения
	ShZatvor.normaNmb[1] = 26;			// код нормы отключения
	// контрольные времена объекта
	ShZatvor.tkAction[0] = 4;			// к.время открытия
	ShZatvor.tkAction[1] = 4;			// к.время закрытия
	ShZatvor.tkAction[2] = 1;			// к.время задержки после открытия
	ShZatvor.tkAction[3] = 1;			// к.время задержки после закрытия
	// диагностики объекта
	ShZatvor.diagnObject[0].x = 9;		// номер байта диагностики "не открылся"
	ShZatvor.diagnObject[0].y = 0x01;	// маска бита диагностики "не открылся"
	ShZatvor.diagnObject[1].x = 9;		// номер байта диагностики "не закрылся"
	ShZatvor.diagnObject[1].y = 0x02;	// маска бита диагностики "не закрылся"
	ShZatvor.diagnObject[2].x = 9;		// номер байта диагностики "не определено"
	ShZatvor.diagnObject[2].y = 0x04;	// маска бита диагностики "не определено"
	ShZatvor.diagnObject[3].x = 9;		// номер байта диагностики "неоднозначно"
	ShZatvor.diagnObject[3].y = 0x08;	// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ShZatvor.zinOut[0].x = 0;			// номер байта упр. выходного сигнала на "открытие"
	ShZatvor.zinOut[0].y = 0x20;		// маска бита упр. выходного сигнала  на "открытие"
	ShZatvor.zinOut[1].x = 0;			// номер байта упр. выходного сигнала на "закрытие"
	ShZatvor.zinOut[1].y = 0x40;		// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ShZatvor.zinIn[0].x = 1;			// номер байта ответного входного сигнала об "открытии"
	ShZatvor.zinIn[0].y = 0x04;			// маска бита ответного входного сигнала об "открытии"
	ShZatvor.zinIn[1].x = 1;			// номер байта ответного входного сигнала о "закрытии"
	ShZatvor.zinIn[1].y = 0x08;			// маска бита ответного входного сигнала о "закрытии"	

	// описание ДЗ
	DZasl.type = 22;					// тип 2/2
	// нормы объекта
	DZasl.normaNmb[0] = 22;				// код нормы включения
	DZasl.normaNmb[1] = 23;				// код нормы отключения
	// контрольные времена объекта
	DZasl.tkAction[0] = 4;				// к.время открытия
	DZasl.tkAction[1] = 4;				// к.время закрытия
	DZasl.tkAction[2] = 1;				// к.время задержки после открытия
	DZasl.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	DZasl.diagnObject[0].x = 2;			// номер байта диагностики "не открылся"
	DZasl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	DZasl.diagnObject[1].x = 2;			// номер байта диагностики "не закрылся"
	DZasl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	DZasl.diagnObject[2].x = 2;			// номер байта диагностики "не определено"
	DZasl.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	DZasl.diagnObject[3].x = 2;			// номер байта диагностики "неоднозначно"
	DZasl.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	DZasl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	DZasl.zinOut[0].y = 0x80;			// маска бита упр. выходного сигнала  на "открытие"
	DZasl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	DZasl.zinOut[1].y = 0x100;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	DZasl.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	DZasl.zinIn[0].y = 0x10;			// маска бита ответного входного сигнала об "открытии"
	DZasl.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	DZasl.zinIn[1].y = 0x20;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание подъемника
	PP.type = 22;						// тип 2/2
	// нормы объекта
	PP.normaNmb[0] = 35;				// код нормы включения
	PP.normaNmb[1] = 36;				// код нормы отключения
	// контрольные времена объекта
	PP.tkAction[0] = 10;				// к.время открытия
	PP.tkAction[1] = 10;				// к.время закрытия
	PP.tkAction[2] = 1;				// к.время задержки после открытия
	PP.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	PP.diagnObject[0].x = 11;			// номер байта диагностики "не открылся"
	PP.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	PP.diagnObject[1].x = 11;			// номер байта диагностики "не закрылся"
	PP.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	PP.diagnObject[2].x = 11;			// номер байта диагностики "не определено"
	PP.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	PP.diagnObject[3].x = 11;			// номер байта диагностики "неоднозначно"
	PP.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	PP.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	PP.zinOut[0].y = 0x200;			// маска бита упр. выходного сигнала  на "открытие"
	PP.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	PP.zinOut[1].y = 0x400;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	PP.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	PP.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	PP.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	PP.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание затвор ИП
	ZIP.type = 12;						// тип 1/2
	// нормы объекта
	ZIP.normaNmb[0] = 100;				// код нормы включения
	ZIP.normaNmb[1] = 101;				// код нормы отключения
	// контрольные времена объекта
	ZIP.tkAction[0] = 10;				// к.время открытия
	ZIP.tkAction[1] = 10;				// к.время закрытия
	ZIP.tkAction[2] = 1;				// к.время задержки после открытия
	ZIP.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ZIP.diagnObject[0].x = 32;			// номер байта диагностики "не открылся"
	ZIP.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	ZIP.diagnObject[1].x = 32;			// номер байта диагностики "не закрылся"
	ZIP.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	ZIP.diagnObject[2].x = 32;			// номер байта диагностики "не определено"
	ZIP.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	ZIP.diagnObject[3].x = 32;			// номер байта диагностики "неоднозначно"
	ZIP.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ZIP.zinOut[0].x = 4;				// номер байта упр. выходного сигнала на "открытие"
	ZIP.zinOut[0].y = 0x2000;			// маска бита упр. выходного сигнала  на "открытие"
	ZIP.zinOut[1].x = 4;				// номер байта упр. выходного сигнала на "закрытие"
	ZIP.zinOut[1].y = 0x2000;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ZIP.zinIn[0].x = 1;					// номер байта ответного входного сигнала об "открытии"
	ZIP.zinIn[0].y = 0x400;				// маска бита ответного входного сигнала об "открытии"
	ZIP.zinIn[1].x = 1;					// номер байта ответного входного сигнала о "закрытии"
	ZIP.zinIn[1].y = 0x800;				// маска бита ответного входного сигнала о "закрытии"
	
	// описание затвора
	Zatvor.type = 12;					// тип 1/2
	// нормы объекта
	Zatvor.normaNmb[0] = 102;			// код нормы включения
	Zatvor.normaNmb[1] = 103;			// код нормы отключения
	// контрольные времена объекта
	Zatvor.tkAction[0] = 10;			// к.время открытия
	Zatvor.tkAction[1] = 10;			// к.время закрытия
	Zatvor.tkAction[2] = 1;				// к.время задержки после открытия
	Zatvor.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	Zatvor.diagnObject[0].x = 32;		// номер байта диагностики "не открылся"
	Zatvor.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	Zatvor.diagnObject[1].x = 32;		// номер байта диагностики "не закрылся"
	Zatvor.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	Zatvor.diagnObject[2].x = 32;		// номер байта диагностики "не определено"
	Zatvor.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	Zatvor.diagnObject[3].x = 32;		// номер байта диагностики "неоднозначно"
	Zatvor.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	Zatvor.zinOut[0].x = 4;				// номер байта упр. выходного сигнала на "открытие"
	Zatvor.zinOut[0].y = 0x8000;		// маска бита упр. выходного сигнала  на "открытие"
	Zatvor.zinOut[1].x = 4;				// номер байта упр. выходного сигнала на "закрытие"
	Zatvor.zinOut[1].y = 0x8000;		// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	Zatvor.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	Zatvor.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	Zatvor.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	Zatvor.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"
}