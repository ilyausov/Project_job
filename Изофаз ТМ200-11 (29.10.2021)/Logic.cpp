//---------------------------------------------------------------------------
#pragma hdrstop
#include "Logic.h"
#include "Modules\RRG.cpp"
#include "Modules\Klapan.cpp"
#include "Modules\BPN\BPN.cpp"
//---------------------------------------------------------------------------
#pragma package(smart_init)

void LogicMain ()
{         
    KOLCO();                    // кольцо
    if ( shr[1] )               // Проверка
    {                           // активации
        R_1();                  // режима 1 "Откачка камеры"
    };
    if ( shr[2] )               // Проверка
    {                           // активации
        R_2();                  // режима 2 "Откачка шлюза"
    };
	if ( shr[3] )               // Проверка
    {                           // активации
        R_3();                  // режима 3 "Рабочий цикл"
    };
	if ( shr[4] )               // Проверка
    {                           // активации
        R_4();                  // режима 4 "Технологический процесс"
    };
    if ( shr[5] )               // Проверка
    {                           // активации
        R_5();                  // режима 5 "Сброс РЦ"
    };
	if ( shr[6] )               // Проверка
    {                           // активации
        R_6();                  // режима 6 "Сбор(выгрузка) пластин"
    };
    if ( shr[7] )               // Проверка
    {                           // активации
        R_7();                  // режима 7 "Отключение установки"
    };
	if ( shr[8] )               // Проверка
    {                           // активации
        R_8();                  // режима 8 "Аварийное отключение установки"
    };
	if ( shr[9] )               // Проверка
    {                           // активации
        R_9();                  // режима 9 "Транспортный тест"
    };	
	if ( shr[10] )               // Проверка
    {                            // активации
        R_10();                  // режима 10 "Открыть ЩЗ"
    };
	if ( shr[11] )               // Проверка
    {                            // активации
        R_11();                  // режима 11 "Закрыть ЩЗ"
    };
	if ( shr[12] )               // Проверка
    {                            // активации
        R_12();                  // режима 12 "Ман. в исх"
    };
	if ( shr[13] )               // Проверка
    {                            // активации
        R_13();                  // режима 13 "Ман. вперед/назад"
    };
    if ( shr[14] )               // Проверка
    {                            // активации
        R_14();                  // режима 15 "Ман. поворот в HOME"
    };
    if ( shr[15] )               // Проверка
    {                            // активации
        R_15();                  // режима 15 "Ман. поворот вправо/влево"
    };
	if ( shr[17] )               // Проверка
    {                            // активации
        R_17();                  // режима 17 "Дросселирование ДЗ"
    };
    if ( shr[18] )               // Проверка
    {                            // активации
        R_18();                  // режима 18 "Открыть ДЗ"
    };
    if ( shr[19] )               // Проверка
    {                            // активации
        R_19();                  // режима 19 "Закрыть ДЗ"
    };
	if ( shr[20] )              // Проверка
    {                           // активации
        R_20();                 // режима 20 "РРГ1"
    };	
    if ( shr[21] )              // Проверка
    {                           // активации
        R_21();                 // режима 21 "РРГ2"
    };
    if ( shr[22] )              // Проверка
    {                           // активации
        R_22();                 // режима 22 "РРГ3"
    };
    if ( shr[23] )              // Проверка
    {                           // активации
        R_23();                 // режима 23 "РРГ4"
    };
	if ( shr[24] )              // Проверка
    {                           // активации
        R_24();                 // режима 24 "РРГ5"
    };
	if ( shr[25] )              // Проверка
    {                           // активации
        R_25();                 // режима 25 "РРГ6"
    };
	if ( shr[26] )              // Проверка
    {                           // активации
        R_26();                 // режима 26 "РРГ7"
    };
	if ( shr[29] )              // Проверка
    {                           // активации
        R_29();                 // режима 29 "Вкл. ВЧГ реактора"
    };
    if ( shr[30] )              // Проверка
    {                           // активации
        R_30();                 // режима 30 "Автосогласование ВЧГ реактора(точно)"
    };
	if ( shr[31] )              // Проверка
    {                           // активации
        R_31();                 // режима 31 "Движ. в точку согл. ВЧГ реатора(грубо)"
    };
	if ( shr[32] )              // Проверка
    {                           // активации
        R_32();                 // режима 32 "Движ. в точку согл. ВЧГ реатора(точно)"
    };
	if ( shr[33] )              // Проверка
    {                           // активации
        R_33();                 // режима 33 "Вкл. нагрев 1"
    };
    if ( shr[34] )              // Проверка
    {                           // активации
        R_34();                 // режима 34 "Откл. нагрев 1"
    };
    if ( shr[37] )              // Проверка
    {                           // активации
        R_37();                 // режима 37 "Кассета в HOME"
    };
    if ( shr[38] )              // Проверка
    {                           // активации
        R_38();                 // режима 38 "Кассета вверх/вниз"
    };
    if ( shr[40] )              // Проверка
    {                           // активации
        R_40();                 // режима 40 "Вкл. нагрева канала 1"
    };
    if ( shr[41] )              // Проверка
    {                           // активации
        R_41();                 // режима 41 "Откл. нагрева канала 1"
    };
    if ( shr[42] )              // Проверка
    {                           // активации
        R_42();                 // режима 42 "Вкл. нагрева канала 2"
    };
    if ( shr[43] )              // Проверка
    {                           // активации
        R_43();                 // режима 43 "Откл. нагрева канала 2"
    };
    if ( shr[48] )              // Проверка
    {                           // активации
        R_48();                 // режима 48 "Вкл. нагрева канала 6"
    };
    if ( shr[49] )              // Проверка
    {                           // активации
        R_49();                 // режима 49 "Откл. нагрева канала 6"
    };
    if ( shr[50] )              // Проверка
    {                           // активации
        R_50();                 // режима 50 "Вкл. нагрева канала 7"
    };
    if ( shr[51] )              // Проверка
    {                           // активации
        R_51();                 // режима 51 "Откл. нагрева канала 7"
    };
    if ( shr[52] )              // Проверка
    {                           // активации
        R_52();                 // режима 52 "Вкл. нагрева канала 8"
    };
    if ( shr[53] )              // Проверка
    {                           // активации
        R_53();                 // режима 53 "Откл. нагрева канала 8"
    };
    if ( shr[54] )              // Проверка
    {                           // активации
        R_54();                 // режима 54 "Вкл. нагрева канала 9"
    };
    if ( shr[55] )              // Проверка
    {                           // активации
        R_55();                 // режима 55 "Откл. нагрева канала 9"
    };
    if ( shr[56] )              // Проверка
    {                           // активации
        R_56();                 // режима 56 "Вкл. нагрева канала 10"
    };
    if ( shr[57] )              // Проверка
    {                           // активации
        R_57();                 // режима 57 "Откл. нагрева канала 10"
    };
    if ( shr[58] )              // Проверка
    {                           // активации
        R_58();                 // режима 58 "Вкл. нагрева канала 11"
    };
    if ( shr[59] )              // Проверка
    {                           // активации
        R_59();                 // режима 59 "Откл. нагрева канала 11"
    };
    if ( shr[60] )              // Проверка
    {                           // активации
        R_60();                 // режима 60 "Вкл. нагрева канала 12"
    };
    if ( shr[61] )              // Проверка
    {                           // активации
        R_61();                 // режима 61 "Откл. нагрева канала 12"
    };
    if ( shr[62] )              // Проверка
    {                           // активации
        R_62();                 // режима 62 "Вкл. нагрева канала 13"
    };
    if ( shr[63] )              // Проверка
    {                           // активации
        R_63();                 // режима 63 "Откл. нагрева канала 13"
    };
    if ( shr[64] )              // Проверка
    {                           // активации
        R_64();                 // режима 64 "Вкл. нагрева канала 14"
    };
    if ( shr[65] )              // Проверка
    {                           // активации
        R_65();                 // режима 65 "Откл. нагрева канала 14"
    };
    if ( shr[66] )              // Проверка
    {                           // активации
        R_66();                 // режима 66 "Вкл. нагрева канала 15"
    };
    if ( shr[67] )              // Проверка
    {                           // активации
        R_67();                 // режима 67 "Откл. нагрева канала 15"
    };
    if ( shr[68] )              // Проверка
    {                           // активации
        R_68();                 // режима 68 "Вкл. нагрева канала 16"
    };
    if ( shr[69] )              // Проверка
    {                           // активации
        R_69();                 // режима 69 "Откл. нагрева канала 16"
    };
    if ( shr[70] )              // Проверка
    {                           // активации
        R_70();                 // режима 70 "Вкл. нагрева канала 17"
    };
    if ( shr[71] )              // Проверка
    {                           // активации
        R_71();                 // режима 71 "Откл. нагрева канала 17"
    };
    if ( shr[72] )              // Проверка
    {                           // активации
        R_72();                 // режима 72 "Вкл. нагрева канала 18"
    };
    if ( shr[73] )              // Проверка
    {                           // активации
        R_73();                 // режима 73 "Откл. нагрева канала 18"
    };
    if ( shr[74] )              // Проверка
    {                           // активации
        R_74();                 // режима 74 "Вкл. нагрева канала 19"
    };
    if ( shr[75] )              // Проверка
    {                           // активации
        R_75();                 // режима 75 "Откл. нагрева канала 19"
    };
    if ( shr[76] )              // Проверка
    {                           // активации
        R_76();                 // режима 76 "Вкл. нагрева канала 20"
    };
    if ( shr[77] )              // Проверка
    {                           // активации
        R_77();                 // режима 77 "Откл. нагрева канала 20"
    };
    if ( shr[78] )              // Проверка
    {                           // активации
        R_78();                 // режима 78 "Вкл. нагрева канала 21"
    };
    if ( shr[79] )              // Проверка
    {                           // активации
        R_79();                 // режима 79 "Откл. нагрева канала 21"
    };
    if ( shr[80] )              // Проверка
    {                           // активации
        R_80();                 // режима 80 "Вкл. нагрева канала 23"
    };
    if ( shr[81] )              // Проверка
    {                           // активации
        R_81();                 // режима 81 "Откл. нагрева канала 23"
    };
    if ( shr[82] )              // Проверка
    {                           // активации
        R_82();                 // режима 82 "Вкл. нагрева канала 24"
    };
    if ( shr[83] )              // Проверка
    {                           // активации
        R_83();                 // режима 83 "Откл. нагрева канала 24"
    };
    if ( shr[84] )              // Проверка
    {                           // активации
        R_84();                 // режима 84 "Вкл. нагрева канала 5"
    };
    if ( shr[85] )              // Проверка
    {                           // активации
        R_85();                 // режима 85 "Откл. нагрева канала 5"
    };

    POST();                     // дешифрация команд оператора
}
//---------------------------------------------------------------------------
void KOLCO()                    // подпрограмма "Кольцо"
{
	DIAGN_KOLCO();              // диагностика в кольце
	AVAR_VODA_IP();				// реакция на пропадание воды в ИП
	AVAR_DAVL();				// "Реакция на высокое давление в камере при работе ТМН"
	UPR_AVAR_OTKL();			// управление аварийным отключением
	UPR_R_30();					// управление режимом автосогл.
	VID_DIAGN_GIR();            // выдача диагностики нет согласования ВЧГ реактора
	OKNSGIR_g();				// отработка кнопок грубо ВЧГ реактора
	OKNSGIR_t();				// отработка кнопок точно ВЧГ реактора
	ZashDD();                   // подпрограмма защиты датчика
	OpenFK_TMN_CloseFK_SHL();	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
	MEH_AVAR_CHK();			// слежение за авриями механизмов
	Vkl_FK_TMN();				// включение ТМН
        UPR();						// подъём/опускание штырей (управл.)
	OPROS_SOST();				// подпрограмма "Опрос и запись состояния"
	PUSK_TP();					// Пуск ТП
}
//---------------------------------------------------------------------------
	void POST()                     // Почта (приём и дешифрация команд)
{
    switch (qkk)
    {
        case 0:;break;          // проверка на KK = 0
        case 1:                 // проверка на KK = 1
        {
            if ( shr[1] == 0 )  // если режим ещё не активизирован
            {
                shr[1] = 1;     // активизируем
                sh[1]  = 1;     // режим 1 "Откачка камеры"
            }
        }; break;
        case 3:                 // проверка на KK = 3
        {
            if ( shr[3] == 0 )  // если режим ещё не активизирован
            {
                shr[3] = 1;     // активизируем
                sh[3]  = 1;     // режим 3 "Рабочий цикл"
            }
        }; break;
		case 5:                 // проверка на KK = 5
        {
            if ( shr[5] == 0 )  // если режим ещё не активизирован
            {
                shr[5] = 1;     // активизируем
                sh[5]  = 1;     // режим 5 "Сброс РЦ"
            }
        }; break;
        case 6:                 // проверка на KK = 6
        {
            if ( shr[6] == 0 )  // если режим ещё не активизирован
            {
                shr[6] = 1;     // активизируем
                sh[6]  = 1;     // режим 6 "Сбор пластин"
            }
        }; break;
		case 7:                 // проверка на KK = 7
        {
            if ( shr[7] == 0 )  // если режим ещё не активизирован
            {
                shr[7] = 1;     // активизируем
                sh[7]  = 1;     // режим 7 "Отключение установки"
            }
        }; break;
		
		case 9:                 // проверка на KK = 9
        {
            if ( shr[9] == 0 )  // если режим ещё не активизирован
            {
                shr[9] = 1;     // активизируем
                sh[9]  = 1;     // режим 9 "Транспортный тест"
            }
        }; break;		
		case 109:				// проверка на KK = 109
        {
            PR_TRTEST = 1;		// признак окончания транспортного теста
        }; break;
		case 10:				// проверка на KK = 10
        {
            if ( shr[10] == 0 )  // если режим ещё не активизирован
            {
                shr[10] = 1;     // активизируем
                sh[10]  = 1;     // режим 10 "Открыть ЩЗ"
            }
        }; break;
		case 11:                 // проверка на KK = 11
        {
            if ( shr[11] == 0 )  // если режим ещё не активизирован
            {
                shr[11] = 1;     // активизируем
                sh[11]  = 1;     // режим 11 "Закрыть ЩЗ"
            }
        }; break;
		case 12:                 // проверка на KK = 12
        {
            if ( shr[12] == 0 )  // если режим ещё не активизирован
            {
                shr[12] = 1;     // активизируем
                sh[12]  = 1;     // режим 12 "Мех. перем. в исх"
            }
        }; break;
		case 13:                 // проверка на KK = 13
        {
            if ( shr[13] == 0 )  // если режим ещё не активизирован
            {
                shr[13] = 1;     // активизируем
                sh[13]  = 1;     // режим 13 "Мех. перем. вперед/назад"
            }
        }; break;
        case 14:                 // проверка на KK = 14
        {
            if ( shr[14] == 0 )  // если режим ещё не активизирован
            {
                shr[14] = 1;     // активизируем
                sh[14]  = 1;     // режим 14 "Мех. пов. HOME"
            }
        }; break;
        case 15:                 // проверка на KK = 15
        {
            if ( shr[15] == 0 )  // если режим ещё не активизирован
            {
                shr[15] = 1;     // активизируем
                sh[15]  = 1;     // режим 15 "Мех. пов. вправо/влево"
            }
        }; break;
		case 113:				// проверка на KK = 113
        {
            SBROS_MEH();		// сброс механизмов
        }; break;
		case 213:				// проверка на KK = 213
        {
            MEH_AVAR_SBROS();	// сброс аварий механизмов
        }; break;
		case 17:                 // проверка на KK = 17
        {
            if ( shr[17] == 0 )  // если режим ещё не активизирован
            {
                shr[17] = 1;     // активизируем
                sh[17]  = 1;     // режим 17 "Дросселирование ДЗ"
            }
        }; break;
		case 18:                 // проверка на KK = 18
        {
            if ( shr[18] == 0 )  // если режим ещё не активизирован
            {
                shr[18] = 1;     // активизируем
                sh[18]  = 1;     // режим 18 "Открыть ДЗ"
            }
        }; break;
		case 19:                 // проверка на KK = 19
        {
            if ( shr[19] == 0 )  // если режим ещё не активизирован
            {
                shr[19] = 1;     // активизируем
                sh[19]  = 1;     // режим 19 "Закрыть ДЗ"
            }
        }; break;
		case 100:				// проверка на KK = 100
        {
            OSBROS();			// общий сброс
        }; break;
		case 20:                // проверка на KK = 20
        {
            if ( shr[20] == 0 ) // если режим ещё не активизирован
            {
                shr[20] = 1;    // активизируем
                sh[20]  = 1;    // режим 20 "Вкл. РРГ1"
            }
        }; break;
		case 120:                // проверка на KK = 120
        {
			RRGOff(ObjRRG[0]);	// отключение РРГ1
		}; break;
		case 21:                // проверка на KK = 21
        {
            if ( shr[21] == 0 ) // если режим ещё не активизирован
            {
                shr[21] = 1;    // активизируем
                sh[21]  = 1;    // режим 21 "Вкл. РРГ2"
            }
        }; break;
		case 121:                // проверка на KK = 121
        {
			RRGOff(ObjRRG[1]);	// отключение РРГ2
		}; break;
		case 22:                // проверка на KK = 22
        {
            if ( shr[22] == 0 ) // если режим ещё не активизирован
            {
                shr[22] = 1;    // активизируем
                sh[22]  = 1;    // режим 22 "Вкл. РРГ3"
            }
        }; break;
		case 122:                // проверка на KK = 122
        {
			RRGOff(ObjRRG[2]);	// отключение РРГ3
		}; break;
		case 23:                // проверка на KK = 23
        {
            if ( shr[23] == 0 ) // если режим ещё не активизирован
            {
                shr[23] = 1;    // активизируем
                sh[23]  = 1;    // режим 23 "Вкл. РРГ4"
            }
        }; break;
		case 123:                // проверка на KK = 123
        {
			RRGOff(ObjRRG[3]);	// отключение РРГ4
		}; break;
		case 24:                // проверка на KK = 24
        {
            if ( shr[24] == 0 ) // если режим ещё не активизирован
            {
                shr[24] = 1;    // активизируем
                sh[24]  = 1;    // режим 24 "Вкл. РРГ5"
            }
        }; break;
		case 124:                // проверка на KK = 124
        {
			RRGOff(ObjRRG[4]);	// отключение РРГ5
		}; break;
		case 25:                // проверка на KK = 25
        {
            if ( shr[25] == 0 ) // если режим ещё не активизирован
            {
                shr[25] = 1;    // активизируем
                sh[25]  = 1;    // режим 25 "Вкл. РРГ5"
            }
        }; break;
		case 125:                // проверка на KK = 125
        {
			RRGOff(ObjRRG[5]);	// отключение РРГ6
		}; break;
		case 26:                // проверка на KK = 26
        {
                shr[26] = 1;    // активизируем
                sh[26]  = 1;    // режим 26 "Вкл. РРГ7"
		}; break;
		case 126:                // проверка на KK = 126
        {
			RRGOff(ObjRRG[6]);	// отключение РРГ7
		}; break;		
		case 27:                // проверка на KK = 27
        {
            if ( shr[27] == 0 ) // если режим ещё не активизирован
            {
                shr[27] = 1;    // активизируем
                sh[27]  = 1;    // режим 27 "Вкл. ВЧГ стола(мощ)"
            }
        }; break;
		case 28:                // проверка на KK = 28
        {
            if ( shr[28] == 0 ) // если режим ещё не активизирован
            {
                shr[28] = 1;    // активизируем
                sh[28]  = 1;    // режим 28 "Вкл. ВЧГ стола(смещ)"
            }
        }; break;
		case 29:                // проверка на KK = 29
        {
            if ( shr[29] == 0 ) // если режим ещё не активизирован
            {
                shr[29] = 1;    // активизируем
                sh[29]  = 1;    // режим 29 "Вкл. ВЧГ реактора"
            }
        }; break;
		case 129:				// проверка на KK = 129
        {
           SBROSR_29();
        }; break;
                 case 30:                // проверка на KK = 30
        {
            if ( shr[30] == 0 ) // если режим ещё не активизирован
            {
                shr[30] = 1;    // активизируем
                sh[30]  = 1;    // режим 30 "Автосогласование ВЧГ реактора(точно)"
            }
        }; break;
		case 33:                // проверка на KK = 33
        {
            if ( shr[33] == 0 ) // если режим ещё не активизирован
            {
                shr[33] = 1;    // активизируем
                sh[33]  = 1;    // режим 33 "Вкл нагрев 1"
            }
        }; break;
		case 34:                // проверка на KK = 34
        {
            if ( shr[34] == 0 ) // если режим ещё не активизирован
            {
                shr[34] = 1;    // активизируем
                sh[34]  = 1;    // режим 33 "Откл нагрев 1"
            }
        }; break;
		case 37:                // проверка на KK = 37
        {
            if ( shr[37] == 0 ) // если режим ещё не активизирован
            {
                shr[37] = 1;    // активизируем
                sh[37]  = 1;    // режим 37 "Кассета в HOME"
            }
        }; break;
		case 38:                // проверка на KK = 38
        {
            if ( shr[38] == 0 ) // если режим ещё не активизирован
            {
                shr[38] = 1;    // активизируем
                sh[38]  = 1;    // режим 38 "Кассета вверх/вниз"
            }
        }; break;
        default:                // любая другая команда
        {
            diagnS[0] |= 0x80;  // отказ: "неопознанная команда"
            return;             //
        };

    };
    qkk = 0;                    // сброс кода команды
    diagnS[0] &= ~(0x80);       // сброс диагностики
}
//---------------------------------------------------------------------------
void DIAGN_KOLCO()				// "Подпрограмма: "Диагностика в кольце"
{
	if((zin[0] & 0x01) == 0)
		diagn[13] |= 0x02;		// Отказ: "Нет охл/нагр. п/держателя"
	else
		diagn[13] &= (~0x02);	// Сброс диагностики
	
	if((zin[0] & 0x02) == 0)
		diagn[13] |= 0x04;		// Отказ: "Нет охл. ФВН камеры"
	else
		diagn[13] &= (~0x04);	// Сброс диагностики

	if((zin[0] & 0x04) == 0)
		diagn[13] |= 0x80;		// Отказ: "Нет охл. ТМН"
	else
		diagn[13] &= (~0x80);	// Сброс диагностики

	if((zin[0] & 0x08) == 0)
		diagn[21] |= 0x01;		// Отказ: "Нет охл. ИП"
	else 
		diagn[21] &= (~0x01);	// Сброс диагностики

	if((zin[0] & 0x10) == 0)	
		diagn[21] |= 0x02;		// Отказ: "Нет охл. ловушки"
	else
		diagn[21] &= (~0x02);	// Сброс диагностики
	
	if((zin[0] & 0x20) == 0)
		diagn[13] |= 0x01;		// Отказ: "Нет давления в пневмосети"
	else
		diagn[13] &= (~0x01);	// Сброс диагностики
	
	if(!(zin[2]&0x10))
		diagn[19] |= 0x02;		// Отказ: "ФВН камеры: предупреждение"
	else
		diagn[19] &= (~0x02);	// Сброс диагностики
	
	if(!(zin[2]&0x20))
		diagn[19] |= 0x01;		// Отказ: "ФВН камеры: нет удаленного упр."
	else
		diagn[19] &= (~0x01);	// Сброс диагностики
	
	if(zin[2]&0x200)
		diagn[19] |= 0x40;		// Отказ: "ТМН: авария"
	else
		diagn[19] &= (~0x40);	// Сброс диагностики	
	
	if(zin[2]&0x4000)
		diagn[19] |= 0x80;		// Отказ: "ТМН: предупреждение"
	else
		diagn[19] &= (~0x80);	// Сброс диагностики
	
	if(!(zin[2]&0x8000))
		diagn[13] |= 0x10;		// Отказ: "ТМН: температура не в норме"
	else
		diagn[13] &= (~0x10);	// Сброс диагностики
	
	if(zin[4] & 0x01)
		diagn[21] |= 0x10;		// Отказ: "Превышение температуры ВЧГ ИП"
	else
		diagn[21] &= (~0x10);	// Сброс диагностики
	
	if(!(zin[4] & 0x400)&&(PR_KLASTER==0))
		diagn[13] |= 0x20;		// Отказ:"Авария манипулятора перемещения"
	else
		diagn[13] &= (~0x20);	// Сброс диагностики

    if(!(zin[4] & 0x2000)&&(PR_KLASTER==0))
		diagn[33] |= 0x01;		// Отказ:"Авария манипулятора поворота"
	else
		diagn[33] &= (~0x01);	// Сброс диагностики

    if(!(zin[4] & 0x80)&&(PR_KLASTER==0))
		diagn[33] |= 0x02;		// Отказ:"Авария манипулятора кассеты"
	else
		diagn[33] &= (~0x02);	// Сброс диагностики

	if(zin[3] & 0x100)
	{
		diagn[11] |= 0x01;		// Отказ:"Отказ двигателя ИП точно"
		SetOut(0,1,0xC00);
		A_OUT(9,8192);
	}
	else
		diagn[11] &= (~0x01);	// Сброс диагностики

	if(zin[3] & 0x200)
	{
		diagn[11] |= 0x02;		// Отказ:"Отказ двигателя ИП грубо"
		SetOut(0,1,0x3000);
		A_OUT(10,8192);
	}
	else
		diagn[11] &= (~0x02);	// Сброс диагностики
	
	if(aik[0] > 901)			// T° > 30°C
		diagn[21] |= 0x04;		// Отказ: "Высокая темп. воды охл. п/д"
	else
		diagn[21] &= ~(0x04);	// Сброс диагностики

	if(aik[2] > 901)			// T° > 30°C
		diagn[13] |= 0x40;		// Отказ: "Высокая темп. воды охл. ТМН"
	else
		diagn[13] &= ~(0x40);	// Сброс диагностики
	
	if(aik[3] > 901)			// T° > 30°C
		diagn[21] |= 0x08;		// Отказ: "Высокая темп. воды охл. ИП"
	else
		diagn[21] &= ~(0x08);	// Сброс диагностики

	if(aik[4] > 901)			// T° > 30°C
		diagn[21] |= 0x40;		// Отказ: "Высокая темп. воды охл. ловушки"
	else
		diagn[21] &= ~(0x40);	// Сброс диагностики
}

//------------------------------------------------------------------------------
void AVAR_VODA_IP()				// "Реакция на пропадание воды в ИП"
{
	if(shr[29])						// есть активизация режимов ИП стола
	{
		if(zin[0] & 0x08)			// есть охлаждение ИП
		{
			CT_VODA_IP = 0;
			return;
		}
		if(CT_VODA_IP >= T_VODA)	// время вышло (5 сек)
		{
			diagn[14] |= 0x20;		// "Авария:нет охл/нагр. ИП"
			if((shr[4])&&(!PR_NALADKA))				// есть активизация РЦ
			{
				shr[5] = 1;			// запуск режима 5
				sh[5] = 1;			// "Сброс РЦ"
			}
			else
			{
				SBROSR_29();
			}			
		}
	}
	else
		CT_VODA_IP = 0;
}
//------------------------------------------------------------------------------
void AVAR_DAVL()      // "Реакция на высокое давление в камере при работе ТМН"
{
 if((zin[2] & 0x1C00) != 0)             // есть входной сигнал ТМН
  if((zin[1] & 0x300) != 0x200)           // Затвор не закрыт
   if((zin[0] & 0xC000) != 0x8000)		// Кл-D4 не закрыт
    if((diagnS[0] & 0x08) == 0)         // есть свяь с D4
     if(D_D4 >= POROG_DAVL)             // давление больше 100 Па
      {
	   SetOut(0,4,0x8000);				// закрыть Затвор

       diagn[14] |= 0x04;               // "Авария: высокое давление в камере"

       shr[1] = 0;                      // сброс активизации режимов
       sh[1] = 0;                       // "Откачка"
	   shr[2] = 0;
       sh[2] = 0;                       // "Откачка шлюза"
       shr[3] = 0;
       sh[3] = 0;                       // "РЦ"
	   shr[4] = 0;
       sh[4] = 0;                       // "Тех. процесс"
       shr[5] = 0;
       sh[5] = 0;                       // "Сброс РЦ"
	   shr[6] = 0;
       sh[6] = 0;                       // "Сбор пластин"
	   shr[7] = 0;
       sh[7] = 0;                       // "Отключение установки"
	   shr[9] = 0;
       sh[9] = 0;                       // "Транспортный тест"
	   shr[10] = 0;
       sh[10] = 0;						// "Открыть ЩЗ"
	   shr[11] = 0;
       sh[11] = 0;						// "Закрыть ЩЗ"
	   
	   shr[17] = 0;
       sh[17] = 0;                      // "Дросселирование ДЗ"
       shr[18] = 0;
       sh[18] = 0;                      // "Открыть ДЗ"
       shr[19] = 0;
       sh[19] = 0;                      // "Закрыть ДЗ"

       shr[29] = 0;						// ВЧГ реактора
	   sh[29]  = 0;
       shr[39] = 0;						// сброс ВЧГ реактора
	   sh[39]  = 0;
       SetOut(0,4,0x300);
       A_OUT(7,8192);

	   shr[31] = 0;
       sh[31] = 0;                      // Движение ИП в точку точно
	   SetOut(0,1,0xC00);
	   A_OUT(9,8192);

	   shr[32] = 0;
       sh[32] = 0;                      // Движение ИП в точку грубо
	   SetOut(0,1,0x3000);
	   A_OUT(10,8192);

	   SBROS_MEH();						// сброс движений
	   
	   RRGOff(ObjRRG[0]);				// отключение РРГ1
	   RRGOff(ObjRRG[1]);				// отключение РРГ2
       RRGOff(ObjRRG[2]);				// отключение РРГ3
	   RRGOff(ObjRRG[3]);				// отключение РРГ4
	   RRGOff(ObjRRG[4]);				// отключение РРГ5
       RRGOff(ObjRRG[5]);				// отключение РРГ6
	   RRGOff(ObjRRG[6]);				// отключение РРГ7
 
       SetOut(0,4,0xC08);               // закрыть Кл-НАП1, Кл-НАП2 , Кл-НАП3
	   SetOut(0,2,0xFFFF);				// закрыть VP1,VP2,...,VP15,VP39
	   SetOut(0,3,0xFFFE);				// закрыть VP16,VP17,...,VP29,VP40,VP41(кроме VP23)
	   SetOut(1,3,0x01);				// закрыть VP23
       SetOut(1,0,0x80);
       SetOut(0,0,0x100);
       SBROSR_29();
       for(int i=0;i<DIAGN_COUNT;i++)
            if(i != 14) diagn[i] = 0;// сброс диагностик кроме аварийных

       KOM_DZASL = 7;                    // "Общий опрос" заслонке
      }
}
//------------------------------------------------------------------------------
void UPR_AVAR_OTKL()			// Управление аварийным отключением
{
	if(zin[2] & 0x1C00)  // ТМН работает
	{
		if (zin[2] & 0x200)
			diagn[14] |= 0x08;// авария ТМН
		else if (zin[2] & 0x02) goto A_1;   // ФВН включен
		else diagn[14] |= 0x10;				// диагностика: "Авария: Отключение ФВН"
        if(shr[8] == 0)						// режим R_8 не активизирован
		{
			shr[8] = 1;						// активизация режима R_8
			sh[8] = 1;
		}
	}
	else
	{
A_1:	   if((out[4]&0x10)&&!(zin[2]&0x08))	// ФВН камеры включен и есть авария
		{
                        diagn[14] |= 0x02;				// диагностика: "Авария: ФВН камеры"
			if(shr[8] == 0)					// режим R_8 не активизирован
			{
				shr[8] = 1;					// активизация режима R_8
				sh[8] = 1;
			}
		}
	}
}
//---------------------------------------------------------------------------
void UPR_R_30 ()			                // Подпр."Управление режимом
					                        // "Автом.согласование ВЧГ реактора"
{
    // если есть движение в точку УС ВЧГ реактора - обход
    if(prDvijGir_g || prDvijGir_t) return;	// движение в точку еще работает
	if(!nasmod[3])							// Автом.согласов.ВЧГ реактора запрещено
	{
		if(shr[30])     					// Есть активиз.реж.автом.согл.ВЧГ реактора
        {
			shr[30] = 0;				    // деактивизация режима
			sh[30] = 0;			            // "Автом.согласование ВЧГ реактора"
			diagn[7] &= (~0x08);		    // Сброс диагн."Нет согл.ВЧГ реактора",
			diagn[11] &= (~0x03);			// "Отказ двигат.УС ВЧГ реактора(точно)"
											// "Отказ двигат.УС ВЧГ реактора(грубо)"
			A_OUT(9,8192);					// Сброс уставки скорости и направления
			A_OUT(10,8192);					// Сброс уставки скорости и направления
			SetOut(0,1,0x3C00);				// двигателей СУ ВЧГ реактора
		}
	}
	else
	{
		if(!shr[29])						// нет активизации режима ВЧГ реактора
		{
			shr[30] = 0;				    // деактивизация режима
			sh[30] = 0;			            // "Автом.согласование ВЧГ реактора"
			diagn[7] &= (~0x08);		    // Сброс диагн."Нет согл.ВЧГ реактора",
											// "Отказ двигат.УС ВЧГ реактора(точно)"
											// "Отказ двигат.УС ВЧГ реактора(грубо)"
			A_OUT(9,8192);					// Сброс уставки скорости и направления
			A_OUT(10,8192);					// Сброс уставки скорости и направления
			SetOut(0,1,0x3C00);				// двигателей СУ ВЧГ реактора
		}
		else if(!shr[30] && VRGIR && N_ST)	// не актив.автосогл., был выход на режим и не наладка 
		{
			shr[30] = 1;				    // активизация режима
			sh[30] = 1;			            // "Автом.согласование ВЧГ реактора"
		}
	}
}
//------------------------------------------------------------------------------
void VID_DIAGN_GIR()            // выдача диагностики нет согласования ВЧГ реактора
{
    if ((shr[29])&&				// есть активизация режима ВЧГ реактора
        (VRGIR)&&				// есть выход на режим ВЧГ реактора
        (aik[13]))				// отраженная мощность не 0
    {
        N_TEK_GIR=aik[12]*10/aik[13];// текущий коэф. согласования
        if (N_TEK_GIR >= nasmod[5])
            diagn[7] &= (~0x08);// снять диагностику
        else
            diagn[7] |= 0x08;	// диагн.: "нет согл. ВЧГ реактора"
    }
    else
    {
     diagn[7] &= (~0x08);// снять диагностику
     N_TEK_GIR = 0;
    }
}
//---------------------------------------------------------------------------
void OKNSGIR_g()		// Подпрограмма: "Отработка кнопок
						// > и < ВЧГ реактора (грубо)(вверх/вниз)
{
    // отказ: "Ограничение движ. УС ВЧГ реактора(грубо)"
	if(aik[17]<200 || aik[17]>3900) diagn[15] |= 0x04;
    else diagn[15] &= (~0x04);               // сброс диагностики
    // есть запрет автоматического согласования ВЧГ реактора
    // или ВЧГ реактора активен в наладочном режиме
    if((!nasmod[3]) || (!shr[4] && shr[29]))
        diagn[7] |= 0x40;   // автосогласование запрещено
    else
    {
        diagn[7] &=(~0x40); // снять диагностику
        return;
    }
    // если есть движение в точку УС ВЧГ реактора - обход
    if(prDvijGir_g) return;
	// опрос кнопки > (вперед)
	if(!klGir_gV) goto S0;		        	// кнопка не включена
	if((out[1] & 0x2000) != 0) goto S1;		// движ.назад (<) включено
	if((out[1] & 0x1000) != 0) return;		// движ.вперед (>) включено
	if(CT_DVIJ_GIR_g <= T_ZAD_DVS)return;	// время задержки не вышло(тик)
	// движение GIR вперед (>)
	A_OUT (10,nasmod[4]);			        // задание скорости GIR(nasmod[4])
	SetOut(0,1,0x2000);						// задание направления
	SetOut(1,1,0x1000);						// вперед (>)
	return;
	// стоп движения
S1: A_OUT (10,8192);						// сброс скорости
	SetOut(0,1,0x3000);						// сброс направления
	CT_DVIJ_GIR_g = 0;			            // сброс сч.вр.задержки
	return;
	// опрос кнопки < (назад)
S0: if(!klGir_gN)	                    	// кнопка не включена
	// стоп движения
	{
		A_OUT(10,8192);			            // сброс скорости
		SetOut(0,1,0x3000);		        	// сброс направления
		return;
	}
	if((out[1] & 0x1000) != 0) goto S1; 	// движ.вперед (>) включено
	if((out[1] & 0x2000) != 0) return;  	// движ.назад (<) включено
	if(CT_DVIJ_GIR_g <= T_ZAD_DVS)return;   // время задержки не вышло
	// движение GIR назад (<)
	A_OUT(10,nasmod[4]);			        // задание скорости GIR(nasmod[4])
	SetOut(0, 1, 0x1000);			        // задание направления
   	SetOut(1, 1, 0x2000);			        // назад (<)
}
//---------------------------------------------------------------------------
void OKNSGIR_t()		// Подпрограмма: "Отработка кнопок
						// > и < ВЧГ реактора (точно)(влево/вправо)
{
    // отказ: "Ограничение движ. УС ВЧГ реактора(точно)"
	if(aik[16]<200 || aik[16]>3900) diagn[15] |= 0x08;
    else diagn[15] &= (~0x08);               // сброс диагностики
    // есть запрет автоматического согласования ВЧГ реактора
    // или ВЧГ реактора активен в наладочном режиме
    if((!nasmod[3]) || (!shr[4] && shr[29]))
        diagn[7] |= 0x40;   // автосогласование запрещено
    else
    {
        diagn[7] &=(~0x40); // снять диагностику
        return;
    }
    // если есть движение в точку УС ВЧГ реактора - обход
    if(prDvijGir_t) return;
	// опрос кнопки > (вперед)
	if(!klGir_tV) goto S0;		        	// кнопка не включена
	if((out[1] & 0x800) != 0) goto S1;		// движ.назад (<) включено
	if((out[1] & 0x400) != 0) return;		// движ.вперед (>) включено
	if(CT_DVIJ_GIR_t <= T_ZAD_DVS)return;	// время задержки не вышло(тик)
	// движение GIR вперед (>)
	A_OUT (9,nasmod[4]);			        // задание скорости GIR(nasmod[4])
	SetOut(0,1,0x800);						// задание направления
	SetOut(1,1,0x400);						// вперед (>)
	return;
	// стоп движения
S1: A_OUT (9,8192);							// сброс скорости
	SetOut(0,1,0xC00);						// сброс направления
	CT_DVIJ_GIR_t = 0;			            // сброс сч.вр.задержки
	return;
	// опрос кнопки < (назад)
S0: if(!klGir_tN)	                    	// кнопка не включена
	// стоп движения
	{
		A_OUT(9,8192);			            // сброс скорости
		SetOut(0,1,0xC00);		        	// сброс направления
		return;
	}
	if((out[1] & 0x400) != 0) goto S1; 		// движ.вперед (>) включено
	if((out[1] & 0x800) != 0) return;  		// движ.назад (<) включено
	if(CT_DVIJ_GIR_t <= T_ZAD_DVS)return;   // время задержки не вышло
	// движение GIR назад (<)
	A_OUT(9,nasmod[4]);			        	// задание скорости GIR(nasmod[4])
	SetOut(0, 1, 0x400);			        // задание направления
   	SetOut(1, 1, 0x800);			        // назад (<)
}
//---------------------------------------------------------------------------
void ZashDD()                           // подпрограмма защиты Д4 и Д2
{
	if((out[2]&0x1C)||(out[3]&0x3148)||(shr[29])) //
        SetOut(0,0,0x18);				// закрыть Кл-Д2,Кл-Д4

    // при открытии VP29 открыть и VP13
    if(out[3]&0x2000) SetOut(1,2,0x4000);
}
//---------------------------------------------------------------------------
void OpenFK_TMN_CloseFK_SHL()	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
{
	if(zin[2] & 0x1C00 )				// если есть вращение ТМН
	 if((zin[1] & 0x03) != 0x02)		// Кл-Д2 не закрыт
	  if((diagnS[0] & 0x02) == 0)		// есть свяь с D2
	   if(D_D2 >= UVAK_ZTMN)			// давление больше 40 Па
		if((zin[0]&0x3000)!=0x1000)		// ФК-ТМН не открыт
		{
			if((zin[0]&0xC00)==0x800)	// ФК-КАМ строго закрыт
				SetOut(1,0,0x04);		// открыть ФК-ТМН
			else	
				SetOut(0,4,0x4000);		// закрыть ФК-КАМ
		}
}
//---------------------------------------------------------------------------
void Vkl_FK_TMN()	// Подпрограмма: Напуска азота в ТМН
{
	if(zin[2]&0x1C00)	// Есть хотя бы один из сигналов ТМН 
	{
		SetOut(1, 4, 0x1000);						// Клапан подачи в ТМН
	}
	else
	{
		SetOut(0, 4, 0x1000);
	}
}
//---------------------------------------------------------------------------
void MEH_AVAR_CHK()				// слежение за авриями механизма
{
	// если нет аварии механизма
	if((zin[4]&0x400)&&(zin[4]&0x80)&&(zin[4]&0x2000))
		SetOut(0,1,0x08);		// сбросить сигнал "Сброс аварий"
}
//---------------------------------------------------------------------------
void MEH_AVAR_SBROS()			// сброс аварий механизма (не в кольце)
{
	SetOut(1,1,0x08);			// выдать сигнал "Сброс аварий"(по кнопке)
}
//---------------------------------------------------------------------------
void OSBROS()					// подпрограмма Общий сброс
{
	PR_PER = 0;

	N_ZICL = 0;
	PR_NALADKA = 0;
    KOM_DZASL=7;
	N_ST = 0;
    if(shr[5])
    {
        shr[4]=0;
        sh[4]=0;
    }
	shr[1] = 0;					// сброс активизации режима 1
	sh[1] = 0;					// "Откачка камеры"
	shr[2] = 0;					// сброс активизации режима 2
	sh[2] = 0;					// "Откачка шлюза"
	shr[5] = 0;					// сброс активизации режима 5
	sh[5] = 0;					// "Сброс РЦ"
	shr[6] = 0;					// сброс активизации режима 6
	sh[6] = 0;					// "Сбор пластин"
	shr[7] = 0;					// сброс активизации режима 7
	sh[7] = 0;					// "Отключение установки"
	shr[8] = 0;					// сброс активизации режима 8
	sh[8] = 0;					// "Аварийное отключение установки"
	shr[10] = 0;				// сброс активизации режима 10
	sh[10] = 0;					// "Открыть ЩЗ"
	shr[11] = 0;				// сброс активизации режима 11
	sh[11] = 0;					// "Закрыть ЩЗ"
	shr[17] = 0;				// сброс активизации режима 17
	sh[17] = 0;					// "Дросселирование ДЗ"
	shr[18] = 0;				// сброс активизации режима 18
	sh[18] = 0;					// "Открыть ДЗ"
	shr[19] = 0;				// сброс активизации режима 19
	sh[19] = 0;					// "Закрыть ДЗ"
	shr[39] = 0;                // сброс активизации режима 39
    sh[39] = 0;                 // "Откл. ВЧГ реактора"
    shr[41] = 0;                // сброс активизации режима 41
    sh[41] = 0;                 // "Откл. нагрева канала 1"
    shr[43] = 0;                // сброс активизации режима 43
    sh[43] = 0;                 // "Откл. нагрева канала 2"
    shr[45] = 0;                // сброс активизации режима 45
    sh[45] = 0;                 // "Откл. нагрева канала 3"
    shr[47] = 0;                // сброс активизации режима 47
    sh[47] = 0;                 // "Откл. нагрева канала 4"
    shr[49] = 0;                // сброс активизации режима 49
    sh[49] = 0;                 // "Откл. нагрева канала 6"
    shr[51] = 0;                // сброс активизации режима 51
    sh[51] = 0;                 // "Откл. нагрева канала 7"
    shr[53] = 0;                // сброс активизации режима 53
    sh[53] = 0;                 // "Откл. нагрева канала 8"
    shr[55] = 0;                // сброс активизации режима 55
    sh[55] = 0;                 // "Откл. нагрева канала 9"
    shr[57] = 0;                // сброс активизации режима 57
    sh[57] = 0;                 // "Откл. нагрева канала 10"
    shr[59] = 0;                // сброс активизации режима 59
    sh[59] = 0;                 // "Откл. нагрева канала 11"
    shr[61] = 0;                // сброс активизации режима 61
    sh[61] = 0;                 // "Откл. нагрева канала 12"
    shr[63] = 0;                // сброс активизации режима 63
    sh[63] = 0;                 // "Откл. нагрева канала 13"
    shr[65] = 0;                // сброс активизации режима 65
    sh[65] = 0;                 // "Откл. нагрева канала 14"
    shr[67] = 0;                // сброс активизации режима 67
    sh[67] = 0;                 // "Откл. нагрева канала 15"
    shr[69] = 0;                // сброс активизации режима 69
    sh[69] = 0;                 // "Откл. нагрева канала 16"
    shr[71] = 0;                // сброс активизации режима 71
    sh[71] = 0;                 // "Откл. нагрева канала 17"
    shr[73] = 0;                // сброс активизации режима 73
    sh[73] = 0;                 // "Откл. нагрева канала 18"
    shr[75] = 0;                // сброс активизации режима 75
    sh[75] = 0;                 // "Откл. нагрева канала 19"
    shr[77] = 0;                // сброс активизации режима 77
    sh[77] = 0;                 // "Откл. нагрева канала 20"
    shr[79] = 0;                // сброс активизации режима 79
    sh[79] = 0;                 // "Откл. нагрева канала 21"
    shr[81] = 0;                // сброс активизации режима 81
    sh[81] = 0;                 // "Откл. нагрева канала 23"
    shr[83] = 0;                // сброс активизации режима 83
    sh[83] = 0;                 // "Откл. нагрева канала 24"
	SetOut(0,0,0x1800);			// сброс уставки и направлений прижима
	A_OUT(11,8192);

    if(shr[34])                 // Есть активизация режима 34
    {
        SetOut(0,4,0x01);
        SetOut(1,4,0x02);
        shr[34] = 0;
        sh[34] = 0;
    }

	RRGOff(ObjRRG[0]);			// отключение РРГ1
	RRGOff(ObjRRG[1]);			// отключение РРГ2
	RRGOff(ObjRRG[2]);			// отключение РРГ3
	RRGOff(ObjRRG[3]);			// отключение РРГ4
	RRGOff(ObjRRG[4]);			// отключение РРГ5
	RRGOff(ObjRRG[5]);			// отключение РРГ6
	RRGOff(ObjRRG[6]);			// отключение РРГ7

	SBROS_MEH();				// сброс движений

	for(int i=0;i<DIAGN_COUNT;i++) // сброс всех диагностик
	    diagn[i] = 0;

	SetOut(0,1,0x10);			// отключить звонок

	norma = 7;					// норма: общий сброс завершен
}
//---------------------------------------------------------------------------
void TIME()			//  подпрограмма управления таймером
{					// (прерывание с периодом в 1 миллисекунду)

	CT_T1++;		// Сч.тиков (1 мсек=1кГц)
	CT_4++;
	// Счетчики тиковские (1 мсек) для устройств и режимов


	if(CT_T1 < 20) return;
	CT_T1 = 0;		// Сброс сч.тиков (1 мсек.)
	CT_T20++;		// Счетчик тиков (20мсек = 50Гц)

	// Счетчики тиковские (20 мсек) для устройств и режимов
	CT_SUT_g++;
	CT_SUT_t++;
    CT_DVIJ_GIR_g++;
	CT_DVIJ_GIR_t++;

	CT_30T++;			    // (тик) сч.вр.режима 30

	if(CT_T20 < 50) return;
	CT_T20 = 0;		// Сброс сч.тиков (20 мсек.)
	
	// Счетчики секундные (1 сек)

	CT_VHG++;
	CT_VODA_IP++;
    CT_PER++;
    CT_POV++;
    CT_KAS++;
    CT_TEMP++;
	//CT_TEMP2++;
	//CT_MP++;
    CT_DZASL++;

        // Счетчики времени режимов (секундные)

	CT_1++;
	CT_2++;
	CT_3++;
	CT_5++;
	CT_6++;
	CT_7++;
	CT_9++;
	CT_17++;
	CT17K1++;
	/*CT_27++;
	CT27K1++;
	CT_28++;
	CT28K1++;*/
	CT_29++;
	CT29K1++;
	/*CT_33++;
	CT33K1++;
	CT_35++;
	CT35K1++;*/

	TimeRRG();
	TimeKlapan();
	TimeBPN();
    
}
//------------------------------------------------------------------------------
//-------------------------------  РЕЖИМЫ  -------------------------------------
//------------------------------------------------------------------------------
void R_1 ()            // Режим "Откачка камеры"
{
	sh_ = sh[1];
	
	if (shr[1] < 1 || shr[1] > 38) goto L100;
	if (shr[1] < 10) goto L00;
	if (shr[1] < 20) goto L01;
	if (shr[1] < 30) goto L02;
	else goto L03;
	
L00:if (shr[1] == 1) goto L1;
	if (shr[1] == 2) goto L2;
	if (shr[1] == 3) goto L3;
	if (shr[1] == 4) goto L4;
	if (shr[1] == 5) goto L5;
	if (shr[1] == 6) goto L6;
	if (shr[1] == 7) goto L7;
	if (shr[1] == 8) goto L8;
	if (shr[1] == 9) goto L9;
L01:if (shr[1] == 10) goto L10;
	if (shr[1] == 11) goto L11;
	if (shr[1] == 12) goto L12;
	if (shr[1] == 13) goto L13;
	if (shr[1] == 14) goto L14;
	if (shr[1] == 15) goto L15;
	if (shr[1] == 16) goto L16;
	if (shr[1] == 17) goto L17;
	if (shr[1] == 18) goto L18;
	if (shr[1] == 19) goto L19;
L02:if (shr[1] == 20) goto L20;
	if (shr[1] == 21) goto L21;
	if (shr[1] == 22) goto L22;
	if (shr[1] == 23) goto L23;
	if (shr[1] == 24) goto L24;
	if (shr[1] == 25) goto L25;
	if (shr[1] == 26) goto L26;
	if (shr[1] == 27) goto L27;
	if (shr[1] == 28) goto L28;
	if (shr[1] == 29) goto L29;
L03:if (shr[1] == 30) goto L30;
	if (shr[1] == 31) goto L31;
	if (shr[1] == 32) goto L32;
	if (shr[1] == 33) goto L33;
	if (shr[1] == 34) goto L34;
	if (shr[1] == 35) goto L35;
    if (shr[1] == 36) goto L36;
    if (shr[1] == 37) goto L37;
    if (shr[1] == 38) goto L38;
	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[1] = sh_;
	if (sh[1] != 0) goto L100;	// sh_ != 0
	++shr[1];					// след. шаг сч.шр1
	if (shr[1] > 38) goto L0;	// число шагов режима
	sh[1] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 2;					// норма: "Откачка камеры завершена"
	shr[1] = 0;
	goto L100;

L1: SetOut(0,2,0xFFFF);			// закрыть VP1,VP2,...,VP15
	SetOut(0,3,0xFFFE);			// закрыть VP16,VP17,...,VP29,VP40,VP41(кроме VP23)
	SetOut(1,3,0x01);			// закрыть VP23
	SetOut(0,4,0x400);			// закрыть Кл-Нап1
	for(int i=0;i<DIAGN_COUNT;i++)
		diagn[i] = 0;			// сброс всех диагностик
	Klapan(1,&ZIP);				// Открыть затвор ИП
	goto L101;
L2: Klapan(1,&KlD4);			// Открыть Кл-Д4
	goto L101;
L3: Klapan(1,&KlD2);			// Открыть Кл-Д2
	if(sh_) goto L101;
    if(PR_KLASTER)
        {
            shr[1]=5;           //переход на шаг 5_1
            sh_=1;
            goto L5_1;
        }
	if(zin[4]&0x200)			// МАН в HOME?
		{shr[1] = 4;				// Переход на шаг 4_1
        goto L4_1;}
	goto L101;
L4: VIDK_PER(0,0,0,1,10);		// МАН в HOME
	if(sh_)goto L101;
L4_1:shr[1]=36;
    if(!(zin[4]&0x1000))goto L101;
    shr[1]=37;
    goto L37_1;
L5: Klapan(0,&ShZatvor);		// закрыть ШЗ
	if(sh_) goto L101;
    SetOut(1,0,0x40);           // закрыть ШЗ
L5_1:for(int i=0;i<24; i++)		// Есть задание хотя бы на один канал нагрева
	{
		if(par_n[i])
		{
			if(shr[33] == 0)
			{
				sh[33]  = 1;	// Активизируем  				
				shr[33] = 1;	// режим 33 "Вкл. нагрев установки" 
			}
            sh_=0;
			goto L101;
		}
	}
    sh_=0;
	goto L101;
L6: Klapan(1,&FvnKam);			// включить ФВН-КАМ
    goto L101;
L7: Klapan(0,&PP);				// подъемник пластин вниз
	if(sh_) goto L101;
	if(zin[2]&0x800)			// есть ТМН:Норма
		shr[1] = 8;				// переход на шаг 9
	goto L101;
L8:	Klapan(0,&Zatvor);			// закрыть затвор
	goto L101;
L9:	if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 <= UVAKV_KAM )		// проверка уровня вакуума в камере
		shr[1] = 18;			// переход на шаг 19
	sh_ = 0;
	goto L101;
L10:Klapan(0,&Zatvor);			// закрыть затвор
	goto L101;
L11:Klapan(0,&KlTmn);			// закрыть ФК-ТМН
	goto L101;
L12:Klapan(1,&KlKam);			// открыть ФК-Кам
	goto L101;
L13:Klapan(1,&DZasl);			// открыть ДЗ
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L14:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 > UVAKV_KAM )		// проверка уровня вакуума в камере
	{
		if(zin[2]&0x1C00)		// есть хоть один из трех сигналов ТМН
		{
			sh_ = 0;			// переход на шаг 15
			goto L101;
		}
		sh_ = 1;
		shr[1] = 15;			// переход на подшаг 15_1 
		goto L15_1;				
	}
	diagn[12] &= (~0x01);        // сброс диагностики
	shr[1] = 18;				// переход на шаг 19
	sh_ = 0;
	goto L101;
L15:if(!(zin[3]&0x40))			// нет форвакуума в ТМН
	{
		sh_ = 0;
		goto L101;
	}
L15_1:if(CT_1 > T_KKAM)			// контрольное время вышло
		diagn[12] |= 0x01;		// диагностика "Медленная фороткачка камеры"
	shr[1] = 13;				// возврат на шаг 14
	sh_ = 0;
	goto L101;
L16:Klapan(0,&KlKam);			// закрыть ФК-Кам
	goto L101;
L17:Klapan(1,&KlTmn);			// открыть ФК-Тмн
	goto L101;
L18:if(!(zin[3]&0x40))			// нет форвакуума в ТМН
		goto L101;
	shr[1] = 10;				// переход на шаг 11
	sh_ = 0;
	goto L101;
L19:Klapan(0,&KlKam);			// закрыть ФК-Кам
	goto L101;
L20:Klapan(1,&KlTmn);			// открыть ФК-Тмн
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L21:if(!(zin[3]&0x40))			// нет форвакуума в ТМН
	{
		if(CT_1 > T_KTMN)		// контрольное время вышло
			diagn[12] |= 0x02;	// диагностика "Медленная фороткачка ТМН"
		goto L101;
	}
	diagn[12] &= (~0x02);		// сброс диагностики
	sh_ = 0;
	goto L101;
L22:SetOut(1,4,0x40);			// включить ТМН
	CT_1 = 0;
    sh_ = 0;
	goto L101;
L23:if(!(zin[2]&0x800))			// нет сигнала "ТМН: норма"
	{
		if(CT_1 > T_KTMN_RAZGON)// контрольное время вышло
			diagn[15] |= 0x01;	// диагностика "Нет выхода на режим ТМН"
		goto L101;
	}
	diagn[15] &= (~0x01);		// сброс диагностики
	sh_ = 0;
	goto L101;
L24:Klapan(1,&DZasl);
	goto L101;
L25:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 > UVAKN_KAM )		// проверка уровня вакуума в камере
	{
		sh_ = 0;
		goto L101;
	}
	shr[1] = 31;				// переход на шаг 32
	sh_ = 0;
	goto L101;
L26:Klapan(0,&KlTmn);			// закрыть ФК-Тмн
	goto L101;
L27:Klapan(1,&KlKam);			// открыть ФК-Кам
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L28:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 <= UVAKV_KAM )		// проверка уровня вакуума в камере
	{
		diagn[12] &= (~0x01);	// сброс диагностики
		shr[1] = 31;			// переход на шаг 32
		sh_ = 0;
		goto L101;	
	}	
	if(zin[2]&0x1C00)			// есть хоть один из трех сигналов ТМН
	{
		if(!(zin[3]&0x40))		// нет форвакуума в ТМН
		{
			sh_ = 0;
			goto L101;			// переход на шаг 27
		}
	}
	if(CT_1 > T_KKAM)			// контрольное время вышло
		diagn[12] |= 0x01;		// диагностика "Медленная фороткачка камеры"
	shr[1] = 27;				// возврат на шаг 28
	sh_ = 0;
	goto L101;
L29:Klapan(0,&KlKam);			// закрыть ФК-Кам
	goto L101;
L30:Klapan(1,&KlTmn);			// открыть ФК-Тмн
	goto L101;
L31:if(!(zin[3]&0x40))			// нет форвакуума в ТМН
		goto L101;
	shr[1] = 25;				// переход на шаг 26
	sh_ = 0;
	goto L101;
L32:Klapan(0,&KlKam);			// закрыть ФК-Кам
	goto L101;
L33:Klapan(1,&KlTmn);			// открыть ФК-Тмн
	goto L101;
L34:Klapan(1,&Zatvor);			// открыть затвор
	if(sh_) goto L101;
	CT_1 = 0;
	goto L101;
L35:if(shr[3])
	{
		if(diagnS[0]&0x08)		// пока нет связи с D4
			goto L101;
		if(D_D4 > nasmod[1])	// проверка уровня вакуума в камере
		{
			if(CT_1 > T_KKAM_V)	// контролькое время вышло
				diagn[15] |= 0x02;	// диагностика "Медленная высоковакуумная откачка камеры"
			goto L101;
		}
	}
	    else
        {
	        if(diagnS[0]&0x08)			// пока нет связи с D4
		        goto L101;
	        if(D_D4 > nasmod[0])		// проверка уровня вакуума в камере
	        {
		        if(CT_1 > T_KKAM_V)		// контролькое время вышло
			        diagn[15] |= 0x02;	// диагностика "Медленная высоковакуумная откачка камеры"
		        goto L101;
	        }
        }
	diagn[15] &= (~0x02);				// сброс диагностики
	sh_ = 0;
	goto L101;
L36:VRR_GIR();					        // вкл. разреш. раб. ВЧГ реактора
	if(sh_)goto L101;
    goto L0;                            // Выход !!
L37:VIDK_POV(0,0,0,1,10);		// Ман. пов. в HOME
	if(sh_) goto L101;
L37_1: if(zin[4]&0x40)shr[1]=4; //переход на шаг 5
    sh_=0;
    goto L101;
L38:VIDK_KAS(0,0,0,1,10); 		// подъём касеты в HOME
    if(sh_)goto L101;
    shr[1]=4;
	goto L101;
}
//---------------------------------------------------------------------------
void R_2 ()            // Режим "Откачка шлюза"
{
	sh_ = sh[2];
	
	if (shr[2] == 1) goto L1;
	if (shr[2] == 2) goto L2;
	if (shr[2] == 3) goto L3;
	if (shr[2] == 4) goto L4;
	if (shr[2] == 5) goto L5;
	if (shr[2] == 6) goto L6;
	if (shr[2] == 7) goto L7;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[2] = sh_;
	if (sh[2] != 0) goto L100;	// sh_ != 0
	++shr[2];					// след. шаг сч.шр2
	if (shr[2] > 7) goto L0;	// число шагов режима
	sh[2] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 1;					// норма: "Откачка шлюза завершена"
	shr[2] = 0;
	goto L100;

L1: if(!(zin[3]&0x4000))		// дверь шлюза не закрыта
	{
		diagn[12] |= 0x40;		// диагностика "Дверь шлюза не закрыта"
		goto L101;
	}
	diagn[12] &= (~0x40);		// сброс диагностики
	SetOut(0,4,0x808);			// закрыть Кл-Нап2-3
	sh_ = 0;
	goto L101;
L2: if(zin[3]&0x20)			// есть форвакуум в шлюзе
	{
		shr[2] = 7;				// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	sh_ = 0;
	goto L101;
L3: sh_ = 0;
	goto L101;
L4:	Klapan(1,&FvnShl);			// включить ФВН шлюза
	if(sh_) goto L101;
	SetOut(1,0,0x02);			// откр. Фк-Шл(мягк.)
	CT_2 = 0;
	goto L101;
L5: if(diagnS[0]&0x01)			// пока нет связи с D1
		goto L101;
	if(D_D1 > UVAK_SHL_MO)		// проверка уровня вакуума в камере
	{
		if(CT_2 > T_KSHL_MO)	// контролькое время вышло
		diagn[12] |= 0x04;		// диагностика "Медленная мягкая откачка шлюза"
		goto L101;
	}
	diagn[12] &= (~0x04);		// сброс диагностики
	sh_ = 0;
	goto L101;
L6: CT_2=0;
    Klapan(1,&KlShl);			// открыть Кл-Шл
	goto L101;
L7: if(!(zin[3]&0x20))			// нет форвакуума в шлюзе
	{
		if(CT_2 > T_KSHL)		// контролькое время вышло
		diagn[20] |= 0x80;		// диагностика "Медленная фороткачка шлюза"
		goto L101;
	}
	diagn[20] &= (~0x80);		// сброс диагностики
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_3 ()            // Режим "Рабочий цикл"
{
	sh_ = sh[3];
	
	if (shr[3] < 1 || shr[3] > 52) goto L100;
	if (shr[3] < 10) goto L00;
	if (shr[3] < 20) goto L01;
	if (shr[3] < 30) goto L02;
	if (shr[3] < 40) goto L03;
	goto L04;

L00:if (shr[3] == 1) goto L1;		if (shr[3] == 2) goto L2;
	if (shr[3] == 3) goto L3;		if (shr[3] == 4) goto L4;
	if (shr[3] == 5) goto L5;		if (shr[3] == 6) goto L6;
	if (shr[3] == 7) goto L7;		if (shr[3] == 8) goto L8;
	if (shr[3] == 9) goto L9;
L01:if (shr[3] == 10) goto L10;		if (shr[3] == 11) goto L11;
	if (shr[3] == 12) goto L12;		if (shr[3] == 13) goto L13;
	if (shr[3] == 14) goto L14;		if (shr[3] == 15) goto L15;
	if (shr[3] == 16) goto L16;		if (shr[3] == 17) goto L17;
	if (shr[3] == 18) goto L18;		if (shr[3] == 19) goto L19;
L02:if (shr[3] == 20) goto L20;		if (shr[3] == 21) goto L21;
	if (shr[3] == 22) goto L22;		if (shr[3] == 23) goto L23;
	if (shr[3] == 24) goto L24;		if (shr[3] == 25) goto L25;
	if (shr[3] == 26) goto L26;		if (shr[3] == 27) goto L27;
	if (shr[3] == 28) goto L28;		if (shr[3] == 29) goto L29;
L03:if (shr[3] == 30) goto L30;		if (shr[3] == 31) goto L31;
	if (shr[3] == 32) goto L32;		if (shr[3] == 33) goto L33;
	if (shr[3] == 34) goto L34;		if (shr[3] == 35) goto L35;
	if (shr[3] == 36) goto L36;		if (shr[3] == 37) goto L37;
	if (shr[3] == 38) goto L38;		if (shr[3] == 39) goto L39;
L04:if (shr[3] == 40) goto L40;		if (shr[3] == 41) goto L41;
	if (shr[3] == 42) goto L42;		if (shr[3] == 43) goto L43;
	if (shr[3] == 44) goto L44;		if (shr[3] == 45) goto L45;
	if (shr[3] == 46) goto L46;		if (shr[3] == 47) goto L47;
	if (shr[3] == 48) goto L48;		if (shr[3] == 49) goto L49;
	if (shr[3] == 50) goto L50;		if (shr[3] == 51) goto L51;
	if (shr[3] == 52) goto L52;
	goto L100;			// выход	
	
	// конечный диспетчер режима
L101:sh[3] = sh_;
	if (sh[3] != 0) goto L100;		// sh_ != 0
	++shr[3];						// след. шаг сч.шр2
	if (shr[3] > 52) goto L0;		// число шагов режима
	sh[3] = 1;
L100:return;						// возврат в "кольцо"

L0: norma = 3;						// норма: "РЦ завершен"
	shr[3] = 0;
	goto L100;
	
L1: N_ST = 0;
	T_PROC = 0;
	N_PL = 0;
	sh[1] = 1;						// активизация режима "Откачка камеры"
	shr[1] = 1;
	sh_ = 0;
	goto L101;
L2:	if(shr[1]) goto L101;			// ожидание конца режима
	sh_ = 0;
	goto L101;
L3:	Klapan(0,&KlShl);				// закрыть ФК-Шл
	if(sh_) goto L101;
	if(zin[3]&0x4000)				// дверь шлюза закрыта
	{
		CT_3 = 0;
		SetOut(1,4,0x08);			// открыть Кл-Нап2
		goto L101;
	}
	otvet = 0;
	shr[3] = 6;						// переход на шаг 7
	goto L101;
L4:	if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
	if(D_D1 <= UVAK_SHL_MN) goto L101;	// проверка уровня вакуума в шлюзе	
	SetOut(1,4,0x800);				// открыть Кл-Нап3
	sh_ = 0;
	goto L101;
L5: if(zin[3]&0x4000)				// дверь шлюза закрыта
	{
		if(CT_3 >= T_KNAP)
			diagn[12] |= 0x08;		// диагностика "Медленный напуск в шлюз"
		goto L101;
	}
	diagn[12] &= (~0x08);			// сброс диагностики
	SetOut(0,4,0x808);				// закрыть Кл-Нап2, Кл-Нап3
    SetOut(1,1,0x10);				// включить звонок
    CT_3 = 0;
	sh_ = 0;
	goto L101;
L6: if(CT_3 <= 3) goto L101;		// задержка
	SetOut(0,1,0x10);				// отключить звонок
	otvet = 0;
	sh_ = 0;
	goto L101;
L7:	if(!otvet) goto L101;		// ожидание ответа оператора
	N_PL = 0;
	if(otvet == 1)
	{
		shr[2] = 1;				// активизация режима "Откачка шлюза"
		sh[2] = 1;
		shr[3] = 11;			// переход на шаг 12
		sh_ = 0;
		goto L101;
	}
	otvet = 0;
	sh_ = 0;
	goto L101;
L8:	if(!otvet) goto L101;		// ожидание ответа оператора
	if(otvet == 1)
	{
		shr[2] = 1;				// активизация режима "Откачка шлюза"
		sh[2] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[3] = 9;					// переход на шаг 10
	sh_ = 0;
	goto L101;
L9:	if(shr[2]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
L10:Klapan(0,&KlShl);			// закрыть ФК-Шл
	goto L101;
L11:Klapan(0,&FvnShl);			// отключить ФВН шлюза
	if(sh_) goto L101;
	shr[3] = 52;				// ВЫХОД!!!
	goto L101;
L12:if(shr[2]) goto L101;		// ожидание конца режима
    sh_ = 0;
    for (int i =0; i<24;i++)
        if(par_n[i])
        {
            if(!(shr[33]))
                {
                shr[33]=1;
                sh[33]=1;
                }
            goto L101;
        }
    shr[3]=15;
	goto L101;
L13:for(int i=0;i<24; i++)			// нет выхода на режим хотя бы одного
	{
        if((i!=2)&&(i!=3)&&(i!=4)&&(i!=21))
		    if(!(ObjBPN[i]->vBPN)) goto L101;
	}
	sh_ = 0;
	goto L101;
L14:sh_ = 0;
	goto L101;
L15:sh_ = 0;
	goto L101;
L16:VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету
	goto L101;
L17:VIDK_KAS(0,OTN,-par_t[5],0,10);	// кассета вниз (h1)
	goto L101;
L18:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	goto L101;
L19:if(!(zin[4]&0x4000))			// пров. налич пластин перед кассетой
	{
		diagn[8] |= 0x01;			// диагностика "Ман. не взял пластину из кассеты"
		goto L101;
	}
	diagn[8] &= (~0x01);			// сброс диагностики
	N_PL++;
	sh_ = 0;
	goto L101;
L20:VIDK_POV(0,ABS,par_t[3],0,10); // ман. пов. к камере
	goto L101;
L21:if(!(zin[4]&0x8000))			// пров. налич пластин перед камерой
	{
		diagn[8] |=0x02 ;			// диагностика "Нет пластины на манип. перед камерой"
		goto L101;
	}
	diagn[8] &= (~0x02 );			// сброс диагностики
	sh_ = 0;
	goto L101;
L22:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 > nasmod[1])		// проверка уровня вакуума в камере
	{
		diagn[34] |=0x40 ;		// диагностика "Нет рабочего вакуума в камере"
		goto L101;	
	}
	diagn[34] &= (~0x40 );		// сброс диагностики
	sh_ = 0;
	goto L101;
L23:if(!(zin[3]&0x20))			// нет форвакуума в шлюзе
	{
		diagn[12] |=0x20 ;			// диагностика "Нет форвакуума в шлюзе"
		goto L101;	
	}
	diagn[12] &= (~0x20 );			// сброс диагностики
	sh_ = 0;
	goto L101;
L24:Klapan(0,&KlShl);				// закрыть ФК-Шл
	goto L101;
L25:Klapan(1,&ShZatvor);			// открыть ШЗ
	goto L101;
L26:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в камеру
	goto L101;
L27:Klapan(1,&PP);					// подъемник вверх
	goto L101;
L28:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	goto L101;
L29:if(zin[4]&0x8000)			// пров. налич пластин перед камерой
	{
		diagn[8] |=0x04 ;			// диагностика "Манипулятор не загрузил пластину в камеру"
		goto L101;
	}
	diagn[8] &= (~0x04 );			// сброс диагностики
	sh_ = 0;
	goto L101;
L30:Klapan(0,&ShZatvor);		// закрыть ШЗ
	goto L101;
L31:Klapan(1,&KlShl);			// открыть ФК-Шл
	goto L101;
L32:Klapan(0,&PP);				// подъемник вниз
	if(sh_) goto L101;
	shr[4] = 1;					// активизация режима "Технол. процесс"
	sh[4] = 1;
	goto L101;
L33:if(shr[4]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
L34:if(!(zin[3]&0x20))			// нет форвакуума в шлюзе
	{
		diagn[12] |=0x20 ;		// диагностика "Нет форвакуума в шлюзе"
		goto L101;
	}
	diagn[12] &= (~0x20 );		// сброс диагностики
	sh_ = 0;
	goto L101;
L35:Klapan(0,&KlShl);			// закрыть ФК-Шл
	goto L101;
L36:Klapan(1,&ShZatvor);		// открыть ШЗ
	goto L101;
L37:Klapan(1,&PP);				// подъемник вверх
	goto L101;
L38:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в камеру
	goto L101;
L39:Klapan(0,&PP);				// подъемник вниз
	goto L101;
L40:VIDK_PER(0,0,0,1,10);		// ман. пер. в HOME
	goto L101;
L41:if(!(zin[4]&0x8000))		// пров. налич пластин перед камерой
	{
		diagn[8] |=0x08 ;		// диагностика "Манип. не выгрузил пласт. из камеры"
		goto L101;
	}
	diagn[8] &= (~0x08 );		// сброс диагностики
	sh_ = 0;
	goto L101;
L42:VIDK_POV(0,0,0,1,10);		// ман. пов. в HOME
	goto L101;
L43:if(!(zin[4]&0x4000))		// пров. налич пластин перед кассетой
	{
		diagn[8] |=0x10;		// диагностика "Нет пластины на манип. перед кассетой"
		goto L101;
	}
	diagn[8] &= (~0x10);		// сброс диагностики
	sh_ = 0;
	goto L101;
L44:VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету
	goto L101;
L45:VIDK_KAS(0,OTN,par_t[5],0,10);	// Кассета вверх на h1
	goto L101;
L46:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	goto L101;
L47:if(zin[4]&0x4000)				// есть пластина перед кассетой
	{
		diagn[8] |=0x20;			// диагностика "Манип. не выгрузил пластину в кассету"
		goto L101;
	}
	diagn[8] &= (~0x20);			// сброс диагностики
	if(N_PL < par[N_ST][20])
	{
		sh_ = 0;
		goto L101;
	}
	shr[3] = 48;				// переход на шаг 49
	sh_ = 0;
	goto L101;
L48:VIDK_KAS(0,OTN,par_t[4],0,10);	// кассета вверх на h
	if(sh_) goto L101;
	shr[3] = 15;
	goto L101;					// переход на шаг 16
L49:VIDK_KAS(0,0,0,1,10);		// кассета в HOME
	goto L101;
L50:Klapan(0,&ShZatvor);		// закрыть ШЗ
	if(sh_) goto L101;
	otvet = 0;
	goto L101;
L51:if(!otvet) goto L101;		// ожидание ответа оператора
	if(otvet == 1)
	{
		shr[3] = 2;				// переход на шаг 3
		sh_ = 0;
		goto L101;
	}
	shr[2] = 1;					// активизация режима 2 "Откачка шлюза"
	sh[2] = 1;
	sh_ = 0;
	goto L101;
L52:if(shr[2]) goto L101;		// ожидание конца режима
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_4 ()            // Режим "Технологический процесс"
{
	sh_ = sh[4];
	
	if (shr[4] == 1) goto L1;
	if (shr[4] == 2) goto L2;
	if (shr[4] == 3) goto L3;
	if (shr[4] == 4) goto L4;
	if (shr[4] == 5) goto L5;
	if (shr[4] == 6) goto L6;
	if (shr[4] == 7) goto L7;
	if (shr[4] == 8) goto L8;
	if (shr[4] == 9) goto L9;
	if (shr[4] == 10) goto L10;
	if (shr[4] == 11) goto L11;
    if (shr[4] == 12) goto L12;
    if (shr[4] == 13) goto L13;
    if (shr[4] == 14) goto L14;
    if (shr[4] == 15) goto L15;
    if (shr[4] == 16) goto L16;
    if (shr[4] == 17) goto L17;
    if (shr[4] == 18) goto L18;
    if (shr[4] == 19) goto L19;
    if (shr[4] == 20) goto L20;
    if (shr[4] == 21) goto L21;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[4] = sh_;
	if (sh[4] != 0) goto L100;		// sh_ != 0
	++shr[4];						// след. шаг сч.шр2
	if (shr[4] > 21) goto L0;		// число шагов режима
	sh[4] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 8;						// норма: "Тех.процесс завершен"
	shr[4] = 0;
	goto L100;
	
L1: N_ZICL = 0;
    N_ST=0;
    T_PROC=0;
    if(!(shr[33]))shr[4]=2;
	sh_ = 0;
	goto L101;
L2: for(int i=0;i<24; i++)			// есть задание на всех каналах нагрева
	{
		if((!ObjBPN[i]->vBPN)&&(i!=2)&&(i!=3)&&(i!=4)&&(i!=21)) goto L101;
	}
	sh_ = 0;
	goto L101;					// переход на подшаг 3_1
L3: Klapan(0,&KlD4);			//Закрыть Кл-Д4
	goto L101;
L4: Klapan(0,&KlD2);            //закрыть Кл-Д2
    if(sh_)goto L101;
    if(nasmod[8]==1)
    {
        PR_NALADKA=1;
        goto L101;
    }
    if(nasmod[18])
    {
        otvet=0;
        shr[4]=20;              //переход на шаг 21
        goto L101;
    }
    shr[4]=21;
    goto L21_1;                 //переход на шаг 21_1
L5: if(nasmod[8]==1)goto L101;
    shr[4]=13;
    sh_=0;
    goto L101;
L6: Klapan(1,&ZIP);					// открыть затвор ИП
	if(sh_)goto L101;
    shr[4]=7;
    goto L7_1;                      //переход на шаг 7_1
L7: Klapan(0,&ZIP);					// закрыть затвор ИП
    if(sh_)goto L101;
L7_1:if((par[N_ST][7]==0)&&(shr[29]))
        SBROSR_29();
    if(par[N_ST][0])				// Есть задание на РРГ1
	{
		if(!shr[20])
		{
			shr[20] = 1;
			sh[20]  = 1;			// активизация режима 20
		}
	}
	else
	{
		RRGOff(ObjRRG[0]);			// отключение РРГ1
		ObjRRG[0]->vRRG = 1;
	}
	if(par[N_ST][1])				// Есть задание на РРГ2
	{
		if(!shr[21])
		{
			shr[21] = 1;
			sh[21]  = 1;			// активизация режима 22
		}
	}
	else
	{
		RRGOff(ObjRRG[1]);			// отключение РРГ2
		ObjRRG[1]->vRRG = 1;
	}
	if(par[N_ST][2])				// Есть задание на РРГ3
	{
		if(!shr[22])
		{
			shr[22] = 1;
			sh[22]  = 1;			// активизация режима 22
		}
	}
	else
	{
		RRGOff(ObjRRG[2]);			// отключение РРГ3
		ObjRRG[2]->vRRG = 1;
	}
	if(par[N_ST][3])				// Есть задание на РРГ4
	{
		if(!shr[23])
		{
			shr[23] = 1;
			sh[23]  = 1;			// активизация режима 23
		}
	}
	else
	{
		RRGOff(ObjRRG[3]);			// отключение РРГ4
		ObjRRG[3]->vRRG = 1;
	}
	if(par[N_ST][4])				// Есть задание на РРГ5
	{
		if(!shr[24])
		{
			shr[24] = 1;
			sh[24]  = 1;			// активизация режима 24
		}
	}
	else
	{
		RRGOff(ObjRRG[4]);			// отключение РРГ5
		ObjRRG[4]->vRRG = 1;
	}
	if(par[N_ST][5])				// Есть задание на РРГ6
	{
		if(!shr[25])
		{
			shr[25] = 1;
			sh[25]  = 1;			// активизация режима 25
		}
	}
	else
	{
		RRGOff(ObjRRG[5]);			// отключение РРГ6
		ObjRRG[5]->vRRG = 1;
	}
	if(par[N_ST][6])				// Есть задание на РРГ7
	{
		if(!shr[26])
		{
			shr[26] = 1;
			sh[26]  = 1;			// активизация режима 26
		}
	}
	else
	{
		RRGOff(ObjRRG[6]);			// отключение РРГ7
		ObjRRG[6]->vRRG = 1;
	}
	sh_ = 0;
	goto L101;
L8:if(  (!ObjRRG[0]->vRRG)||
        (!ObjRRG[1]->vRRG)||
        (!ObjRRG[2]->vRRG)||
        (!ObjRRG[3]->vRRG)||
        (!ObjRRG[4]->vRRG)||
        (!ObjRRG[5]->vRRG)||
        (!ObjRRG[6]->vRRG)
    ) goto L101;	// ожидание конца времени процесса
	if(par[N_ST][10])				// есть задание на ДЗ
	{
		if(!shr[17])					// есть активация режима 17
		{
			sh[17]  = 1;
			shr[17] = 1;			// активизация режима 17
			shr[4] = 9;				// переход на шаг 10
			sh_ = 0;
			goto L101;
		}
		shr[4] = 10;
		goto L10_1;					// переход на шаг 10_1
	}
	shr[18] = 1;
	sh[18]  = 1;					// активизвция режима 18 "Открыть ДЗ"
	sh_ = 0;
	goto L101;
L9: if(shr[18]) goto L101;
	shr[4] = 10;						// переход на шаг 8_1
	goto L10_1;
L10:if(!VRDZASL) goto L101;			// ожидание выхода на режим ДЗ
L10_1:if(par[N_ST][7])				// есть зад. по мощности на ВЧГ реактора
	{
		sh[31]  = 1;
		shr[31] = 1;				// активизация режима 31
		sh[32]  = 1;	
		shr[32] = 1;				// активизация режима 32
		sh_ = 0;
		goto L101;
	}
	if(shr[29]) SBROSR_29();
	shr[4] = 12;						// переход на шаг 8_1
	goto L12_1;
L11:if(shr[31]||shr[32]) goto L101;	// ожидание выхода в точку конденсаторов
	shr[29] = 1;
	sh[29]  = 1;					// активизация режима 29
	sh_ = 0;
	goto L101;
L12:if(!VRGIR) goto L101;
    if(diagn[7]&0x08) goto L101;    // есть диагностика "Нет соглас..."
L12_1:CT_4 = 0;
	sh_ = 0;
	goto L101;
L13:if(CT_4 <= par[N_ST][11])		// ожидание конца времени процесса
	{
		T_PROC = CT_4;
		goto L101;
	}
L13_1:N_ST++;
	if(N_ST>N_ST_MAX)
	{

        sh_ = 0;
		goto L101;
	}
	if(par[N_ST][13] == 3000001)
	{
		N_ST++;
        ZN_ST = N_ST;
L13_2:	N_ZICL++;
L13_3:	T_PROC = 0;
		shr[4] = 21;
		goto L21_2;
	}
	if(par[N_ST][13] == 3000002)
	{
		if(par[ZN_ST-1][12] > N_ZICL)
		{
            N_ST = ZN_ST;
			shr[4] = 11;
			goto L13_2;
		}
        ZN_ST = 0;
		shr[4] = 13;
		goto L13_1;
	}
	if(par[N_ST][11])
	{
		shr[4] = 13;
		goto L13_3;
	}
	sh_ = 0;
	goto L101;
L14:T_PROC=0;
    SBROSR_29();
    shr[20]=0;

    shr[21]=0;
    shr[22]=0;
    shr[23]=0;
    shr[24]=0;
    shr[25]=0;
    shr[26]=0;
    RRGOff(ObjRRG[0]);
    RRGOff(ObjRRG[1]);
    RRGOff(ObjRRG[2]);
    RRGOff(ObjRRG[3]);
    RRGOff(ObjRRG[4]);
    RRGOff(ObjRRG[5]);
    RRGOff(ObjRRG[6]);
    SetOut(0,2,0xFFFF);
    SetOut(0,3,0xFFFE);
    SetOut(1,3,0x01);
    if(shr[8])
    {
        shr[4]=20;
        goto L20_1;
    }
    sh_=0;
    goto L101;
L15:Klapan(1,&ZIP);					// открыть затвор ИП
	if(sh_)goto L101;
    shr[18]=1;
    goto L101;
L16:if(shr[18])goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L17:if(CT_4/1000>nasmod[14])sh_=0;
    goto L101;
L18:Klapan(1,&KlD4);
    goto L101;
L19:Klapan(1,&KlD2);
    goto L101;
L20:if(diagnS[0]&0x08)			// пока нет связи с D4
		goto L101;
	if(D_D4 >= nasmod[7])
        goto L101;
L20_1:N_ST=0;
    T_PROC=0;
    N_ZICL=0;
    PR_NALADKA=0;
    sh_=0;
    shr[4]=21;          //выход
    goto L101;
L21:if(otvet==0)
        goto L101;
L21_1:N_ST=1;
L21_2:UPR_Klapan(par[N_ST][13]);
    if(out[4]&0x2000)
    {
        shr[4]=5;           //переход на шаг 6
        sh_=0;
        goto L101;
    }
    shr[4]=6;               //переход на шаг 7
    sh_=0;
    goto L101;

}
//---------------------------------------------------------------------------
void R_5()            // Режим "Сброс РЦ"
{
	sh_ = sh[5];
	
	if (shr[5] == 1) goto L1;
	if (shr[5] == 2) goto L2;
	if (shr[5] == 3) goto L3;
	if (shr[5] == 4) goto L4;
	if (shr[5] == 5) goto L5;
	if (shr[5] == 6) goto L6;
	goto L100;				// выход
		
	// конечный диспетчер режима
L101:sh[5] = sh_;
	if (sh[5] != 0) goto L100;		// sh_ != 0
	++shr[5];						// след. шаг сч.шр2
	if (shr[5] > 6) goto L0;		// число шагов режима
	sh[5] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 4;						// норма: "Сброс РЦ завершен"
	shr[5] = 0;
	goto L100;	
	
L1: prDvijGir_g = 0;
	prDvijGir_t = 0;
	shr[31] = 0;					// сброс режима 31
	sh[31] = 0;
	shr[32] = 0;					// сброс режима 32
	sh[32] = 0;
	SetOut(0,1,0x3C00);				// сброс направлений ИП
	A_OUT(9,8192);					// сброс скоростей ИП
	A_OUT(10,8192);
    if((!PR_PER)&&(!PR_POV)&&(!PR_KAS))	// нет движения манипулятора
	{
		shr[5] = 4;
		sh_ = 1;
		goto L4_1;				 // переход на шаг 4_1
	}
	CT_5 = 0;
	sh_ = 0;
	goto L101;	
L2: if(PR_PER)						// пока ман. перем. движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[14] |= 0x80;			// отказ: "Отказ манипулятора перем."
        shr[5] = 4;
		sh_ = 1;
		PR_PER = 0;
		PR_POV = 0;
		PR_KAS = 0;
		goto L4_1;				// переход на шаг 4_1
	}
    sh_ = 0;
    goto L101;
L3:if(PR_POV)						// пока ман. пов. движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[20] |= 0x04;			// отказ: "Отказ манипулятора пов."
        shr[5] = 4;
		sh_ = 1;
		PR_PER = 0;
		PR_POV = 0;
		PR_KAS = 0;
		goto L4_1;				// переход на шаг 4_1
	}
    sh_ = 0;
    goto L101;
L4:if(PR_KAS)						// пока ман. кас. движется
	{
		if(CT_5 < T_DVIJ) goto L101;
		diagn[20] |= 0x08;			// отказ: "Отказ манипулятора кас."
        shr[5] = 4;
		sh_ = 1;
        PR_PER = 0;
		PR_POV = 0;
		PR_KAS = 0;
		goto L4_1;				// переход на шаг 4_1
	}
L4_1:SBROS_MEH();					// "Стоп механизма"
	SetOut(0,4,0xC08);				// закрыть Кл-Нап1, Кл-Нап2, Кл-Нап3
	SetOut(0,1,0x8010);				// откл. звуковую сигнализацию

	zshr3 = shr[3];
	shr[3] = 0;					// сброс активиз. режима 3
	sh[3] = 0;				       	// "РЦ"
	shr[2] = 0;					// сброс активиз. режима 2
	sh[2] = 0;					// "Откл. Шл"
	shr[1] = 0;					// сброс активиз. режима 1
	sh[1] = 0;					// "Откачки Кам."
	for(int i=0;i<DIAGN_COUNT;i++)
        {
            if(i==20)diagn[i]&=(~0xF3);
            else if((i != 14)&&(i != 24)&&(i != 28)) diagn[i] = 0;// сброс диагностик кроме аварийных
        }
	if((zshr3>0)&&(zshr3<=2))
	{
		shr[5] = 6;					
		sh_ = 0;					// ВЫХОД
		goto L101;
	}
	if(shr[4])
	{
		shr[4]	=14;				//активизация режима 4 "Технолог. процесс"
		sh[4]	=1;					//на шаге 14
		N_ST	=0;
		sh_		=0;
		goto L101;
	}
	shr[5]	=5;						//переход на шаг 5_1
	sh_	=1;
	goto L5_1;
L5:	if(shr[4])goto L101;			//ожидание конца режима 4 "Технолог. процесс "
L5_1:if((PR_KLASTER)||(shr[8]))goto L0;
	shr[6]	=1;						//активиз. режима 6
	sh[6]	=1;						//"сбор(выгрузка) пластин"
	sh_=0;
	goto L101;
L6:	if(shr[6]) goto L101;			// ожидание конца режима
	sh_=0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_6()            // Режим "Сбор/выгрузка пластин"
{
	sh_ = sh[6];
	
	if (shr[6] < 1 || shr[6] > 30) goto L100;
	if (shr[6] < 10) goto L00;
	if (shr[6] < 20) goto L01;
	else goto L02;
	
L00:if (shr[6] == 1) goto L1;
	if (shr[6] == 2) goto L2;
	if (shr[6] == 3) goto L3;
	if (shr[6] == 4) goto L4;
	if (shr[6] == 5) goto L5;
	if (shr[6] == 6) goto L6;
	if (shr[6] == 7) goto L7;
	if (shr[6] == 8) goto L8;
	if (shr[6] == 9) goto L9;
L01:if (shr[6] == 10) goto L10;
	if (shr[6] == 11) goto L11;
	if (shr[6] == 12) goto L12;
	if (shr[6] == 13) goto L13;
	if (shr[6] == 14) goto L14;
	if (shr[6] == 15) goto L15;
	if (shr[6] == 16) goto L16;
	if (shr[6] == 17) goto L17;
	if (shr[6] == 18) goto L18;
	if (shr[6] == 19) goto L19;
L02:if (shr[6] == 20) goto L20;
	if (shr[6] == 21) goto L21;
	if (shr[6] == 22) goto L22;
	if (shr[6] == 23) goto L23;
	if (shr[6] == 24) goto L24;
	if (shr[6] == 25) goto L25;
	if (shr[6] == 26) goto L26;
	if (shr[6] == 27) goto L27;
	if (shr[6] == 28) goto L28;
    if (shr[6] == 29) goto L29;
    if (shr[6] == 30) goto L30;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[6] = sh_;
	if (sh[6] != 0) goto L100;			// sh_ != 0
	++shr[6];							// след. шаг сч.шр1
	if (shr[6] > 30) goto L0;			// число шагов режима
	sh[6] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma = 11;							// норма: "Сбор пластин завершен"
	shr[6] = 0;
	goto L100;
L1: SetOut(0,2,0xFFFF);
    SetOut(0,3,0xFFFE);					// закрыть VP1-VP22,VP24-VP29,VP39-VP41
	SetOut(1,3,0x01);					// закрыть VP23
    SetOut(0,4,0xC08);                       //Закрыть Кл-Нап 1-3
    sh_=0;
    goto L101;
L2: Klapan(1,&ZIP);					// открыть затвор ИП
    goto L101;
L3:	Klapan(1,&KlD2);					// открыть Кл-Д2
	goto L101;
L4: Klapan(1,&KlD4);					// Открыть Кл-Д4
	if(sh_) goto L101;
	if(zin[4]&0x200)					// МАН пер. в HOME?
	{
		shr[6] = 5;						// Переход на шаг 3_1
		sh_ = 1;
		goto L5_1;
	}
	goto L101;
L5: VIDK_PER(0,0,0,1,10);				// МАН пер. в HOME
	if(sh_) goto L101;
L5_1:if(zin[4]&0x1000)					// МАН пов. в HOME?
	{
		shr[6] = 6;						// переход на шаг 4_1
		sh_ = 1;
		goto L6_1;
	}
    sh_ = 0;
	goto L101;
L6:	VIDK_POV(0,0,0,1,10);				// МАН пов. в HOME
	if(sh_) goto L101;
L6_1:if(zin[4]&0x4000)					// проверка нал. пл. перед кам.
	{
		shr[6] = 15;					// переход на шаг 16
		sh_ = 0;
		goto L101;
	}
	if(shr[5])							// есть активиз. режима 5 "Сброс РЦ"
	{
		if((27>zshr3)||(zshr3>39))		// Пл в кам.
		{
			sh_ = 0;
			goto L101;
		}
	}
	shr[10] = 1;						// активиз. режима 10
	sh[10] = 1;							// "открыть ЩЗ"
	sh_ = 0;
    shr[6]=7;                           //переход на шаг 8
	goto L101;
L7:Klapan(0,&ShZatvor);	 			// Закрыть ЩЗ
	if(sh_)goto L101;
	shr[6]=19;
	goto L101;
L8: if(shr[10]) goto L101;				// ожид. конца режима
	sh_ = 0;
	goto L101;
L9: sh_=0;
	goto L101;
L10: Klapan(1,&PP);						// подъемник вверх
	goto L101;
L11:VIDK_POV(0,ABS,par_t[3],0,10);		// МАН пов. к кам.
	goto L101;
L12:VIDK_PER(0,ABS,par_t[2],0,10);		// ман. перем. в кам.
	goto L101;
L13:Klapan(0,&PP);						// подъемник вниз
	goto L101;
L14:VIDK_PER(0,0,0,1,10);				// ман. пер. в HOME
	if(sh_)goto L101;
	if(!(zin[4]&0x8000))				// проверка нал. пл. перед кам.
	{
		diagn[8]|=0x40;					//отказ:"Нет пластины в камере и на манипуляторе"	
		shr[6]	=19;
		sh_		=0;
		goto L101;
	}
	sh_	=0;
	goto L101;
L15:VIDK_POV(0,0,0,1,10);				// МАН пов. в HOME
    if(sh_)goto L101;
	if(!(zin[4]&0x4000))
	{
		diagn[8]|=0x10;					// отказ "Нет пластины на манипуляторе перед кассетой"
		shr[6]	=19;
		goto L101;
	}
	sh_	=0;
	goto L101;
L16:if(!KasVPaze())
	{
		diagn[8]|=0x80;					// отказ:"Кассета не в положении загрузки - выгрузки"
		shr[6] = 19;
		sh_ = 0;
		goto L101;
	}
	sh_ = 0;
	goto L101;
L17:VIDK_PER(0,ABS,par_t[1],0,10);		// МАН перемещ. в кассету
	goto L101;	
L18:VIDK_KAS(0,OTN,par_t[5],0,10);		// Кассета вверх на h1
	goto L101;
L19:VIDK_PER(0,0,0,1,10);				// МАН перемещения в HOME
	if(sh_) goto L101;
	if(zin[4]&0x4000)diagn[8]|=0x20;	// Проверка отсутствия пластины перед кассетой 									
	sh_ = 0;							// отказ:"Манип. не выгрузил пласт. в кассету"
	goto L101;
L20:VIDK_KAS(0,0,0,1,15);				// Кассета в HOME
	goto L101;
L21:Klapan(0,&ShZatvor);	 			// Закрыть ЩЗ
	goto L101;
L22:Klapan(0,&KlShl);					// Закрыть ФК-Шл
	if(sh_) goto L101;
	CT_6	=0;
	SetOut(1,4,0x08);					// Открыть Кл-Нап2
	goto L101;
L23:if(diagnS[0]&0x01)					// пока нет связи с D1
		goto L101;
	if(D_D1 <= UVAK_SHL_MN) goto L101;	// Проверка вак. в шлюзе(НАПУСК в шлюз для охлаждения)
	SetOut(1,4,0x800);					// Открыть Кл-Нап3
	sh_=0;
	goto L101;
L24:if(zin[3]&0x4000)
	{
		if(CT_6>=T_KNAP) diagn[12]|=0x08;//отказ "Медленный напуск в шлюз"
		goto L101;
	}
	diagn[12] &= (~0x08);				// сброс диагностики
	SetOut(0,4,0x808);					// Закрыть Кл-НАП2,Кл-НАП3
	CT_6=0;
	SetOut(1,1,0x10);					// включить звонок
	sh_=0;
	goto L101;
L25:if(CT_6<=3)goto L101;
	SetOut(0,1,0x10);					// отключить звонок
	otvet=0;
	sh_=0;
	goto L101;
L26:if(!otvet)goto L101;				// нет ответа оператора
	if(otvet==1)
	{
		sh_=0;
		goto L101;
	}
	shr[6]=28;							// переход в шаг 29
	sh_=0;
	goto L101;
L27:if(!(zin[3]&0x4000))goto L101;		//дверь шлюза закрыта
	shr[2]=1;							//активиз. режима 2
	sh[2]=1;							// "Откачка шлюза"
	sh_=0;
	goto L101;
L28:if(!shr[2])sh_=0;
	goto L101;
L29:Klapan(0,&KlShl);					// Закрыть ФК-Шл
	goto L101;
L30:Klapan(0,&FvnShl);					// отключить ФВН шлюза
	goto L101;
								//	Выход

}
//---------------------------------------------------------------------------
void R_7 ()							// Режим "Отключение установки"
{
	sh_ = sh[7];

	if (shr[7] == 1) goto L1;
	if (shr[7] == 2) goto L2;
	if (shr[7] == 3) goto L3;
	if (shr[7] == 4) goto L4;
	if (shr[7] == 5) goto L5;
	if (shr[7] == 6) goto L6;
	if (shr[7] == 7) goto L7;
	if (shr[7] == 8) goto L8;
	if (shr[7] == 9) goto L9;
	if (shr[7] == 10) goto L10;
	if (shr[7] == 11) goto L11;
	if (shr[7] == 12) goto L12;
	if (shr[7] == 13) goto L13;
	if (shr[7] == 14) goto L14;
	if (shr[7] == 15) goto L15;
	if (shr[7] == 16) goto L16;
	if (shr[7] == 17) goto L17;
	if (shr[7] == 18) goto L18;
    if (shr[7] == 19) goto L19;
    if (shr[7] == 20) goto L20;
    if (shr[7] == 21) goto L21;
	else goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[7] = sh_;
	if (sh[7] != 0) goto L100;		// SH != 0
	++shr[7];						// след. шаг сч.шр5
	if (shr[7] > 21) goto L0;		// число шагов режима
	sh[7] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 6;						// норма: "Отключение установки завершено"
	shr[7] = 0;
	goto L100;

L1: SetOut(0,2,0xFFFF);				// закрыть VP1,VP2,...,VP15
	SetOut(0,3,0xFFFE);				// закрыть VP16,VP17,...,VP29,VP39-VP41(кроме VP23)
	SetOut(0,3,0x01);				// закрыть VP23
	SetOut(0,4,0xC08);				// закрыть Кл-Нап1, Кл-Нап2
    sh_ = 0;
	goto L101;
//L2: Klapan(0,&ZIP);					// Закрыть клапан ИП
L2: Klapan(1,&ZIP);					// ОТКРЫТЬ клапан ИП
	goto L101;
    //SetOut(0,4,0x100);				// снять разрешение работы CX-600
L3: ORR_GIR();							// снять р/р ВЧГ ип
	if(sh_)goto L101;
    if(PR_KLASTER)
    {
        shr[7]=9;
        goto L101;
    }
	if(!(zin[4]&0x200))				// манип. перем. в исх.
        goto L101;
	shr[7] = 4;					// переход на шаг 4
    goto L4_1;
L4: VIDK_PER(0,0,0,1,10);			// перемещение манип. в исх.
	if(sh_)goto L101;
L4_1:if(!(zin[4]&0x1000))
        goto L101;
    shr[7]=5;
    goto L5_1;
L5: VIDK_POV(0,0,0,1,10);			// поворот манип. в исх.
	if(sh_)goto L101;
L5_1:if(zin[4]&0x40)
        shr[7]=6;
    sh_=0;
    goto L101;
L6: VIDK_KAS(0,0,0,1,10); 				// кассета в HOME
    goto L101;
L7: Klapan(0,&KlShl);				// закрыть ФК-Шл
	goto L101;
L8: Klapan(0,&FvnShl);		// отключить ФВН-Шл
	goto L101;
L9: Klapan(0,&ShZatvor);			// закрыть щелевой затвор
	goto L101;
L10: Klapan(0,&PP);					// подъемник пластин вниз
	goto L101;
L11:Klapan(0,&KlKam);				// закрыть ФК-Кам
	goto L101;
L12: Klapan(0,&DZasl);				// закрыть ДЗ
	goto L101;
L13: Klapan(0,&Zatvor);				// закрыть затвор
	if(sh_) goto L101;
	if(!(zin[2]&0x1C00))			// нет вращение ТМН
	{
		shr[7] = 16;				// переход на шаг 17
		goto L101;
	}
	goto L101;
L14:Klapan(1,&KlTmn);				// открыть ФК-Тмн
	if(sh_) goto L101;
	SetOut(0,4,0x40);				// снять сигнал "Старт ТМН"
	CT_7 = 0;
	goto L101;
L15:if(CT_7 <= 5) goto L101;		// задержка 5 сек
	sh_ = 0;
	goto L101;
L16:if(zin[2]&0x1C00)				// есть вращение ТМН
		goto L101;
	sh_ = 0;
	goto L101;
L17:Klapan(0,&KlTmn);		// закрыть ФК-Тмн
	goto L101;
L18:Klapan(0,&FvnKam);		// отключить ФВН-Кам
	goto L101;
L19:Klapan(0,&KlD4);		// закрыть Кл-Д4
	goto L101;
L20:Klapan(0,&KlD2);		// закрыть Кл-Д2
	if(sh_) goto L101;
	if(shr[33])				// режим 33 активирован
	{
		shr[34] = 1;		// активизация режима 34 "откл. нагр. установки"
		sh[34] = 1;
	}
	goto L101;
L21:if(shr[34]) goto L101;	// ожидание режима 34 "откл. нагр. установки"
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_8 ()							// Режим "Аварийное отключение установки"
{
	sh_ = sh[8];

	if (shr[8] == 1) goto L1;
	if (shr[8] == 2) goto L2;
	if (shr[8] == 3) goto L3;
	if (shr[8] == 4) goto L4;
	if (shr[8] == 5) goto L5;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[8] = sh_;
	if (sh[8] != 0) goto L100;		// SH != 0
	++shr[8];						// след. шаг сч.шр5
	if (shr[8] > 5) goto L0;		// число шагов режима
	sh[8] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 9;						// норма: "Авар. откл. установки завершено"
	shr[8] = 0;
	goto L100;

L1: if(shr[5])						// есть активизация режима 5 "Сброс РЦ"
	{
		shr[8] = 3;					// переход на шаг 4
		sh_ = 0;
		goto L101;
	}
	if((shr[3])||(shr[4]))
	{
		sh[5] = 1;					// активизация режима 5 "Сброс РЦ"
		shr[5]  = 1;
		shr[8] = 3;					// переход на шаг 4
		sh_ = 0;
		goto L101;
	}
    SBROSR_29();
    RRGOff(ObjRRG[0]);				// отключение РРГ1
	RRGOff(ObjRRG[1]);				// отключение РРГ2
    RRGOff(ObjRRG[2]);				// отключение РРГ3
	RRGOff(ObjRRG[3]);				// отключение РРГ4
	RRGOff(ObjRRG[4]);				// отключение РРГ5
    RRGOff(ObjRRG[5]);				// отключение РРГ6
	RRGOff(ObjRRG[6]);				// отключение РРГ7
	SetOut(0,2,0xFFFF);				// закрыть VP1,VP2,...,VP15
	SetOut(0,3,0xFFFE);				// закрыть VP16,VP17,...,VP29,VP39-VP41(кроме VP23)
    sh_=0;
    goto L101;
L2: Klapan(0,&Zatvor);				// закрыть затвор
	if(sh_) goto L101;
	shr[19] = 1;
	sh[19]  = 1;					// активизация режима 19 "Закрыть ДЗ"
	sh_ = 0;
	goto L101;
L3: if(shr[19]) goto L101;			// ожидание конца режима "ЗАкрыть ДЗ"
	sh[1] = 0;						// сброс режимов
	shr[1] = 0;
	sh[2] = 0;
	shr[2] = 0;
	sh[6] = 0;
	shr[6] = 0;
	sh[9] = 0;
	shr[9] = 0;
	sh[10] = 0;
	shr[10] = 0;
	sh[11] = 0;
	shr[11] = 0;
	SBROS_MEH();					// сброс механизмов
	goto L4_1;	
L4: if(shr[5]) goto L101;			// ожидание конца режима "Сброс РЦ"
L4_1:if(shr[7]) 					// есть активация режима "отключение установки"
	{
		shr[8] = 4;					// переход на шаг 5
		sh_ = 0;
		goto L101;
	}
	sh[7]  = 1;
	shr[7] = 1;						// активация режима 7 "Откл. установки"
	sh_ = 0;
	goto L101;
L5: if(shr[7]) goto L101;			// ожидание конца режима "отключение установки"
	sh_ = 0;
	goto L101;
}
//---------------------------------------------------------------------------
void R_9 ()							// Режим "Транспортный тест"
{
	sh_ = sh[9];
	
	if (shr[9] < 1 || shr[9] > 36) goto L100;
	if (shr[9] < 10) goto L00;
	if (shr[9] < 20) goto L01;
	if (shr[9] < 30) goto L02;
	else goto L03;
	
L00:if (shr[9] == 1) goto L1;
	if (shr[9] == 2) goto L2;
	if (shr[9] == 3) goto L3;
	if (shr[9] == 4) goto L4;
	if (shr[9] == 5) goto L5;
	if (shr[9] == 6) goto L6;
	if (shr[9] == 7) goto L7;
	if (shr[9] == 8) goto L8;
	if (shr[9] == 9) goto L9;
L01:if (shr[9] == 10) goto L10;
	if (shr[9] == 11) goto L11;
	if (shr[9] == 12) goto L12;
	if (shr[9] == 13) goto L13;
	if (shr[9] == 14) goto L14;
	if (shr[9] == 15) goto L15;
	if (shr[9] == 16) goto L16;
	if (shr[9] == 17) goto L17;
	if (shr[9] == 18) goto L18;
	if (shr[9] == 19) goto L19;
L02:if (shr[9] == 20) goto L20;
	if (shr[9] == 21) goto L21;
	if (shr[9] == 22) goto L22;
	if (shr[9] == 23) goto L23;
	if (shr[9] == 24) goto L24;
	if (shr[9] == 25) goto L25;
	if (shr[9] == 26) goto L26;
	if (shr[9] == 27) goto L27;
	if (shr[9] == 28) goto L28;
	if (shr[9] == 29) goto L29;
L03:if (shr[9] == 30) goto L30;
	if (shr[9] == 31) goto L31;
	if (shr[9] == 32) goto L32;
	if (shr[9] == 33) goto L33;
	if (shr[9] == 34) goto L34;
	if (shr[9] == 35) goto L35;
	if (shr[9] == 36) goto L36;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[9] = sh_;
	if (sh[9] != 0) goto L100;	// sh_ != 0
	++shr[9];					// след. шаг сч.шр1
	if (shr[9] > 36) goto L0;	// число шагов режима
	sh[9] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 10;					// норма: "Транспортный тест завершен"
	shr[9] = 0;
	goto L100;
L1: PR_TRTEST = 0;					// непрерывный цикл
	N_PL = 0;
	sh_ = 0;
	goto L101;	
L2: sh_=0;
	goto L101;
L3: Klapan(0,&PP);					// механизм подъёмника вниз
	goto L101;
L4: sh_=0;
	goto L101;
L5:	VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету 
	goto L101;
L6:	VIDK_KAS(0,OTN,-par_t[5],0,10);	// кассета вниз на(h1)
	goto L101;
L7:	VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_)goto L101;
	if(!(nasmod[17])) 				// тр. тест с пластиной
	{
		shr[9] = 8;				// переход на шаг 8_1
		sh_	=1;
		goto L8_1;
	}
	goto L101;
L8:	if(!(zin[4]&0x4000))			// проверка нал. пл. перед кам.
	{
		diagn[8] |= 0x01;			// отказ: "Ман. не взял пластину из кассеты"
		goto L101;		
	}
	diagn[8] &= (~0x01);			// сброс диагностик МАН перемещения
L8_1:N_PL++;
	shr[9]=11;
	sh_=0;
	goto L101;
L9: sh_=0;
	goto L101;
L10: sh_=0;
	goto L101;
L11: sh_=0;
	goto L101;
L12:VIDK_POV(0,ABS,par_t[3],0,10);	// ман. пов. к камере
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9]=13;		//транспортный тест с пластиной // переход на шаг 14
	goto L101;
L13:if(!(zin[4]&0x8000))			// проверка нал. пл. перед кам.
	{
		diagn[8] |= 0x02;			// отказ: "Нет пластины в манипуляторе перед камерой"
		goto L101;		
	}
	diagn[8] &= (~0x02);			// сброс диагностик МАН перемещения	
	sh_	=0;
	goto L101;
L14:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в камеру
	goto L101;
L15:Klapan(1,&PP);					// подъемник вверх
	goto L101;
L16:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9]=17;		//транспортный тест с пластиной // переход на шаг 18
	goto L101;
L17:if(zin[4]&0x8000)			// проверка нал. пл. перед кам.
	{
		diagn[8] |= 0x04;			// отказ: "Манипулятор не загрузил пластину в камеру"
		goto L101;		
	}
	diagn[8] &= (~0x04);			// сброс диагностик МАН перемещения	
	sh_	=0;
	goto L101;
L18:Klapan(0,&PP);						// подъёмник вниз
	if(sh_) goto L101;
	CT_9=0;
	goto L101;
L19:if(CT_9<=5)goto L101;			//задержка
	sh_=0;
	goto L101;
L20:sh_=0;
	goto L101;
L21:sh_ = 0;
	goto L101;
L22:sh_=0;
	goto L101;
L23:Klapan(1,&PP);					// подъемник вверх
	goto L101;
L24:VIDK_PER(0,ABS,par_t[2],0,10);	// ман. пер. в кам.
	goto L101;	
L25:Klapan(0,&PP);					// подъемник вниз
	goto L101;
L26:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9] = 27;	// тр. тест с пластиной// переход на шаг 28
	sh_=0;
	goto L101;
L27:if(!(zin[4]&0x8000))
	{
		diagn[8] |= 0x08;			// отказ: "Ман. не выгр. пластину из кам."
		goto L101;
	}
	diagn[8] &= (~0x08);			// сброс диагностик МАН
	sh_ = 0;
	goto L101;
L28:VIDK_POV(0,0,0,1,10);			// ман. пов. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))shr[9] = 29;	// тр. тест с пластиной// переход на 30 шаг
	goto L101;
L29:if(!(zin[4]&0x4000))				// проверка отсутств. пласт. перед касс.
	{
		diagn[8] |= 0x10;			// отказ: "Нет пластины на манипулятор перед кассетой"
		goto L101;		
	}
	diagn[8] &= (~0x10);			// сброс диагностик МАН перемещения
	sh_ = 0;
	goto L101;
L30:VIDK_PER(0,ABS,par_t[1],0,10);	// ман. пер. в кассету 
	goto L101;
L31:VIDK_KAS(0,OTN,par_t[5],0,10);	// перем. кас. вверх на (h1).
	goto L101;
L32:VIDK_PER(0,0,0,1,10);			// ман. пер. в HOME
	if(sh_) goto L101;
	if(!(nasmod[17]))				// тр. тест с пластиной
	{
		shr[9] = 33;				// переход на 33_1 шаг
		sh_ = 1;
		goto L33_1;
	}
	goto L101;
L33:if((zin[4]&0x4000))				// проверка нал. пл. перед касс.
	{
		diagn[8] |= 0x20;			// отказ: "Ман. не выгр. пл. в кас."
		goto L101;		
	}
	diagn[8] &= (~0x20);			// сброс диагностик МАН перемещения
L33_1:if((N_PL<par[N_ST][20])&&(!PR_TRTEST))
	{
		CT_9=0;
		sh_=0;
		goto L101;
	}
	shr[9]=35;
	sh_=0;
	goto L101;
L34:if(!(CT_9<=5))sh_=0;
	goto L101;
L35:VIDK_KAS(0,OTN,par_t[4],0,10);	// кас. вверх на h1 отн.
	if(sh_) goto L101;
	sh_=0;
	shr[9]=4;
	goto L101;
L36:VIDK_KAS(0,0,0,1,10); 			// кассета в HOME
	if(sh_) goto L101;
	goto L0;
}
//---------------------------------------------------------------------------
void R_10 ()							// Режим "Открыть ЩЗ"
{
	sh_ = sh[10];

	if (shr[10] < 1 || shr[10] > 18) goto L100;
	if (shr[10] < 10) goto L00;
	goto L01;

L00:if (shr[10] == 1) goto L1;
	if (shr[10] == 2) goto L2;
	if (shr[10] == 3) goto L3;
	if (shr[10] == 4) goto L4;
	if (shr[10] == 5) goto L5;
	if (shr[10] == 6) goto L6;
	if (shr[10] == 7) goto L7;
	if (shr[10] == 8) goto L8;
	if (shr[10] == 9) goto L9;
L01:if (shr[10] == 10) goto L10;
	if (shr[10] == 11) goto L11;
	if (shr[10] == 12) goto L12;
	if (shr[10] == 13) goto L13;
	if (shr[10] == 14) goto L14;
	if (shr[10] == 15) goto L15;
	if (shr[10] == 16) goto L16;
	if (shr[10] == 17) goto L17;
	if (shr[10] == 18) goto L18;

	// конечный диспетчер режима
L101:sh[10] = sh_;
	if (sh[10] != 0) goto L100;		// SH != 0
	++shr[10];						// след. шаг сч.шр5
	if (shr[10] > 18) goto L0;		// число шагов режима
	sh[10] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 25;						// норма: "Щелевой затвор открылся"
	shr[10] = 0;
	goto L100;

L1: shr[11] = 0;					// сброс активизации режима 11
	sh[11] = 0;
	diagn[9] &= (~0x0F);			// сброс диагностик ЩЗ
	sh_ = 0;
	goto L101;
L2:	if((zin[1] & 0x0C) == 0x04)		// ЩЗ открыт
	{
		diagn[9] &= (~0x04);		// сброс диагностики
		shr[10] = 18;				// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	if((zin[1] & 0x0C) == 0x08)		// ЩЗ закрыт
	{
		diagn[9] &= (~0x04);		// сброс диагностики
		sh_ = 0;
		goto L101;
	}
	diagn[9] |= 0x04;				// диагностика "Положение щелевого затвора не определено"
	goto L101;
L3:	Klapan(1,&KlD4);				// открыть Кл-Д4
	goto L101;
L4:	Klapan(1,&KlD2);				// открыть Кл-Д2
	goto L101;
L5:	if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if(D_D4 > UATM_D4 )				// проверка уровня вакуума в камере
	{
		sh_ = 0;
		goto L101;
	}
	shr[10] = 7;					// переход на 8 шаг
	sh_ = 0;
	goto L101;
L6:
	if(!(zin[3]&0x4000))				// Дверь шлюза открыта
	{
		SetOut(0,4,0x808);			// закрыть Кл-НАП2-3
		shr[10] = 17;				// на шаг 18
		sh_ = 0;
		goto L101;
	}
	sh_ = 0;
	goto L101;
L7:	Klapan(0,&KlShl);				// закрыть Кл-Шл
	if(sh_) goto L101;
	SetOut(1,4,0x800);				// открыть Кл-НАП3
	shr[10] = 5;					// возврат на шаг 6
	goto L101;
L8:	if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
	if(D_D4 > UVAKN_KAM)            // проверка уровня вакуума в камере
	{
		SetOut(0,4,0x400);			// закрыть Кл-НАП1
        SetOut(0,2,0x9800);         // закрыть VP14 и VP 15 и VP39
        SetOut(0,3,0xC00A);           // закрыть VP18 и VP 19, VP40-VP41
        SetOut(1,3,0x01);           // закрыть VP23
		sh_ = 0;
		goto L101;
	}
	shr[10] = 12;					// переход на шаг 13
	sh_ = 0;
	goto L101;
L9:	Klapan(0,&KlTmn);				// закрыть Кл-ТМН
	goto L101;
L10:Klapan(1,&FvnKam);				// включить ФВН-Кам
	goto L101;
L11:Klapan(1,&KlKam);				// открыть Кл-КАМ
	goto L101;
L12:Klapan(1,&DZasl);				// открыть ДЗ
	if(sh_) goto L101;
	shr[10] = 7;					// возврат на шаг 8
	goto L101;
L13:if(!(zin[3]&0x20))					// нет форвакуума в шлюзе
	{
		shr[2] = 1;					// активизация режима 2
		sh[2] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[10] = 14;					// переход на шаг 15
	sh_ = 0;
	goto L101;
L14:if(shr[2]) goto L101;			// ожидание конца режима
	sh_ = 0;
	goto L101;
L15:Klapan(0,&KlShl);				// закрыть Кл-Шл
	if(sh_) goto L101;
	if(zin[2]&0x1C00)				// есть вращение ТМН
		goto L101;
	shr[10] = 17;					// переход на шаг 18
	goto L101;
L16:Klapan(0,&KlKam);				// закрыть ФК-Кам
	goto L101;
L17:Klapan(1,&KlTmn);				// открыть Кл-ТМН
	goto L101;
L18:Klapan(1,&ShZatvor);			// открыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_11()							// Режим "Закрыть ЩЗ"
{
	sh_ = sh[11];

	if (shr[11] == 1) goto L1;
	if (shr[11] == 2) goto L2;
		else goto L100;				// выход

	// конечный диспетчер режима
L101:sh[11] = sh_;
	if (sh[11] != 0) goto L100;		// SH != 0
	++shr[11];						// след. шаг
	if (shr[11] > 2) goto L0;		// число шагов режима
	sh[11] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 26;						// норма: "Щелевой затвор закрылся"
	shr[11] = 0;
	goto L100;

L1:	shr[10] = 0;					// сброс активизации режима 10
	sh[10] = 0;
	diagn[15] &= (~0xF0);			// сброс диагностик ФВН
	diagn[10] &= (~0xFF);			// ФК-КАМ, ФК-Шл
	diagn[9] &= (~0xFF);			// щелевого затвора, ФК-ТМН
	diagn[6] &= (~0xFF);			// Кл-Д4, Кл-Д2
    diagn[12] &= (~0x40);           //дверь шлюза не закрыта
	sh_ = 0;
	goto L101;
L2:	Klapan(0,&ShZatvor);			// закрыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_12() // режим 12 "МАН в исходное"
{
	sh_ = sh[12];
	if((shr[12] < 1) || (shr[12] > 2)) goto L100; // на выход

L00:if(shr[12] == 1) goto L1;
	if(shr[12] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[12] = sh_;
	if (sh[12] != 0) goto L100;		// SH != 0
	shr[12]++;						// след.шаг
	if (shr[12] > 2) goto L0;		// число шагов режима
	sh[12] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 43;						// норма: "Мех. перем. в исходном"
	shr[12] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[13] = 0;							// сброс активации режима 13
	shr[13] = 0;
	diagn[5] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PER(par[0][16],0,0,1,60);				// перемещение манип. в исх.
	goto L101;
}
//----------------------------------------------------------------------------
void R_13() // режим 13 "МАН вперёд/назад"
{
	sh_ = sh[13];
	if ((shr[13] < 1) || (shr[13] > 2)) goto L100; // на выход

L00:if(shr[13] == 1) goto L1;
	if(shr[13] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[13] = sh_;
	if(sh[13] != 0) goto L100;		// SH != 0
	shr[13]++;						// след.шаг
	if(shr[13] > 2) goto L0;		// число шагов режима
	sh[13] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 44;						// норма: "Механизм. перемещения путь прошел"
	shr[13] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[12] = 0;							// сброс активации режима 12
	shr[12] = 0;
	diagn[5] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_PER(par[0][16],OTN,par[0][15],0,60);// перемещение манип. вперед/назад
	goto L101;
}

//----------------------------------------------------------------------------
void VIDK_PER(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x01) return;		// нет связи с контроллером
	SetOut(0,1,0x02);				// снять Стоп механизмов
	PR_PER = 1;
	CT_PER = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x100))				// нет готовности привода
	{
		if(CT_PER >= 5)
			diagn[5] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[5] &= (~0x01);			// сброс диагностики
	OTVET_PER = 0;
	V_PER = a;
	TYPE_PER = b;
	PUT_PER = c;
	HOME_PER = d;
	KOM_PER = 1;
	CT_PER = 0;
    TEK_OTN_PER = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x01 || !OTVET_PER)	// есть диагностика нет связи или нет ответа
	{
		if(CT_PER >= 5)
			diagn[5] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[5] &= (~0x04);			// сброс диагностики
	KOM_PER = 0;
	if(!HOME_PER)					// не движение в HOME
	{
		SetOut(1,1,0x01);           // выдать движение
		CT_PER = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,1,0x04);          		// выдать движение в Home
	CT_PER = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x200)||(TEK_ABS_PER))				// механизм не пришел в HOME
	{
		if(CT_PER >= e)
			diagn[5] |= 0x08;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;		
	}
	diagn[5] &= (~0x08);			// сброс диагностики
	SetOut(0,1,0x04);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[4]&0x100))				// нет готовности привода
	{
		if(CT_PER >= 5)
		diagn[5] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[5] &= (~0x01);			// сброс диагностики
	PR_PER = 0;
	norma = 43;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[4]&0x100)				// есть готовность привода
	{
		if(CT_PER >= 5)
			diagn[5] |= 0x02;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[5] &= (~0x02);			// сброс диагностики
	SetOut(0,1,0x01);               // сбросить начало движение
	CT_PER = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[4]&0x100)||((TYPE_PER==ABS)&&(PUT_PER!=TEK_ABS_PER))||((TYPE_PER==OTN)&&(PUT_PER!=TEK_OTN_PER)))				// есть готовность привода
	{
		if(CT_PER >= e)
			diagn[5] |= 0x10;		// отказ: "Нет завершения движ. перемещ."
		return;		
	}
	diagn[5] &= (~0x10);			// сброс диагностики
	PR_PER = 0;
	norma = 44;						//"Манипулятор перемещения путь прошел"
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
void R_14() // режим 14 "МПВ в исходное"
{
	sh_ = sh[14];
	if((shr[14] < 1) || (shr[14] > 2)) goto L100; // на выход

L00:if(shr[14] == 1) goto L1;
	if(shr[14] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[14] = sh_;
	if (sh[14] != 0) goto L100;		// SH != 0
	shr[14]++;						// след.шаг
	if (shr[14] > 2) goto L0;		// число шагов режима
	sh[14] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 108;					// норма: "Мех. поворота в исходном"
	shr[14] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[33] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POV(par[0][16],0,0,1,60);				// поворот манип. в исх.
	goto L101;
}
//---------------------------------------------------------------------------
void R_15() // режим 15 "МПВ вправо/влево"
{
	sh_ = sh[15];
	if ((shr[15] < 1) || (shr[15] > 2)) goto L100; // на выход

L00:if(shr[15] == 1) goto L1;
	if(shr[15] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[15] = sh_;
	if(sh[15] != 0) goto L100;		// SH != 0
	shr[15]++;						// след.шаг
	if(shr[15] > 2) goto L0;		// число шагов режима
	sh[15] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 109;						// норма: "Механизм. поворота путь прошел"
	shr[15] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[14] = 0;							// сброс активации режима 14
	shr[14] = 0;
	diagn[33] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POV(par[0][16],OTN,par[0][17],0,60);// поворот манип. вперед/назад
	goto L101;
}
//---------------------------------------------------------------------------
void VIDK_POV(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. поворота
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x02) return;		// нет связи с контроллером
	SetOut(0,1,0x02);				// снять Стоп механизмов
	PR_POV = 1;
	CT_POV = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x800))				// нет готовности привода
	{
		if(CT_POV >= 5)
			diagn[33] |= 0x04;		// отказ: "Нет готовности привода повор."
		return;
	}
	diagn[33] &= (~0x04);			// сброс диагностики
	OTVET_POV = 0;
	V_POV = a;
	TYPE_POV = b;
	PUT_POV = c;
	HOME_POV = d;
	KOM_POV = 1;
	CT_POV = 0;
    TEK_OTN_POV = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x02 || !OTVET_POV)	// есть диагностика нет связи или нет ответа
	{
		if(CT_POV >= 5)
			diagn[33] |= 0x10;		// отказ: "Нет ответа на команду повор."
		return;
	}
	diagn[33] &= (~0x10);			// сброс диагностики
	KOM_POV = 0;
	if(!HOME_POV)					// не движение в HOME
	{
		SetOut(1,0,0x800);           // выдать движение
		CT_POV = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,0,0x1000);              // выдать движение в Home
	CT_POV = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x1000)||(TEK_ABS_POV))			// механизм не пришел в HOME
	{
		if(CT_POV >= e)
			diagn[33] |= 0x20;		// отказ: "Мех. повор. не пришел в пол. HOME"
		return;		
	}
	diagn[33] &= (~0x20);			// сброс диагностики
	SetOut(0,0,0x1000);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[4]&0x800))				// нет готовности привода
	{
		if(CT_POV >= 5)
			diagn[33] |= 0x04;		// отказ: "Нет готовности привода повор."
		return;
	}
	diagn[33] &= (~0x04);			// сброс диагностики
	PR_POV = 0;
	norma = 108;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[4]&0x800)				// есть готовность привода
	{
		if(CT_POV >= 5)
			diagn[33] |= 0x08;			// отказ: "Нет ответа на START движ. повор."
		return;
	}
	diagn[33] &= (~0x08);				// сброс диагностики
	SetOut(0,0,0x800);               	// сбросить начало движение
	CT_POV = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[4]&0x800)||((TYPE_POV==ABS)&&(PUT_POV!=TEK_ABS_POV))||((TYPE_POV==OTN)&&(PUT_POV!=TEK_OTN_POV)))				// есть готовность привода
	{
		if(CT_POV >= e)
			diagn[33] |= 0x40;		// отказ: "Нет завершения движ. повор."
		return;		
	}
	diagn[33] &= (~0x40);			// сброс диагностики
	PR_POV = 0;
	norma = 109;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
void R_17 ()	             		// режим "Поддержание давления (заслонка)"
{
	sh_ = sh[17];
	if (shr[17] == 1) goto L1;
	if (shr[17] == 2) goto L2;
	if (shr[17] == 3) goto L3;
	else goto L100;      	 		// на выход

L101:sh[17] = sh_;	   			    // |                           |
	if ( sh[17] != 0) goto L100;    // |    sh_!= 0                |
	shr[17]++;		        		// |    след.шаг 	           |
	sh[17] = 1;		         		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: shr[18] = 0;                    // сброс активации режима 18
	sh[18] = 0;                     // 'Открыть заслонку'
	shr[19] = 0;                    // сброс активации режима 19
	sh[19] = 0;                     // 'Закрыть заслонку'
	VRDZASL = 0;               		// сброс признака выхода на режим заслонки
	diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xC0);
    SetOut(0,0,0x180);				// сброс выходов "Открыть ДЗ" и "Закрыть ДЗ"
	sh_ = 0;
	goto L101;
L2:	VIBPAR_DZASL();		     		// выбор параметра заслонки
	VIDK_DZASL(2,3,0x40,0); 	 	// выдать задание по давлению
	if(sh_!=0) goto L101;           // ожидание окончания выдачи задания
	ZPAR_DZASL = PAR_DZASL;	            // запоминание параметра задания давления
	CT_17 = 0;	           	 		// сброс
	CT17K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L3: VIBPAR_DZASL();		     		// выбор параметра заслонки
	if(PAR_DZASL == ZPAR_DZASL)			// параметр не изменился
	{ 
		sh_ = 0;					// обход задания
		goto L3_8;
	}
	VIDK_DZASL(2,3,0x40,0); 	 	// выдать задание по давлению
	if(sh_!=0) goto L101;           // ожидание окончания выдачи задания
	ZPAR_DZASL = PAR_DZASL;				// зап.парам.задания давления
L3_8:PDDZASL ();                   	// Подготовка аналоговых данных
	RLIMDZASL();	        			// расчет LIM для заслонки
	if (DELDZASL <= LIM1DZASL) goto L3_4;// модуль Ет <= LIM1
	if (VRDZASL == 0) goto L3_6;		// нет выхода на режим
	diagn[3] |= 0x04;		        // отказ: "нет регулирования заслонки"
	goto L3_5;	            		// на сброс диагн."больш.ош."
L3_4:diagn[3] &= (~0x04);	   		// сброс д."нет регулирования заслонки"
	if (DELDZASL <= LIM2DZASL) goto L3_5;// LIM2 (зона регулирования)
	if (VRDZASL == 0) goto L3_6;		// нет выхода на режим
	diagn[3] |= 0x02;		       	// отказ: "б.ош.регулирования заслонки"
	goto L3_7;
L3_5:diagn[3] &= (~0x02);	   		// сброс д."б.ош.регулирования заслонки"
	goto L3_7;
L3_6:CT17K1 = 0;
L3_7:if (CT_17 <= T_VRDZASL) goto L3_2;// Ттек <= Тзад
	if (VRDZASL != 0) goto L3_1;      // есть выход на режим
	diagn[3] |= 0x01;		        // отказ: "нет выхода на режим заслонки"
	goto L3_2;
L3_1:diagn[3] &= (~0x01);	       	// сброс д."нет выхода на режим заслонки"
L3_2:if (CT17K1 <= T_KDZASL) goto L3_3;// Т.K.тек <= Т.K.зад
	VRDZASL = 1;	               		// выход на режим
L3_3:shr[17] = 2;                   // Возврат на L2
	goto L101;
}
//--------------------------------------------------------------------------------
void VIBPAR_DZASL ()					// подпрограмма "Выбор параметра для заслонки"
{
    PAR_DZASL = par[N_ST][10];
}
//---------------------------------------------------------------------------
void RLIMDZASL()						// подпрограмма "Расчет LIM для заслонки"
{
	if (PAR_DZASL == 0)	        	//если задание = 0, расшир.лимитов
	{
		LIM1DZASL = 10000;	    	// MAX доп.знач.по входу ап.ср.
		LIM2DZASL = LIM1DZASL / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2DZASL = PAR_DZASL / DOPDZASL;	// LIM2 (малый)
		LIM1DZASL = PAR_DZASL / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDDZASL ()						// подготовка аналоговых данных заслонки
{
	X_TDZASL = TEK_DAVL_DZASL;			// тек.значение
	E_TDZASL = PAR_DZASL - X_TDZASL;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TDZASL >= 0) DELDZASL = E_TDZASL;
	else  DELDZASL = E_TDZASL * (-1);	// вычисление модуля ошибки
}
//------------------------------------------------//
//--Подпрограмма выдачи команд на заслонку (MKS)--//
//------------------------------------------------//
void VIDK_DZASL ( int a, int b, int c, int d )
	// a - код команды к заслонке
	// b - номер байта массива диагностики DIAGM
	// c - номер бита в байте DIAGM
	// d - задание по положению (0...10000)
{
	switch ( sh_ )
	{
		case 1:
		{
			// если нет связи с заслонкой
			if ( diagnS[0] & 0x40 ) return;
			// обнуление признака положительного ответа
			PR_DZASL = 0;
			// обнуление кода ответа
			OTVET_DZASL = 0;
			// выдача заданной команды
			KOM_DZASL = a;
			// есть команда контроль давления
			if ( KOM_DZASL == 2 )
			{
				// выбрали параметр заслонки
				VIBPAR_DZASL();
				// установили параметр
				DATA_DZASL = PAR_DZASL;
			}
			// есть команда контроль положения
			else if ( KOM_DZASL == 1 )
			{
				// определили параметр из задания (по положению)
				DATA_DZASL = d;
			};
			// сбросили счетчик времени заслонки
			CT_DZASL = 0;
			// перешли на следующий шаг
			sh_ = 2;
		}; break;
		case 2:
		{
			// если нет связи с заслонкой или ответ не положительный
			if ( ( diagnS[0] & 0x40 ) || ( PR_DZASL == 0 ) )
				// сброс сч.времени заслонки
				CT_DZASL = 0;
			// есть связь с заслонкой и ответ положительный
			// и ответ заслонки НЕ соответствует искомому
			else if ( OTVET_DZASL != a )
			{
				// сравнение с контрольным временем и диагностика
				if ( CT_DZASL > 5 ) diagn[b] |= c;
			}
			// если все штатно
			else
			{
				// сброс диагностики
				diagn[b] &= ~c;
				// если команда НЕ опрос состояния заслонки
				if ( KOM_DZASL != 7 )
				{
					// запись кода команды - общий опрос
					KOM_DZASL = 7;
					// сброс признака положительного ответа
					PR_DZASL = 0;
				}
				// выход из подпрограммы
				sh_ = 0;
			}
		}; break;
		default: ;break;
	};
}
// Команды на заслонку
//             КК   диагн
// VIDK_DZASL ( 1, 3, 0x20,..)  - Задание положения (код положения)
// VIDK_DZASL ( 2, 3, 0x40, 0)  - Задание давление
// VIDK_DZASL ( 3, 3, 0x08, 0)  - Открыть заслонку
// VIDK_DZASL ( 4, 3, 0x10, 0)  - Закрыть заслонку
// VIDK_DZASL ( 7, 3, 0x80, 0)  - Опрос состояния заслонки
//---------------------------------------------------------------------------
void R_18() // режим 18 "Открыть заслонку"
{
	sh_ = sh[18];
	if ( shr[18] < 1 || shr[18] > 2 ) goto L100; // на выход

L00:if ( shr[18] == 1 ) goto L1;
	if ( shr[18] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[18] = sh_;
	if ( sh[18] != 0) goto L100;    // SH != 0
	shr[18]++;                      // след.шаг сч.шр1
	if ( shr[18] > 2) goto L0;      // число шагов режима
	sh[18] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 22;		           	    // норма: "Заслонка открылась"
	shr[18] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL = 7;                   // перевод в опрос состояния заслонки
    shr[17]  = 0;                   // сброс активации режима 17
	sh[17] = 0;                     // "Дросселирование"
	shr[19]  = 0;                   // сброс активации режима 19
	sh[19] = 0;                     // "Закрыть заслонку"
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xC0);
	sh_ = 0;
	goto L101;
L2: Klapan(1,&DZasl);				// открыть заслонку
	goto L101;
}
//------------------------------------------------------------------------------
void R_19() // режим 19 "Закрыть заслонку"
{
	sh_ = sh[19];
	if ( shr[19] < 1 || shr[19] > 2 ) goto L100; // на выход

L00:if ( shr[19] == 1 ) goto L1; 
	if ( shr[19] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[19] = sh_;
	if ( sh[19] != 0 ) goto L100;   // SH != 0
	shr[19]++;                      // след.шаг сч.шр1
	if ( shr[19] > 2) goto L0;    	// число шагов режима
	sh[19] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 23;		           	    // норма: "Заслонка закрылась"
	shr[19] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL = 7;                   // перевод в опрос состояния заслонки
    shr[17]  = 0;                   // сброс активации режима 17
	sh[17] = 0;                     // "Дросселирование"
	shr[18] = 0;                    // сброс активации режима 18
	sh[18] = 0;                     // "Открыть заслонку"
    diagn[3] &= (~0xFF);			// сброс диагностик заслонки
    diagn[2] &= (~0xC0);
	sh_ = 0;
	goto L101;
L2: Klapan(0,&DZasl);				// закрыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_20()							// РЕЖИМ 20 "Включить РРГ1"
{
	// выставление параметра РРГ
	ObjRRG[0]->parRRG = par[N_ST][0];

	// запуск режима
	RRGOn(ObjRRG[0]);				// включение РРГ1
}
//---------------------------------------------------------------------------
void R_21()							// РЕЖИМ 21 "Включить РРГ2"
{
	// выставление параметра РРГ
	ObjRRG[1]->parRRG = par[N_ST][1];

	// запуск режима
	RRGOn(ObjRRG[1]);				// включение РРГ2
}
//---------------------------------------------------------------------------
void R_22()							// РЕЖИМ 22 "Включить РРГ3"
{
	// выставление параметра РРГ
	ObjRRG[2]->parRRG = par[N_ST][2];

	// запуск режима
	RRGOn(ObjRRG[2]);				// включение РРГ3
}
//---------------------------------------------------------------------------
void R_23()							// РЕЖИМ 23 "Включить РРГ4"
{
	// выставление параметра РРГ
	ObjRRG[3]->parRRG = par[N_ST][3];
	
	// запуск режима
	RRGOn(ObjRRG[3]);				// включение РРГ4
}
//---------------------------------------------------------------------------
void R_24()							// РЕЖИМ 24 "Включить РРГ5"
{
	// выставление параметра РРГ
	ObjRRG[4]->parRRG = par[N_ST][4];

	// запуск режима
	RRGOn(ObjRRG[4]);				// включение РРГ5
}
//---------------------------------------------------------------------------
void R_25()							// РЕЖИМ 25 "Включить РРГ6"
{
	// выставление параметра РРГ
	ObjRRG[5]->parRRG = par[N_ST][5];
	
	// запуск режима
	RRGOn(ObjRRG[5]);				// включение РРГ6
}
//---------------------------------------------------------------------------
void R_26()							// РЕЖИМ 26 "Включить РРГ7"
{
	// выставление параметра РРГ
	ObjRRG[6]->parRRG = par[N_ST][6];

	// запуск режима
	RRGOn(ObjRRG[6]);				        // включение РРГ7
}
//---------------------------------------------------------------------------
void R_29 ()	                    // режим "Вкл. ВЧГ реактора"
{
	sh_ = sh[29];
	if (shr[29] == 1) goto L1;
	if (shr[29] == 2) goto L2;
	if (shr[29] == 3) goto L3;
	if (shr[29] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[29] = sh_;					//  |                           |
	if(sh[29]) goto L100;			//	|    sh != 0                |
	shr[29]++;						//	|    след.шаг 	            |
	sh[29] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: VRGIR = 0;                      // сброс признака выхода на режим ВЧГ реактора
	diagn[7] &= (~0xBF);            // сброс диагностики режима ВЧГ реактора
    A_OUT(7,8192);                  // обнуление уставки
    VRR_GIR();                      // выставить разр. работы ВЧГ реактора
    goto L101;
L2: VIBPAR_GIR();                   // выбор параметров ВЧГ реактора
    A_OUT(7,2*PAR_GIR+8192);        // выдача уставки на ВЧГ реактора
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,4,0x200);				// включение выходной мощности ВЧГ реактора
    CT_29 = 0;                      // очистка счетчиков
    CT29K1 = 0;                     // режима
    sh_ = 0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIR();                   // выбор параметров ВЧГ реактора
    A_OUT(7,2*PAR_GIR+8192);        // выдача уставки на ВЧГ
	PDGIR ();                   	// Подготовка аналоговых данных
	RLIMGIR();	        			// новый расчет LIM для ВЧГ реактора
	if (DELGIR <= LIM1GIR) goto L4_4;// модуль Ет <= LIM1
	if (VRGIR == 0) goto L4_6;		// нет выхода на режим
	diagn[7] |= 0x04;		        // отказ: "нет регулирования ВЧГ реактора"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[7] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ реактора"
	if (DELGIR <= LIM2GIR) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIR == 0) goto L4_6;		// нет выхода на режим
	diagn[7] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ реактора"
	goto L4_7;
L4_5:diagn[7] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ реактора"
	goto L4_7;
L4_6:CT29K1 = 0;
L4_7:if (CT_29 <= T_VRGIR) goto L4_2;// Ттек <= Тзад
	if (VRGIR != 0) goto L4_1;      // есть выход на режим
	diagn[7] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ реактора"
	goto L4_2;
L4_1:diagn[7] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ стола"
L4_2:if (CT29K1 <= T_KGIR) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIR = 1;	               		// выход на режим
    norma = 51;                     // норма: "ВЧГ ИП вышел на режим"
L4_3:shr[29]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_GIR ()				    // подпрограмма "Выбор параметра для ВЧГ реактора"
{
	PAR_GIR = par[N_ST][7];
}
//---------------------------------------------------------------------------
void RLIMGIR ()						// подпрограмма "Расчет LIM для ВЧГ реактора"
{
    if (VRGIR == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIR = 15;                // допуск 66,6%
        LIM2GIR = (PAR_GIR * 10) / DOPGIR; // LIM2 (малый)
        LIM1GIR = (PAR_GIR*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIR <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIR = 30;           // допуск 33%
	    else  if ( PAR_GIR <= 276 ) // если зад. мощность <= 40Вт
		    DOPGIR = 40;            // допуск 25%
        else DOPGIR = 50;           // иначе допуск 20%

	    if (PAR_GIR == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIR = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIR = LIM1GIR / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIR = PAR_GIR * 10 / DOPGIR; // LIM2 (малый)
	        LIM1GIR = PAR_GIR / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIR ()						// подготовка аналоговых данных ВЧГ реактора
{
	X_TGIR = aik[12];	            // тек.значение падающей мощности
	E_TGIR = PAR_GIR - X_TGIR;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIR >= 0) DELGIR = E_TGIR;
	else  DELGIR = E_TGIR * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void RKOEF_GIR ()						// подпрограмма "Расчет текущего
										// коэф-та согласования ВЧГ реактора
										// Рпад/Ротр"
{
	if(aik[13] == 0) return;			// проверка Ротр. на 0
	long T1 = int((float(aik[12])*10.0)/float(aik[13]));	// увеличенный на 10 для контроля знака после ","
	N_TEK_GIR = T1;						// K=Pпад.*10/Pотр.
}
//---------------------------------------------------------------------------
void SBROSR_29()					// "Откл. ВЧГ реактора"
{
	shr[29] = 0;        // сброс активизации
	sh[29] = 0;         // режима 29 "Вкл. ВЧГ реактора"
	VRGIR = 0;          // сброс выхода ВЧГ на режим
	A_OUT(7,8192);      // сброс уставки вых. мощности ВЧГ
	SetOut(0,4,0x200);	// откл. вых. мощн.
	diagn[7]&=(~0xFF);	// сброс диагностик режимов "ВЧГ"
	norma = 59;			// норма: "Сброс режима ВЧГ ИП завершен"
}
//---------------------------------------------------------------------------
//--Режим "Автоподстройка (согласование) генератора ВЧГ реактора--// 
//---------------------------------------------------------------------------
void R_30 ()					// режим "Автоподстройка
{								//(согласование) генератора ВЧГ реактора"
	sh_ = sh[30];
	if ( shr[30] == 1 ) goto L1;
	if ( shr[30] == 2 ) goto L2;
	if ( shr[30] == 3 ) goto L3;
	if ( shr[30] == 4 ) goto L4;
	if ( shr[30] == 5 ) goto L5;
	if ( shr[30] == 6 ) goto L6;
	if ( shr[30] == 7 ) goto L7;
	if ( shr[30] == 8 ) goto L8;
	if ( shr[30] == 9 ) goto L9;
	else goto L100;             // на выход

							 	// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА  |
L101:sh[30] = sh_;				// |                            |
	if (sh[30] != 0) goto L100;	// |    SH != 0                 |
	shr[30]++;		         	// |    след.шаг сч.шр30        |
	sh[30] = 1;		         	// |                            |
L100:return;         		 	// |    возврат в "кольцо"      |

L1: NAPRS_GIR = 0;		 		// сброс направления - прямое (>)
    A_OUT(9,nasmod[4]);      	// Задание скорости УС ИП
	sh_ = 0;
	goto L101;
	// проверка отраженной мощности на 0
L2: if (aik[12] == 0) goto L2_1;	    // переход на сброс двигателей
	RKOEF_GIR();			       		// расчет тек.коэф-та согласования
	//SK_SU_GIR();						// расчет уставки скорости
	N_PRED_GIR = N_TEK_GIR;				// запоминание коэф-та согласования
	if(N_TEK_GIR >= nasmod[5]) goto L2_1;	// есть согласование
	diagn[7] |= 0x08;		            // отказ: "Нет согласования ВЧГ реактора"
	if (NAPRS_GIR == 0) goto L2_2;	    // направление - прямое
	goto L2_3;
L2_2:if(aik[16]>(par[N_ST][9]+DOP_DV_IP))   // переехал вперед
	{
		shr[30] = 4;                  	// переход на L4_1
		goto L4_1;
	}
	SetOut(0,1,0x0C00);			    	// прямое
	SetOut(1,1,0x0400); 	   		    // движение
	CT_30T = 0;		               	    // сброс сч.вр.режима
	shr[30] = 3;					    // переход на L4
	sh_ = 0;
	goto L101;							// через диспетчер
L2_3:if (aik[16]<(par[N_ST][9]-DOP_DV_IP))	// переехали назад
	{
		shr[30] = 6;                 	// переход на L6_1
		goto L6_1;
	}
	SetOut(0,1,0x0C00);			    	// обратное
	SetOut(1,1,0x0800); 	   		    // движение
	CT_30T = 0;	             	  	    // сброс сч.вр.режима
	sh_ = 0;
	shr[30] = 5;					    // переход на L6
	goto L101;							// через диспетчер
L2_1:SetOut(0,1,0x0C00);				// сброс движений
	CT_30T = 0;	                	    // сброс сч.вр.режима
	sh_ = 0;
	goto L101;
L3: if (CT_30T <= T_STOP) goto L101;	// задержка 0,5 сек на СТОП двигателей
	diagn[7] &= (~0x08);				// сброс диагн. "Нет согласования ВЧГ реактора"
	shr[30] = 1;					    // переход на L2
	sh_ = 0;
	goto L101;							// через диспетчер
L4: if (CT_30T <= T_DVIJ) goto L101;	// задержка 0,5 сек на движение
	if ( aik[16]<200 || aik[16]>3900 )	// есть ограничение движения УС реактора
	{
	    shr[30] = 7;				    // переход на L8
		sh_ = 0;
	    goto L101;                      // через диспетчер
	}
	if (aik[13] == 0)		          	// 0 отраженной мощности
	{
	    shr[30] = 1;				    // переход на L2_1 (сброс движений)
		goto L2_1;
	}
	RKOEF_GIR();			        	// расчет тек.коэф-та согласования
	//SK_SU_GIR();						// расчет уставки скорости
	if (N_TEK_GIR >= N_PRED_GIR)		// согласование лучше или такое же
	{
		NAPRS_GIR = 0;			   		// запоминание "лучшего" направления
	    shr[30] = 1;				    // переход на L2
	    sh_ = 0;
	    goto L101;}						// через диспетчер
	// согласование хуже
	N_PRED_GIR = N_TEK_GIR;				// запоминание коэф-та согласования
L4_1:SetOut(0,1,0x0C00);		    	// сброс движений
	CT_30T = 0;			                // сброс сч.вр.режима
	sh_ = 0;
	goto L101;
L5: if (CT_30T <= T_SM_NAPR) goto L101; // задержка 0,5сек на смену направл.
	shr[30] = 2;			            // переход на обратное движение
	goto L2_3;			                // (смена направления)
L6: if (CT_30T <= T_DVIJ) goto L101;  	// задержка 0,5сек на движение
	if ( aik[16]<200 || aik[16]>3900 )	// есть ограничение движения УС реактора
	{
	    shr[30] = 7;				    // переход на L8
		sh_ = 0;
	    goto L101;						// через диспетчер
	}
	if (aik[13] == 0)		          	// 0 отраженной мощности
	{
		shr[30] = 1;
		goto L2_1;	    				// переход на L2_1 (сброс движений)
	}
	RKOEF_GIR();			            // расчет тек.коэф-та согласования
	//SK_SU_GIR();						// расчет уставки скорости
	if (N_TEK_GIR >= N_PRED_GIR)		// согласование лучше или такое же
	{
		NAPRS_GIR = 1;		         	// запоминание "лучшего" направления
	    shr[30] = 1;				    // переход на L2
	    sh_ = 0;
	    goto L101;						// через диспетчер
	}
	// согласование хуже
	N_PRED_GIR = N_TEK_GIR;				// запоминание коэф-та согласования
L6_1:SetOut(0,1,0x0C00);	     		// сброс движений
	CT_30T = 0;			           	    // сброс сч.вр.режима
	sh_ = 0;
	goto L101;
L7: if (CT_30T <= T_SM_NAPR) goto L101; // задержка 0,5сек на смену направл.
	shr[30] = 2;			            // переход на прямое движение
	goto L2_2;			                // (смена направления)
L8: SetOut(0, 1, 0x0C00);		        // сброс движений
	diagn[17] |= 0x10;	            	// отказ: "Ограничение согласования ВЧГ реактора"
	sh_ = 0;
	goto L101;
L9: goto L100;							// бесконечный режим
}
//---------------------------------------------------------------------------
void R_31 ()	// режим "Движение в точку согл. ВЧГ реактора(грубо)
{	
	sh_ = sh[31];
	if((shr[31] < 1)||(shr[31] > 3)) goto L100; // на выход

	if(shr[31] == 1) goto L1; 
	if(shr[31] == 2) goto L2;
	if(shr[31] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[31] = sh_;
	if(sh[31] != 0) goto L100;   // SH != 0
	shr[31]++;                      // след.шаг сч.шр1
	if(shr[31] > 3) goto L0;    	// число шагов режима
	sh[31] = 1;
L100:return;                  	    // возврат в "кольцо"

L0:	shr[31] = 0;
	goto L100;

L1:	prDvijGir_g = 1;		// выставить признак движения ИП реактора
	diagn[20]&=(~0x01);		// сброс диагностики
	CT_DVIJ_GIR_g = 0;		// сброс сч. времени движения УС конденсатора
	sh_ = 0;
	goto L101;
L2:	if(abs(aik[17]-par[N_ST][8])<DOP_SU) // проверка нахождения УС в точке
	{
		SetOut(0,1,0x3000);		// сброс направления
		A_OUT(10,8192);			// сброс скорости
		diagn[20]&=(~0x01);		// сброс диагностик
		prDvijGir_g = 0;		// снять признак движения ИП реактора
		norma = 39;				// норма: "Конд. ИП(грубо) пришел в заданную точку"
		shr[31] = 3;			// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	// УС не в точке + время вышло
	else if(CT_DVIJ_GIR_g > T_KDVIJ_SU)
	{
		SetOut(0,1,0x3000);		// сброс направления
		A_OUT(10,8192);         // сброс скорости
		diagn[20] |= 0x01;		// отказ "Конд. ИП(грубо) не пришел в зад. полож."
	}
	// положение УС меньше заданного
	else if(aik[17] < par[N_ST][8])
	{
		// если есть движение "назад"
		if(out[1]&0x2000)
		{
			SetOut(0,1,0x3000); // сброс направления
			A_OUT(10,8192);		// сброс скорости
			CT_SUT_g = 0;		// сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "назад"
		else
		{
			SetOut(1,1,0x1000); // движение "вперёд"
			A_OUT(10,nasmod[4]);// задать уставку скорости
		}
	}
	// положение УС больше заданного
	else
	{
		// если есть движение "вперед"
		if(out[1]&0x1000)
		{
			SetOut(0,1,0x3000); // сброс направления
			A_OUT(10,8192);     // сброс скорости
			CT_SUT_g = 0;         // сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "вперед"
		else
		{
			SetOut(1,1,0x2000); // движение "назад"
			A_OUT(10,nasmod[4]);// задать уставку скорости
		}
	}
	goto L101;
L3:	if(CT_SUT_g > T_KSUT)		// ожидание задержки на переключение
		shr[31] = 2;			// возврат на 2 шаг
    goto L101;
}
//------------------------------------------------------------------------------
void R_32 ()	// режим "Движение в точку согл. ВЧГ реактора(точно)
{
	sh_ = sh[32];
	if((shr[32] < 1)||(shr[32] > 3)) goto L100; // на выход

	if(shr[32] == 1) goto L1; 
	if(shr[32] == 2) goto L2;
	if(shr[32] == 3) goto L3;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[32] = sh_;
	if(sh[32] != 0) goto L100;   // SH != 0
	shr[32]++;                      // след.шаг сч.шр1
	if(shr[32] > 3) goto L0;    	// число шагов режима
	sh[32] = 1;
L100:return;                  	    // возврат в "кольцо"

L0:	shr[32] = 0;
	goto L100;

L1:	prDvijGir_t = 1;		// выставить признак движения ИП реактора
	diagn[20]&=(~0x02);		// сброс диагностики
	CT_DVIJ_GIR_t = 0;		// сброс сч. времени движения УС конденсатора
	sh_ = 0;
	goto L101;
L2:	if(abs(aik[16]-par[N_ST][9])<DOP_SU) // проверка нахождения УС в точке
	{
		SetOut(0,1,0xC00);		// сброс направления
		A_OUT(9,8192);			// сброс скорости
		diagn[20]&=(~0x02);		// сброс диагностик
		prDvijGir_t = 0;		// снять признак движения ИП реактора
		norma = 40;				// норма: "Конд. ИП(точно) пришел в заданную точку"
		shr[32] = 3;			// ВЫХОД!!!
		sh_ = 0;
		goto L101;
	}
	// УС не в точке + время вышло
	else if(CT_DVIJ_GIR_t > T_KDVIJ_SU)
	{
		SetOut(0,1,0xC00);		// сброс направления
		A_OUT(9,8192);         // сброс скорости
		diagn[20] |= 0x02;		// отказ "Конд. ИП(точно) не пришел в зад. полож."
	}
	// положение УС меньше заданного
	else if(aik[16] < par[N_ST][9])
	{
		// если есть движение "назад"
		if(out[1]&0x800)
		{
			SetOut(0,1,0xC00); // сброс направления
			A_OUT(9,8192);		// сброс скорости
			CT_SUT_t = 0;		// сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "назад"
		else
		{
			SetOut(1,1,0x400); // движение "вперёд"
			A_OUT(9,nasmod[4]);// задать уставку скорости
		}
	}
	// положение УС больше заданного
	else
	{
		// если есть движение "вперед"
		if(out[1]&0x400)
		{
			SetOut(0,1,0xC00); // сброс направления
			A_OUT(9,8192);     // сброс скорости
			CT_SUT_t = 0;         // сброс сч. времени на задержку
			sh_ = 0;			// переход на след. шаг
		}
		// если нет движения "вперед"
		else
		{
			SetOut(1,1,0x800); // движение "назад"
			A_OUT(9,nasmod[4]);// задать уставку скорости
		}
	}
	goto L101;
L3:	if(CT_SUT_t > T_KSUT)		// ожидание задержки на переключение
		shr[32] = 2;			// возврат на 2 шаг
    goto L101;
}
//------------------------------------------------------------------------------
void R_33 ()						// Режим "Вкл. нагрев установки"
{
	sh_ = sh[33];
	
	if (shr[33] < 1 || shr[33] > 20) goto L100;
	if (shr[33] < 10) goto L00;
	goto L01;

L00:if (shr[33] == 1) goto L1;
	if (shr[33] == 2) goto L2;
	if (shr[33] == 3) goto L3;
	if (shr[33] == 4) goto L4;
	if (shr[33] == 5) goto L5;
	if (shr[33] == 6) goto L6;
	if (shr[33] == 7) goto L7;
	if (shr[33] == 8) goto L8;
	if (shr[33] == 9) goto L9;
L01:if (shr[33] == 10) goto L10;
	if (shr[33] == 11) goto L11;
	if (shr[33] == 12) goto L12;
	if (shr[33] == 13) goto L13;
	if (shr[33] == 14) goto L14;
	if (shr[33] == 15) goto L15;
	if (shr[33] == 16) goto L16;
	if (shr[33] == 17) goto L17;
	if (shr[33] == 18) goto L18;
	if (shr[33] == 19) goto L19;
	if (shr[33] == 20) goto L20;

	// конечный диспетчер режима
L101:sh[33] = sh_;
	if (sh[33] != 0) goto L100;		// SH != 0
	++shr[33];						// след. шаг сч.шр5
	if (shr[33] > 20) goto L0;		// число шагов режима
	sh[33] = 1;
L100:return;						// возврат в "кольцо"

L0:	shr[33] = 0;
	goto L100;
	
L1: VBPN();							// включить БПН
	if(sh_) goto L101;
	if(par_n[0])					// Есть задание на канал 1
	{
		if(!shr[40])				// Есть активизация режима(вкл. нагр. кан. 1)
		{
			sh[40]  = 1;			// активация режима 40
			shr[40] = 1;
		}
		shr[33] = 2;	
		goto L2_2;					// переход на шаг 2_2	
	}
	if(shr[40])						// Есть активизация режима(вкл. нагр. кан. 1)
	{
		sh[41]  = 1;				// активация режима 41
		shr[41] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 2;	
	goto L2_1;						// переход на шаг 2_1	
L2: if(shr[41]) goto L101;			// ожидание конца режима
L2_1:ObjBPN[0]->vBPN = 1;
L2_2:if(par_n[1])					// Есть задание на канал 2
	{
		if(!shr[42])				// Есть активизация режима(вкл. нагр. кан. 2)
		{
			sh[42]  = 1;			// активация режима 42
			shr[42] = 1;
		}
		shr[33] = 4;
		goto L4_2;					// переход на шаг 4_2
	}
	if(shr[42])						// Есть активизация режима(вкл. нагр. кан. 2)
	{
		sh[43]  = 1;				// активация режима 43			
		shr[43] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 3;	
	goto L3_1;						// переход на шаг 4_1	
L3: if(shr[43]) goto L101;			// ожидание конца режима
L3_1:ObjBPN[1]->vBPN = 1;
L3_2:/*if(par_n[2])					// Есть задание на канал 3
	{
		if(!shr[44])				// Есть активизация режима(вкл. нагр. кан. 3)
		{
			sh[44]  = 1;			// активация режима 44
			shr[44] = 1;
		}
		shr[33] = 4;	
		goto L4_2;					// переход на шаг 4_2
	}
	if(shr[44])						// Есть активизация режима(вкл. нагр. кан. 3)
	{
		sh[45]  = 1;				// активация режима 45			
		shr[45] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 4;	
	goto L4_1; */						// переход на шаг 4_1
L4: //if(shr[45]) goto L101;			// ожидание конца режима
L4_1://ObjBPN[2]->vBPN = 1;
L4_2:if(par_n[4])					// Есть задание на канал 5
	{
		if(!shr[84])				// Есть активизация режима(вкл. нагр. кан. 5)
		{
			sh[84]  = 1;			// активация режима 84
			shr[84] = 1;
		}
		shr[33] = 5;
		goto L5_2;					// переход на шаг 5_2	
	}
	if(shr[84])						// Есть активизация режима(вкл. нагр. кан. 8)
	{
		sh[85]  = 1;				// активация режима 85
		shr[85] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 5;	
	goto L5_1;						// переход на шаг 5_1
L5: if(shr[85]) goto L101;			// ожидание конца режима
L5_1:ObjBPN[4]->vBPN = 1;
L5_2: if(par_n[5])					// Есть задание на канал 6
	{
		if(!shr[48])				// Есть активизация режима(вкл. нагр. кан. 6)
		{
			sh[48]  = 1;			// активация режима 48
			shr[48] = 1;
		}
		shr[33] = 6;
		goto L6_2;					// переход на шаг 6_2	
	}
	if(shr[48])						// Есть активизация режима(вкл. нагр. кан. 6)
	{
		sh[49]  = 1;				// активация режима 49			
		shr[49] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 6;
	goto L6_1;						// переход на шаг 6_1
L6: if(shr[49]) goto L101;			// ожидание конца режима
L6_1:ObjBPN[5]->vBPN = 1;
L6_2: if(par_n[6])					// Есть задание на канал 7
	{
		if(!shr[50])				// Есть активизация режима(вкл. нагр. кан. 7)
		{
			sh[50]  = 1;			// активация режима 50
			shr[50] = 1;
		}
		shr[33] = 7;	
		goto L7_2;					// переход на шаг 7_2
	}
	if(shr[50])						// Есть активизация режима(вкл. нагр. кан. 7)
	{
		sh[51]  = 1;				// активация режима 51			
		shr[51] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 7;	
	goto L7_1;						// переход на шаг 7_1	
L7: if(shr[51]) goto L101;			// ожидание конца режима
L7_1:ObjBPN[6]->vBPN = 1;
L7_2: if(par_n[7])					// Есть задание на канал 8 
	{
		if(!shr[52])				// Есть активизация режима(вкл. нагр. кан. 8)
		{
			sh[52]  = 1;			// активация режима 52
			shr[52] = 1;
		}
		shr[33] = 8;	
		goto L8_2;					// переход на шаг 8_2
	}
	if(shr[52])						// Есть активизация режима(вкл. нагр. кан. 8)
	{
		sh[53]  = 1;				// активация режима 53			
		shr[53] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 8;
	goto L8_1;						// переход на шаг 8_1
L8: if(shr[53]) goto L101;			// ожидание конца режима
L8_1:ObjBPN[7]->vBPN = 1;
L8_2: if(par_n[8])					// Есть задание на канал 9 
	{
		if(!shr[54])				// Есть активизация режима(вкл. нагр. кан. 9)
		{
			sh[54]  = 1;			// активация режима 54
			shr[54] = 1;
		}
		shr[33] = 9;	
		goto L9_2;					// переход на шаг 9_2
	}
	if(shr[54])						// Есть активизация режима(вкл. нагр. кан. 9)
	{
		sh[55]  = 1;				// активация режима 55			
		shr[55] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 9;	
	goto L9_1;						// переход на шаг 9_1	
L9: if(shr[55]) goto L101;			// ожидание конца режима
L9_1:ObjBPN[8]->vBPN = 1;
L9_2: if(par_n[9])					// Есть задание на канал 10 
	{
		if(!shr[56])				// Есть активизация режима(вкл. нагр. кан. 10)
		{
			sh[56]  = 1;			// активация режима 56
			shr[56] = 1;
		}
		shr[33] = 10;	
		goto L10_2;					// переход на шаг 10_2
	}
	if(shr[56])						// Есть активизация режима(вкл. нагр. кан. 10)
	{
		sh[57]  = 1;				// активация режима 57			
		shr[57] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 10;	
	goto L10_1;						// переход на шаг 10_1	
L10: if(shr[57]) goto L101;			// ожидание конца режима
L10_1:ObjBPN[9]->vBPN = 1;
L10_2: if(par_n[10])				// Есть задание на канал 11 
	{
		if(!shr[58])				// Есть активизация режима(вкл. нагр. кан. 11)
		{
			sh[58]  = 1;			// активация режима 58
			shr[58] = 1;
		}
		shr[33] = 11;	
		goto L11_2;					// переход на шаг 11_2	
	}
	if(shr[58])						// Есть активизация режима(вкл. нагр. кан. 11)
	{
		sh[59]  = 1;				// активация режима 59			
		shr[59] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 11;	
	goto L11_1;						// переход на шаг 11_1	
L11: if(shr[59]) goto L101;			// ожидание конца режима
L11_1:ObjBPN[10]->vBPN = 1;
L11_2: if(par_n[11])				// Есть задание на канал 12 
	{
		if(!shr[60])				// Есть активизация режима(вкл. нагр. кан. 12)
		{
			sh[60]  = 1;			// активация режима 60
			shr[60] = 1;
		}
		shr[33] = 12;	
		goto L12_2;					// переход на шаг 12_2	
	}
	if(shr[60])						// Есть активизация режима(вкл. нагр. кан. 12)
	{
		sh[61]  = 1;				// активация режима 61			
		shr[61] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 12;	
	goto L12_1;						// переход на шаг 12_1
L12: if(shr[61]) goto L101;			// ожидание конца режима
L12_1:ObjBPN[11]->vBPN = 1;
L12_2: if(par_n[12])				// Есть задание на канал 13 
	{
		if(!shr[62])				// Есть активизация режима(вкл. нагр. кан. 13)
		{
			sh[62]  = 1;			// активация режима 62
			shr[62] = 1;
		}
		shr[33] = 13;	
		goto L13_2;					// переход на шаг 13_2	
	}
	if(shr[62])						// Есть активизация режима(вкл. нагр. кан. 13)
	{
		sh[63]  = 1;				// активация режима 63			
		shr[63] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 13;	
	goto L13_1;						// переход на шаг 13_1
L13: if(shr[63]) goto L101;			// ожидание конца режима
L13_1:ObjBPN[12]->vBPN = 1;
L13_2: if(par_n[13])				// Есть задание на канал 14 
	{
		if(!shr[64])				// Есть активизация режима(вкл. нагр. кан. 14)
		{
			sh[64]  = 1;			// активация режима 64
			shr[64] = 1;
		}
		shr[33] = 14;	
		goto L14_2;					// переход на шаг 14_2	
	}
	if(shr[64])						// Есть активизация режима(вкл. нагр. кан. 14)
	{
		sh[65]  = 1;				// активация режима 65			
		shr[65] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 14;	
	goto L14_1;						// переход на шаг 14_1
L14: if(shr[65]) goto L101;			// ожидание конца режима
L14_1:ObjBPN[13]->vBPN = 1;
L14_2: if(par_n[14])				// Есть задание на канал 15 
	{
		if(!shr[66])				// Есть активизация режима(вкл. нагр. кан. 15)
		{
			sh[66]  = 1;			// активация режима 66
			shr[66] = 1;
		}
		shr[33] = 15;	
		goto L15_2;					// переход на шаг 15_2	
	}
	if(shr[66])						// Есть активизация режима(вкл. нагр. кан. 15)
	{
		sh[67]  = 1;				// активация режима 67			
		shr[67] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 15;	
	goto L15_1;						// переход на шаг 15_1
L15: if(shr[67]) goto L101;			// ожидание конца режима
L15_1:ObjBPN[14]->vBPN = 1;
L15_2: if(par_n[15])				// Есть задание на канал 16 
	{
		if(!shr[68])				// Есть активизация режима(вкл. нагр. кан. 16)
		{
			sh[68]  = 1;			// активация режима 68
			shr[68] = 1;
		}
		shr[33] = 16;	
		goto L16_2;					// переход на шаг 15_2	
	}
	if(shr[68])						// Есть активизация режима(вкл. нагр. кан. 16)
	{
		sh[69]  = 1;				// активация режима 69			
		shr[69] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 16;	
	goto L16_1;						// переход на шаг 15_1
L16: if(shr[69]) goto L101;			// ожидание конца режима
L16_1:ObjBPN[15]->vBPN = 1;
L16_2: if(par_n[16])				// Есть задание на канал 17 
	{
		if(!shr[70])				// Есть активизация режима(вкл. нагр. кан. 16)
		{
			sh[70]  = 1;			// активация режима 70
			shr[70] = 1;
		}
		shr[33] = 17;	
		goto L17_2;					// переход на шаг 17_2	
	}
	if(shr[70])						// Есть активизация режима(вкл. нагр. кан. 16)
	{
		sh[71]  = 1;				// активация режима 71			
		shr[71] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 17;	
	goto L17_1;						// переход на шаг 17_1
L17: if(shr[71]) goto L101;			// ожидание конца режима
L17_1:ObjBPN[16]->vBPN = 1;
L17_2: if(par_n[17])				// Есть задание на канал 18 
	{
		if(!shr[72])				// Есть активизация режима(вкл. нагр. кан. 18)
		{
			sh[72]  = 1;			// активация режима 72
			shr[72] = 1;
		}
		shr[33] = 18;	
		goto L18_2;					// переход на шаг 18_2	
	}
	if(shr[72])						// Есть активизация режима(вкл. нагр. кан. 18)
	{
		sh[73]  = 1;				// активация режима 73			
		shr[73] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 18;	
	goto L18_1;						// переход на шаг 18_1	
L18: if(shr[73]) goto L101;			// ожидание конца режима
L18_1:ObjBPN[17]->vBPN = 1;
L18_2: if(par_n[18])				// Есть задание на канал 19 
	{
		if(!shr[74])				// Есть активизация режима(вкл. нагр. кан. 19)
		{
			sh[74]  = 1;			// активация режима 74
			shr[74] = 1;
		}
		shr[33] = 19;	
		goto L19_2;					// переход на шаг 19_2	
	}
	if(shr[74])						// Есть активизация режима(вкл. нагр. кан. 19)
	{
		sh[75]  = 1;				// активация режима 75			
		shr[75] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 19;	
	goto L19_1;						// переход на шаг 19_1
L19: if(shr[75]) goto L101;			// ожидание конца режима
L19_1:ObjBPN[18]->vBPN = 1;
L19_2: if(par_n[19])				// Есть задание на канал 20
	{
		if(!shr[76])				// Есть активизация режима(вкл. нагр. кан. 20)
		{
			sh[76]  = 1;			// активация режима 76
			shr[76] = 1;
		}
		shr[33] = 20;
		goto L20_2;					// переход на шаг 20_2
	}
	if(shr[76])						// Есть активизация режима(вкл. нагр. кан. 20)
	{
		sh[77]  = 1;				// активация режима 77
		shr[77] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 20;
	goto L20_1;						// переход на шаг 20_1
L20: if(shr[77]) goto L101;			// ожидание конца режима
L20_1:ObjBPN[19]->vBPN = 1;
L20_2: if(par_n[20])				// Есть задание на канал 21
	{
		if(!shr[78])				// Есть активизация режима(вкл. нагр. кан. 21)
		{
			sh[78]  = 1;			// активация режима 78
			shr[78] = 1;
		}
		shr[33] = 21;
		goto L21_2;					// переход на шаг 21_2
	}
	if(shr[78])						// Есть активизация режима(вкл. нагр. кан. 21)
	{
		sh[79]  = 1;				// активация режима 79
		shr[79] = 1;
        sh_ = 0;
		goto L101;
	}
	shr[33] = 21;
	goto L21_1;
L21: if(shr[79]) goto L101;			// ожидание конца режима
L21_1:ObjBPN[20]->vBPN = 1;
L21_2: if(par_n[22])				// Есть задание на канал 23
	{
		if(!shr[80])				// Есть активизация режима(вкл. нагр. кан. 23)
		{
			sh[80]  = 1;			// активация режима 80
			shr[80] = 1;
		}
		shr[33] = 22;
		goto L22_2;					// переход на шаг 22_2
	}
	if(shr[80])						// Есть активизация режима(вкл. нагр. кан. 23)
	{
		sh[81]  = 1;				// активация режима 81
		shr[81] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[33] = 22;
	goto L22_1;						// переход на шаг 22_1
L22: if(shr[81]) goto L101;			// ожидание конца режима
L22_1:ObjBPN[22]->vBPN = 1;
L22_2: if(par_n[23])				// Есть задание на канал 24
	{
		if(!shr[82])				// Есть активизация режима(вкл. нагр. кан. 24)
		{
			sh[82]  = 1;			// активация режима 82
			shr[82] = 1;
		}
		shr[33] = 1;
        sh_ = 1;
		goto L101;
	}
	if(shr[82])						// Есть активизация режима(вкл. нагр. кан. 24)
	{
		sh[83]  = 1;				// активация режима 83
		shr[83] = 1;
        shr[33]=1;
		sh_ = 1;
		goto L101;
	}
	shr[33] = 23;
	goto L23_1;						// переход на шаг 23_1
L23: if(shr[83]) goto L101;			// ожидание конца режима
L23_1:ObjBPN[23]->vBPN = 1;
      shr[33]=1;
      sh_ = 1;
      goto L101;
}
//---------------------------------------------------------------------------
void R_34() // режим 34 "Откл. нагрева"
{
	sh_ = sh[34];

L00:if (shr[34] == 1) goto L1;        
	if (shr[34] == 2) goto L2;
	if (shr[34] == 3) goto L3;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[34] = sh_;
	if (sh[34] != 0) goto L100;   	// SH != 0
	shr[34]++;                    	// след.шаг сч.шр1
	if (shr[34] > 3) goto L0;    	// число шагов режима
	sh[34] = 1;
L100: return;                  		// возврат в "кольцо"

L0: shr[34] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: shr[33] = 0;
    sh[33] = 0;
    if(shr[40])						// Есть активация режима 40?
	{
		sh[41]  = 1;				// активизация режима 41
		shr[41] = 1;
	}
	if(shr[42])						// Есть активация режима 42?
	{
		sh[43]  = 1;				// активизация режима 43
		shr[43] = 1;
	}
	/*if(shr[44])						// Есть активация режима 44?
	{
		sh[45]  = 1;				// активизация режима 45
		shr[45] = 1;
	}
	if(shr[46])						// Есть активация режима 46?
	{
		sh[47]  = 1;				// активизация режима 47
		shr[47] = 1;
	}            */
	if(shr[48])						// Есть активация режима 48?
	{
		sh[49]  = 1;				// активизация режима 49
		shr[49] = 1;
	}
    if(shr[50])						// Есть активация режима 50?
	{
		sh[51]  = 1;				// активизация режима 51
		shr[51] = 1;
	}
	if(shr[52])						// Есть активация режима 52?
	{
		sh[53]  = 1;				// активизация режима 53
		shr[53] = 1;
	}
	if(shr[54])						// Есть активация режима 54?
	{
		sh[55]  = 1;				// активизация режима 55
		shr[55] = 1;
	}
	if(shr[56])						// Есть активация режима 56?
	{
		sh[57]  = 1;				// активизация режима 57
		shr[57] = 1;
	}
	if(shr[58])						// Есть активация режима 58?
	{
		sh[59]  = 1;				// активизация режима 59
		shr[59] = 1;
	}
	if(shr[60])						// Есть активация режима 60?
	{
		sh[61]  = 1;				// активизация режима 61
		shr[61] = 1;
	}
	if(shr[62])						// Есть активация режима 62?
	{
		sh[63]  = 1;				// активизация режима 63
		shr[63] = 1;
	}
	if(shr[64])						// Есть активация режима 64?
	{
		sh[65]  = 1;				// активизация режима 65
		shr[65] = 1;
	}
	if(shr[66])						// Есть активация режима 66?
	{
		sh[67]  = 1;				// активизация режима 67
		shr[67] = 1;
	}
	if(shr[68])						// Есть активация режима 68?
	{
		sh[69]  = 1;				// активизация режима 69
		shr[69] = 1;
	}
	if(shr[70])						// Есть активация режима 70?
	{
		sh[71]  = 1;				// активизация режима 71
		shr[71] = 1;
	}
	if(shr[72])						// Есть активация режима 72?
	{
		sh[73]  = 1;				// активизация режима 73
		shr[73] = 1;
	}
	if(shr[74])						// Есть активация режима 74?
	{
		sh[75]  = 1;				// активизация режима 75
		shr[75] = 1;
	}
	if(shr[76])						// Есть активация режима 76?
	{
		sh[77]  = 1;				// активизация режима 77
		shr[77] = 1;
	}
	if(shr[78])						// Есть активация режима 78?
	{
		sh[79]  = 1;				// активизация режима 79
		shr[79] = 1;
	}
    if(shr[80])						// Есть активация режима 80?
	{
		sh[81]  = 1;				// активизация режима 81
		shr[81] = 1;
	}
    if(shr[82])						// Есть активация режима 82?
	{
		sh[83]  = 1;				// активизация режима 83
		shr[83] = 1;
	}
    if(shr[84])						// Есть активация режима 84?
	{
		sh[85]  = 1;				// активизация режима 85
		shr[85] = 1;
	}
	sh_ = 0;
	goto L101;
L2: if(shr[41]||shr[43]||shr[45]||shr[47]||shr[51]||shr[53]||shr[55]||shr[57]||shr[59]||shr[61]||shr[63]||shr[65]||shr[67]||shr[69]||shr[71]||shr[73]||shr[75]||shr[77]||shr[79]||shr[81]||shr[83]||shr[85]) goto L101; 	// ожидание конца режимов
	sh_ = 0;
	goto L101;
L3: OBPN();							// отключение БПН
	if(sh_) goto L101;
	diagn[16] &= (~0xE7);			// сброс диагностик БПН и контроля ответов БПН
	goto L101;
}
//---------------------------------------------------------------------------

void UPR_Klapan( unsigned int N_Rec)		// Подпр. "Управление клапанами"
{
	if(N_Rec & 0x01)			// закрыт/открыт VP13
	{
		SetOut(1,2,0x4000);		// включить VP13
	}
	else
	{
		SetOut(0,2,0x4000);		// выключить VP13
	}
	if(N_Rec & 0x02)			// закрыт/открыт VP14
	{
		SetOut(1,2,0x800);		// включить VP14
	}
	else
	{
		SetOut(0,2,0x800);		 // выключить VP14
	}
	if(N_Rec & 0x04)			// закрыт/открыт VP15
	{
		SetOut(1,2,0x1000);		// включить VP15
	}
	else
	{
		SetOut(0,2,0x1000);		// выключить VP15
	}
	if(N_Rec & 0x08)			// закрыт/открыт VP16
	{
		SetOut(1,3,0x20);		// включить VP16
	}
	else
	{
		SetOut(0,3,0x20);		// выключить VP16
	}
	if(N_Rec & 0x10)			// закрыт/открыт VP17
	{
		SetOut(1,3,0x800);		// включить VP17
	}
	else
	{
		SetOut(0,3,0x800);		// выключить VP17
	}
	if(N_Rec & 0x20)			// закрыт/открыт VP18
	{
		SetOut(1,3,0x08);		// включить VP18
	}
	else
	{
		SetOut(0,3,0x08);		// выключить VP18
	}
        if(N_Rec & 0x40)		// закрыт/открыт VP19
	{
		SetOut(1,3,0x02);		// включить VP19
	}
	else
	{
		SetOut(0,3,0x02);		// выключить VP19
	}
        if(N_Rec & 0x80)		// закрыт/открыт VP20
	{
		SetOut(1,3,0x04);		// включить VP20
	}
	else
	{
		SetOut(0,3,0x04);		// выключить VP20
	}
	if(N_Rec & 0x100)		// закрыт/открыт VP21
	{
		SetOut(1,3,0x400);		// включить VP21
	}
	else
	{
		SetOut(0,3,0x400);		// выключить VP21
	}
        if(N_Rec & 0x200)		// закрыт/открыт VP22
	{
		SetOut(1,3,0x10);		// включить VP22
	}
	else
	{
		SetOut(0,3,0x10);		// выключить VP22
	}
    //инверсия///
        if(N_Rec & 0x400)		// закрыт/открыт VP23
	{
		SetOut(0,3,0x01);		// выключить VP23
	}
	else
	{
		SetOut(1,3,0x01);		// включить VP23
	}
    /////////
        if(N_Rec & 0x800)		// закрыт/открыт VP24
	{
		SetOut(1,3,0x40);		// включить VP24
	}
	else
	{
		SetOut(0,3,0x40);		// выключить VP24
	}
        if(N_Rec & 0x1000)		// закрыт/открыт VP25
	{
		SetOut(1,3,0x100);		// включить VP25
	}
	else
	{
		SetOut(0,3,0x100);		// выключить VP25
	}
        if(N_Rec & 0x2000)		// закрыт/открыт VP26
	{
		SetOut(1,3,0x80);		// включить VP26
	}
	else
	{
		SetOut(0,3,0x80);		// выключить VP26
	}
        if(N_Rec & 0x4000)		// закрыт/открыт VP27
	{
		SetOut(1,3,0x200);		// включить VP27
	}
	else
	{
		SetOut(0,3,0x200);		// выключить VP27
	}
        if(N_Rec & 0x8000)		// закрыт/открыт VP28
	{
		SetOut(1,3,0x1000);		// включить VP28
	}
	else
	{
		SetOut(0,3,0x1000);		// выключить VP28
	}
	if(N_Rec & 0x10000)	// закрыт/открыт VP29
	{
		SetOut(1,3,0x2000);		// включить VP29
	}
	else
	{
		SetOut(0,3,0x2000);		// выключить VP29
	}
    if(N_Rec & 0x20000)	// закрыт/открыт VP35
	{
		SetOut(1,4,0x2000);		// включить VP35
	}
	else
	{
		SetOut(0,4,0x2000);		// выключить VP35
	}
    if(N_Rec & 0x40000)	// закрыт/открыт VP39
	{
		SetOut(1,2,0x8000);		// включить VP39
	}
	else
	{
		SetOut(0,2,0x8000);		// выключить VP39
	}
    if(N_Rec & 0x80000)	// закрыт/открыт VP40
	{
		SetOut(1,3,0x4000);		// включить VP40
	}
	else
	{
		SetOut(0,3,0x4000);		// выключить VP40
	}
    if(N_Rec & 0x100000)	// закрыт/открыт VP41
	{
		SetOut(1,3,0x8000);		// включить VP41
	}
	else
	{
		SetOut(0,3,0x8000);		// выключить VP41
	}


}
//---------------------------------------------------------------------------
void R_37() // режим 39 "МКС в исходное"
{
	sh_ = sh[37];
	if((shr[37] < 1) || (shr[37] > 2)) goto L100; // на выход

L00:if(shr[37] == 1) goto L1;
	if(shr[37] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[37] = sh_;
	if (sh[37] != 0) goto L100;		// SH != 0
	shr[37]++;			        // след.шаг
	if (shr[37] > 2) goto L0;		// число шагов режима
	sh[37] = 1;
L100: return;				        // возврат в "кольцо"

L0:	norma = 110;			        // норма: "Мех. кассеты в исходном"
	shr[37] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[38] = 0;			        // сброс активации режима 19
	shr[38] = 0;
	diagn[34] &= (~0xFF);		        // сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_KAS(par[0][16],0,0,1,60);		// механизм кассеты в исх.
	goto L101;
}
//---------------------------------------------------------------------------
void R_38() // режим 38 "МКС вверх/вниз"
{
	sh_ = sh[38];
	if ((shr[38] < 1) || (shr[38] > 2)) goto L100; // на выход

L00:if(shr[38] == 1) goto L1;
	if(shr[38] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[38] = sh_;
	if(sh[38] != 0) goto L100;		// SH != 0
	shr[38]++;			        // след.шаг
	if(shr[38] > 2) goto L0;		// число шагов режима
	sh[38] = 1;
L100:return;				        // возврат в "кольцо"

L0:	norma = 111;			        // норма: "Механизм. кассеты путь прошел"
	shr[38] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[37] = 0;			        // сброс активации режима 39
	shr[37] = 0;
	diagn[34] &= (~0xFF);		        // сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_KAS(par[0][16],OTN,par[0][18],0,60);     // механизм кассеты вверх/вниз
	goto L101;
}
//---------------------------------------------------------------------------
void VIDK_KAS(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. кассеты
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x04) return;	// нет связи с контроллером
	SetOut(0,1,0x02);				// снять Стоп механизмов
	PR_KAS = 1;
	CT_KAS = 0;
	sh_ = 2;
A2:	if(!(zin[4]&0x20))				// нет готовности привода
	{
		if(CT_KAS >= 5)
			diagn[34] |= 0x01;		// отказ: "Нет готовности привода кассеты"
		return;
	}
	diagn[34] &= (~0x01);			// сброс диагностики
	OTVET_KAS = 0;
	V_KAS = a;
	TYPE_KAS = b;
	PUT_KAS = c;
	HOME_KAS = d;
	KOM_KAS = 1;
	CT_KAS = 0;
    TEK_OTN_KAS = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x04 || !OTVET_KAS)	// есть диагностика нет связи или нет ответа
	{
		if(CT_KAS >= 5)
			diagn[34] |= 0x04;		// отказ: "Нет ответа на команду кассеты"
		return;
	}
	diagn[34] &= (~0x04);			// сброс диагностики
	KOM_KAS = 0;
	if(!HOME_KAS)					// не движение в HOME
	{
		SetOut(1,0,0x2000);           // выдать движение
		CT_KAS = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,0,0x4000);              // выдать движение в Home
	CT_KAS = 0;
	sh_ = 4;
A4:	if(!(zin[4]&0x40)||(TEK_ABS_KAS))
    // механизм не пришел в HOME
	{
		if(CT_KAS >= e)
			diagn[34] |= 0x08;		// отказ: "Мех. кассеты не пришел в пол. HOME"
		return;
	}
	diagn[34] &= (~0x08);			// сброс диагностики
	SetOut(0,0,0x4000);              // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[4]&0x20))				// нет готовности привода
	{
		if(CT_KAS >= 5)
			diagn[34] |= 0x01;		// отказ: "Нет готовности привода кассеты"
		return;
	}
	diagn[34] &= (~0x01);			// сброс диагностики
	PR_KAS = 0;
	norma = 110;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[4]&0x20)				    // есть готовность привода
	{
		if(CT_KAS >= 5)
			diagn[34] |= 0x02;		// отказ: "Нет ответа на START движ. кассеты"
		return;
	}
	diagn[34] &= (~0x02);			// сброс диагностики
	SetOut(0,0,0x2000);               // сбросить начало движение
	CT_KAS = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[4]&0x20)||((TYPE_KAS==ABS)&&(PUT_KAS!=TEK_ABS_KAS))||((TYPE_KAS==OTN)&&(PUT_KAS!=TEK_OTN_KAS)))
    // есть готовность привода
	{
		if(CT_KAS >= e)
			diagn[34] |= 0x10;		// отказ: "Нет завершения движ. кассеты"
		return;
	}
	diagn[34] &= (~0x10);			// сброс диагностики
	PR_KAS = 0;
	norma = 111;
    SetOut(1,1,0x02);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
bool KasVPaze() 		// подпрограмма проверки нахождения кассеты между пазами
{
        int PAZ;
        for(int n = 0;n < 25;n++)
        {
                PAZ = par_t[0] - int(par_t[5]) + int(par_t[4]*n);
                if(((PAZ-20)<TEK_ABS_KAS)&&((PAZ+20)>TEK_ABS_KAS)) return true;
        }
        return false;
}
//------------------------------------------------------------------------------
void R_40()							// РЕЖИМ 40 "Включить нагрев канала 1"
{
	// выставление параметра канала
	ObjBPN[0]->parBPN = par_n[0];

	// запуск режима
	BPNOn(ObjBPN[0]);				// включение нагерва канала 1
}
//---------------------------------------------------------------------------
void R_41()							// РЕЖИМ 41 "Выключить нагрев канала 1"
{
	BPNOff(ObjBPN[0]);				// выключение нагерва канала 1
}
//---------------------------------------------------------------------------
void R_42()							// РЕЖИМ 42 "Включить нагерв канала 2"
{
	// выставление параметра канала
	ObjBPN[1]->parBPN = par_n[1];

	// запуск режима
	BPNOn(ObjBPN[1]);				// включение нагерва канала 2
}
//---------------------------------------------------------------------------
void R_43()							// РЕЖИМ 43 "Выключить нагерв канала 2"
{
	BPNOff(ObjBPN[1]);				// выключение нагерва канала 2
}
//---------------------------------------------------------------------------

void R_48()							// РЕЖИМ 48 "Включить нагрев канала 6"
{
	// выставление параметра канала
	ObjBPN[5]->parBPN = par_n[5];

	// запуск режима
	BPNOn(ObjBPN[5]);				// включение нагрева канала 6
}
//---------------------------------------------------------------------------
void R_49()							// РЕЖИМ 49 "Выключить нагрев канала 6"
{
	BPNOff(ObjBPN[5]);				// выключение нагрева канала 6
}
//---------------------------------------------------------------------------
void R_50()							// РЕЖИМ 50 "Включить нагрев канала 7"
{
	// выставление параметра канала
	ObjBPN[6]->parBPN = par_n[6];
	
	// запуск режима
	BPNOn(ObjBPN[6]);				// включение нагрева канала 7
}
//---------------------------------------------------------------------------
void R_51()							// РЕЖИМ 51 "Выключить нагрев канала 7"
{
	BPNOff(ObjBPN[6]);				// выключение нагрева канала 7
}
//---------------------------------------------------------------------------
void R_52()							// РЕЖИМ 52 "Включить нагрев канала 8"
{
	// выставление параметра канала
	ObjBPN[7]->parBPN = par_n[7];
	
	// запуск режима
	BPNOn(ObjBPN[7]);				// включение нагрева канала 8
}
//---------------------------------------------------------------------------
void R_53()							// РЕЖИМ 53 "Выключить нагрев канала 8"
{
	BPNOff(ObjBPN[7]);				// выключение нагрева канала 8
}
//---------------------------------------------------------------------------
void R_54()							// РЕЖИМ 54 "Включить нагрев канала 9"
{
	// выставление параметра канала
	ObjBPN[8]->parBPN = par_n[8];
	
	// запуск режима
	BPNOn(ObjBPN[8]);				// включение нагрева канала 9
}
//---------------------------------------------------------------------------
void R_55()							// РЕЖИМ 55 "Выключить нагрев канала 9"
{
	BPNOff(ObjBPN[8]);				// выключение нагрева канала 9
}
//---------------------------------------------------------------------------
void R_56()							// РЕЖИМ 56 "Включить нагрев канала 10"
{
	// выставление параметра канала
	ObjBPN[9]->parBPN = par_n[9];
	
	// запуск режима
	BPNOn(ObjBPN[9]);				// включение нагрева канала 10
}
//---------------------------------------------------------------------------
void R_57()							// РЕЖИМ 57 "Выключить нагрев канала 10"
{
	BPNOff(ObjBPN[9]);				// выключение нагрева канала 10
}
//---------------------------------------------------------------------------
void R_58()							// РЕЖИМ 58 "Включить нагрев канала 11"
{
	// выставление параметра канала
	ObjBPN[10]->parBPN = par_n[10];
	
	// запуск режима
	BPNOn(ObjBPN[10]);				// включение нагрева канала 11
}
//---------------------------------------------------------------------------
void R_59()							// РЕЖИМ 59 "Выключить нагрев канала 11"
{
	BPNOff(ObjBPN[10]);				// выключение нагрева канала 11
}
//---------------------------------------------------------------------------
void R_60()							// РЕЖИМ 60 "Включить нагрев канала 12"
{
	// выставление параметра канала
	ObjBPN[11]->parBPN = par_n[11];
	
	// запуск режима
	BPNOn(ObjBPN[11]);				// включение нагрева канала 12
}
//---------------------------------------------------------------------------
void R_61()							// РЕЖИМ 61 "Выключить нагрев канала 12"
{
	BPNOff(ObjBPN[11]);				// выключение нагрева канала 12
}
//---------------------------------------------------------------------------
void R_62()							// РЕЖИМ 62 "Включить нагрев канала 13"
{
	// выставление параметра канала
	ObjBPN[12]->parBPN = par_n[12];
	
	// запуск режима
	BPNOn(ObjBPN[12]);				// включение нагрева канала 13
}
//---------------------------------------------------------------------------
void R_63()							// РЕЖИМ 63 "Выключить нагрев канала 13"
{
	BPNOff(ObjBPN[12]);			// выключение нагрева канала 13
}
//---------------------------------------------------------------------------
void R_64()							// РЕЖИМ 60 "Включить нагрев канала 14"
{
	// выставление параметра канала
	ObjBPN[13]->parBPN = par_n[13];
	
	// запуск режима
	BPNOn(ObjBPN[13]);				// включение нагрева канала 14
}
//---------------------------------------------------------------------------
void R_65()							// РЕЖИМ 61 "Выключить нагрев канала 14"
{
	BPNOff(ObjBPN[13]);				// выключение нагрева канала 14
}
//---------------------------------------------------------------------------
void R_66()							// РЕЖИМ 66 "Включить нагрев канала 15"
{
	// выставление параметра канала
	ObjBPN[14]->parBPN = par_n[14];
	
	// запуск режима
	BPNOn(ObjBPN[14]);				// включение нагрева канала 15
}
//---------------------------------------------------------------------------
void R_67()							// РЕЖИМ 67 "Выключить нагрев канала 15"
{
	BPNOff(ObjBPN[14]);				// включение нагрева канала 15
}
//---------------------------------------------------------------------------
void R_68()							// РЕЖИМ 68 "Включить нагрев канала 16"
{
	// выставление параметра канала
	ObjBPN[15]->parBPN = par_n[15];
	
	// запуск режима
	BPNOn(ObjBPN[15]);				// включение нагрева канала 16
}
//---------------------------------------------------------------------------
void R_69()							// РЕЖИМ 69 "Выключить нагрев канала 16"
{
	BPNOff(ObjBPN[15]);				// включение нагрева канала 16
}
//---------------------------------------------------------------------------
void R_70()							// РЕЖИМ 70 "Включить нагрев канала 17"
{
	// выставление параметра канала
	ObjBPN[16]->parBPN = par_n[16];
	
	// запуск режима
	BPNOn(ObjBPN[16]);				// включение нагрева канала 17
}
//---------------------------------------------------------------------------
void R_71()							// РЕЖИМ 71 "Выключить нагрев канала 17"
{
	BPNOff(ObjBPN[16]);				// выключение нагрева канала 17
}
//---------------------------------------------------------------------------
void R_72()							// РЕЖИМ 72 "Включить нагрев канала 18"
{
	// выставление параметра канала
	ObjBPN[17]->parBPN = par_n[17];

	// запуск режима
	BPNOn(ObjBPN[17]);			// включение нагрева канала 18
}
//---------------------------------------------------------------------------
void R_73()							// РЕЖИМ 73 "Выключить нагрев канала 18"
{
	BPNOff(ObjBPN[17]);				// выключение нагрева канала 18
}
//---------------------------------------------------------------------------
void R_74()							// РЕЖИМ 74 "Включить нагрев канала 19"
{
	// выставление параметра канала
	ObjBPN[18]->parBPN = par_n[18];
	
	// запуск режима
	BPNOn(ObjBPN[18]);				// включение нагрева канала 19
}
//---------------------------------------------------------------------------
void R_75()							// РЕЖИМ 75 "Выключить нагрев канала 19"
{
	BPNOff(ObjBPN[18]);				// выключение нагрева канала 19
}
//---------------------------------------------------------------------------
void R_76()							// РЕЖИМ 76 "Включить нагрев канала 20"
{
	// выставление параметра канала
	ObjBPN[19]->parBPN = par_n[19];
	
	// запуск режима
	BPNOn(ObjBPN[19]);				// включение нагрева канала 20
}
//---------------------------------------------------------------------------
void R_77()							// РЕЖИМ 77 "Выключить нагрев канала 20"
{
	BPNOff(ObjBPN[19]);				// выключение нагрева канала 20
}
//---------------------------------------------------------------------------
void R_78()							// РЕЖИМ 78 "Включить нагрев канала 21"
{
	// выставление параметра канала
	ObjBPN[20]->parBPN = par_n[20];

	// запуск режима
	BPNOn(ObjBPN[20]);				// включение нагрева канала 21
}
//---------------------------------------------------------------------------
void R_79()							// РЕЖИМ 79 "Выключить нагрев канала 21"
{
	BPNOff(ObjBPN[20]);				// выключение нагрева канала 21
}
//---------------------------------------------------------------------------
void R_80()							// РЕЖИМ 78 "Включить нагрев канала 23"
{
	// выставление параметра канала
	ObjBPN[22]->parBPN = par_n[22];

	// запуск режима
	BPNOn(ObjBPN[22]);				// включение нагрева канала 23
}
//---------------------------------------------------------------------------
void R_81()							// РЕЖИМ 79 "Выключить нагрев канала 23"
{
	BPNOff(ObjBPN[22]);				// выключение нагрева канала 23
}
//---------------------------------------------------------------------------
void R_82()							// РЕЖИМ 78 "Включить нагрев канала 24"
{
	// выставление параметра канала
	ObjBPN[23]->parBPN = par_n[23];

	// запуск режима
	BPNOn(ObjBPN[23]);				// включение нагрева канала 24
}
//---------------------------------------------------------------------------
void R_83()							// РЕЖИМ 79 "Выключить нагрев канала 24"
{
	BPNOff(ObjBPN[23]);				// выключение нагрева канала 24
}
void R_84()							// РЕЖИМ 78 "Включить нагрев канала 5"
{
	// выставление параметра канала
	ObjBPN[4]->parBPN = par_n[4];

	// запуск режима
	BPNOn(ObjBPN[4]);				// включение нагрева канала 5
}
//---------------------------------------------------------------------------
void R_85()							// РЕЖИМ 79 "Выключить нагрев канала 5"
{
	BPNOff(ObjBPN[4]);				// выключение нагрева канала 5
}
//------------------------------------------------------------------------------
//---------  ПОДПРОГРАММЫ  -----------------------------------------------------
//------------------------------------------------------------------------------
 /*
bool KasVPaze() 		// подпрограмма проверки нахождения кассеты между пазами
{
        int PAZ;
        for(int n = 0;n < 25;n++)
        {
                PAZ = par_t[0] - int(par_t[5]) + int(par_t[4]*n);
                if(((PAZ-1667)<TEK_ABS_KAS)&&((PAZ+1667)>TEK_ABS_KAS)) return true;
        }
        return false;
}    */
//------------------------------------------------------------------------------
void SBROS_MEH() 				// режим "Сброс механизмов"
{
	// сброс движения МАН
	// сброс режимов
	shr[9] 	= 0;				// транспортный тест	
	sh[9]  	= 0;
	shr[12] = 0;           		// МАН перемещения в исходное
	sh[12]  = 0;
	shr[13] = 0;           		// МАН перемещения вперед/назад
	sh[13]  = 0;
	shr[14] = 0;           		// МАН поворота в исходное
	sh[14]  = 0;
	shr[15]	= 0;				// МВП поворота вправо/влево
	sh[15]	= 0;
	shr[37]	= 0;				// Кассета в HOME
	sh[37]	= 0;
	shr[38]	= 0;				// Кассета вверх/вниз
	sh[38]	= 0;
    diagn[34] &=  (~0x3F);		// сброс диагностик МАН поворота
    diagn[33] &=  (~0xFC);		// сброс диагностик МАН поворота
	diagn[5] &=  (~0xFF);		// сброс диагностик МАН перемещения
	diagn[25] &= (~0xFF);		// сброс диагностик
    diagn[26] &= (~0xFF);		// сброс диагностик    
    diagn[27] &= (~0xFF);		// сброс диагностик
    diagn[28] &= (~0xFF);       // сброс диагностик
    diagn[8] &= (~0xFF);
	diagn[11] &= (~0xF0);
	SetOut(0,1,0x05);			// Отключение движения механизмов
	SetOut(0,0,0x7800);
	SetOut(1,1,0x02);			// СТОП движение
    PR_PER=0;
    PR_POV=0;
    PR_KAS=0;
	norma = 45;					// сброс механизмов завершен
}
//------------------------------------------------------------------------------
void VRR_GIR()						// подпрограмма "Выставить разр. работы ВЧГ реактора"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(1,4,0x100);				// выставить разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[4] & 0x02) == 0)		// разр.раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[7] |= 0x10;			// отказ:"Разр. работы ВЧГ не выставилось"
		return;
	}
	diagn[7] &= (~0x10);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------
void ORR_GIR()						// подпрограмма "Снять разр. работы ВЧГ реактора"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(0,4,0x100);				// снять разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[4] & 0x02) != 0)		// разр.раб. не снято
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[7] |= 0x20;			// отказ: "Разр. работы ВЧГ не снялось"
		return;
	}
	diagn[7] &= (~0x20);			// сброс диагностики
	sh_ = 0;
}
//---------------------------------------------------------------------------
void PUSK_TP ()						//Пуск ТП
{
	if(KOM_MOD&0x40)				//есть команда "Пуск ТП"
	{
		if(!shr[4])
		{
			shr[4]=1;				//активизировать режим 4
			sh[4]=1;				//"Технологический процесс"
		}
	}
	if(shr[4])
		OTVET_MOD|=0x40;		//запись активизации режима 4
	else
		OTVET_MOD	&=(~0x40);
}
//------------------------------------------------------------------------------
void OPROS_SOST ()			// подпрограмма "Опрос и запись состояния"
{
	if(zin[1] & 0x40)OTVET_MOD |= 0x08;		//запись положения подъёмника
	else OTVET_MOD &= (~0x08);
	
    if(zin[1] & 0x80)OTVET_MOD |= 0x10;		//запись положения подъёмника
	else OTVET_MOD &= (~0x10);
	
	OTVET_MOD |= 0x20;	//запись состояния прижима
	
	if(!(diagnS[0]&0x08)&&(zin[0]&0x4000))   //есть связь с датчиком вакуума и Кл-Д4 открыт
	{
	    if (D_D4 <=nasmod[1])
            {
                OTVET_MOD |= 0x04;	// если давление меньше или равно рабочему вакууму
                OTVET_MOD &= (~0x03);
            }
            else if((D_D4>nasmod[1])&&(D_D4<=UVAKV_KAM))
            {
                OTVET_MOD |= 0x03;	// если давление больше рабочего вакуума и меньше или равно 8 ПА
                OTVET_MOD &= (~0x04);
            }
            else if((D_D4>UVAKV_KAM)&&(D_D4<=UATM_D4))
            {
                OTVET_MOD |= 0x02;// если давление больше 8 ПА и меньше или равно АТМ
                OTVET_MOD &= (~0x05);
            }
            else
            {
                OTVET_MOD |= 0x01; //иначе
                OTVET_MOD &= (~0x06);
            }
	}
    else OTVET_MOD &= (~0x07);
	
	OTVET_MOD|=0x80;								
	for (int i=1;i<=38;i++)					//если нет активиз. режимов кроме
	{												//"Нагрев кам."
		if((i!=33)&&(i!=34)&&
		(shr[i]))
		{
			OTVET_MOD&=(~0x80);
			break;
		}
	}
}
//------------------------------------------------------------------------------
void UPR()								// подъём/опускание штырей (управл.)
{
	if(((KOM_MOD&0x18)!=0x18)&&((KOM_MOD&0x18)!=0x00)) // если 4ый и 5ый биты не равны
	{
		if(KOM_MOD&0x08)
                {       // если 4ый бит 1 то подъёмник вверх
                        SetOut(1,0,0x200);
                        SetOut(0,0,0x400);
                }
		else		// иначе вниз
                {
                        SetOut(0,0,0x200);
                        SetOut(1,0,0x400);
                }
	}
}