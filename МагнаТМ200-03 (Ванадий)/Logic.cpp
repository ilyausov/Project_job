 //---------------------------------------------------------------------------
#pragma hdrstop
#include "Logic.h"
#include "Modules\RRG\RRG.cpp"
#include "Modules\Klapan\Klapan.cpp"

//---------------------------------------------------------------------------
#pragma package(smart_init)

void LogicMain ()
{
    KOLCO();                    // кольцо
    if ( shr[1] )               // Проверка
    {                           // активации
        R_1();                  // режима 1 "Откачка камеры"
    };
    if ( shr[2] )               // Проверка
    {                           // активации
        R_2();                  // режима 2 "Тренировка"
    };
	if ( shr[3] )               // Проверка
    {                           // активации
        R_3();                  // режима 3 "Рабочий цикл"
    };
	if ( shr[4] )               // Проверка
    {                           // активации
        R_4();                  // режима 4 "Технологический процесс"
    };
    if ( shr[5] )               // Проверка
    {                           // активации
        R_5();                  // режима 5 "Сброс РЦ"
    };
	if ( shr[6] )               // Проверка
    {                           // активации
        R_6();                  // режима 6 "Сбор(выгрузка) пластин"
    };
    if ( shr[7] )               // Проверка
    {                           // активации
        R_7();                  // режима 7 "Отключение установки"
    };
	if ( shr[8] )               // Проверка
    {                           // активации
        R_8();                  // режима 8 "Аварийное отключение установки"
    };
	if ( shr[9] )               // Проверка
    {                           // активации
        R_9();                  // режима 9 "Транспортный тест"
    };	
	if ( shr[10] )               // Проверка
    {                            // активации
        R_10();                  // режима 10 "Открыть ЩЗ"
    };
    if ( shr[11] )               // Проверка
    {                            // активации
        R_11();                  // режима 11 "Закрыть ЩЗ"
    };
	if ( shr[12] )               // Проверка
    {                            // активации
        R_12();                  // режима 12 "Ман. в исх"
    };
	if ( shr[13] )               // Проверка
    {                            // активации
        R_13();                  // режима 13 "Ман. вперед/назад"
    };
	if ( shr[14] )               // Проверка
    {                            // активации
        R_14();                  // режима 14 "Подъём п/д в кам"
    };
	if ( shr[15] )               // Проверка
    {                            // активации
        R_15();                  // режима 15 "Подъём п/д в HOME"
    };
    if ( shr[16] )               // Проверка
    {                            // активации
        R_16();                  // режима 16 "Вращение п/д в home"
    };
	if ( shr[17] )               // Проверка
    {                            // активации
        R_17();                  // режима 17 "Вращение п/д на угол"
    };
    if ( shr[18] )               // Проверка
    {                            // активации
        R_18();                  // режима 18 "Подъём п/д в рабочее положение"
    };
    if ( shr[19] )               // Проверка
    {                            // активации
        R_19();                  // режима 19 "ВысВак откачка шлюза"
    };
    if ( shr[20] )              // Проверка
    {                           // активации
        R_20();                 // режима 20 "РРГ1"
    };	
    if ( shr[21] )              // Проверка
    {                           // активации
        R_21();                 // режима 21 "РРГ2"
    };
    if ( shr[22] )              // Проверка
    {                           // активации
        R_22();                 // режима 22 "РРГ3"
    };
    if ( shr[25] )              // Проверка
    {                           // активации
        R_25();                 // режима 25 "Открыть ДЗ кам"
    };
    if ( shr[26] )              // Проверка
    {                           // активации
        R_26();                 // режима 26 "Закрыть ДЗ кам"
    };
    if ( shr[27] )              // Проверка
    {                           // активации
        R_27();                 // режима 27 "ДЗ кам дросселирование"
    };
    if ( shr[28] )              // Проверка
    {                           // активации
        R_28();                 // режима 28 "ВЧГ п/д (вкл)"
    };
   	if ( shr[29] )              // Проверка
    {                           // активации
        R_29();                 // режима 29 "Нагрев кам вкл"
    };
    if ( shr[30] )              // Проверка
    {                           // активации
        R_30();                 // режима 30 "Нагрев кам откл"
    };
	if ( shr[31] )              // Проверка
    {                           // активации
        R_31();                 // режима 31 "Нагрев п/д вкл"
    };
	if ( shr[32] )              // Проверка
    {                           // активации
        R_32();                 // режима 32 "Нагрев п/д откл"
    };
	if ( shr[33] )              // Проверка
    {                           // активации
        R_33();                 // режима 33 "БПМ вкл"
    };
    if ( shr[34] )              // Проверка
    {                           // активации
        R_34();                 // режима 34 "Сброс БПМ"
    };
    if ( shr[35] )              // Проверка
    {                           // активации
        R_35();                 // режима 35 "Поворот заслонки в HOME"
    };
    if ( shr[36] )              // Проверка
    {                           // активации
        R_36();                 // режима 36 "Поворот заслонки на угол"
    };
	if ( shr[37] )              // Проверка
    {                           // активации
        R_37();                 // режима 37 "Открыть ДЗ масс-спектрометр"
    };
	if ( shr[38] )              // Проверка
    {                           // активации
        R_38();                 // режима 38 "Закрыть ДЗ масс-спектрометр"
    };
    if ( shr[39] )              // Проверка
    {                           // активации
        R_39();                 // режима 39 "ДЗ масс-спектрометр на угол"
    };
    if ( shr[40] )              // Проверка
    {                           // активации
        R_40();                 // режима 40 "Измерит. сопротивления 1 точка"
    };
	if ( shr[41] )              // Проверка
    {                           // активации
        R_41();                 // режима 41 "Измерит. сопротивления след. точка"
    };
    if ( shr[43] )              // Проверка
    {                           // активации
        R_43();                 // режима 43 "Поддержание соотношения газов по масс-спектрометру вкл"
    };
    if ( shr[44] )              // Проверка
    {                           // активации
        R_44();                 // режима 44 "Поддержание соотношения газов по масс-спектрометру откл"
    };
    if ( shr[45] )              // Проверка
    {                           // активации
        R_45();                 // режима 45 "Включить откачной пост"
    };
    if ( shr[46] )              // Проверка
    {                           // активации
        R_46();                 // режима 46 "Отключить откачной пост"
    };
    if ( shr[47] )              // Проверка
    {                           // активации
        R_47();                 // режима 47 "Вращение магнетрона вкл."
    };
    if ( shr[48] )              // Проверка
    {                           // активации
        R_48();                 // режима 48 "Вращение магнетрона откл."
    };

     if ( shr[49] )              // Проверка
    {                           // активации
        R_49();                 // режима 49 "ТМН пуск"
    };
    if ( shr[50] )              // Проверка
    {                           // активации
        R_50();                 // режима 50 "ТМН стоп"
    };
    POST();                     // дешифрация команд оператора
};
//---------------------------------------------------------------------------
void KOLCO()                    // подпрограмма "Кольцо"
{
	DIAGN_KOLCO();              // диагностика в кольце
   // REAKCIA_KZ_BMH1();             // реакция на КЗ БПМ

    UPR_AVAR_OTKL();			// Управление аварийным отключением
    MEH_AVAR_CHK();				// слежение за авриями механизма

    AVAR_VODA_BM();				// реакция на отсутствие воды в М


    AVAR_DAVL();      // "Реакция на высокое давление в камере при работе ТМН"
    AVAR_DAVL_SHL();      // "Реакция на высокое давление в шлюзе при работе ТМН"

    VID_DIAGN_GIS();        // выдача диагностики нет согласования ВЧГ п/д


  //  Fk_Kl6();                       //Открытие клапана 6 при работе форнасоса камеры

}
//---------------------------------------------------------------------------
void POST()                     // Почта (приём и дешифрация команд)
{
    switch (qkk)
    {
        case 0:;break;          // проверка на KK = 0
        case 1:                 // проверка на KK = 1
        {
            if ( shr[1] == 0 )  // если режим ещё не активизирован
            {
                shr[1] = 1;     // активизируем
                sh[1]  = 1;     // режим 1 "Откачка камеры"
            }
        }; break;
        case 2:                 // проверка на KK = 2
        {
            if ( shr[2] == 0 )  // если режим ещё не активизирован
            {
                shr[2] = 1;     // активизируем
                sh[2]  = 1;     // режим 2 "Тренировка"
            }
        }; break;
        case 3:                 // проверка на KK = 3
        {
            if ( shr[3] == 0 )  // если режим ещё не активизирован
            {
                shr[3] = 1;     // активизируем
                sh[3]  = 1;     // режим 3 "Рабочий цикл"
            }
        }; break;
		case 5:                 // проверка на KK = 5
        {
            if ( shr[5] == 0 )  // если режим ещё не активизирован
            {
                shr[5] = 1;     // активизируем
                sh[5]  = 1;     // режим 5 "Сброс РЦ"
            }
        }; break;
        case 6:                 // проверка на KK = 6
        {
            if ( shr[6] == 0 )  // если режим ещё не активизирован
            {
                shr[6] = 1;     // активизируем
                sh[6]  = 1;     // режим 6 "Сбор пластин"
            }
        }; break;
		case 7:                 // проверка на KK = 7
        {
            if ( shr[7] == 0 )  // если режим ещё не активизирован
            {
                shr[7] = 1;     // активизируем
                sh[7]  = 1;     // режим 7 "Отключение установки"
            }
        }; break;
		
		case 9:                 // проверка на KK = 9
        {
            if ( shr[9] == 0 )  // если режим ещё не активизирован
            {
                shr[9] = 1;     // активизируем
                sh[9]  = 1;     // режим 9 "Транспортный тест"
            }
        }; break;		
		case 109:				// проверка на KK = 109
        {
            PR_TRTEST = 1;		// признак окончания транспортного теста
        }; break;
		case 10:				// проверка на KK = 10
        {
            if ( shr[10] == 0 )  // если режим ещё не активизирован
            {
                shr[10] = 1;     // активизируем
                sh[10]  = 1;     // режим 10 "Открыть ЩЗ"
            }
        }; break;
		case 11:                 // проверка на KK = 11
        {
            if ( shr[11] == 0 )  // если режим ещё не активизирован
            {
                shr[11] = 1;     // активизируем
                sh[11]  = 1;     // режим 11 "Закрыть ЩЗ"
            }
        }; break;
		case 12:                 // проверка на KK = 12
        {
            if ( shr[12] == 0 )  // если режим ещё не активизирован
            {
                shr[12] = 1;     // активизируем
                sh[12]  = 1;     // режим 12 "Мех. перем. в исх"
            }
        }; break;
		case 13:                 // проверка на KK = 13
        {
            if ( shr[13] == 0 )  // если режим ещё не активизирован
            {
                shr[13] = 1;     // активизируем
                sh[13]  = 1;     // режим 13 "Мех. перем. вперед/назад"
            }
        }; break;
		case 101:				// проверка на KK = 101
        {
            SBROS_MEH();		// сброс механизмов
        }; break;
		case 213:				// проверка на KK = 213
        {
            MEH_AVAR_SBROS();	// сброс аварий механизмов
        }; break;
		case 14:                 // проверка на KK = 14
        {
            if ( shr[14] == 0 )  // если режим ещё не активизирован
            {
                shr[14] = 1;     // активизируем
                sh[14]  = 1;     // режим 14 "Мех. пов. в HOME"
            }
        }; break;
		case 15:                 // проверка на KK = 15
        {
            if ( shr[15] == 0 )  // если режим ещё не активизирован
            {
                shr[15] = 1;     // активизируем
                sh[15]  = 1;     // режим 15 "Мех. пов. вправо/влево"
            }
        }; break;
        case 16:                 // проверка на KK = 16
        {
            if ( shr[16] == 0 )  // если режим ещё не активизирован
            {
                shr[16] = 1;     // активизируем
                sh[16]  = 1;     // режим 16 "Вращение п/д (вкл)"
            }
        }; break;
		case 17:                 // проверка на KK = 17
        {
            if ( shr[17] == 0 )  // если режим ещё не активизирован
            {
                shr[17] = 1;     // активизируем
                sh[17]  = 1;     // режим 17 "Дросселирование ДЗ"
            }
        }; break;
		case 18:                 // проверка на KK = 18
        {

                shr[18] = 1;     // активизируем
                sh[18]  = 1;     // режим 18 "Открыть ДЗ"

            PRR_POD=0;
        }; break;
        case 118:                 // проверка на KK = 18
        {

                shr[18] = 1;     // активизируем
                sh[18]  = 1;     // режим 18 "Открыть ДЗ"

            PRR_POD=1;
        }; break;

		case 100:				// проверка на KK = 100
        {
            OSBROS();			// общий сброс
        }; break;
		case 20:                // проверка на KK = 20
        {

                shr[20] = 1;    // активизируем
                sh[20]  = 1;    // режим 20 "Вкл. РРГ1"

        }; break;

		case 120:                // проверка на KK = 120
        {
			RRGOff(ObjRRG[0]);	// отключение РРГ1
            SetOut(0,1,0x800);
            PR_RG1  = 0;
		}; break;
		case 21:                // проверка на KK = 21
        {

                shr[21] = 1;    // активизируем
                sh[21]  = 1;    // режим 21 "Вкл. РРГ2"
                PR_RG2  = 0;
        }; break;

		case 121:                // проверка на KK = 121
        {
			RRGOff(ObjRRG[1]);	// отключение РРГ2
            SetOut(0,1,0x800);
            PR_RG2  = 0;
		}; break;
		case 22:                // проверка на KK = 22
        {

                shr[22] = 1;    // активизируем
                sh[22]  = 1;    // режим 22 "Вкл. РРГ3"
                PR_RG3  = 0;
        }; break;
        case 222:                // проверка на KK = 22
        {

                shr[22] = 1;    // активизируем
                sh[22]  = 1;    // режим 22 "Вкл. РРГ3"
                PR_RG3  = 1;
        }; break;
		case 122:                // проверка на KK = 122
        {
			RRGOff(ObjRRG[2]);	// отключение РРГ3
            PR_RG3  = 0;
		}; break;

        case 25:                // проверка на KK = 25
        {
            if ( shr[25] == 0 ) // если режим ещё не активизирован
            {
                shr[25] = 1;    // активизируем
                sh[25]  = 1;    // режим 25
            }
        }; break;
        case 26:                // проверка на KK = 26
        {
            if ( shr[26] == 0 ) // если режим ещё не активизирован
            {
                shr[26] = 1;    // активизируем
                sh[26]  = 1;    // режим 26
            }
        }; break;
        case 27:                // проверка на KK = 27
        {
            if ( shr[27] == 0 ) // если режим ещё не активизирован
            {
                shr[27] = 1;    // активизируем
                sh[27]  = 1;    // режим 27
            }
        }; break;
        case 28:                // проверка на KK = 28
        {
            if ( shr[28] == 0 ) // если режим ещё не активизирован
            {
                shr[28] = 1;    // активизируем
                sh[28]  = 1;    // режим 28
            }
        }; break;
        case 128:                // проверка на KK = 128
        {
            SBROSR_28();
        }; break;
		case 29:                // проверка на KK = 29
        {
            if ( shr[29] == 0 ) // если режим ещё не активизирован
            {
                shr[29] = 1;    // активизируем
                sh[29]  = 1;    // режим 29
            }
        }; break;

        case 30:                // проверка на KK = 30
        {
            if ( shr[30] == 0 ) // если режим ещё не активизирован
            {
                shr[30] = 1;    // активизируем
                sh[30]  = 1;    // режим 30
            }
        }; break;
		case 31:                // проверка на KK = 31
        {
            if ( shr[31] == 0 ) // если режим ещё не активизирован
            {
                shr[31] = 1;    // активизируем
                sh[31]  = 1;    // режим 31
            }
        }; break;
		case 32:                // проверка на KK = 32
        {
            if ( shr[32] == 0 ) // если режим ещё не активизирован
            {
                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32
            }
        }; break;
		case 33:                // проверка на KK = 33
        {
            if ( shr[33] == 0 ) // если режим ещё не активизирован
            {
                shr[33] = 1;    // активизируем
                sh[33]  = 1;    // режим 33
            }
        }; break;
		case 34:                // проверка на KK = 34
        {
            if ( shr[34] == 0 ) // если режим ещё не активизирован
            {
                shr[34] = 1;    // активизируем
                sh[34]  = 1;    // режим 34
            }
        }; break;
        case 35:                // проверка на KK = 35
        {
            if ( shr[35] == 0 ) // если режим ещё не активизирован
            {
                shr[35] = 1;    // активизируем
                sh[35]  = 1;    // режим 35
            }
        }; break;
        case 36:                // проверка на KK = 36
        {
            if ( shr[36] == 0 ) // если режим ещё не активизирован
            {
                shr[36] = 1;    // активизируем
                sh[36]  = 1;    // режим 36
            }
        }; break;
		case 37:                // проверка на KK = 37
        {
            if ( shr[37] == 0 ) // если режим ещё не активизирован
            {
                shr[37] = 1;    // активизируем
                sh[37]  = 1;    // режим 37
            }
        }; break;
		case 38:                // проверка на KK = 38
        {
            if ( shr[38] == 0 ) // если режим ещё не активизирован
            {
                shr[38] = 1;    // активизируем
                sh[38]  = 1;    // режим 38
            }
        }; break;
		case 39:                // проверка на KK = 39
        {
            if ( shr[39] == 0 ) // если режим ещё не активизирован
            {
                shr[39] = 1;    // активизируем
                sh[39]  = 1;    // режим 39
            }
        }; break;
		case 40:                // проверка на KK = 40
        {
            if ( shr[40] == 0 ) // если режим ещё не активизирован
            {
                shr[40] = 1;    // активизируем
                sh[40]  = 1;    // режим 40
            }
        }; break;
		case 41:                // проверка на KK = 41
        {
            if ( shr[41] == 0 ) // если режим ещё не активизирован
            {
                shr[41] = 1;    // активизируем
                sh[41]  = 1;    // режим 41
            }
        }; break;
        case 43:                // проверка на KK = 43
        {
            if ( shr[43] == 0 ) // если режим ещё не активизирован
            {
                shr[43] = 1;    // активизируем
                sh[43]  = 1;    // режим 43
            }
        }; break;
        case 44:                // проверка на KK = 44
        {
            if ( shr[44] == 0 ) // если режим ещё не активизирован
            {
                shr[44] = 1;    // активизируем
                sh[44]  = 1;    // режим 44
            }
        }; break;
        case 45:                // проверка на KK = 45
        {
            if ( shr[45] == 0 ) // если режим ещё не активизирован
            {
                shr[45] = 1;    // активизируем
                sh[45]  = 1;    // режим 45
            }
        }; break;
        case 46:                // проверка на KK = 46
        {
            if ( shr[46] == 0 ) // если режим ещё не активизирован
            {
                shr[46] = 1;    // активизируем
                sh[46]  = 1;    // режим 46
            }
        }; break;
        case 47:                // проверка на KK = 47
        {
            if ( shr[47] == 0 ) // если режим ещё не активизирован
            {
                shr[47] = 1;    // активизируем
                sh[47]  = 1;    // режим 47
            }
        }; break;
        case 48:                // проверка на KK = 48
        {
            if ( shr[48] == 0 ) // если режим ещё не активизирован
            {
                shr[48] = 1;    // активизируем
                sh[48]  = 1;    // режим 48
            }
        }; break;
        case 147:                 // проверка на KK = 147
        {
            STVRM();
        }; break;
        case 49:                // проверка на KK = 49
        {
            if ( shr[49] == 0 ) // если режим ещё не активизирован
            {
                shr[49] = 1;    // активизируем
                sh[49]  = 1;    // режим 49
            }
        }; break;
        case 50:                // проверка на KK = 50
        {
            if ( shr[50] == 0 ) // если режим ещё не активизирован
            {
                shr[50] = 1;    // активизируем
                sh[50]  = 1;    // режим 50
            }
        }; break;
        default:                // любая другая команда
        {
            diagnS[0] |= 0x80;  // отказ: "неопознанная команда"
            return;             //
        };

    };
    qkk = 0;                    // сброс кода команды
    diagnS[0] &= ~(0x80);       // сброс диагностики
}
//---------------------------------------------------------------------------
void DIAGN_KOLCO()				// "Подпрограмма: "Диагностика в кольце"   
{
    if(!(zin[0]&0x01))
        diagn[21]|=0x01;            //отказ "Нет охлаждения магнетрона"
    else
        diagn[21]&=(~0x01);         //Сброс диагностики

    if(!(zin[0]&0x02))
        diagn[21]|=0x02;            //отказ "Нет охлаждения ТМН"
    else
        diagn[21]&=(~0x02);         //Сброс диагностики

    if(!(zin[0]&0x04))
        diagn[21]|=0x04;            //отказ "Нет охлаждения шлюза"
    else
        diagn[21]&=(~0x04);         //Сброс диагностики

    if(!(zin[0]&0x40))
        diagn[21]|=0x08;            //отказ "Нет давления в пневмосети"
    else
        diagn[21]&=(~0x08);         //Сброс диагностики

    if(!(zin[1]&0x08))
        diagn[21]|=0x10;            //отказ "ТМН: предупреждение по температуре"
    else
        diagn[21]&=(~0x10);         //Сброс диагностики

    if((zin[2]&0x04))
        diagn[21]|=0x20;            //отказ "ВЧГ п/д: перегрев"
    else
        diagn[21]&=(~0x20);         //Сброс диагностики

    if((zin[2]&0x08))
        diagn[21]|=0x40;            //отказ "ВЧГ п/д: предупреждение"
    else
        diagn[21]&=(~0x40);         //Сброс диагностики

    if((zin[2]&0x10))
        diagn[21]|=0x80;            //отказ "ВЧГ п/д: авария"
    else
        diagn[21]&=(~0x80);         //Сброс диагностики

    if((zin[2]&0x40)&&(!(zin[4]&0x02)))
        diagn[22]|=0x01;            //отказ "Нет высокого вакуума в масс-спектрометре"
    else
        diagn[22]&=(~0x01);         //Сброс диагностики

    if((zin[2]&0x400))
        diagn[22]|=0x02;            //отказ "Предупреждение привода вращения магнетрона"
    else
        diagn[22]&=(~0x02);         //Сброс диагностики

    if(!(zin[2]&0x100))
        diagn[22]|=0x04;            //отказ "Авария привода вращения магнетрона"
    else
        diagn[22]&=(~0x04);         //Сброс диагностики

    if(!(zin[3]&0x04))
        diagn[22]|=0x08;            //отказ "Авария привода вращения п/д"
    else
        diagn[22]&=(~0x08);         //Сброс диагностики

    if(!(zin[3]&0x20))
        diagn[22]|=0x10;            //отказ "Авария привода поворота заслонки"
    else
        diagn[22]&=(~0x10);         //Сброс диагностики

    if(!(zin[3]&0x400))
        diagn[22]|=0x20;            //отказ "Авария привода манипулятора"
    else
        diagn[22]&=(~0x20);         //Сброс диагностики

    if(!(zin[3]&0x2000))
        diagn[22]|=0x40;            //отказ "Авария привода подъёма п/д"
    else
        diagn[22]&=(~0x40);         //Сброс диагностики

    if(aik[0] > 901)
        diagn[22]|=0x80;            //отказ "Высокая температура воды охлаждения магнетрона"
    else
        diagn[22]&=(~0x80);         //Сброс диагностики

    if(aik[1] > 901)
        diagn[24]|=0x01;            //отказ "Высокая температура воды охлаждения ТМН"
    else
        diagn[24]&=(~0x01);         //Сброс диагностики




}
//---------------------------------------------------------------------------
void TIME()			//  подпрограмма управления таймером
{					// (прерывание с периодом в 1 миллисекунду)

	CT_T1++;		// Сч.тиков (1 мсек=1кГц)
	
	// Счетчики тиковские (1 мсек) для устройств и режимов

    CT_REQSG++;
	if(CT_T1 < 20) return;
	CT_T1 = 0;		// Сброс сч.тиков (1 мсек.)
	CT_T20++;		// Счетчик тиков (20мсек = 50Гц)

	// Счетчики тиковские (20 мсек) для устройств и режимов


    CT_VRSG++;
    CT_PR_SG++;




    //CT_AVAR_OTKL++;
	if(CT_T20 < 50) return;
	CT_T20 = 0;		// Сброс сч.тиков (20 мсек.)

	// Счетчики секундные (1 сек)




    CT_POD++;
    CT_VR++;
    CT_POV++;




    CT_VODA_BM++;

    CT_Kl6++;



    CT_PER++;
    CT_DZASL1++;
    CT_DZASL2++;
    CT_TEMP1++;
    CT_TEMP2++;
    CT_VHG++;
    CT_IST++;
    CT_BMH1++;
    CT_KZ_BMH1++;
    CT_VODA_II++;
    CT_TMN++;
    CT_VAK++;
    CT_Tok++;
	// инкремент счетчиков механизмов
	//AZdrive_Time();

	// Счетчики времени режимов (секундные)
	CT_1++;
    CT_2++;
    CT_3++;
    CT_4++;
    CT_5++;
    CT_6++;
    CT_7++;
    CT_9++;
    CT_10++;
    CT_19++;
    CT_27++;
    CT27K1++;
    CT_28++;
    CT28K1++;
    CT_29++;
    CT29K1++;
    CT_31++;
    CT31K1++;
    CT_33++;
    CT33K1++;
    CT_43++;
    CT43K1++;
    CT_39++;
    CT_46++;
    CT_47++;
    CT_48++;


	TimeRRG();
	TimeKlapan();
}

//---------------------------------------------------------------------------
//-------------------------------  РЕЖИМЫ  ----------------------------------
//---------------------------------------------------------------------------
void R_1 ()            // Режим "Откачка камеры"
{
	sh_ = sh[1];
	
	if (shr[1] < 1 || shr[1] > 43) goto L100;
	if (shr[1] < 10) goto L00;
	if (shr[1] < 20) goto L01;
	if (shr[1] < 30) goto L02;
	if (shr[1] < 40) goto L03;
	else goto L04;
	
L00:if (shr[1] == 1) goto L1;
	if (shr[1] == 2) goto L2;
	if (shr[1] == 3) goto L3;
	if (shr[1] == 4) goto L4;
	if (shr[1] == 5) goto L5;
	if (shr[1] == 6) goto L6;
	if (shr[1] == 7) goto L7;
	if (shr[1] == 8) goto L8;
	if (shr[1] == 9) goto L9;
L01:if (shr[1] == 10) goto L10;
	if (shr[1] == 11) goto L11;
	if (shr[1] == 12) goto L12;
	if (shr[1] == 13) goto L13;
	if (shr[1] == 14) goto L14;
	if (shr[1] == 15) goto L15;
	if (shr[1] == 16) goto L16;
	if (shr[1] == 17) goto L17;
	if (shr[1] == 18) goto L18;
	if (shr[1] == 19) goto L19;
L02:if (shr[1] == 20) goto L20;
	if (shr[1] == 21) goto L21;
	if (shr[1] == 22) goto L22;
	if (shr[1] == 23) goto L23;
	if (shr[1] == 24) goto L24;
	if (shr[1] == 25) goto L25;
	if (shr[1] == 26) goto L26;
	if (shr[1] == 27) goto L27;
	if (shr[1] == 28) goto L28;
	if (shr[1] == 29) goto L29;
L03:if (shr[1] == 30) goto L30;
	if (shr[1] == 31) goto L31;
	if (shr[1] == 32) goto L32;
	if (shr[1] == 33) goto L33;
	if (shr[1] == 34) goto L34;
	if (shr[1] == 35) goto L35;
	if (shr[1] == 36) goto L36;
	if (shr[1] == 37) goto L37;
	if (shr[1] == 38) goto L38;
    if (shr[1] == 39) goto L39;
L04:if (shr[1] == 40) goto L40;
	if (shr[1] == 41) goto L41;
	if (shr[1] == 42) goto L42;
	if (shr[1] == 43) goto L43;

	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[1] = sh_;
	if (sh[1] != 0) goto L100;	// sh_ != 0
	++shr[1];					// след. шаг сч.шр1
	if (shr[1] > 43) goto L0;	// число шагов режима
	sh[1] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 1;					// норма: "Откачка камеры завершена"
	shr[1] = 0;
	goto L100;
L1: SetOut(0,1,0x3B00);         //Закрыть Кл1-5
    SetOut(0,2,0x05);           //Закрыть Кл6 Кл-НАП2
    if(zin[3]&0x200)
        shr[1]=2;               //переход на шаг 3
    sh_=0;
    goto L101;
L2: OPMAN();//Манип. в HOME
    goto L101;
L3: Klapan(0,&ShZatvor);//Закрыть Щелевой затвор
    if(sh_)goto L101;
    if(zin[3]&0x1000)
    {
        shr[1]=4;
        goto L4_1;                  //переход на шаг 4_1
    }
    goto L101;
L4: VIDK_POD(0,0,0,1,10);//П/д в HOME
    if(sh_)goto L101;
L4_1:if(zin[3]&0x02)
        shr[1]=5;                   //Переход на шаг 6
    sh_=0;
    goto L101;
L5: VIDK_VR(0,0,0,1,10);//Вращение п/д в HOME
    goto L101;
L6: Klapan(0,&PP);//ПОдъёмник вниз
    goto L101;
L7: VIDK_POV(0,0,0,1,20);//Поворот заслонки в HOME
    goto L101;
L8: Klapan(1,&FvnKam);//Включить форнасос камеры
    if(sh_)goto L101;
    if(nasmod[18]!=1)
    {
        shr[45]=1;              //активиз. режима 45
        sh[45]=1;               //"Включить отк. пост"
    }
    goto L101;
L9: Klapan(1,&DzaslMass);//Открыть ДЗ масс-спектр
    if(sh_)goto L101;
    if(zin[1]&0x04)
        shr[1]=10;
    goto L101;
L10:Klapan(0,&DzaslKam);//Закрыть ДЗ кам
    goto L101;
L11:Klapan(0,&VvKl);//Закрыть ВК-Шл
    goto L101;
L12:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3>UVAKV_KAM)
    {
        sh_=0;
        goto L101;
    }
    shr[1]=15;
    goto L15_1;
L13:Klapan(0,&KlTmn);//Закрыть ФК-ТМН
    goto L101;
L14:Klapan(1,&KlKam);//Открыть ФК-Кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L15:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3<=UVAKV_KAM)
    {
        diagn[11]&=(~0x01);         //сброс диагностики
L15_1:  SetOut(1,1,0x800);      //открыть Кл5
        SetOut(1,2,0x04);       //Открыть Кл6
        shr[1]=19;              //переход на шаг 20
        sh_=0;
        goto L101;
    }
    if(zin[1]&0x3004)
    {
        sh_=0;
        goto L101;
    }
    shr[1]=16;
    goto L16_1;                 //переход на шаг 16_1
L16:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L16_1:if(CT_1>T_KKAM)
        diagn[11]|=0x01;            //отказ "Медленная фороткачка камеры"
    shr[1]=14;                  //переход на шаг 15
    sh_=0;
    goto L101;
L17:Klapan(0,&KlKam);//Закрыть Фк-Кам
    goto L101;
L18:Klapan(1,&KlTmn);//Открыть ФК-ТМН
    goto L101;
L19:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[1]=12;                  //переход на шаг 13
    sh_=0;
    goto L101;
L20:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6<=UVAKV_TMN)
        shr[1]=22;              //переход на шаг 23
    sh_=0;
    goto L101;
L21:Klapan(0,&DzaslKam);//Закрыть ДЗ кам
    goto L101;
L22:Klapan(0,&KlKam);//Закрыть ФК-Кам
    goto L101;
L23:Klapan(1,&KlTmn);//Открыть ФК-ТМН
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L24:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6<=UVAKV_TMN)
    {
        diagn[11]&=(~0x02);         //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_1>T_KTMN)
        diagn[11]|=0x02;            //отказ "Медленная фороткачка ТМН"
    goto L101;
L25:TMN(1);//Пуск ТМН
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L26:if(zin[1]&0x04)
    {
        diagn[11]&=(~0x04);         //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_1>T_KTMN_RAZGON)
        diagn[11]|=0x04;            //отказ "Нет выхода на режим ТМН"
    goto L101;
L27:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3<=UVAKN_KAM)
        shr[1]=34;              //переход на шаг 35
    sh_=0;
    goto L101;
L28:Klapan(0,&KlTmn);//Закрыть ФК-ТМН
    goto L101;
L29:Klapan(1,&KlKam);//Открыть ФК-Кам
    if(sh_)goto L101;
    CT_1=0;
    goto L101;
L30:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3<=UVAKV_KAM)
    {
        diagn[11]&=(~0x01);         //сброс диагностики
        shr[1]=34;              //переход на шаг 35
        sh_=0;
        goto L101;
    }
    if(zin[1]&0x3004)
    {
        sh_=0;
        goto L101;
    }
    shr[1]=31;
    goto L31_1;                 //переход наш 31_1
L31:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6>UVAKN_TMN)
    {
        sh_=0;
        goto L101;
    }
L31_1:if(CT_1>T_KKAM)
        diagn[11]|=0x01;            //отказ "Медленная фороткачка камеры"
    shr[1]=29;
    sh_=0;
    goto L101;
L32:Klapan(0,&KlKam);//Закрыть Фк-Кам
    goto L101;
L33:Klapan(1,&KlTmn);//Открыть ФК-ТМН
    goto L101;
L34:if(diagnS[0]&0x20)			// пока нет связи с Д6
		goto L101;
    if(D_D6>UVAKV_TMN)
        goto L101;
    shr[1]=27;
    sh_=0;
    goto L101;
L35:Klapan(0,&KlKam);//Закрыть Фк-Кам
    goto L101;
L36:Klapan(1,&KlTmn);//Открыть ФК-ТМН
    goto L101;
L37:Klapan(1,&DzaslKam);//Открыть ДЗ кам
    if(sh_)goto L101;
    CT_1=0;
    if((shr[3]==0)&&(shr[2]==0))
    {
        if((nasmod[4])&&(nasmod[5]))
        {
            shr[29]=1;              //активиз. режим 29
            sh[29]=1;               //"Вкл. нагрев кам"
        }
        else
        {
            if(shr[29])
            {
                shr[30]=1;              //активиз. рижим 30
                sh[30]=1;              //"Откл. нагрев кам"
            }
        }
    }
    sh_=0;
    goto L101;
L38:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3<=nasmod[0])
    {
        diagn[11]&=(~0x08);            //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_1>T_KKAV_V)
        diagn[11]|=0x08;            //отказ "Медленная высковакуумн. откачка камеры"
    goto L101;
L39:VRR_GIS();//Вкл. разр. работы ВЧГ п/д
    goto L101;
L40:VIDK_BMH1(0x1804,0x800,1,28,0x10);//Вкл. БПМ
    if(sh_)goto L101;
    if((nasmod[4])&&(nasmod[6]))
    {
        shr[31]=1;              //активиз. режим 31
        sh[31]=1;               //"Вкл. нагрев п/д"
    }
    else
    {
        if(shr[31])
        {
            shr[32]=1;              //активиз. режим 32
            sh[32]=1;               //"Откл. нагрев п/д"
        }
    }
    if(!(shr[29]))
        shr[1]=41;              //переход на шаг 42
    sh_=0;
    goto L101;
L41:if(VRTEMP1!=1)
        goto L101;
    shr[30]=1;                  //активиз. режим 30
    sh[30]=1;                   //"Откл. нагрев кам"
    sh_=0;
    goto L101;
L42:if(shr[30]||shr[32])
        goto L101;
    sh_=0;
    goto L101;
L43:if(shr[45])
        goto L101;
    sh_=0;
    goto L101;                  //выход



}
//---------------------------------------------------------------------------
void R_2 ()            // Режим "Тренировка"
{
	sh_ = sh[2];

	if (shr[2] == 1) goto L1;   if (shr[2] == 2) goto L2;
	if (shr[2] == 3) goto L3;   if (shr[2] == 4) goto L4;
	if (shr[2] == 5) goto L5;   if (shr[2] == 6) goto L6;
	if (shr[2] == 7) goto L7;   if (shr[2] == 8) goto L8;
    if (shr[2] == 9) goto L9;   if (shr[2] == 10) goto L10;
    if (shr[2] == 11) goto L11; if (shr[2] == 12) goto L12;
    if (shr[2] == 13) goto L13;

	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[2] = sh_;
	if (sh[2] != 0) goto L100;	// sh_ != 0
	++shr[2];					// след. шаг сч.шр2
	if (shr[2] > 13) goto L0;	// число шагов режима
	sh[2] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 2;					// норма: "Откачка шлюза завершена"
	shr[2] = 0;
	goto L100;
	
L1: T_PROC=0;
    shr[1]=1;                   //активиз. режим 1
    sh[1]=1;                    //"Откачка камеры"
    sh_=0;
    goto L101;
L2: if(shr[1])
        goto L101;
    sh_=0;
    goto L101;

L3: VIDK_POV(0,ABS,par_t[0],0,20);//ЗАкрыть заслонку п/д
    if(sh_)goto L101;
    N_ST=5;
    shr[20]=1;                  //активиз. режим 20
    sh[20]=1;                   //"Вкл. РРГ1"
L4: if(!(ObjRRG[0]->vRRG))
        goto L101;
    shr[27]=1;                  //активиз. режим 27
    sh[27]=1;                   //ДЗ кам. дросселирование
    sh_=0;
    goto L101;
L5: if(VRDZASL1!=1)
        goto L101;
    sh_=0;
    goto L101;
L6: VVRM();//Вкл. вращение магнетрона
    if(sh_)goto L101;
    shr[33]=1;                  //активиз режим 33
    sh[33]=1;                   //"Вкл. БПМ"
    goto L101;
L7: if(VRBMH1!=1)
        goto L101;
    CT_2=0;
    sh_=0;
    goto L101;
L8: if(CT_2<=par[N_ST][12])
    {
        T_PROC=CT_2;
        goto L101;
    }
    shr[34]=1;                  //активиз. режим 34
    sh[34]=1;                   //"Сброс БПМ"
    sh_=0;
    goto L101;
L9: if(shr[34])
        goto L101;
    sh_=0;
    goto L101;
L10:OVRM();	//Откл. вращение магнетрона
    if(sh_)goto L101;
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    SetOut(0,1,0x800);
    shr[25]=1;          //активиз. режима 25
    sh[25]=1;           //"Открыть ДЗ кам"
    goto L101;
L11:if(shr[25])
        goto L101;
    T_PROC=0;
    N_ST=0;
    sh_=0;
    goto L101;
L12:VIDK_POV(0,0,0,1,20);//Заслонка п/д в HOME
    goto L101;
L13:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3>nasmod[0])
        goto L101;
    sh_=0;
    goto L101;




}
//---------------------------------------------------------------------------
void R_3 ()            // Режим "Рабочий цикл"
{
	sh_ = sh[3];

	if (shr[3] < 1 || shr[3] > 36) goto L100;
	if (shr[3] < 10) goto L00;
	if (shr[3] < 20) goto L01;
	if (shr[3] < 30) goto L02;
	goto L03;

L00:if (shr[3] == 1) goto L1;		if (shr[3] == 2) goto L2;
	if (shr[3] == 3) goto L3;		if (shr[3] == 4) goto L4;
	if (shr[3] == 5) goto L5;		if (shr[3] == 6) goto L6;
	if (shr[3] == 7) goto L7;		if (shr[3] == 8) goto L8;
	if (shr[3] == 9) goto L9;
L01:if (shr[3] == 10) goto L10;		if (shr[3] == 11) goto L11;
	if (shr[3] == 12) goto L12;		if (shr[3] == 13) goto L13;
	if (shr[3] == 14) goto L14;		if (shr[3] == 15) goto L15;
	if (shr[3] == 16) goto L16;		if (shr[3] == 17) goto L17;
	if (shr[3] == 18) goto L18;		if (shr[3] == 19) goto L19;
L02:if (shr[3] == 20) goto L20;		if (shr[3] == 21) goto L21;
	if (shr[3] == 22) goto L22;		if (shr[3] == 23) goto L23;
	if (shr[3] == 24) goto L24;		if (shr[3] == 25) goto L25;
	if (shr[3] == 26) goto L26;		if (shr[3] == 27) goto L27;
	if (shr[3] == 28) goto L28;		if (shr[3] == 29) goto L29;
L03:if (shr[3] == 30) goto L30;		if (shr[3] == 31) goto L31;
	if (shr[3] == 32) goto L32;     if (shr[3] == 33) goto L33;
    if (shr[3] == 34) goto L34;     if (shr[3] == 35) goto L35;
    if (shr[3] == 36) goto L36;
	goto L100;			// выход

	// конечный диспетчер режима
L101:sh[3] = sh_;
	if (sh[3] != 0) goto L100;		// sh_ != 0
	++shr[3];						// след. шаг сч.шр2
	if (shr[3] > 36) goto L0;		// число шагов режима
	sh[3] = 1;
L100:return;						// возврат в "кольцо"

L0: norma = 3;						// норма: "РЦ завершен"
	shr[3] = 0;
    sh[3] = 0;
    goto L100;
	
L1: N_ST=0;
    T_PROC=0;
    PR_OTP=0;
    shr[1]=1;                       //активиз. режима 1
    sh[1]=1;                        //"Откачка камеры"
    sh_=0;
    goto L101;
L2: if(shr[1])
        goto L101;
    sh_=0;
    goto L101;
L3: Klapan(0,&KlShl);//Закрыть ФК-Шл
    if(sh_)goto L101;
    if(zin[1]&0x8000)
    {
        SetOut(1,2,0x02);               //Открыть Кл-НАП1
        CT_3=0;
        goto L101;
    }
    otvet=0;
    shr[3]=6;                       //переход на шаг 7
    goto L101;
L4: if(diagnS[0]&0x01)				// пока нет связи с D1
		goto L101;
	if(D_D1>UATM)
    {
        diagn[11]&=(~0x10);             //сброс диагностики
        CT_3=0;
        sh_=0;
        goto L101;
    }
    if(CT_3>=T_KNAP)
        diagn[11]|=0x10;                //отказ "Медленный напуск в шлюз"
    goto L101;
L5: if(CT_3<=T_NAPUSK)
        goto L101;
    SetOut(1,1,0x08);               //Включить звонок
    sh_=0;
    goto L101;
L6: if(zin[1]&0x8000)
        goto L101;
    SetOut(0,1,0x08);               //Отключить звонок
    SetOut(0,2,0x02);               //Закрыть Кл-НАП1
    otvet=0;
    sh_=0;
    goto L101;
L7: if(!(zin[1]&0x8000))
        goto L101;
    if(otvet==0)
        goto L101;
    shr[19]=1;                      //активиз. режим 19
    sh[19]=1;                       //"Высоковак. откачка шлюза"
    sh_=0;
    goto L101;
L8: if(shr[19])
        goto L101;
    if(otvet==1)
        shr[3]=9;                   //переход на шаг 10
    sh_=0;
    goto L101;
L9: Klapan(0,&FvnShl);//Отключить форнасос шлюза
    if(sh_)goto L101;
    goto L0;                                                // ВЫХОД!!!
L10:Klapan(1,&ShZatvor);//Открыть Щелевой затвор
    goto L101;
L11:VPMAN();//Манипулятор в камеру
    goto L101;
L12:Klapan(1,&PP);//Подъёмник вверх
    goto L101;
L13:OPMAN();//Манипулятор в HOME
    goto L101;
L14:Klapan(0,&ShZatvor);//Закрыть Щелевой затвор
    goto L101;
L15:Klapan(0,&FvnShl);//Отключить форнасос шлюза
    goto L101;
L16:Klapan(0,&PP);//Подъёмник вниз
    goto L101;
L17:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
	if(D_D3>nasmod[0])
        goto L101;
    if(nasmod[3]==1)
    {
        PR_NALADKA=1;
        sh_=0;
        goto L101;
    }
    shr[4]=1;                       //активиз. режим 4
    sh[4]=1;                        //"Технологический процесс"
    shr[3]=18;                      //переход на шаг 19
    sh_=0;
    goto L101;
L18:if(nasmod[3]==1)
        goto L101;
    PR_NALADKA=0;
    shr[3]=19;
    goto L19_1;                     //переход на шаг 19_1
L19:if(shr[4])
        goto L101;
L19_1:SBROS_MEH();
    if(shr[33])
    {
        shr[34]=1;                  //активиз. режим 34
        sh[34]=1;                   //"Сброс БПМ"
    }
    sh_=0;
    goto L101;
L20:if(shr[34])
        goto L101;
    SBROSR_28();
    if(nasmod[18])
    {
        shr[3]=33;
        goto L33_1;                 //переход на шаг 33_1
    }
    shr [44]=1;                     //активиз. режима 44
    sh  [44]=1;                     //"Откл. поддержание оотношения газов"
    shr[3]=32;                      //переход на шаг 33
    sh_=0;
    goto L101;
L21:if(shr[48])
        goto L101;
    sh_=0;
    shr[25]=1;                      //активиз. режим 25
    sh[25]=1;                       //"Открыть ДЗ"
    goto L101;
L22:if(shr[25])
        goto L101;
    shr[3]=33;                      //переход на шаг 34
    sh_=0;
    goto L101;
L23:VIDK_POD(0,0,0,1,10);//Подъём п/д в HOME
    goto L101;
L24:VIDK_VR(0,0,0,1,10);//Вращение п/д в HOME
    goto L101;
L25:VIDK_POV(0,0,0,1,20);//поворот заслонки в HOME
    goto L101;
L26:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
	if(D_D3>nasmod[0])
        goto L101;
    shr[19]=1;                      //активиз. режим 19
    sh[19]=1;                       //"Высоковакум. откачка шлюза"
    sh_=0;
    goto L101;
L27:if(shr[19])
        goto L101;
    sh_=0;
    goto L101;
L28:Klapan(1,&ShZatvor);//Открыть Щелевой затвор
    goto L101;
L29:Klapan(1,&PP);//подъёмник вверх
    goto L101;
L30:VPMAN();//Манипулятор в камеру
    goto L101;
L31:Klapan(0,&PP);//Подъёмник вниз
    goto L101;
L32:OPMAN();//Манипулятор в HOME
    if(sh_)goto L101;
    shr[3]=35;          //переход на шаг 36
    goto L101;
L33:if(shr[44])
        goto L101;
L33_1:RRGOff(ObjRRG[0]);	// отключение РРГ1
    RRGOff(ObjRRG[1]);	// отключение РРГ2
    SetOut(0,1,0x800);
    RRGOff(ObjRRG[2]);	// отключение РРГ3
    shr [48]=1;                     //активиз. режима 48
    sh  [48]=1;                     //"Откл. вращение магнетрона"
    shr[3]=20;                      //переход на шаг 21
    sh_=0;
    goto L101;
L34:Klapan(0,&KlOp);//Закрыть ФК-ОП
    if(sh_)goto L101;
    shr [37]=1;                     //активиз. режима 37
    sh  [37]=1;                     //"Открыть ДЗ масс-спектрометра"
    goto L101;
L35:if(shr[37])
        goto L101;
    shr[3]=22;                      //переход на шаг 23
    sh_=0;
    goto L101;
L36:Klapan(0,&ShZatvor);//Закрыть Щелевой затвор
    if(sh_)goto L101;
    shr[3]=2;           //переход на шаг 3
    goto L101;



}
//---------------------------------------------------------------------------
void R_4()			//Режим "Технологический процесс"
{
	sh_ = sh[4];

    if (shr[4] < 1 || shr[4] > 48) goto L100;
	if (shr[4] < 10) goto L00;
	if (shr[4] < 20) goto L01;
    if (shr[4] < 30) goto L02;
	if (shr[4] < 40) goto L03;
	else goto L04;

L00:if (shr[4] == 1) goto L1;
	if (shr[4] == 2) goto L2;
	if (shr[4] == 3) goto L3;
	if (shr[4] == 4) goto L4;
	if (shr[4] == 5) goto L5;
	if (shr[4] == 6) goto L6;
	if (shr[4] == 7) goto L7;
	if (shr[4] == 8) goto L8;
	if (shr[4] == 9) goto L9;
L01:if (shr[4] == 10) goto L10;
	if (shr[4] == 11) goto L11;
	if (shr[4] == 12) goto L12;
	if (shr[4] == 13) goto L13;
	if (shr[4] == 14) goto L14;
	if (shr[4] == 15) goto L15;
	if (shr[4] == 16) goto L16;
	if (shr[4] == 17) goto L17;
	if (shr[4] == 18) goto L18;
	if (shr[4] == 19) goto L19;
L02:if (shr[4] == 20) goto L20;
	if (shr[4] == 21) goto L21;
	if (shr[4] == 22) goto L22;
	if (shr[4] == 23) goto L23;
	if (shr[4] == 24) goto L24;
	if (shr[4] == 25) goto L25;
	if (shr[4] == 26) goto L26;
	if (shr[4] == 27) goto L27;
	if (shr[4] == 28) goto L28;
	if (shr[4] == 29) goto L29;
L03:if (shr[4] == 30) goto L30;
	if (shr[4] == 31) goto L31;
	if (shr[4] == 32) goto L32;
	if (shr[4] == 33) goto L33;
	if (shr[4] == 34) goto L34;
	if (shr[4] == 35) goto L35;
	if (shr[4] == 36) goto L36;
	if (shr[4] == 37) goto L37;
    if (shr[4] == 38) goto L38;
    if (shr[4] == 39) goto L39;
L04:if (shr[4] == 40) goto L40;
	if (shr[4] == 41) goto L41;
	if (shr[4] == 42) goto L42;
	if (shr[4] == 43) goto L43;
	if (shr[4] == 44) goto L44;
	if (shr[4] == 45) goto L45;
	if (shr[4] == 46) goto L46;
	if (shr[4] == 47) goto L47;
    if (shr[4] == 48) goto L48;


	goto L100;				//выход
	
	// конечный диспетчер режима	
L101:sh[4] = sh_;
	if (sh[4] != 0) goto L100;	// sh_ != 0	
	++shr[4];					// след. шаг сч.шр1
	if (shr[4] > 48) goto L0;	// число шагов режима
	sh[4] = 1;
L100:return;					//возврат в "кольцо"	

L0:	norma = 4;					//норма: "Тех.процесс завершен"	
	shr[4] = 0;					
	goto L100;					

L1: T_PROC=0;
    N_ST=0;
    if(shr[31])                 //Есть активиз. режима 31 "Негрев п/д"
    {
        sh_=0;
        goto L101;
    }
    shr[4]=2;                   //переход на шаг 2_1
    goto L2_1;
L2: if(VRTEMP2!=1)
        goto L101;
L2_1:if(par[1][12])
    {
        N_ST=1;
        CT_4=0;
        shr[4]=4;               //переход на шаг 5
        sh_=0;
        goto L101;
    }
    shr[4]=5;
    goto L5_1;                  //переход на шаг 5_1
L3: if(!(ObjRRG[2]->vRRG))
        goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L4: if(CT_4<=T_SBROSHE)
        goto L101;
L4_1:SetOut(0,1,0x2000);         //Закрыть Кл4
    SetOut(1,1,0x1000);         //Открыть Кл3
    PR_RG3=0;
L4_2:if(nasmod[18])
    {
        shr[20]=1;
        sh[20]=1;
        if(par[N_ST][1])
        {
            shr[21]=1;
            sh[21]=1;
        }
        else
            ObjRRG[1]->vRRG=1;
        shr[4]=30;          //переход на шаг 31
        sh_=0;
        goto L101;
    }
    
    shr[4]=22;              //переход на шаг 23
    sh_=0;
    goto L101;
L5: if(CT_4<=par[N_ST][12])
    {
        T_PROC=CT_4;
        goto L101;
    }
    T_PROC=0;
L5_1:if((par[2][0]==0)||(par[2][8]==0)||(par[2][12]==0))
    {
        shr[4]=11;
        goto L11_1;             //переход на шаг 11_1
    }
    N_ST=2;
    shr[20]=1;                  //активиз. режима 20
    sh[20]=1;                   //"Включить РРГ1"
    sh_=0;
    goto L101;
L6: if(!(ObjRRG[0]->vRRG))
        goto L101;
    shr[27]=1;                  //активиз. режим 27
    sh[27]=1;                   // "ДЗ кам дросселирование"
    sh_=0;
    goto L101;
L7: if(VRDZASL1!=1)
        goto L101;
    shr[28]=1;                  //активиз. режим 28
    sh[28]=1;                   //"включить ВЧГ п/д"
    sh_=0;
    goto L101;
L8: if(VRGIS!=1)
        goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L9: if(CT_4<=par[N_ST][12])
    {
        T_PROC=CT_4;
        goto L101;
    }
    SBROSR_28();
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    SetOut(0,1,0x800);
    shr[25]=1;                  //активиз. режим 25
    sh[25]=1;                   //"Открыть ДЗ кам"
    sh_=0;
    goto L101;
L10:if(shr[25])
        goto L101;
    sh_=0;
    goto L101;
L11:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>nasmod[0])
        goto L101;
    T_PROC=0;
L11_1:if((par[3][0]==0)||(par[3][6]==0)||(par[3][12]==0))
    {
        shr[4]=21;
        goto L21_1;                 //переход на шаг 21_1
    }
    N_ST=3;
    sh_=0;
    goto L101;
L12:VIDK_POV(0,ABS,par_t[0],0,20);//Закрыть заслонку п/д
    if(sh_)goto L101;
    shr[20]=1;                      //активиз. режим 20
    sh[20]=1;                       //"Включить РРГ1"
    goto L101;
L13:if(!(ObjRRG[0]->vRRG))
        goto L101;
    shr[27]=1;                      //активиз. режим 27
    sh[27]=1;                       //"ДЗ кам дросселирование"
    sh_=0;
    goto L101;
L14:if(VRDZASL1!=1)
        goto L101;
    sh_=0;
    goto L101;
L15:VVRM();//Включить вращение магнетрона
    if(sh_)goto L101;
    shr[33]=1;                      //активиз. режим 33
    sh[33]=1;                       //"БПМ"
    goto L101;
L16:if(VRBMH1!=1)
        goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L17:if(CT_4<=par[N_ST][12])
    {
        T_PROC=CT_4;
        goto L101;
    }
    shr[34]=1;                      //активиз. режима 34
    sh[34]=1;                       //"Сброс БПМ"
    sh_=0;
    goto L101;
L18:if(shr[34])
        goto L101;
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    SetOut(0,1,0x800);
    shr[25]=1;          //активиз. режима 25
    sh[25]=1;           //"Открыть ДЗ кам"
    sh_=0;
    goto L101;
L19:if(shr[25])
        goto L101;
    sh_=0;
    goto L101;
L20:VIDK_POV(0,0,0,1,20);//Заслонка п/д в HOME
    goto L101;
L21:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>nasmod[0])
        goto L101;
    T_PROC=0;
L21_1:if((par[4][0]==0)||(par[4][6]==0)||(par[4][12]==0))
    {
        shr[4]=44;
        goto L44_1;                 //переход на шаг 44_1
    }
    N_ST=4;
    sh_=0;
    goto L101;
    
L22:VIDK_POD(0,ABS,nasmod[16],0,10);//Подъём п/д в поз напыл
    if(sh_)goto L101;
    if(nasmod[2])
    {
        if(shr[22])
        {
            shr[4]=4;
            goto L4_1;              //переход на 4_1
        }
        PR_RG3=1;
        shr[22]=1;
        sh[22]=1;
        shr[4]=2;                   //переход на шаг 3
        sh_=0;
        goto L101;
    }
    shr[4]=4;
    goto L4_2;                      //переход на 4_2
L23:if(zin[4]&0x80)
    {
        shr[39]=1;
        sh[39]=1;
        sh_=0;
        goto L101;
    }
    if(shr[45])goto L101;
    shr[45]=1;
    sh[45]=1;
    goto L101;
L24:if(VRDZASL2)
        sh_=0;
    goto L101;
L25:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4>=UVVAK_TMNOP)
        goto L101;
    sh_=0;
    goto L101;
L26:Klapan(1,&KlOp);//Открыть ФК-ОП
    if(sh_)goto L101;
    shr[20]=1;                      //активиз. режима 20
    sh[20]=1;                       //"РРГ1"
    shr[21]=1;                      //активиз. режима 21
    sh[21]=1;                       //"РРГ2"
    sh_=0;
    goto L101;
L27:if((!(ObjRRG[0]->vRRG))||(!(ObjRRG[1]->vRRG)))
        goto L101;
    shr[27]=1;                      //активиз. режима 27
    sh[27]=1;                       //"ДЗ кам дросселирование"
    sh_=0;
    goto L101;
L28:if(!VRDZASL1)goto L101;
        sh_=0;
    goto L101;
L29:if(diagnS[0]&0x08)				// пока нет связи с D4
		goto L101;
    if(D_D4>=POROG_M)
    {
        diagn[20]&=(~0x40);             //сброс диагностики
        shr[43]=1;                  //активиз. режима 43
        sh[43]=1;                   //"Поддержание соотношения газов"
        sh_=0;
        goto L101;
    }
    diagn[20]|=0x40;                    //отказ "Нет вакуума для включения масс-спектрометра"
    goto L101;
L30:if(VRSO2!=1)
        goto L101;
    shr[4]=32;                      //переход на шаг 32_1
    goto L32_1;
L31:if((!(ObjRRG[0]->vRRG))||(!(ObjRRG[1]->vRRG)))
        goto L101;
    shr[27]=1;                      //активиз. режим 27
    sh[27]=1;                       //"ДЗ кам дроссел"
    sh_=0;
    goto L101;
L32:if(VRDZASL1!=1)
        goto L101;
L32_1:if(!(par[N_ST][8]))
    {
        shr[4]=33;
        goto L33_1;                 //переход на шаг 33_1
    }
    shr[28]=1;                      //активиз. режима 28
    sh[28]=1;                       //"Вкл. ВЧГ п/д"
    sh_=0;
    goto L101;
L33:if(VRGIS!=1)
        goto L101;
L33_1:if(zin[2]&0x200)              //Есть вращение магнетрона
    {
        shr[4]=34;
        goto L34_1;                 //переход на шаг 34_1
    }
    sh_=0;
    goto L101;
L34:VVRM();//Вкл. вращение магнетрона
    if(sh_)goto L101;
L34_1:shr[33]=1;                    //активиз. режим 33
    sh[33]=1;                       //"Вкл. БПМ"
    sh_=0;
    goto L101;
L35:if(VRBMH1!=1)
        goto L101;
    CT_4=0;
    sh_=0;
    goto L101;
L36:if(CT_4<=par[N_ST][12])
    {
        T_PROC=CT_4;
        goto L101;
    }
    shr[34]=1;                  //активиз. режима 34
    sh[34]=1;                   //"сброс бпм"
    sh_=0;
    goto L101;
L37:if(shr[34])goto L101;
    SBROSR_28();
    if(!(nasmod[18]))
    {
        shr[44]=1;              //активиз. режим 44
        sh[44]=1;               //"Откл. режима поддержания газов"
        sh_=0;
        goto L101;
    }
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    RRGOff(ObjRRG[1]);	// отключение РРГ2
    RRGOff(ObjRRG[2]);	// отключение РРГ3
    SetOut(0,1,0x800);
    shr[4]=38;                  //переход на шаг 39
    sh_=0;
    goto L101;
L38:if(shr[44])
        goto L101;
    RRGOff(ObjRRG[0]);	// отключение РРГ1
    RRGOff(ObjRRG[1]);	// отключение РРГ2
    RRGOff(ObjRRG[2]);	// отключение РРГ3
    SetOut(0,1,0x800);
    sh_=0;
    goto L101;
L39:OVRM();//Отключить вращение магнетронов
    if(sh_)goto L101;
    shr[25]=1;                  //активиз. режим 25
    sh[25]=1;                   //"Открыть ДЗ кам"
    sh_=0;
    goto L101;
L40:if(shr[25])
        goto L101;
    sh_=0;
    goto L101;
L41:Klapan(0,&KlOp);//Закрыть ФК-ОП
    if(sh_)goto L101;
    shr[37]=1;          //активиз. режим 37
    sh[37]=1;           //"Открыть ДЗ масс"
    goto L101;
L42:if(shr[37])
        goto L101;
    sh_=0;
    goto L101;
L43:VIDK_POD(0,0,0,1,10);//подъём п/д в HOME
    goto L101;
L44:if(diagnS[0]&0x04)				// пока нет связи с D3
		goto L101;
    if(D_D3>nasmod[0])
        goto L101;
L44_1:T_PROC=0;
    N_ST=0;
    if(nasmod[7]==1)
    {
        otvet=0;
        sh_=0;
        goto L101;
    }
    shr[4]=48;                      //Выход
    sh_=0;
    goto L101;
L45:if(otvet==0)
        goto L101;
    SBROS_MEH();
    if(otvet==1)
        shr[4]=48;                  //выход
    sh_=0;
    goto L101;
L46:VIDK_POD(0,0,0,1,10);//Подъём п/д в HOME
    goto L101;
L47:VIDK_POV(0,0,0,1,20);//Заслонка п/д в HOME
    goto L101;
L48:VIDK_VR(0,0,0,1,10);//Вращение п/д в HOME
    if(sh_)goto L101;
    shr[4]=21;
    goto L21_1;                     //переход на шаг 21_1







    


}
//---------------------------------------------------------------------------
void R_5()            // Режим "Сброс РЦ"
{
	sh_ = sh[5];

    if (shr[5] < 1 || shr[5] > 35) goto L100;
	if (shr[5] < 10) goto L00;
	if (shr[5] < 20) goto L01;
    if (shr[5] < 30) goto L02;
    goto L03;

L00:if (shr[5] == 1) goto L1;
	if (shr[5] == 2) goto L2;
	if (shr[5] == 3) goto L3;
	if (shr[5] == 4) goto L4;
	if (shr[5] == 5) goto L5;
	if (shr[5] == 6) goto L6;
	if (shr[5] == 7) goto L7;
    if (shr[5] == 8) goto L8;
    if (shr[5] == 9) goto L9;
L01:if (shr[5] == 10) goto L10;
    if (shr[5] == 11) goto L11;
	if (shr[5] == 12) goto L12;
	if (shr[5] == 13) goto L13;
	if (shr[5] == 14) goto L14;
	if (shr[5] == 15) goto L15;
	if (shr[5] == 16) goto L16;
	if (shr[5] == 17) goto L17;
    if (shr[5] == 18) goto L18;
    if (shr[5] == 19) goto L19;
L02: if (shr[5] == 20) goto L20;
    if (shr[5] == 21) goto L21;
	if (shr[5] == 22) goto L22;
	if (shr[5] == 23) goto L23;
	if (shr[5] == 24) goto L24;
	if (shr[5] == 25) goto L25;
	if (shr[5] == 26) goto L26;
    if (shr[5] == 27) goto L27;
    if (shr[5] == 28) goto L28;
    if (shr[5] == 29) goto L29;
L03: if (shr[5] == 30) goto L30;
    if (shr[5] == 31) goto L31;
	if (shr[5] == 32) goto L32;
	if (shr[5] == 33) goto L33;
	if (shr[5] == 34) goto L34;
	if (shr[5] == 35) goto L35;

	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[5] = sh_;
	if (sh[5] != 0) goto L100;		// sh_ != 0
	++shr[5];						// след. шаг сч.шр2
	if (shr[5] > 35) goto L0;		// число шагов режима
	sh[5] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 5;						// норма: "Сброс РЦ завершен"
	shr[5] = 0;
	goto L100;

L1: if(shr[2])
        PR_TREN=1;
    else
        PR_TREN=0;
    if((!PR_POD)||(!PR_POD)||(!PR_VR)||(!PR_POV))
    {
        CT_5=0;
        sh_=0;
        goto L101;
    }
    shr[5]=5;
    goto L5_1;                      //переход на шаг 5_1
L2: if(PR_PER==1)
    {
        if(CT_5>=T_DVIJ)
        {
           diagn[14]|=0x01;            //отказ "Отказ движения манипулятора"
           PR_PER=0;
           PR_POD=0;
           PR_VR=0;
           PR_POV=0;
           shr[5]=5;
           goto L5_1;               //переход на шаг 5_1
        }
        goto L101;
    }
    sh_=0;
    goto L101;
L3: if(PR_POD==1)
    {
        if(CT_5>=T_DVIJ)
        {
           diagn[14]|=0x02;            //отказ "Отказ механизма подъёма п/д"
           PR_PER=0;
           PR_POD=0;
           PR_VR=0;
           PR_POV=0;
           shr[5]=5;
           goto L5_1;               //переход на шаг 5_1
        }
        goto L101;
    }
    sh_=0;
    goto L101;
L4: if(PR_VR==1)
    {
        if(CT_5>=T_DVIJ)
        {
           diagn[14]|=0x04;            //отказ "Отказ механизма вращения п/д"
           PR_PER=0;
           PR_POD=0;
           PR_VR=0;
           PR_POV=0;
           shr[5]=5;
           goto L5_1;               //переход на шаг 5_1
        }
        goto L101;
    }
    sh_=0;
    goto L101;
L5: if(PR_POV==1)
    {
        if(CT_5>=T_DVIJ)
        {
           diagn[14]|=0x08;            //отказ "Отказ механизма поворота заслонки"
           PR_PER=0;
           PR_POD=0;
           PR_VR=0;
           PR_POV=0;
        }
        goto L101;
    }

L5_1:SBROS_MEH();
    SetOut(0,1,0x08);       //Отключить звонок
    SetOut(0,2,0x03);       //Закрыть Кл-НАП1,2
    zshr3=shr[3];
    shr[3]=0;               //Снятие активиз. режима 3
    sh[3]=0;                //"Рабочий цикл"
    shr[4]=0;               //Снятие активиз. режима 4
    sh[4]=0;                //"Технологический процесс"
    shr[2]=0;               //Снятие активиз. режима 2
    sh[2]=0;                //"Тренировка"
    shr[19]=0;              //Снятие активиз. режима 19
    sh[19]=0;               //"Высоковакуумная откачка шлюза"
    RRGOff(ObjRRG[2]);				// отключение РРГ3
    SBROSR_28();
    for(int i=0;i<DIAGN_COUNT;i++)
        if((i != 14)&&(i != 23)) diagn[i] = 0;// сброс диагностик кроме аварийных
    if(shr[1])
    {
        shr[5]=35;          //выход
        sh_=0;
        goto L101;
    }
    if(shr[33])
    {
        shr[34]=1;          //активиз. режима 34
        sh[34]=1;           //"Сброс БПМ"
    }
    sh_=0;
    goto L101;
L6: if(shr[34])
        goto L101;
    if(nasmod[18]==1)
    {
        shr[5]=7;
        goto L7_1;          //переход на шаг 7_1
    }
    shr[44]=1;              //активиз. режим 44
    sh[44]=1;               //"Откл. режима поддерж. газов"
    sh_=0;
    goto L101;
L7: if(shr[44])
        goto L101;
L7_1:RRGOff(ObjRRG[0]);				// отключение РРГ1
    RRGOff(ObjRRG[1]);				// отключение РРГ2
    SetOut(0,1,0x800);
    RRGOff(ObjRRG[2]);				// отключение РРГ3
    shr[48]=1;              //Активиз. режима 48
    sh[48]=1;               //"Отключение вращения магнетрона"
    sh_=0;
    goto L101;
L8: if(shr[48])
        goto L101;
    sh_=0;
    goto L101;
L9: Klapan(0,&KlOp);//Закрыть ФК-ОП
    if(sh_)goto L101;
    N_ST=0;
    T_PROC=0;
    if(shr[8])
    {
        shr[5]=35;          //выход
        sh_=0;
        goto L101;
    }
    shr[25]=1;              //активиз. режима 25
    sh[25]=1;               //"Открыть ДЗ кам"
    sh_=0;
    goto L101;
L10:if(shr[25])
        goto L101;
    shr[37]=1;              //активиз. режима 37
    sh[37]=1;               //"Открыть ДЗ масс-спектрометра"
    sh_=0;
    goto L101;
L11:if(shr[37])
        goto L101;
    sh_=0;
    goto L101;
L12:VIDK_POD(0,0,0,1,10);           //Подъём п/д в HOME
    goto L101;
L13:VIDK_VR(0,0,0,1,10);            //Вращение п/д в HOME
    goto L101;
L14:VIDK_POV(0,0,0,1,20);//Поворот заслонки в  HOME
    goto L101;
L15:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3>nasmod[0])
        goto L101;
    if(PR_TREN==1)
    {
        shr[5]=35;              //выход
        sh_=0;
        goto L101;
    }
    if(zshr3==9)
    {
        shr[5]=35;              //выход
        sh_=0;
        goto L101;
    }
    if(!(zin[1]&0x8000))
    {
        shr[5]=33;              //переход на шаг 33_1
        goto L33_1;
    }
    if(zshr3<=10)
    {
        sh_=0;
        goto L101;
    }
    if(zshr3==11)
    {
        shr[5]=17;      //переход на шаг 18
        sh_=0;
        goto L101;
    }
    if(zshr3==12)
    {
        shr[5]=18;      //переход на шаг 19
        sh_=0;
        goto L101;
    }
    if(zshr3==13)
    {
        shr[5]=19;      //переход на шаг 20
        sh_=0;
        goto L101;
    }
    if(((zshr3>30)&&(zshr3<33))||(zshr3==36))
    {
        shr[5]=18;      //переход на шаг 19
        sh_=0;
        goto L101;
    }
    if((zin[1]&0xC00)==0x400)
    {
        shr[5]=22;      //переход на шаг 23
        sh_=0;
        goto L101;
    }
    shr[5]=24;      //переход на шаг     25
    sh_=0;
    goto L101;
L16:Klapan(0,&ShZatvor);//Закрыть Щелевой затвор
    if(sh_)goto L101;
    otvet=0;
    goto L101;
L17:if(otvet==0)goto L101;
    if(otvet==1)
    {
        shr[5]=28;      //переход на шаг 29
        sh_=0;
        goto L101;
    }
    shr[5]=33;
    goto L33_1;         //переход на шаг 33_1
L18:OPMAN();              //Манипулятор в HOME
    if(sh_)goto L101;
    shr[5]=15;      //переход на шаг 16
    goto L101;
L19:Klapan(0,&PP);//Подъёмник вниз
    if(sh_)goto L101;
    shr[5]=17;      //переход на шаг 18
    goto L101;
L20:OPMAN();              //Манипулятор в HOME
    goto L101;
L21:Klapan(1,&PP);//подъёмник вверх
    goto L101;
L22:VPMAN();// Манипулятор в камеру
    if(sh_)goto L101;
    shr[5]=18;      //Переход на шаг 19
    goto L101;
L23:OPMAN();        //Манипулятор в HOME
    goto L101;
L24:Klapan(1,&PP);//подъёмник вверх
    if(sh_)goto L101;
    shr[5]=21;      //переход на шаг 22
    goto L101;
L25:if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1>nasmod[1])
    {
        shr[19]=1;          //активиз. режима 19
        sh[19]=1;           //"Высоковакуумная откачка шлюза"
        sh_=0;
        goto L101;
    }
    shr[5]=26;              //переход на шаг 27
    sh_=0;
    goto L101;
L26:if(shr[19])
        goto L101;
    sh_=0;
    goto L101;
L27:Klapan(0,&KlShl);//Закрыть ФК-Шл
    goto L101;
L28:Klapan(1,&ShZatvor);//Открыть Щелевой затвор
    if(sh_)goto L101;
    shr[5]=23;          //переход на шаг 24
    goto L101;
L29:Klapan(0,&KlShl);//Закрыть ФК-Шл
    goto L101;
L30:Klapan(0,&VvKl);//Закрыть ВК-Шл
    if(sh_)goto L101;
    SetOut(1,2,0x02);       //Открыть Кл-Нап1
    CT_5=0;
    goto L101;
L31:if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1>UATM)
    {
        diagn[11]&=(~0x10);         //сброс диагностики
        CT_5=0;
        sh_=0;
        goto L101;
    }
    if(CT_5>=T_KNAP)
        diagn[11]|=0x10;            //отказ "Медленный напуск в шлюз"
    goto L101;
L32:if(CT_5<T_NAPUSK)
        goto L101;
    SetOut(1,1,0x08);           //Включить звонок
    sh_=0;
    goto L101;
L33:if(zin[1]&0x8000)
        goto L101;
L33_1:SetOut(0,1,0x08);         //отключить звонок
    SetOut(0,2,0x02);           //Закрыть Кл-НАП1
    otvet=0;
    sh_=0;
    goto L101;
L34:if(zin[1]&0x8000)
    {
        if(otvet!=0)
        {
            shr[19]=1;          //активизю режима 19
            sh[19]=1;           //"Высоковакуумная откачка шлюза"
            sh_=0;
        }
    }
    goto L101;
L35:if(shr[19])
        goto L101;
    sh_=0;
    goto L101;



}
//---------------------------------------------------------------------------
void R_6 ()            // Режим "Сбор/выгрузка пластин"
{
	sh_ = sh[6];

	if (shr[6] < 1 || shr[6] > 19) goto L100;
	if (shr[6] < 10) goto L00;
	else goto L01;

L00:if (shr[6] == 1) goto L1;
	if (shr[6] == 2) goto L2;
	if (shr[6] == 3) goto L3;
	if (shr[6] == 4) goto L4;
	if (shr[6] == 5) goto L5;
	if (shr[6] == 6) goto L6;
	if (shr[6] == 7) goto L7;
	if (shr[6] == 8) goto L8;
	if (shr[6] == 9) goto L9;
L01:if (shr[6] == 10) goto L10;
	if (shr[6] == 11) goto L11;
	if (shr[6] == 12) goto L12;
	if (shr[6] == 13) goto L13;
	if (shr[6] == 14) goto L14;
	if (shr[6] == 15) goto L15;
	if (shr[6] == 16) goto L16;
	if (shr[6] == 17) goto L17;
	if (shr[6] == 18) goto L18;
	if (shr[6] == 19) goto L19;

	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[6] = sh_;
	if (sh[6] != 0) goto L100;			// sh_ != 0
	++shr[6];							// след. шаг сч.шр1
	if (shr[6] > 19) goto L0;			// число шагов режима
	sh[6] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma = 6;							// норма: "Сбор пластин завершен"
	shr[6] = 0;
	goto L100;
	
L1: SetOut(0,1,0x3B00);                 //Закрыть Кл1,2,3,4,5
    SetOut(0,2,0x03);                   //Закрыть Кл-НАП1,2
    if(zin[3]&0x200)                    //ман в HOME ?
    {
        otvet=0;
        shr[6]=3;                       //переход на шаг 4
    }
    sh_=0;
    goto L101;
L2: sh_=0;
    goto L101;
L3: OPMAN();                            //манипулятор в HOME
    if(sh_)goto L101;
    otvet=0;
    goto L101;
L4: if(otvet==0)
        goto L101;
    if(otvet==1)
    {
        sh_=0;
        goto L101;
    }
    shr[10]=1;                          //активиз. режим 10
    sh[10]=1;                           //"Открыть Щелевой затвор"
    shr[6]=12;                          //переход на шаг 13
    sh_=0;
    goto L101;
L5: Klapan(0,&ShZatvor);//Закрыть Щелевой затвор
    goto L101;
L6: Klapan(0,&KlShl);//Закрыть ФК-Шл
    if(sh_)goto L101;
    shr[6]=11;                          //переход на шаг 12
    goto L101;
L7: if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1>UATM)
    {
        diagn[11]&=(~0x10);         //Сброс диагностики
        CT_6=0;
        sh_=0;
        goto L101;
    }
    if(CT_6>=T_KNAP)
        diagn[11]|=0x10;            //отказ "Медленный напуск в шлюз"
    goto L101;
L8: if(CT_6<=T_NAPUSK)
        goto L101;
    SetOut(1,1,0x08);           //Включить звонок
    sh_=0;
    goto L101;
L9: if(zin[1]&0x8000)
        goto L101;
    SetOut(0,1,0x08);           //Отключить звонок
    SetOut(0,2,0x02);           //Закрыть Кл-НАП1
    otvet =0;
    sh_=0;
    goto L101;
L10:if(zin[1]&0x8000)
    {
        if(otvet!=0)
        {
            if(otvet==1)
            {
                shr[19]=1;      //активиз. режима 19
                sh[19]=1;       //"Высоковакуумная откачка шлюза"
                sh_=0;
                goto L101;
            }
            shr[6]=19;          //выход
            sh_=0;
            goto L101;
        }
    }
    goto L101;
L11:if(shr[19])
        goto L101;
    shr[6]=19;                  //выход
    sh_=0;
    goto L101;
L12:Klapan(0,&VvKl);//Закрыть ВК-Шл
    if(sh_)goto L101;
    shr[6]=6;
    SetOut(1,2,0x02);           //Открыть Кл-НАП1
    CT_6=0;
    goto L101;
L13:if(shr[10])
        goto L101;
    sh_=0;
    goto L101;
L14:VIDK_POD(0,0,0,1,10);                 //Подъём п/д в HOME
    goto L101;
L15:VIDK_VR(0,0,0,1,10);                  //Вращщение п/д в HOME
    goto L101;
L16:Klapan(1,&PP);//Подъёмник вверх
    goto L101;
L17:VPMAN();                    //Манипулятор в камеру
    goto L101;
L18:Klapan(0,&PP);//Подъёмник вниз
    goto L101;
L19:OPMAN();                    //Манипулятор в HOME
    if(sh_)goto L101;
    shr[6]=4;                   //переход на шаг 5
    goto L101;

}
//---------------------------------------------------------------------------
void R_7 ()							// Режим "Отключение установки"
{
  	sh_ = sh[7];

    if (shr[7] < 1 || shr[7] > 24) goto L100;
	if (shr[7] < 10) goto L00;
    if (shr[7] < 20) goto L01;

	else goto L02;


L00:if (shr[7] == 1) goto L1;
	if (shr[7] == 2) goto L2;
	if (shr[7] == 3) goto L3;
	if (shr[7] == 4) goto L4;
	if (shr[7] == 5) goto L5;
	if (shr[7] == 6) goto L6;
	if (shr[7] == 7) goto L7;
	if (shr[7] == 8) goto L8;
	if (shr[7] == 9) goto L9;
L01:if (shr[7] == 10) goto L10;
	if (shr[7] == 11) goto L11;
	if (shr[7] == 12) goto L12;
	if (shr[7] == 13) goto L13;
	if (shr[7] == 14) goto L14;
	if (shr[7] == 15) goto L15;
	if (shr[7] == 16) goto L16;
	if (shr[7] == 17) goto L17;
	if (shr[7] == 18) goto L18;
	if (shr[7] == 19) goto L19;
L02:if (shr[7] == 20) goto L20;
	if (shr[7] == 21) goto L21;
	if (shr[7] == 22) goto L22;
	if (shr[7] == 23) goto L23;
    if (shr[7] == 24) goto L24;

	else goto L100;			// выход

	// конечный диспетчер режима
L101:sh[7] = sh_;
	if (sh[7] != 0) goto L100;			// SH != 0
	++shr[7];							// след. шаг сч.шр5
	if (shr[7] > 24) goto L0;			// число шагов режима
	sh[7] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma 	= 7;						// норма: "Отключение установки завершено"
	shr[7] 	= 0;
	goto L100;

L1: //STVRM();
    SetOut(0,1,0x3B00);                 //Закрыть Кл1-5
    SetOut(0,2,0x07);                   //Закрыть Кл-НАП1,2, Кл6
    SetOut(0,3,0x400);                  //Снять сигнал "Включить эмиссию"
    shr[1]=0;                           //Снять активиз. режима 1
    sh[1]=0;                            //"Откачка камеры"
    sh_=0;
    goto L101;
L2: ORR_GIS();                          //Снять разр. работы ВЧГ п/д
    if(sh_)goto L101;
    shr[26]=1;                          //активиз. режим 26
    sh[26]=1;                           //"Закрыть ДЗ кам"
    goto L101;
L3: if(shr[26])
        goto L101;
    shr[38]=1;                          //активиз. режим 38
    sh[38]=1;                           //"Закрыть ЗД масс-спектрометра"
    sh_=0;
    goto L101;
L4: if(shr[38])
        goto L101;
    sh_=0;
    goto L101;
L5: Klapan(0,&KlOp);                    //Закрыть ФК-ОП
    if(sh_)goto L101;
    shr[46]=1;                          //активиз. режим 46
    sh[46]=1;                           //"Откл. откачной пост"
    goto L101;
L6: OPMAN();                            //Манипулятор в HOME
    goto L101;
L7: Klapan(0,&ShZatvor);                //Закрыть Щелевой затвор
    goto L101;
L8: Klapan(0,&VvKl);                    //Закрыть ВК-Шл
    if(sh_)goto L101;
    if(!(zin[1]&0x3004))
    {
        shr[7]=10;                      //переход на шаг 11
        goto L101;
    }
    if(diagn[23]&0x01)
    {
        shr[7]=9;
        goto L9_1;                      //переход на шаг 9_1
    }
    sh_=0;
    goto L101;
L9: Klapan(1,&KlTmn);                   //Открыть ФК-ТМН
    if(sh_)goto L101;
L9_1:shr[50]=1;                         //активиз. режим 50
    sh[50]=1;                           //"Отключение ТМН"
    goto L101;
L10:if(shr[50])
        goto L101;
    sh_=0;
    goto L101;
L11:Klapan(0,&KlShl);                   //Закрыть ФК-Шл
    goto L101;
L12:Klapan(0,&FvnShl);                  //Отключить ФВН шлюза
    goto L101;
L13:Klapan(0,&PP);                      //Манипулятор подъёма вниз
    goto L101;
L14:VIDK_POV(0,0,0,1,20);                       //Поворот заслонки в HOME
    goto L101;
L15:VIDK_VR(0,0,0,1,10);                        //Вращение заслонки в HOME
    goto L101;
L16:VIDK_POD(0,0,0,1,10);                       //Подъём п/д в HOME
    goto L101;
L17:if(zin[1]&0x3004)
        goto L101;
    sh_=0;
    goto L101;
L18:Klapan(0,&KlTmn);                   //Закрыть ФК-ТМН
    goto L101;
L19:Klapan(0,&FvnKam);                  //Октлючить ФВН камеры
    goto L101;
L20:if(shr[46])
        goto L101;
    if(shr[29])
    {
        shr[30]=1;                      //активиз. режим 30
        sh[30]=1;                       //"Откл. нагрева камеры"
    }
    sh_=0;
    goto L101;
L21:if(shr[30])
        goto L101;
    if(shr[31])
    {
        shr[32]=1;                      //активиз. режим 32
        sh[32]=1;                       //"Отключение нагрева п/д"
    }
    sh_=0;
    goto L101;
L22:if(shr[32])
        goto L101;
    sh_=0;
    goto L101;
L23:OBPN();                             //Отключить БПН
    goto L101;
L24:VIDK_BMH1(0x1004,0x800,0,28,0x20);   //Отключить БПМ
    goto L101;


}
//---------------------------------------------------------------------------
void R_8 ()							// Режим "Аварийное отключение установки"
{
	sh_ = sh[8];

	if (shr[8] == 1) goto L1;
	if (shr[8] == 2) goto L2;
	if (shr[8] == 3) goto L3;
	if (shr[8] == 4) goto L4;
    if (shr[8] == 5) goto L5;
	goto L100;				// выход

	// конечный диспетчер режима
L101:sh[8] = sh_;
	if (sh[8] != 0) goto L100;		// SH != 0
	++shr[8];						// след. шаг сч.шр5
	if (shr[8] > 5) goto L0;		// число шагов режима
	sh[8] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 8;						// норма: "Авар. откл. установки завершено"
	shr[8] = 0;
	goto L100;

L1: SetOut(0,0,0x04);               //Закрыть ДЗ камеры
    SetOut(1,0,0x08);
    SetOut(0,0,0x40);               //Закрыть ВК-Шл
    if(diagn[23]&0x01)              //Есть "Авария: отключение форнасоса камеры"
        SetOut(0,0,0x02);           //Закрыть ФК-ТМН
    if(shr[5])
    {
        shr[8]=3;                   //переход на шаг 4
        sh_=0;
        goto L101;
    }
    if((!(shr[2]))&&(!(shr[3])))
    {
        if(shr[43])
        {
            shr [44]=1;             //активиз. режима 44
            sh  [44]=1;             //"Откл. Поддержания газов"
        }
        if(shr[33])
        {
            shr [34]=1;             //активиз. режима 34
            sh  [34]=1;             //"Сброс БПМ"
        }
        sh_=0;
        goto L101;
    }
    shr [5]=1;                      //активиз. режима 5
    sh  [5]=1;                      //"Сброс Рабочего цикла"
    shr[8]=3;                       //переход на шаг 4
    sh_=0;
    goto L101;
L2: if(shr[34])
        goto L101;
    sh_=0;
    goto L101;
L3: if(shr[44])
        goto L101;
    SBROSR_28();
    RRGOff(ObjRRG[0]);
    RRGOff(ObjRRG[1]);
    SetOut(0,1,0x800);
    RRGOff(ObjRRG[2]);
    shr [1]=0;                      //Сброс активиз. режима 1
    sh  [1]=0;                      //"Откачка камеры"
    shr [6]=0;                      //Сброс активиз. режима 6
    sh  [6]=0;                      //"Сбор пластин"
    shr [10]=0;                      //Сброс активиз. режима 10
    sh  [10]=0;                      //"Открыть ЩЗ"
    shr [11]=0;                      //Сброс активиз. режима 11
    sh  [11]=0;                      //"Закрыть ЩЗ"
    shr [19]=0;                      //Сброс активиз. режима 19
    sh  [19]=0;                      //"Высоковакуумная откачка шлюза"
    SBROS_MEH();
    //STVRM();
    shr[48] =1; 
    sh[48]  =1;
    if(shr[29])
    {
        shr [30]=1;                 //активиз. режима 30
        sh  [30]=1;                 //"Откл. нагрева"
    }
    if(shr[31])
    {
        shr [32]=1;                 //активиз. режима 32
        sh  [32]=1;                 //"Откл. нагрева п/д"
    }
    for(int i=0;i<DIAGN_COUNT;i++)
        if((i != 14)&&(i != 23)) diagn[i] = 0;// сброс диагностик кроме аварийных
    shr[8]=4;                       //переход на шаг 4_1
    goto L4_1;
L4: if(shr[5])
        goto L101;
L4_1:if(!(shr[7]))
    {
        shr [7]=1;                  //активиз. режима 7
        sh  [7]=1;                  //"Отключение установки"
    }
    sh_=0;
    goto L101;
L5: if(shr[7])
        goto L101;
    sh_=0;
    goto L101;
    

}
//---------------------------------------------------------------------------
void R_9 ()							// Режим "Транспортный тест"
{
	sh_ = sh[9];

	if (shr[9] < 1 || shr[9] > 16) goto L100;
	if (shr[9] < 10) goto L00;

	else goto L01;

L00:if (shr[9] == 1) goto L1;
	if (shr[9] == 2) goto L2;
	if (shr[9] == 3) goto L3;
	if (shr[9] == 4) goto L4;
	if (shr[9] == 5) goto L5;
	if (shr[9] == 6) goto L6;
	if (shr[9] == 7) goto L7;
	if (shr[9] == 8) goto L8;
	if (shr[9] == 9) goto L9;
L01:if (shr[9] == 10) goto L10;
	if (shr[9] == 11) goto L11;
	if (shr[9] == 12) goto L12;
	if (shr[9] == 13) goto L13;
	if (shr[9] == 14) goto L14;
	if (shr[9] == 15) goto L15;
    if (shr[9] == 16) goto L16;
	goto L100;			// выход
		
	// конечный диспетчер режима
L101:sh[9] = sh_;
	if (sh[9] != 0) goto L100;	// sh_ != 0
	++shr[9];					// след. шаг сч.шр1
	if (shr[9] > 16) goto L0;	// число шагов режима
	sh[9] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 9;					// норма: "Транспортный тест завершен"
	shr[9] = 0;
	goto L100;
	
L1: PR_TRTEST=0;
    VIDK_POV(0,0,0,1,20);                 //поворот заслонки в HOME
    goto L101;
L2: VIDK_VR(0,0,0,1,10);                    //Вращение п/д в HOME
    goto L101;
L3: VIDK_POD(0,0,0,1,10);                   //подъём п/д в HOME
    goto L101;
L4: Klapan(0,&PP);                  //Механизм подъёма вниз
    goto L101;
L5: VPMAN();                        //манипулятор в камеру
    goto L101;
L6: Klapan(1,&PP);                  //Механизм подъёма вверх
    goto L101;
L7: OPMAN();                        //Манипулятор в HOME
    goto L101;
L8: Klapan(0,&PP);                  //Механизм подъёма вниз
    goto L101;
    
L9: VIDK_POD(0,ABS,nasmod[16],0,10);//Подъём п/д в поз напыл
    if(sh_)goto L101;
    CT_9=0;
    goto L101;
L10:if(CT_9<=5)
        goto L101;
    sh_=0;
    goto L101;
L11:VIDK_POD(0,0,0,1,10);                   //Подъём п/д в HOME
    goto L101;
L12:Klapan(1,&PP);                  //Механизм подъёма вверх
    goto L101;
L13:VPMAN();                        //Манипулятор в камеру
    goto L101;
L14:Klapan(0,&PP);                  //Механизм подъёма вниз
    goto L101;
L15:OPMAN();                        //Манипулятор в HOME
    if(sh_)goto L101;
    if(PR_TRTEST==0)
    {
        CT_9=0;
        goto L101;
    }
    shr[9]=16;                      //выход
    goto L101;
L16:if(CT_9<=5)
        goto L101;
    shr[9]=4;                       //переход на шаг 5
    sh_=0;
    goto L101;
}	
//---------------------------------------------------------------------------
void R_10 ()							// Режим "Открыть ЩЗ"
{
	sh_ = sh[10];

	if (shr[10] < 1 || shr[10] > 18) goto L100;
	if (shr[10] < 10) goto L00;
	goto L01;

L00:if (shr[10] == 1) goto L1;
	if (shr[10] == 2) goto L2;
	if (shr[10] == 3) goto L3;
	if (shr[10] == 4) goto L4;
	if (shr[10] == 5) goto L5;
	if (shr[10] == 6) goto L6;
	if (shr[10] == 7) goto L7;
	if (shr[10] == 8) goto L8;
	if (shr[10] == 9) goto L9;
L01:if (shr[10] == 10) goto L10;
	if (shr[10] == 11) goto L11;
	if (shr[10] == 12) goto L12;
	if (shr[10] == 13) goto L13;
	if (shr[10] == 14) goto L14;
    if (shr[10] == 15) goto L15;
    if (shr[10] == 16) goto L16;
    if (shr[10] == 17) goto L17;
    if (shr[10] == 18) goto L18;
	goto L100;
	// конечный диспетчер режима
L101:sh[10] = sh_;
	if (sh[10] != 0) goto L100;		// SH != 0
	++shr[10];						// след. шаг сч.шр5
	if (shr[10] > 18) goto L0;		// число шагов режима
	sh[10] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 10;						// норма: "Щелевой затвор открылся"
	shr[10] = 0;
	goto L100;

L1: shr[11]=0;                      //Сброс активиз. режима 11
    sh[11]=0;                       //"Закрыть Щелевой затвор"
    sh_=0;
    goto L101;
L2: if((zin[1]&0xC00)==0x400)
    {
        diagn[4]&=(~0x40);             //сброс диагностики
        shr[10]=16;                 //переход на шаг 17
        sh_=0;
        goto L101;
    }
    if((zin[1]&0xC00)==0x800)
    {
        diagn[4]&=(~0x40);             //сброс диагностики
        sh_=0;
        goto L101;
    }
    diagn[4]|=0x40;                    //отказ "Положение щелевого затвора не определено"
    goto L101;
L3: if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3<=UATM)
        shr[10]=6;                  //переход на шаг 7
    sh_=0;
    goto L101;
L4: if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1>UATM)
    {
        SetOut(1,2,0x03);               //Открыть Кл-НАП1-2
        CT_10=0;
        shr[10]=17;             //переход на шаг 18
    }
    sh_=0;
    goto L101;
L5: Klapan(0,&KlShl);//Закрыть ФК-Шл
    goto L101;
L6: Klapan(0,&VvKl);//Закрыть ВК-Шл
    if(sh_)goto L101;
    SetOut(1,2,0x03);               //Открыть Кл-НАП1-2

    shr[10]=3;                      //переход на шаг 4
    goto L101;
L7: if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3>UVAK_KAM)
    {
        SetOut(0,2,0x01);           //ЗАкрыть Кл-НАП2
        SetOut(0,1,0x1300);         //Закрыть Кл1,2,3
    }
    else
        shr[10]=10;                 //переход на шаг 11
    sh_=0;
    goto L101;
L8: Klapan(0,&KlTmn);//Закрыть ФК-ТМН
    goto L101;
L9: Klapan(1,&FvnKam);//Вкл. ФВН камеры
    goto L101;
L10:Klapan(1,&KlKam);//Открыть ФК-Кам
    if(sh_)goto L101;
    shr[10]=6;                      //переход на шаг 7
    goto L101;
L11:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3>UVVAK_KAM)
        shr[10]=12;                 //переход на шаг 13
    sh_=0;
    goto L101;
L12:if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1>UVVAK_SHL)
    {
        PR_FOTK_SHL=0;
        shr[19]=1;                  //активиз. режима 19
        sh[19]=1;                   //"Высоковакуумная откачка шлюза"
        shr[10]=13;                 //переход на шаг 14
    }
    else
        shr[10]=16;                 //переход на шаг 17
    sh_=0;
    goto L101;
L13:if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1>UVAK_SHL)
    {
        PR_FOTK_SHL=1;
        shr[19]=1;                  //активиз. режима 19
        sh[19]=1;                   //"Высоковакуумная откачка шлюза"
    }
    else
        shr[10]=16;                 //переход на шаг 17
    sh_=0;
    goto L101;
L14:if(shr[19])
        goto L101;
    if(zin[1]&0x3004)
    {
        sh_=0;
        goto L101;
    }
    shr[10]=16;                     //переход на шаг 17
    sh_=0;
    goto L101;
L15:Klapan(0,&KlKam);//Закрыть ФК-Кам
    goto L101;
L16:Klapan(1,&KlTmn);//Открыть ФК-ТМН
    goto L101;
L17:Klapan(1,&ShZatvor);//Открыть ЩЗ
    if(sh_)goto L101;
    shr[10]=18;         //выход
    goto L101;
L18:if(CT_10<T_NAPUSK)
        goto L101;
    SetOut(0,2,0x03);           //Закрыть Кл-НАП1-2
    shr[10]=16;                 //переход на шаг 17
    sh_=0;
    goto L101;


}
//---------------------------------------------------------------------------
void R_11()							// Режим "Закрыть ЩЗ"
{
	sh_ = sh[11];

	if (shr[11] == 1) goto L1;
	if (shr[11] == 2) goto L2;
		else goto L100;				// выход

	// конечный диспетчер режима
L101:sh[11] = sh_;
	if (sh[11] != 0) goto L100;		// SH != 0
	++shr[11];						// след. шаг
	if (shr[11] > 2) goto L0;		// число шагов режима
	sh[11] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 11;						// норма: "Щелевой затвор закрылся"
	shr[11] = 0;
	goto L100;

L1:	shr[10] = 0;					// сброс активизации режима 10
	sh[10] = 0;
	diagn[4] &= (~0xF0);			// сброс диагностик
	diagn[3] &= (~0xFF);			//
	diagn[2] &= (~0x0F);			//
    diagn[1] &= (~0xFF);			//
    diagn[0] &= (~0xFF);			//
    diagn[11] &= (~0xE0);			//
    diagn[12] &= (~0x03);
	sh_ = 0;
	goto L101;
L2:	Klapan(0,&ShZatvor);			// закрыть щелевой затвор
	goto L101;
}
//---------------------------------------------------------------------------
void R_12() // режим 12 "МАН в исходное"
{
	sh_ = sh[12];

	if (shr[12] == 1)  goto L1;
	else goto L100;// на выход

L101:sh[12] = sh_;
	if (sh[12] != 0) goto L100;		// SH != 0
	shr[12]++;						// след.шаг
	if (shr[12] > 1) goto L0;		// число шагов режима
	sh[12] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[12] = 0;
	goto L100;

L1: OPMAN();						// Ман в HOME
	goto L101;
}
//---------------------------------------------------------------------------
void R_13() // режим 13 "МАН в кам"
{
	sh_ = sh[13];

	if (shr[13] == 1)  goto L1;
	else goto L100;// на выход

L101:sh[13] = sh_;
	if (sh[13] != 0) goto L100;		// SH != 0
	shr[13]++;						// след.шаг
	if (shr[13] > 1) goto L0;		// число шагов режима
	sh[13] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[13] = 0;
	goto L100;

L1: VPMAN();						// Ман в камеру
	goto L101;
}
//---------------------------------------------------------------------------
void R_14() // режим 14 "подъём п/д в HOME"
{
	sh_ = sh[14];
	if((shr[14] < 1) || (shr[14] > 2)) goto L100; // на выход

L00:if(shr[14] == 1) goto L1;
	if(shr[14] == 2) goto L2;

	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[14] = sh_;
	if (sh[14] != 0) goto L100;		// SH != 0
	shr[14]++;						// след.шаг
	if (shr[14] > 2) goto L0;		// число шагов режима
	sh[14] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 14;					// норма: "Мех. поворота в исходном"
	shr[14] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
    sh[18] = 0;							// сброс активации режима 15
	shr[18] = 0;
	diagn[15] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POD(0,0,0,1,60);                       //подъём п/д в HOME
	goto L101;
}
//---------------------------------------------------------------------------
void R_15() // режим 15 "подъём п/д СТАРТ"
{
	sh_ = sh[15];
	if ((shr[15] < 1) || (shr[15] > 2)) goto L100; // на выход

L00:if(shr[15] == 1) goto L1;
	if(shr[15] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[15] = sh_;
	if(sh[15] != 0) goto L100;		// SH != 0
	shr[15]++;						// след.шаг
	if(shr[15] > 2) goto L0;		// число шагов режима
	sh[15] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 15;						// норма: "Механизм. поворота путь прошел"
	shr[15] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[14] = 0;							// сброс активации режима 14
	shr[14] = 0;
    sh[18] = 0;							// сброс активации режима 15
	shr[18] = 0;
	diagn[15] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
    
L2: VIDK_POD(par[0][11],OTN,par[0][10],0,30);
	goto L101;
}
//---------------------------------------------------------------------------
void R_16 ()                    // режим 16 "Вращ. п/д в HOME"
{

	sh_ = sh[16];
	if ((shr[16] < 1) || (shr[16] > 2)) goto L100; // на выход

L00:if(shr[16] == 1) goto L1;
	if(shr[16] == 2) goto L2;
	goto L100;// на выход
// Конечный диспетчер режима
L101:sh[16] = sh_;
	if(sh[16] != 0) goto L100;			// SH != 0
	++shr[16];							// След. шаг
	if(shr[16] > 2) goto L0;			// Число шагов режима
	sh[16] = 1;
L100:return;							// Возврат в "кольцо"

L0: norma=16;
    shr[16] = 0;						// Конец режима
	goto L100;

L1:	sh[17] = 0;							// сброс активации режима 15
	shr[17] = 0;
	diagn[16] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_VR(0,0,0,1,60);                       //подъём п/д в HOME
	goto L101;
}
//---------------------------------------------------------------------------
void R_17 ()                    // режим 17 "Вращ. п/д на угол"
{
	sh_ = sh[17];
	if ((shr[17] < 1) || (shr[17] > 2)) goto L100; // на выход

L00:if(shr[17] == 1) goto L1;
	if(shr[17] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[17] = sh_;
	if(sh[17] != 0) goto L100;		// SH != 0
	shr[17]++;						// след.шаг
	if(shr[17] > 2) goto L0;		// число шагов режима
	sh[17] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 17;						// норма: "Механизм. поворота путь прошел"
	shr[17] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[16] = 0;							// сброс активации режима 14
	shr[16] = 0;
	diagn[16] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
    
L2: VIDK_VR(par[0][11],OTN,par[0][18],0,30);
	goto L101;
}
//---------------------------------------------------------------------------
void R_18 ()                    // режим 18 "подъём п/д в раб полож"
{
  	sh_ = sh[18];
	if((shr[18] < 1) || (shr[18] > 2)) goto L100; // на выход

L00:if(shr[18] == 1) goto L1;
	if(shr[18] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[18] = sh_;
	if (sh[18] != 0) goto L100;		// SH != 0
	shr[18]++;						// след.шаг
	if (shr[18] > 2) goto L0;		// число шагов режима
	sh[18] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 18;					// норма: "Мех. поворота в исходном"
	shr[18] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[14] = 0;							// сброс активации режима 15
	shr[14] = 0;
    sh[15] = 0;							// сброс активации режима 15
	shr[15] = 0;
	diagn[15] &= (~0xFF);				// сброс диагностики
    if(!PRR_POD)  PAR_POD=nasmod[16];
    else        PAR_POD=nasmod[17];
	sh_ = 0;
	goto L101;
    
L2: VIDK_POD(par[0][11],ABS,PAR_POD,0,30);
	goto L101;

}
//---------------------------------------------------------------------------
void R_19 ()							// Режим "Высоковакуумная откачка шлюза"
{
	sh_ = sh[19];

    if (shr[19] == 1) goto L1;
	if (shr[19] == 2) goto L2;
	if (shr[19] == 3) goto L3;
	if (shr[19] == 4) goto L4;
	if (shr[19] == 5) goto L5;
    if (shr[19] == 6) goto L6;
	if (shr[19] == 7) goto L7;
	if (shr[19] == 8) goto L8;
	if (shr[19] == 9) goto L9;
	if (shr[19] == 10) goto L10;
    if (shr[19] == 11) goto L11;
	if (shr[19] == 12) goto L12;
	if (shr[19] == 13) goto L13;
	if (shr[19] == 14) goto L14;
	if (shr[19] == 15) goto L15;


	goto L100;
	// конечный диспетчер режима
L101:sh[19] = sh_;
	if (sh[19] != 0) goto L100;		// SH != 0
	++shr[19];						// след. шаг сч.шр5
	if (shr[19] > 15) goto L0;		// число шагов режима
	sh[19] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma =19 ;						// норма: ""
	shr[19] = 0;
	goto L100;

L1: if(!(zin[1]&0x8000))
    {
        diagn[11]|=0x20;                //отказ "Дверь шлюза не закрыта"
        goto L101;
    }
    diagn[11]&=(~0x20);                 //сброс диагностики
    SetOut(0,2,0x02);               //Закрыть Кл-НАП1
    sh_=0;
    goto L101;
L2:if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1<=UVAK_SHL)
        shr[19]=7;              //переход на шаг 8
    sh_=0;
    goto L101;
L3: Klapan(0,&VvKl);//Закрыть ВК-Шл
    goto L101;
L4: Klapan(1,&FvnShl);//Вкл. форнасос шлюза
    if(sh_)goto L101;
    SetOut(1,0,0x300);          //Открыть Фк-Шл мягк
    CT_19=0;
    goto L101;
L5: if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1<=UVAK_SHL_MO)
    {
        diagn[11]&=(~0x40);         //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_19>T_KSHL_MO)
        diagn[11]|=0x40;            //отказ "Медленная мягкая откачка шлюза"
    goto L101;
L6: Klapan(1,&KlShl);//Открыть ФК-Шл
    if(sh_)goto L101;
    CT_19=0;
    goto L101;
L7: if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1<=UVAK_SHL)
    {
        diagn[11]&=(~0x80);         //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_19>T_KSHL)
        diagn[11]|=0x80;            //Отказ "Медленная откачка шлюза"
    goto L101;
L8: Klapan(0,&KlShl);//Закрыть ФК-Шл
    goto L101;
L9: Klapan(0,&FvnShl);//Откл. Форнасос шлюза
    if(sh_)goto L101;
    if((shr[6])||(PR_FOTK_SHL))
    {
        shr[19]=15;                 //выход
        PR_FOTK_SHL=0;
    }
    goto L101;
L10:Klapan(0,&DzaslKam);//Закрыть ДЗ кам
    goto L101;
L11:Klapan(1,&VvKl);//Открыть ВК-Шл
    if(sh_)goto L101;
    CT_19=0;
    goto L101;
L12:if(diagnS[0]&0x01)			// пока нет связи с Д1
		goto L101;
    if(D_D1<=nasmod[1])
    {
        diagn[12]&=(~0x01);         //сброс диагностики
        sh_=0;
        goto L101;
    }
    if(CT_19>=T_KSHL_V)
        diagn[12]|=0x01;            //отказ "Медленная высоковакуумная откачка шлюза"
    goto L101;
L13:if(diagnS[0]&0x04)			// пока нет связи с Д3
		goto L101;
    if(D_D3>UVAKN_KAM)
    {
        diagn[12]|=0x02;            //отказ "Нет форвакуума в камере"
        goto L101;
    }
    diagn[12]&=(~0x02);             //сброс диагностики
    sh_=0;
    goto L101;
L14:Klapan(0,&VvKl);//Закрыть ВК-Шл
    goto L101;
L15:Klapan(1,&DzaslKam);//Открыть ДЗ кам
    goto L101;                  //выход



}
//---------------------------------------------------------------------------
void R_20()							// РЕЖИМ 20 "Включить РРГ1"
{
	// выставление параметра РРГ
	ObjRRG[0]->parRRG = par[N_ST][0];
    SetOut(1,1,0x800);
	// запуск режима
	RRGOn(ObjRRG[0],1);				// включение РРГ1

}
//---------------------------------------------------------------------------
void R_21()							// РЕЖИМ 21 "Включить РРГ2"
{
	// выставление параметра РРГ
	ObjRRG[1]->parRRG = par[N_ST][1];
    SetOut(1,1,0x800);
	// запуск режима
	RRGOn(ObjRRG[1],1);				// включение РРГ2

}
//---------------------------------------------------------------------------
void R_22()							// РЕЖИМ 22 "Включить РРГ3"
{
	// выставление параметра РРГ
	if(shr[4])ObjRRG[2]->parRRG = nasmod[2];
    else      ObjRRG[2]->parRRG = par[0][2];
	// запуск режима
	RRGOn(ObjRRG[2],PR_RG3);				// включение РРГ3

}

//---------------------------------------------------------------------------
void R_25() // режим 25 "Открыть ДЗ кам"
{
	sh_ = sh[25];
	if ( shr[25] < 1 || shr[25] > 2 ) goto L100; // на выход

L00:if ( shr[25] == 1 ) goto L1;
	if ( shr[25] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[25] = sh_;
	if ( sh[25] != 0) goto L100;    // SH != 0
	shr[25]++;                      // след.шаг сч.шр1
	if ( shr[25] > 2) goto L0;      // число шагов режима
	sh[25] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 27;		           	    // норма: "Заслонка открылась"
	shr[25] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL1 = 7;                   // перевод в опрос состояния заслонки
    shr[26]  = 0;                   // сброс активации режима 26
	sh[26] = 0;                     // "Закрыть заслонку"
	shr[27]  = 0;                   // сброс активации режима 27
	sh[27] = 0;                     // "ДЗ на угол"
    diagn[8] &= (~0xFF);			// сброс диагностик заслонки
    diagn[7] &= (~0x08);
    diagn[3] &= (~0xF0);
	sh_ = 0;
	goto L101;
L2: Klapan(1,&DzaslKam);				// открыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_26() // режим 26 "Закрыть ДЗ кам"
{
	sh_ = sh[26];
	if ( shr[26] < 1 || shr[26] > 2 ) goto L100; // на выход

L00:if ( shr[26] == 1 ) goto L1;
	if ( shr[26] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[26] = sh_;
	if ( sh[26] != 0 ) goto L100;   // SH != 0
	shr[26]++;                      // след.шаг сч.шр1
	if ( shr[26] > 2) goto L0;    	// число шагов режима
	sh[26] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 28;		           	    // норма: "Заслонка закрылась"
	shr[26] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL1 = 7;                   // перевод в опрос состояния заслонки
    shr[25]  = 0;                   // сброс активации режима 25
	sh[25] = 0;                     // "Открыть заслонку"
	shr[27] = 0;                    // сброс активации режима 27
	sh[27] = 0;                     // "ДЗ на угол"
    diagn[8] &= (~0xFF);			// сброс диагностик заслонки
    diagn[7] &= (~0x08);
    diagn[3] &= (~0xF0);
	sh_ = 0;
	goto L101;
L2: Klapan(0,&DzaslKam);				// закрыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_27 ()            // Режим "ДЗ кам дросселирование"
 {
 sh_ = sh[27];
	if (shr[27] == 1) goto L1;
	if (shr[27] == 2) goto L2;
	if (shr[27] == 3) goto L3;
	else goto L100;      	 		// на выход

L101:sh[27] = sh_;	   			    // |                           |
	if ( sh[27] != 0) goto L100;    // |    sh_!= 0                |
	shr[27]++;		        		// |    след.шаг 	           |
	sh[27] = 1;		         		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: shr[26] = 0;                    // сброс активации режима 18
	sh[26] = 0;                     // 'Открыть заслонку'
	shr[25] = 0;                    // сброс активации режима 19
	sh[25] = 0;                     // 'Закрыть заслонку'
	VRDZASL1 = 0;               		// сброс признака выхода на режим заслонки
	diagn[8] &= (~0xFF);			// сброс диагностик заслонки
    diagn[7] &= (~0x08);
    diagn[3] &= (~0xF0);
    SetOut(0,0,0x0C);				// сброс выходов "Открыть ДЗ" и "Закрыть ДЗ"
	sh_ = 0;
	goto L101;
L2:	VIBPAR_DZASL1();		     		// выбор параметра заслонки
	VIDK_DZASL1(2,8,0x40,0); 	 		// выдать задание по давлению
	if(sh_!=0) goto L101;           // ожидание окончания выдачи задания
	ZPAR_DZASL1 = PAR_DZASL1;	            // запоминание параметра задания давления
	CT_27 = 0;	           	 		// сброс
	CT27K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L3: VIBPAR_DZASL1();		     		// выбор параметра заслонки
	if(PAR_DZASL1 == ZPAR_DZASL1)			// параметр не изменился
	{
		sh_ = 0;					// обход задания
		goto L3_8;
	}
	VIDK_DZASL1(2,8,0x40,0); 	 		// выдать задание по давлению
	if(sh_!=0) goto L101;           // ожидание окончания выдачи задания
	ZPAR_DZASL1 = PAR_DZASL1;				// зап.парам.задания давления
L3_8:PDDZASL1 ();                   	// Подготовка аналоговых данных
	RLIMDZASL1();	        			// расчет LIM для заслонки
	if (DELDZASL1 <= LIM1DZASL1) goto L3_4;// модуль Ет <= LIM1
	if (VRDZASL1 == 0) goto L3_6;		// нет выхода на режим
	diagn[8] |= 0x04;		        // отказ: "нет регулирования заслонки"
	goto L3_5;	            		// на сброс диагн."больш.ош."
L3_4:diagn[8] &= (~0x04);	   		// сброс д."нет регулирования заслонки"
	if (DELDZASL1 <= LIM2DZASL1) goto L3_5;// LIM2 (зона регулирования)
	if (VRDZASL1 == 0) goto L3_6;		// нет выхода на режим
	diagn[8] |= 0x02;		       	// отказ: "б.ош.регулирования заслонки"
	goto L3_7;
L3_5:diagn[8] &= (~0x02);	   		// сброс д."б.ош.регулирования заслонки"
	goto L3_7;
L3_6:CT27K1 = 0;
L3_7:if (CT_27 <= T_VRDZASL1) goto L3_2;// Ттек <= Тзад
	if (VRDZASL1 != 0) goto L3_1;      // есть выход на режим
	diagn[8] |= 0x01;		        // отказ: "нет выхода на режим заслонки"
	goto L3_2;
L3_1:diagn[8] &= (~0x01);	       	// сброс д."нет выхода на режим заслонки"
L3_2:if (CT27K1 <= T_KDZASL1) goto L3_3;// Т.K.тек <= Т.K.зад
	VRDZASL1 = 1;	               		// выход на режим
L3_3:shr[27] = 2;                   // Возврат на L2
	goto L101;
}
//---------------------------------------------------------------------------
void R_28 ()	                    // режим "Вкл. ВЧГ стола"
{
	sh_ = sh[28];
	if (shr[28] == 1) goto L1;
	if (shr[28] == 2) goto L2;
	if (shr[28] == 3) goto L3;
	if (shr[28] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[28] = sh_;					//  |                           |
	if(sh[28]) goto L100;			//	|    sh != 0                |
	shr[28]++;						//	|    след.шаг 	            |
	sh[28] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: VRGIS = 0;                      // сброс признака выхода на режим ВЧГ стола
	diagn[10] &= (~0xBF);            // сброс диагностики режима ВЧГ стола
    A_OUT(4,8192);                  // обнуление уставки
    VRR_GIS();                      // выставить разр. работы ВЧГ стола
    goto L101;
L2: VIBPAR_GIS();                   // выбор параметров ВЧГ стола
    A_OUT(4,2*PAR_GIS+8192);        // выдача уставки на ВЧГ стола
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,3,0x4000);				// включение выходной мощности ВЧГ стола
    CT_28 = 0;                      // очистка счетчиков
    CT28K1 = 0;                     // режима
    sh_ = 0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIS();                   // выбор параметров ВЧГ стола
    A_OUT(4,2*PAR_GIS+8192);        // выдача уставки на ВЧГ
	PDGIS ();                   	// Подготовка аналоговых данных
	RLIMGIS();	        			// новый расчет LIM для ВЧГ стола
	if (DELGIS <= LIM1GIS) goto L4_4;// модуль Ет <= LIM1
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[10] |= 0x04;		        // отказ: "нет регулирования ВЧГ п/д"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[10] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ п/д"
	if (DELGIS <= LIM2GIS) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[10] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ п/д"
	goto L4_7;
L4_5:diagn[10] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ п/д"
	goto L4_7;
L4_6:CT28K1 = 0;
L4_7:if (CT_28 <= T_VRGIS) goto L4_2;// Ттек <= Тзад
	if (VRGIS != 0) goto L4_1;      // есть выход на режим
	diagn[10] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ п/д"
	goto L4_2;
L4_1:diagn[10] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ стола"
L4_2:if (CT28K1 <= T_KGIS) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIS = 1;	               		// выход на режим
    norma = 29;                     // норма: "ВЧГ п/д вышел на режим"
L4_3:shr[28]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void R_29 ()	             		// режим "Вкл. нагрева 1"
{
	sh_ = sh[29];
	if (shr[29] == 1) goto L1;
	if (shr[29] == 2) goto L2;
	if (shr[29] == 3) goto L3;
	if (shr[29] == 4) goto L4;
	if (shr[29] == 5) goto L5;
	if (shr[29] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[29] = sh_;	   				// |                           |
	if (sh[29] != 0) goto L100;	  	// |    SH != 0                |
	shr[29]++;		        		// |    след.шаг 	           |
	sh[29] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1: SetOut(0,3,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,3,0x01);				// Вкл. пускатель нагревателя
    shr[30] = 0;					// режима 34
	sh[30] = 0;						// 'Откл. нагрева'
	VRTEMP1 = 0;               		// сброс признака выхода на режим БПН
	diagn[18] &= (~0xE7);      		// сброс диагностики режима БПН
	CT_29 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_29<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,3,0x01);			// вкл. силовое питание БПН
		CT_29 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[29] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_29<=T_VKL_BPN) goto L101;
		diagn[18]|=0x08;			// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,3,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[18]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP1();		     		// выбор параметра БПН
	VIDK_TEMP1(1,18,040,1);			// выдать задание по температуре
	if(sh_) goto L101;            	//
	ZPAR_TEMP1 = PAR_TEMP1;			// запоминание параметра задания температуры
	CT_29 = 0;	           			// сброс
	CT29K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP1();		     		// выбор параметра БПН
	if ( PAR_TEMP1 == ZPAR_TEMP1 )  // параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 	// обход задания
	VIDK_TEMP1(1,18,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;           //
	ZPAR_TEMP1 = PAR_TEMP1; 		// зап.парам.задания температуры
L6_8:	PDTEMP1 ();                 // Подготовка аналоговых данных
	RLIMTEMP1();	        		// расчет LIM для БПН
	if (DELTEMP1<=LIM1TEMP1)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[18] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[18] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP1<=LIM2TEMP1)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP1 == 0) goto L6_6;	// нет выхода на режим
	diagn[18] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[18] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT29K1 = 0;
L6_7:if (CT_29<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP1 != 0) goto L6_1;     // есть выход на режим
	diagn[18] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[18] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT29K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP1 = 1;	               		// выход на режим
L6_3:shr[29]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void R_30() // режим 30 "Откл. нагрева 1"
{
	sh_ = sh[30];

L00:if (shr[30] == 1)  goto L1;
	if (shr[30] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[30] = sh_;
	if (sh[30] != 0) goto L100;   // SH != 0
	shr[30]++;                    // след.шаг сч.шр1
	if (shr[30] > 2) goto L0;    	// число шагов режима
	sh[30] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[30] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[29]  = 0;                  // режима 33
	shr[29] = 0;                  // "Вкл. БПН"
	diagn[18] &= (~0xE7);		// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP1(1,18,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//---------------------------------------------------------------------------
void R_31 ()	             		// режим "Вкл. нагрева 2"
{
	sh_ = sh[31];
	if (shr[31] == 1) goto L1;
	if (shr[31] == 2) goto L2;
	if (shr[31] == 3) goto L3;
	if (shr[31] == 4) goto L4;
	if (shr[31] == 5) goto L5;
	if (shr[31] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[31] = sh_;	   					// |                           |
	if (sh[31] != 0) goto L100;	  	// |    SH != 0                |
	shr[31]++;		        		// |    след.шаг 	           |
	sh[31] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1:	SetOut(0,3,0x03);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,3,0x01);				// Вкл. пускатель нагревателя
	shr[32] = 0;                   	// режима 36
	sh[32] = 0;                     // 'Откл. нагрева'
	VRTEMP2 = 0;               		// сброс признака выхода на режим БПН
	diagn[19] &= (~0xE7);      		// сброс диагностики режима БПН

	CT_31 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_31<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,3,0x01);			// вкл. силовое питание БПН
		CT_31 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[31] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_31<=T_VKL_BPN) goto L101;
		diagn[18]|=0x08;				// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:SetOut(0,3,0x03);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[18]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP2();                   // выбор параметров нагрева
	VIDK_TEMP2(1,19,040,1); 		// выдать задание по температуре
	if(sh_) goto L101;            //
	ZPAR_TEMP2 = PAR_TEMP2;			// запоминание параметра задания температуры
	CT_31 = 0;	           			// сброс
	CT31K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP2();                   // выбор параметров нагрева
	if(PAR_TEMP2 == ZPAR_TEMP2)   	// параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 		// обход задания
	VIDK_TEMP2(1,19,040,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;            //
	ZPAR_TEMP2 = PAR_TEMP2; 			// зап.парам.задания температуры
L6_8:PDTEMP2();                 	// Подготовка аналоговых данных
	RLIMTEMP2();	        			// расчет LIM для БПН
	if (DELTEMP2<=LIM1TEMP2)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP2 == 0) goto L6_6;		// нет выхода на режим
	diagn[19] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[19] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP2<=LIM2TEMP2)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP2 == 0) goto L6_6;		// нет выхода на режим
	diagn[19] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[19] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT31K1 = 0;
L6_7:if (CT_31<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP2 != 0) goto L6_1;     // есть выход на режим
	diagn[19] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[19] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT31K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP2 = 1;	               		// выход на режим
L6_3:shr[31]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void R_32() // режим 32 "Откл. нагрев 2"
{
	sh_ = sh[32];

L00:if (shr[32] == 1)  goto L1;
      if (shr[32] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[32] = sh_;
	if (sh[32] != 0) goto L100;   // SH != 0
	shr[32]++;                    // след.шаг сч.шр1
	if (shr[32] > 2) goto L0;    	// число шагов режима
	sh[32] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[32] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[31]  = 0;                  	// режима 35
	shr[31] = 0;                  	// "Вкл. БПН"
	diagn[19] &= (~0xE7);			// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP2(1,19,0100,0);		// выкл. БПН 0 температуры
	goto L101;
}
//----------------------------------------------------------------------------
void R_33()							// режим "БПМ вкл"
{
	sh_ = sh[33];
	if (shr[33] == 1) goto L1;
	if (shr[33] == 2) goto L2;
	if (shr[33] == 3) goto L3;
	if (shr[33] == 4) goto L4;
	if (shr[33] == 5) goto L5;
	if (shr[33] == 6) goto L6;
    else goto L100;              // на выход

										// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[33] = sh_;	   	            	// |                           |
    if (sh[33] != 0) goto L100;      	// |    SH != 0                |
    shr[33]++;		            		// |    след.шаг 	           |
    sh[33] = 1;		            		// |						   |
L100:return;			    			// |    возврат в "кольцо"	   |

L1: VRBMH1 = 0;                       // сброс признака выхода на режим БПМ
	diagn[28] &= (~0xFF);            // сброс диагностик БПМ
// Проверка включения и включение подсистем БПМ
    if(PR_SV_BMH1 == 0) goto L101;   // Нет готовности связи БПМ
    if((OTVET_BMH1[9] & 0x800) != 0)    // Блок включен
    {
        shr[33] = 3;
        sh_ = 0;
        goto L101;                  // Переход на L4
    }
    sh_ = 0;
    goto L101;
L2: VIDK_BMH1(0x1804,0x800,1,28,0x10);  // Вкл. блок БПМ
    if(sh_) goto L101;
    CT_33 = 0;                      // сброс счетчика времени режима
    goto L101;
L3: if(CT_33 <= 2) goto L101;       // задержка 2 сек на включение пускателя БПМ
    sh_ = 0;
    goto L101;
L4: SetOut(0,3,0x100);        		// снятие блокировки Uвых БПМ
    VIBPAR_BMH1();			// выбор параметра БПМ
    RLIMBMH1();	  	            // задание LIM для БПМ
    sh_ = 0;
    goto L101;
    // выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_BMH1(0x800,0x1000,0,28,0x40);  // Вкл. Uвых. БПМ
    if(sh_) goto L101;
    CT_33 = 0;	            	    // сброс
    CT33K1 = 0;	            	    // счетчиков
    goto L101;
    // выход на режим и диагностика
L6: VIBPAR_BMH1();				// выбор параметра БПМ
    VIDK_BMH1(0x800,0x1000,0,28,0x40);  // выдать уставку БПМ
    if(sh_) goto L101;           // (Вкл.Uвых.)
    PDBMH1();                       // Подготовка аналоговых данных
    RLIMBMH1();	        	    // новый расчет LIM для БПМ
    if(DELBMH1 <= LIM1BMH1) goto L6_4; // модуль Ет <= LIM1
    if(VRBMH1 == 0) goto L6_6;	    // нет выхода на режим
    diagn[28] |= 0x04;		    // отказ: "нет регулирования БПМ"
    goto L6_5;	            	    // на сброс диагн."больш.ош."
L6_4:diagn[28] &= (~0x04);	    // сброс д."нет регулирования БПМ"
    if(DELBMH1 <= LIM2BMH1) goto L6_5; // LIM2 (зона регулирования)
    if(VRBMH1 == 0) goto L6_6;	    // нет выхода на режим
    diagn[28] |= 0x02;		    // отказ: "б.ош.регулирования БПМ"
    goto L6_7;
L6_5:diagn[28] &= (~0x02);	    // сброс д."б.ош.регулирования БПМ"
    goto L6_7;
L6_6:CT33K1 = 0;
L6_7:if(CT_33 <= T_VRBMH) goto L6_2; // Ттек <= Тзад
    if(VRBMH1 != 0) goto L6_1;        // есть выход на режим
    diagn[28] |= 0x01;		    // отказ: "нет выхода на режим БПМ"
    goto L6_2;
L6_1:diagn[28] &= (~0x01);	    // сброс д."нет выхода на режим БПМ"
L6_2:if(CT33K1 <= T_KBMH) goto L6_3; // Т.K.тек <= Т.K.зад
    VRBMH1 = 1;	               	    // выход на режим
L6_3:shr[33] = 5;                   // Возврат на L6
    goto L101;
}
//---------------------------------------------------------------------------
void R_34 ()                        // режим "БПМ откл"
{
	sh_ = sh[34];
	if (shr[34] < 1 || shr[34] > 2) goto L100; // на выход

    if (shr[34] == 1)  goto L1;        if (shr[34] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[34] = sh_;
	if (sh[34] != 0) goto L100;   	// SH != 0
	shr[34]++;                    	// след.шаг сч.шр1
	if (shr[34] > 2) goto L0;    	// число шагов режима
	sh[34] = 1;
L100: return;  	                	// возврат в "кольцо"

L0: shr[34] = 0;
    norma = 33;                 // "Сброс БПМ завершен"
	goto L100;

L1:	shr[33] = 0;				// сброс активизации режима R_35
	sh[33] = 0;					// "М1"
    SetOut(1,3,0x100);
	sh_ = 0;
	goto L101;
L2:	VIDK_BMH1(0x1804,0x1000,1,28,0x80); // команда "Выкл. Uвых БПМ1"
	if(sh_) goto L101;			// ожидание завершения
	diagn[28] &= (~0xFF);		// сброс диагностик реж. БПМ1
    PAR_BMH1_P = 0;				// сброс параметров М1
    PAR_BMH1_I = 0;
    goto L101;
}
//------------------------------------------------------------------------------
void R_35 ()	                    // режим "Поворот заслонки в HOME"
{
	sh_ = sh[35];
	if((shr[35] < 1) || (shr[35] > 2)) goto L100; // на выход

L00:if(shr[35] == 1) goto L1;
	if(shr[35] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[35] = sh_;
	if (sh[35] != 0) goto L100;		// SH != 0
	shr[35]++;						// след.шаг
	if (shr[35] > 2) goto L0;		// число шагов режима
	sh[35] = 1;
L100: return;						// возврат в "кольцо"

L0:	norma = 55;					// норма: "Мех. поворота в исходном"
	shr[35] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[36] = 0;							// сброс активации режима 15
	shr[36] = 0;
	diagn[17] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
L2: VIDK_POV(0,0,0,1,60);                       //поворот заслонки
	goto L101;
}
//------------------------------------------------------------------------------

void R_36 ()	                    // режим "Поворот заслонки на угол"
{
	sh_ = sh[36];
	if ((shr[36] < 1) || (shr[36] > 2)) goto L100; // на выход

L00:if(shr[36] == 1) goto L1;
	if(shr[36] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[36] = sh_;
	if(sh[36] != 0) goto L100;		// SH != 0
	shr[36]++;						// след.шаг
	if(shr[36] > 2) goto L0;		// число шагов режима
	sh[36] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 56;						// норма: "Механизм. поворота путь прошел"
	shr[36] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:	sh[35] = 0;							// сброс активации режима 14
	shr[35] = 0;
	diagn[17] &= (~0xFF);				// сброс диагностики
	sh_ = 0;
	goto L101;
    
L2: VIDK_POV(par[0][11],OTN,par[0][19],0,30);
	goto L101;
}
 //-----------------------------------------------------------------------------------
void R_37()							// РЕЖИМ 37 "Открыть ДЗ масс-спектр"
{
    sh_ = sh[37];
	if ( shr[37] < 1 || shr[37] > 2 ) goto L100; // на выход

L00:if ( shr[37] == 1 ) goto L1;
	if ( shr[37] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[37] = sh_;
	if ( sh[37] != 0) goto L100;    // SH != 0
	shr[37]++;                      // след.шаг сч.шр1
	if ( shr[37] > 2) goto L0;      // число шагов режима
	sh[37] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 34;		           	    // норма: "Заслонка открылась"
	shr[37] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL2 = 7;                   // перевод в опрос состояния заслонки
    shr[38]  = 0;                   // сброс активации режима 26
	sh[38] = 0;                     // "Закрыть заслонку"
	shr[39]  = 0;                   // сброс активации режима 27
	sh[39] = 0;                     // "ДЗ на угол"
    diagn[9] &= (~0xFF);			// сброс диагностик заслонки
    diagn[7] &= (~0x10);
    diagn[4] &= (~0x0F);
	sh_ = 0;
	goto L101;
L2: Klapan(1,&DzaslMass);				// открыть заслонку
	goto L101;
}
//---------------------------------------------------------------------------
void R_38 ()	                    // режим "Закрыть ДЗ масс-спектр"
{
    sh_ = sh[38];
	if ( shr[38] < 1 || shr[38] > 2 ) goto L100; // на выход

L00:if ( shr[38] == 1 ) goto L1;
	if ( shr[38] == 2 ) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[38] = sh_;
	if ( sh[38] != 0 ) goto L100;   // SH != 0
	shr[38]++;                      // след.шаг сч.шр1
	if ( shr[38] > 2) goto L0;    	// число шагов режима
	sh[38] = 1;
L100: return;                  	    // возврат в "кольцо"

L0: norma = 35;		           	    // норма: "Заслонка закрылась"
	shr[38] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: KOM_DZASL2 = 7;                   // перевод в опрос состояния заслонки
    shr[37]  = 0;                   // сброс активации режима 25
	sh[37] = 0;                     // "Открыть заслонку"
	shr[39] = 0;                    // сброс активации режима 27
	sh[39] = 0;                     // "ДЗ на угол"
    diagn[9] &= (~0xFF);			// сброс диагностик заслонки
    diagn[7] &= (~0x10);
    diagn[4] &= (~0x0F);
	sh_ = 0;
	goto L101;
L2: Klapan(0,&DzaslMass);				// закрыть заслонку
	goto L101;
}
//------------------------------------------------------------------------------
void R_39 ()	                    // режим "ДЗ масс-спектр на угол"
{
      sh_ = sh[39];
  if (shr[39] == 1) goto L1;
  if (shr[39] == 2) goto L2;
  if (shr[39] == 3) goto L3;
  if (shr[39] == 4) goto L4;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[39] = sh_;
	if (sh[39] != 0) goto L100;    // SH != 0
	++shr[39];                     // след. шаг сч.шр5
	if (shr[39] > 4) goto L0;     // число шагов режима
	sh[39] = 1;
L100:return;                    // возврат в "кольцо"

L0:	norma = 36;                   // норма: "ДЗ пришла в позицию"
	shr[39] = 0;
	goto L100;

L1:	shr[37] = 0;				// сброс активизации режима 25
	sh[37] = 0;
	shr[38] = 0;				// сброс активизации режима 26
	sh[38] = 0;
    diagn[9] &= (~0xFF);			// сброс диагностик заслонки
    diagn[7] &= (~0x10);
    diagn[4] &= (~0x0F);
L1_1:   VRDZASL2 = 0;
        VIBPAR_DZASL2();		     		// выбор параметра заслонки
	sh_ = 0;
	goto L101;
L2:	VIDK_DZASL2(1,9,0x20,PAR_DZASL2);    // открыть ДЗ на угол
	CT_27 = 0;
	goto L101;
L3:	if(TEK_POZ_DZASL2 != PAR_DZASL2)
	{
		if(CT_39 >= T_VRDZASL2)
			diagn[7] |= 0x10;		// диагностика "ДЗ не пришла в заданное положение"
		goto L101;
	}
	diagn[7] &= (~0x10);          // сброс диагностики
	VRDZASL2 = 1;
	ZPAR_DZASL2 = PAR_DZASL2;
	sh_ = 0;
	goto L101;
L4: VIBPAR_DZASL2();
    if(PAR_DZASL2 == ZPAR_DZASL2) // задание не изменилось
		goto L101;
	shr[39] = 1;
	goto L1_1;						// возврат на шаг 1_1
}

//------------------------------------------------------------------------------
void R_40()					// Режим "Измеритель сопротивления 1 точка"
{
    sh_ = sh[40];

	if (shr[40] == 1) goto L1;
	if (shr[40] == 2) goto L2;
	if (shr[40] == 3) goto L3;
    if (shr[40] == 4) goto L4;
	else goto L101;	// выход

L101:sh[40] = sh_;
	if (sh[40] != 0) goto L100;		// SH != 0
	++shr[40];						// след. шаг
	if (shr[40] > 4) goto L0;		// число шагов режима
	sh[40] = 1;
L100:return;

L0:	shr[40] = 0;
	goto L100;

L1: VIDK_POD(0,0,0,1,30);//Подъём п/д в HOME
    goto L101;
    
L2: VIDK_POV(0,ABS,par_t[0] + Rash_Pov(par[0][13]),0,30);//Заслонка п/д в точку измерения
    if(sh_)goto L101;
    if(par[0][13]==0)
        shr[40]=3;      //переход на шаг 4
    goto L101;
L3: VIDK_VR(0,ABS,Rash_Vr(par[0][13]),0,30);//Вращение п/д в точку измерения
    goto L101;

L4: VIDK_POD(0,ABS,nasmod[17],0,30);//Подъём п/д в точку измер
    goto L101;
}
//---------------------------------------------------------------------------
void R_41()					// Режим "Измеритель сопротивления след. точка"
{
	sh_ = sh[41];

	if (shr[41] == 1) goto L1;
	if (shr[41] == 2) goto L2;
	if (shr[41] == 3) goto L3;
	if (shr[41] == 4) goto L4;
	else goto L101;	// выход

L101:sh[41] = sh_;
	if (sh[41] != 0) goto L100;		// SH != 0
	++shr[41];						// след. шаг
	if (shr[41] > 4) goto L0;		// число шагов режима
	sh[41] = 1;
L100:return;

L0:	shr[41] = 0;
	goto L100;

L1:	VIDK_POD(0,0,0,1,30);//Подъём п/д в HOME
    goto L101;
L2: VIDK_POV(0,ABS,par_t[0] + Rash_Pov(par[0][13]),0,30);//Заслонка п/д в точку измерения
    goto L101;
L3: VIDK_VR(0,OTN,par[0][14],0,30);//Вращение п/д в точку
    goto L101;
L4: VIDK_POD(0,ABS,nasmod[17],0,30);//Подъём п/д в точку измерения
    goto L101;
}
//------------------------------------------------------------------------------
void R_43 ()			         // режим  "Включить поддержание соотношение газов (УУН-СГ)"
{			                 // индекс устройства SG
	sh_ = sh[43];
	if (shr[43] == 1) goto L1;
	if (shr[43] == 2) goto L2;
	if (shr[43] == 3) goto L3;
	if (shr[43] == 4) goto L4;
    else goto L100;                      // на выход

                                         //    | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[43] = sh_;		         //    |                           |
	if (sh[43] != 0) goto L100;         //    |    SH != 0                |
	shr[43]++; 	                 //    |    след.шаг сч.шр 43      |
	sh[43] = 1;		         //    |                           |
L100:return;                             //    |    возврат в "кольцо"     |

L1:	V_Tok();//Включить ток эмиссии
	if(sh_)goto L101;
	shr	[21]=0;						//Сброс активиз. режима 21
	sh	[21]=0;						//"РРГ2"
	diagn[6]&=(~0x0F);					//сброс диагностик режима 21
	//A_OUT(1,8192);					// обнуление уставки
	goto L101;
L2: VRSG = 0;						// сброс признака выхода на режим УУН-СГ
    //A_OUT(1,8192);					// обнуление уставки
    diagn[25] &= (~0x07);				// сброс диагностик режима УУН-СГ
	//SetOut(1,1,0x200);				//открыть клапан Кл2			
    CT_43 = 0;						// обнуление сч.вр.режима УУН-СГ
    sh_ = 0;
    goto L101;
L3: if(CT_43 <= 0) goto L101;            //задержка 0 сек на откачку магистрали 
    CT_43 = 0;                           // обнуление сч.вр.режима УУН-СГ
    sh_ = 0;
    goto L101;
L4: RABSG();		                 // работа УУН-СГ
    goto L101;
}
//----------------------------------------------------------------------------
void RABSG ()			         // подпрограмма "Работа УУН-СГ"
{
    long T1;
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else goto A100;	                // на выход
	// расчет приращений LIMU при пробое
A1: PORCPR_SG = LIMUSG / T_VPRB_SG;	// расчет порции
	LIMUPR_SG = LIMUSG % T_VPRB_SG;	// остаток-нач.ограничение
				 // по уставке при пробое
	// расчет приращений LIMU при выходе на режим
	PORCNV_SG = LIMUSG / T_VREJ_SG;	// расчет порции
	LIMU_SG = LIMUSG % T_VREJ_SG;	// остаток-нач.ограничение по
					// уставке при выходе на реж.
	CT_VRSG = 0;		        // обнуление счетчика выхода на режим
	E_PSG = 0;		        // обнуление предыдущей ошибки,
	SOSG = 0;		        // сумматора остатков,
	U_PSG = 0;		        // предыдущей уставки,
	VRSG = 0;		        // признака выхода на режим УУН-СГ
	PROBSG = 0;		        // признак отработки пробоя
	sh_ = 2;
	// выход на режим УУН-СГ
A2: VIBPAR_SG();		        // выбор параметра УУН-СГ
	REQSG();	        	// регулятор УУН-СГ
	if (CT_VRSG == 0) goto A100;    // пров. CT.VR на ноль (время не вышло)
	T1 = CT_VRSG; T1 *= PORCNV_SG;
	if (T1 > LIMUSG) goto S1;       // MAX достигнут
	LIMU_SG = T1;		        // выдача текущего LIMU
A100:return;			        // выход
S1: LIMU_SG = LIMUSG;	                // выдача MAX LIMU
	CT43K1 = 0;		        // сброс счетчика к.времени опред.ошибки
	CT_43 = 0;		        // и выхода на режим
	sh_ = 3;
	// анализ выхода на режим УУН-СГ
A3: UN_SG();		                // регулятор УУН-СГ с отработкой пробоя
	if (DELSG < LIM2SG) goto S2;    // Тош < LIM
	CT43K1 = 0;
	if (CT_43 > T_VRSG)	        // время выхода на режим вышло
	diagn[25] |= 0x01;               // отказ: "нет выхода на режим УУН-СГ"
	goto S3;
S2: if (CT43K1 <= T_KSG) goto S4;// Т.K.тек <= Т.K.зад
	diagn[25] &= (~0x01);	        // сброс д."нет выхода на режим УУН-СГ"
	VRSG = 1;		        // признак выхода на режим УУН-СГ
	goto S3;
S4: VRSG = 0;	                        // сброс признака выхода на режим УУН-СГ
S3: if (VRSG == 0) goto S5;	        // нет выхода на режим УУН-СГ
	CT_43 = 0;	        	// сброс счетчика режима УУН-СГ
	sh_ = 4;
	goto A100;
S5: diagn[25] &= (~0x06);	        // сброс д."нет рег.УУН-СГ" и "б.ош.рег.УУН-СГ"
	goto A100;
A4: UN_SG();		                // регулятор УУН-СГ с отработкой пробоя
	goto A100;
}
//----------------------------------------------------------------------------
void UN_SG ()		             // подпрограмма "рег.УУН-СГ с отработкой пробоя"
{
    long T1;
	// определение пробоя УУН-СГ
    //???? if ((ZIN2 & 01400) != 0) goto S3;// пробой: перегрузка или дуга
	if (PROBSG == 0		                 // нет отработки пробоя
			|| CT_PR_SG == 0) goto S2;
	// расчет и выдача текущей LIMU_SG
	T1 = CT_PR_SG; T1 *= PORCPR_SG;
	if (T1 > LIMUSG) goto S1;    // MAX достигнут
	LIMU_SG = T1;	             // выдача текущей LIMU
	goto S2;
S1: LIMU_SG = LIMUSG;                // выдача MAX LIMU
	PROBSG = 0;	             // сброс признака отработки пробоя
	goto S2;
	// начальная отработка пробоя
S3: PROBSG = 1;		             // признак отработки пробоя УУН-СГ
	LIMU_SG = LIMUPR_SG;         // выдать начальное ограничение
	CT_PR_SG = 0;		     // сброс сч.пробоя
S2: UN_DSG();
}
//----------------------------------------------------------------------------
void UN_DSG ()		             // подпрограмма "рег.УУН-СГ с диагностикой"
{
	VIBPAR_SG();		     // выбор параметра УУН-СГ
	REQSG();		     // регулятор УУН-СГ
	RLIMSG();	             // расчет LIM1,LIM2 для УУН-СГ
	if (DELSG <= LIM1SG) goto S1;// модуль Ет <= LIM1
	diagn[25] |= 0x04;	     // отказ: "нет регулирования УУН-СГ"
	goto S2;
S1: diagn[1] &= (~040);	     // сброс д."нет регулирования УУН-СГ"
	if (DELSG <= LIM2SG) goto S2;// LIM2 (зона регулирования)
	diagn[25] |= 0x02;	     // отказ: "большая ошибка рег.УУН-СГ"
	goto A100;
S2: diagn[25] &= (~0x02);     	     // сброс д."большая ошибка рег.УУН-СГ"
A100:return;
}
//----------------------------------------------------------------------------
void RLIMSG ()		             // подпрограмма "Расчет LIM для УУН-СГ"
{
	if (PAR_SG == 0)	     // если задание = 0, расшир.лимитов
    {
       LIM1SG = 7000;		     // MAX доп.знач.по входу ап.ср.
	   LIM2SG = LIM1SG / 5;     // LIM2 = 0,2 LIM1 (для датчика 979)
    }
    else
    {
	LIM2SG = PAR_SG / DOPSG;     // LIM2 (малый)
	    LIM1SG = PAR_SG / 5;    // LIM1 (большой) - 20% (для датчика 979)
    }
}
//----------------------------------------------------------------------------
void REQSG ()			         // подпрограмма "Регулятор УУН-СГ"
{
    long T1,PPSSG,PISSG;
	int PSSG,ISSG,INVSOSG;

	if (CT_REQSG <= T_REQSG) return;// ограничение регулятора УУН-СГ
	CT_REQSG=0;			            // по быстродействию
	PDSG();               		 // подготовка аналоговых данных УУН-СГ
	VBKSG();			         // выбор коэф-тов регулятора УУН-СГ
	// расчет пропорциональной составляющей регулятора
	T1 = K_PSG;			         // расширение коэф-та до типа LONG
	PPSSG = T1 * (E_TSG - E_PSG);// полная Р-сост.=Кр * (Етек - Епред)
	PSSG = PPSSG / 100;	         // P-составляющая регулятора со смещением
	// проверка Р-составляющей на лимит
	if (PSSG < 0) goto S1;	     // если "-"
	if (PSSG > LIMPSG) PSSG = LIMPSG; // если > LIM
	goto S0;
S1: if ((PSSG + LIMPSG) > 0) goto S0;
	PSSG = LIMPSG * (-1);		 // если < (-LIM)
	// расчет интегральной составляющей регулятора
S0: T1 = K_ISG;			         // расширение коэф-та до типа LONG
	PISSG = T1 * E_TSG;		     // полная I-сост.= Ки * Етек
	ISSG = PISSG / 100;	         // I-составляющая регулятора со смещением
	{ // суммирование остатков
	SOSG += PISSG % 100;	 // прибав.остатка деления к сумматору
	    if (SOSG < 0) goto S1_1; // сумматор меньше нуля
	    if (SOSG < LOSG) goto S1_3; // сравнение с лимитом остатков
	    ISSG = ISSG + 1;		 // увеличение I-сост.на (...)
	    goto S1_2;
S1_1:   INVSOSG = SOSG * (-1);	 // изменение знака сумматора остатков
	    if (INVSOSG < LOSG) goto S1_3;
	    ISSG = ISSG - 1;		 // уменьшение I-сост.на (...)
S1_2:   SOSG = 0;			     // обнуление сумматора
	}
	// проверка I-составляющей на лимит
S1_3:if (ISSG < 0) goto S2;		 // если "-"
	if (ISSG > LIMISG) ISSG = LIMISG; // если > LIM
	goto S3;
S2: if ((ISSG + LIMISG) > 0) goto S3;
	ISSG = LIMISG * (-1);		 // если < (-LIM)
S3: U_PSG += (PSSG + ISSG);	     // уставка = Uпред + (P-сост + I-сост)
	// ограничение по уставке
	if (U_PSG < 0) goto S4;	     // < 0
	if (U_PSG > LIMU_SG) U_PSG = LIMU_SG; // LIMU_SG - переменный
	goto S5;
S4: U_PSG = 0;
S5: E_PSG = E_TSG;		      	// запоминание ошибки
	A_VIH = U_PSG+8192;	  	// выдача уставки (уст+8192+4095(5в))
	A_OUT (1,A_VIH);	    	// со смещением для платы DA8
}
//----------------------------------------------------------------------------
void PDSG ()			         // подготовка аналоговых данных УУН-СГ
{	
	// тек.значение соотношения парциональных давлений Ar и O2
	if(aik[16])
		X_TSG = aik[15]/aik[16];
	else
		X_TSG = aik[15]/1;
                                                 
	E_TSG = X_TSG -PAR_SG ;	     // Хтек - Хзад = Етек (тек.ошибка)
	if (E_TSG >= 0) DELSG = E_TSG;
	else  DELSG = E_TSG * (-1);	 // вычисление модуля ошибки
}
//----------------------------------------------------------------------------
void VBKSG ()			         // выбор коэф-тов регулятора УУН-СГ
{
    int i;
    for (i = 0; i <= 8; i++)
	   if (DELSG > MZRSG[i]) {} else break;// опред.зоны регулирования
	K_PSG = MKPSG[i]; K_ISG = MKISG[i];	// коэф-ты для P- и I- сост.
}
//----------------------------------------------------------------------------
void VIBPAR_SG ()		   // подпрограмма "Выбор параметра УУН-СГ"
{
    PAR_SG = par[N_ST][15]/par[N_ST][16];//Заданное значение Ar/O2
}
//------------------------------------------------------------------------------
void SBROSR_43()                         // "Сброс режима 43 поддержание соотношения газов"
{
	shr[43] = 0;                          // сброс активизации режима "УУН-СГ"
	sh[43] 	= 0;
	diagn[25] &= (~0x07);                  // сброс диагностик
	SetOut(0,1,0x200);					// закрыть клапан (Кл2 РРГ2)

	A_OUT(1,8192);                        // сброс уставки
	PAR_SG = 0;                           // сброс параметра
	norma = 64;                           // норма: "Сброс  завершен"
}
//------------------------------------------------------------------------------
void R_44 ()			         // режим  "Откл. Поддержание соотношение газов "
{			                 // индекс устройства SG
	sh_ = sh[44];
	if (shr[44] == 1) goto L1;
	if (shr[44] == 2) goto L2;
    else goto L100;                      // на выход

                                         //    | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[44] = sh_;
	if (sh[44] != 0) goto L100;	// sh_ != 0
	++shr[44];					// след. шаг сч.шр1
	if (shr[44] > 2) goto L0;	// число шагов режима
	sh[44] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 64;					// норма: "Поддержание соотношения газов отключено"
	shr[44] = 0;
	goto L100;

L1:	shr	[43]=0;
	sh	[43]=0;
	diagn[25]&=(~0x07);					//сброс диагностик режима 43
	sh_=0;
	goto L101;
L2:	O_Tok();//Отключить ток эмиссии
	if(sh_)goto L101;
	SetOut(0,1,0x200);				//закрыть Кл2
	A_OUT(1,8192);					// обнуление уставки
	goto L101;
}
/////////////////////////////////////////////////////////////////////////////////////
void V_Tok()							//Подпрограмма включения тока эмиссии
{
	switch (sh_)
	{
		case 1:
		{
			SetOut(1,3,0x400);			//Выставить сигнал "Включить эмиссию"
			CT_Tok=0;					//Сбросить счётчик времени
			sh_=2;
			return;
		}
		case 2:
		{
			if(!(zin[4]&0x01))			//Эмисия не включена
			{
				if(CT_Tok>=10)			//Время вышло
					diagn[25]|=0x08;		//отказ "Ток эмиссии не включился"
				return;
			}
			diagn[25]&=(~0x08);				//сброс диагностики
			norma=65;					//норма: "Ток эмиссии включён"
			sh_=0;
			return;
		}
		default:
			return;
		
	}
}
/////////////////////////////////////////////////////////////////////////////////////
void O_Tok()							//Подпрограмма отключения тока эмиссии
{
	switch (sh_)
	{
		case 1:
		{
			SetOut(0,3,0x400);			//Снять сигнал "Включить эмиссию"
			CT_Tok=0;					//Сбросить счётчик времени
			sh_=2;
			return;
		}
		case 2:
		{
			if((zin[4]&0x01))			//Эмисия не отключена
			{
				if(CT_Tok>=10)			//Время вышло
					diagn[25]|=0x10;		//отказ "Ток эмиссии не отлючился"
				return;
			}
			diagn[25]&=(~0x10);				//сброс диагностики
			norma=66;					//норма: "Ток эмиссии отключён"
			sh_=0;
			return;
		}
		default:
			return;
		
	}
}
//------------------------------------------------------------------------------
void R_45()					// Режим "Вкл. откачной пост"
{
	sh_ = sh[45];

	if (shr[45] == 1) goto L1;
	if (shr[45] == 2) goto L2;
	if (shr[45] == 3) goto L3;
	if (shr[45] == 4) goto L4;
	else goto L101;	// выход

L101:sh[45] = sh_;
	if (sh[45] != 0) goto L100;		// SH != 0
	++shr[45];						// след. шаг
	if (shr[45] > 4) goto L0;		// число шагов режима
	sh[45] = 1;
L100:return;

L0:	shr[45] = 0;
	goto L100;

L1:	Klapan(0,&KlOp);//Закрыть ФК-ОП
    if(sh_)goto L101;
    shr[46]=0;                      //сброс активиз. режима 46
    sh[46]=0;
    SetOut(1,3,0x40);               //Вкл. форнасос отк. поста
    goto L101;
L2: if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4>=UVAK_TMNOP)
        goto L101;
    sh_=0;
    goto L101;
L3: VVAK_NASOS();//Вкл. ТМН ОП
    goto L101;
L4: if(diagnS[0]&0x08)			// пока нет связи с Д4
		goto L101;
    if(D_D4>=UVVAK_TMNOP)
        goto L101;
    sh_=0;
    goto L101;

}
//------------------------------------------------------------------------------
void R_46()					// Режим "Откл. откачной пост"
{
	sh_ = sh[46];

	if (shr[46] == 1) goto L1;
	if (shr[46] == 2) goto L2;
	if (shr[46] == 3) goto L3;
	else goto L101;	// выход

L101:sh[46] = sh_;
	if (sh[46] != 0) goto L100;		// SH != 0
	++shr[46];						// след. шаг
	if (shr[46] > 3) goto L0;		// число шагов режима
	sh[46] = 1;
L100:return;

L0:	shr[46] = 0;
	goto L100;

L1: Klapan(0,&KlOp);//Закрыть ФК-ОП
    if(sh_)goto L101;
    shr[45]=0;                      //сброс активиз. режима 45
    sh[45]=0;
    goto L101;
L2: OVAK_NASOS();//Откл. ТМН ОП
    if(sh_)goto L101;
    CT_46=0;
    goto L101;
L3: if(CT_46<T_OSTANOV_TMNOP)
        goto L101;
    SetOut(0,3,0x40);               //Откл. форнасос ОП
    sh_=0;
    goto L101;

}
//---------------------------------------------------------------------------
void R_47() // режим 47 "ВКЛ вращ магн"
{
	sh_ = sh[47];
	if ((shr[47] < 1) || (shr[47] > 2)) goto L100; // на выход

L00:if(shr[47] == 1) goto L1;
	if(shr[47] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[47] = sh_;
	if(sh[47] != 0) goto L100;		// SH != 0
	shr[47]++;						// след.шаг
	if(shr[47] > 2) goto L0;		// число шагов режима
	sh[47] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 37;					// норма:
	shr[47] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:     SetOut(0,2,0x10);	// сняли стоп
        SetOut(1,2,0x08);	// дали пуск
        diagn[12] &= (~0x0C);
        shr[48]=0;
        sh[48]=0;
        CT_47 = 0;
	sh_ = 0;
	goto L101;

L2:     if(zin[2]&0x200)  {
                diagn[12] &= (~0x04); //сбросили диагностику
                sh_ = 0;             //выход
                goto L101;
                }
        if(CT_47 >= T_M_VR)
                diagn[12] |= 0x04; //выставили диагностику нет вращаения
        goto L101;

}
//---------------------------------------------------------------------------
void R_48() // режим 48 "ВЫКЛ вращ магн"
{
	sh_ = sh[48];
	if ((shr[48] < 1) || (shr[48] > 2)) goto L100; // на выход

L00:if(shr[48] == 1) goto L1;
	if(shr[48] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[48] = sh_;
	if(sh[48] != 0) goto L100;		// SH != 0
	shr[48]++;						// след.шаг
	if(shr[48] > 2) goto L0;		// число шагов режима
	sh[48] = 1;
L100:return;						// возврат в "кольцо"

L0:	norma = 38;					// норма: "Механизм. перемещения путь прошел"
	shr[48] = 0;
	goto L100;

//--Проверка начальных условий--//
L1:     SetOut(0,2,0x08);	// сняли пуск
        CT_48 = 0;
        diagn[12] &= (~0x0C);
        shr[47]=0;
        sh[47]=0;
	sh_ = 0;
	goto L101;

L2:     if(!(zin[2]&0x200))  {
                diagn[12] &= (~0x08); //сбросили диагностику
				SetOut(1,2,0x10);	// дали стоп
                sh_ = 0;             //выход
                goto L101;
                }
        if(CT_48 >= T_M_VR)
                diagn[12] |= 0x08; //выставили диагностику не выключился
        goto L101;

}
//------------------------------------------------------------------------------
void R_49() // режим 49 "Вкл. ТМН камеры"
{
	sh_ = sh[49];
	if ((shr[49] < 1) || (shr[49] > 2)) goto L100; // на выход

L00:if(shr[49] == 1) goto L1;
	if(shr[49] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[49] = sh_;
	if(sh[49] != 0) goto L100;		// SH != 0
	shr[49]++;						// след.шаг
	if(shr[49] > 2) goto L0;		// число шагов режима
	sh[49] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[49] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: shr[50]=0;
    sh[50]=0;
    diagn[12]&=(~0x30);
	sh_ = 0;
	goto L101;

L2: TMN(1);                         //включить ТМН камеры
    goto L101;

}
//------------------------------------------------------------------------------
void R_50() // режим 50 "Откл. ТМН камеры"
{
	sh_ = sh[50];
	if ((shr[50] < 1) || (shr[50] > 2)) goto L100; // на выход

L00:if(shr[50] == 1) goto L1;
	if(shr[50] == 2) goto L2;
	goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[50] = sh_;
	if(sh[50] != 0) goto L100;		// SH != 0
	shr[50]++;						// след.шаг
	if(shr[50] > 2) goto L0;		// число шагов режима
	sh[50] = 1;
L100:return;						// возврат в "кольцо"

L0: shr[50] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: shr[49]=0;
    sh[49]=0;
    diagn[12]&=(~0x30);
	sh_ = 0;
	goto L101;

L2: TMN(0);                         //отключить ТМН камеры
    goto L101;

}




//---------------------------------------------------------------------------
//---------  ПОДПРОГРАММЫ  --------------------------------------------------
//---------------------------------------------------------------------------
void MEH_AVAR_CHK()				// слежение за авриями механизма
{
	// если нет аварии механизма
	if((zin[3]&0x04)&&(zin[3]&0x20)&&(zin[3]&0x400)&&(zin[3]&0x2000))
		SetOut(0,2,0x80);		// сбросить сигнал "Сброс аварий"
    if(zin[2]&0x100)
        SetOut(0,2,0x20);
}
//---------------------------------------------------------------------------
void MEH_AVAR_SBROS()			// сброс аварий механизма (не в кольце)
{
	SetOut(1,2,0x80);			// выдать сигнал "Сброс аварий"(по кнопке)
    SetOut(1,2,0x20);           // выдать сигнал "Сброс аварии вращ. магнетрона"
}
//------------------------------------------------------------------------------
void TMN(bool OnOff)
{            //1-вкл 0-выкл
    switch(sh_)
    {
        case 1:
        {
            if(OnOff)
            {
                if(zin[1]&0x2004)
                {
                    sh_=0;
                    return;
                }
                SetOut(1,3,0x04);       //Выдать ПУСК ТМН
                SetOut(0,3,0x08);       //Выдать ПУСК ТМН
                CT_TMN=0;
                sh_=2;
            }
            else
            {
                if
                (
                (zin[1]&0x1000)||
                ((!(zin[1]&0x2000))&&(!(zin[1]&0x04)))
                )
                {
                    sh_=0;
                    return;
                }
                SetOut(0,3,0x04);       //Выдать СТОП ТМН
                SetOut(1,3,0x08);       //Выдать СТОП ТМН
                CT_TMN=0;
                sh_=2;
            }
            return;
        }
        case 2:
        {
            if(OnOff)
            {
                if(zin[1]&0x2000)
                {
                    diagn[12]&=(~0x10);     //сброс диагностики
                    SetOut(0,3,0x04);       //Снять ПУСК ТМН
                    norma=49;
                    sh_=0;
                    return;
                }
                if(CT_TMN>2)
                    diagn[12]|=0x10;            //отказ "Нет пуска ТМН"
                return;
            }
            else
            {
                if(zin[1]&0x1000)
                {
                    diagn[12]&=(~0x20);     //сброс диагностики
                    SetOut(0,3,0x08);       //Снять ПУСК ТМН
                    norma=50;
                    sh_=0;
                    return;
                }
                if(CT_TMN>2)
                    diagn[12]|=0x20;            //отказ "Нет пуска ТМН"
                return;
            }

        }
    }
}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
void VIBPAR_DZASL1 ()					// подпрограмма "Выбор параметра для заслонки"
{
    PAR_DZASL1 = par[N_ST][4];
}
//---------------------------------------------------------------------------
void RLIMDZASL1()						// подпрограмма "Расчет LIM для заслонки"
{
	if (PAR_DZASL1 == 0)	        	//если задание = 0, расшир.лимитов
	{
		LIM1DZASL1 = 10000;	    	// MAX доп.знач.по входу ап.ср.
		LIM2DZASL1 = LIM1DZASL1 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2DZASL1 = PAR_DZASL1 / DOPDZASL1;	// LIM2 (малый)
		LIM1DZASL1 = PAR_DZASL1 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDDZASL1 ()						// подготовка аналоговых данных заслонки
{
	X_TDZASL1 = TEK_DAVL_DZASL1;			// тек.значение
	E_TDZASL1 = PAR_DZASL1 - X_TDZASL1;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TDZASL1 >= 0) DELDZASL1 = E_TDZASL1;
	else  DELDZASL1 = E_TDZASL1 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------------//
//--Подпрограмма выдачи команд на заслонку (MKS)--//
//------------------------------------------------//
void VIDK_DZASL1 ( int a, int b, int c, int d )
	// a - код команды к заслонке
	// b - номер байта массива диагностики DIAGM
	// c - номер бита в байте DIAGM
	// d - задание по положению (0...10000)
{
	switch ( sh_ )
	{
		case 1:
		{
			// если нет связи с заслонкой
			if ( diagnS[0] & 0x40 ) return;
			// обнуление признака положительного ответа
			PR_DZASL1 = 0;
			// обнуление кода ответа
			OTVET_DZASL1 = 0;
			// выдача заданной команды
			KOM_DZASL1 = a;
			// есть команда контроль давления
			if ( KOM_DZASL1 == 2 )
			{
				// выбрали параметр заслонки
				VIBPAR_DZASL1();
				// установили параметр
				DATA_DZASL1 = PAR_DZASL1;
			}
			// есть команда контроль положения
			else if ( KOM_DZASL1 == 1 )
			{
				// определили параметр из задания (по положению)
				DATA_DZASL1 = d;
			};
			// сбросили счетчик времени заслонки
			CT_DZASL1 = 0;
			// перешли на следующий шаг
			sh_ = 2;
		}; break;
		case 2:
		{
			// если нет связи с заслонкой или ответ не положительный
			if ( ( diagnS[0] & 0x40 ) || ( PR_DZASL1 == 0 ) )
				// сброс сч.времени заслонки
				CT_DZASL1 = 0;
			// есть связь с заслонкой и ответ положительный
			// и ответ заслонки НЕ соответствует искомому
			else if ( OTVET_DZASL1 != a )
			{
				// сравнение с контрольным временем и диагностика
				if ( CT_DZASL1 > 5 ) diagn[b] |= c;
			}
			// если все штатно
			else
			{
				// сброс диагностики
				diagn[b] &= ~c;
				// если команда НЕ опрос состояния заслонки
				if ( KOM_DZASL1 != 7 )
				{
					// запись кода команды - общий опрос
					KOM_DZASL1 = 7;
					// сброс признака положительного ответа
					PR_DZASL1 = 0;
				}
				// выход из подпрограммы
				sh_ = 0;
			}
		}; break;
		default: ;break;
	};
}
// Команды на заслонку
//             КК   диагн
// VIDK_DZASL1 ( 1, 3, 0x20,..)  - Задание положения (код положения)
// VIDK_DZASL1 ( 2, 3, 0x40, 0)  - Задание давление
// VIDK_DZASL1 ( 3, 3, 0x08, 0)  - Открыть заслонку
// VIDK_DZASL1 ( 4, 3, 0x10, 0)  - Закрыть заслонку
// VIDK_DZASL1 ( 7, 3, 0x80, 0)  - Опрос состояния заслонки
//---------------------------------------------------------------------------
void VIBPAR_DZASL2 ()					// подпрограмма "Выбор параметра для заслонки"
{

        PAR_DZASL2 = par[N_ST][17];

}
//---------------------------------------------------------------------------
void RLIMDZASL2()						// подпрограмма "Расчет LIM для заслонки"
{
	if (PAR_DZASL2 == 0)	        	//если задание = 0, расшир.лимитов
	{
		LIM1DZASL2 = 10000;	    	// MAX доп.знач.по входу ап.ср.
		LIM2DZASL2 = LIM1DZASL2 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2DZASL2 = PAR_DZASL2 / DOPDZASL2;	// LIM2 (малый)
		LIM1DZASL2 = PAR_DZASL2 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDDZASL2 ()						// подготовка аналоговых данных заслонки
{
	X_TDZASL2 = TEK_DAVL_DZASL2;			// тек.значение
	E_TDZASL2 = PAR_DZASL2 - X_TDZASL2;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TDZASL2 >= 0) DELDZASL2 = E_TDZASL2;
	else  DELDZASL2 = E_TDZASL2 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------------//
//--Подпрограмма выдачи команд на заслонку (MKS)--//
//------------------------------------------------//
void VIDK_DZASL2 ( int a, int b, int c, int d )
	// a - код команды к заслонке
	// b - номер байта массива диагностики DIAGM
	// c - номер бита в байте DIAGM
	// d - задание по положению (0...10000)
{
	switch ( sh_ )
	{
		case 1:
		{
			// если нет связи с заслонкой
			if ( diagnS[2] & 0x80 ) return;
			// обнуление признака положительного ответа
			PR_DZASL2 = 0;
			// обнуление кода ответа
			OTVET_DZASL2 = 0;
			// выдача заданной команды
			KOM_DZASL2 = a;
            //снятие дискреты выхода
            SetOut(0,0,0x30);
			// есть команда контроль давления
			if ( KOM_DZASL2 == 2 )
			{
				// выбрали параметр заслонки
				VIBPAR_DZASL2();
				// установили параметр
				DATA_DZASL2 = PAR_DZASL2;
			}
			// есть команда контроль положения
			else if ( KOM_DZASL2 == 1 )
			{
				// определили параметр из задания (по положению)
				DATA_DZASL2 = d;
			};
			// сбросили счетчик времени заслонки
			CT_DZASL2 = 0;
			// перешли на следующий шаг
			sh_ = 2;
		}; break;
		case 2:
		{
			// если нет связи с заслонкой или ответ не положительный
			if ( ( diagnS[2] & 0x80 ) || ( PR_DZASL2 == 0 ) )
				// сброс сч.времени заслонки
				CT_DZASL2 = 0;
			// есть связь с заслонкой и ответ положительный
			// и ответ заслонки НЕ соответствует искомому
			else if ( OTVET_DZASL2 != a )
			{
				// сравнение с контрольным временем и диагностика
				if ( CT_DZASL2 > 5 ) diagn[b] |= c;
			}
			// если все штатно
			else
			{
				// сброс диагностики
				diagn[b] &= ~c;
				// если команда НЕ опрос состояния заслонки
				if ( KOM_DZASL2 != 7 )
				{
					// запись кода команды - общий опрос
					KOM_DZASL2 = 7;
					// сброс признака положительного ответа
					PR_DZASL2 = 0;
				}
				// выход из подпрограммы
				sh_ = 0;
			}
		}; break;
		default: ;break;
	};
}
// Команды на заслонку
//             КК   диагн
// VIDK_DZASL2 ( 1, 3, 0x20,..)  - Задание положения (код положения)
// VIDK_DZASL2 ( 2, 3, 0x40, 0)  - Задание давление
// VIDK_DZASL2 ( 3, 3, 0x08, 0)  - Открыть заслонку
// VIDK_DZASL2 ( 4, 3, 0x10, 0)  - Закрыть заслонку
// VIDK_DZASL2 ( 7, 3, 0x80, 0)  - Опрос состояния заслонки


//------------------Привод подъёма----------------------------------------------
void VIDK_POD(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x01) return;		// нет связи с контроллером
	SetOut(0,2,0x40);				// снять Стоп механизмов
	PR_POD = 1;
	CT_POD = 0;
	sh_ = 2;
A2:	if(!(zin[3]&0x800))				// нет готовности привода
	{
		if(CT_POD >= 5)
			diagn[15] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[15] &= (~0x01);			// сброс диагностики
	OTVET_POD = 0;
	V_POD = a;
	TYPE_POD = b;
	PUT_POD = c;
	HOME_POD = d;
	KOM_POD = 1;
	CT_POD = 0;
    TEK_OTN_POD = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x01 || !OTVET_POD)	// есть диагностика нет связи или нет ответа
	{
		if(CT_POD >= 5)
			diagn[15] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[15] &= (~0x04);			// сброс диагностики
	KOM_POD = 0;
	if(!HOME_POD)					// не движение в HOME
	{
		SetOut(1,2,0x400);           // выдать движение
		CT_POD = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,2,0x800);          		// выдать движение в Home
	CT_POD = 0;
	sh_ = 4;
A4:	if(!(zin[3]&0x1000)||(TEK_ABS_POD))				// механизм не пришел в HOME
	{
		if(CT_POD >= e)
			diagn[15] |= 0x08;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;
	}
	diagn[15] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x800);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[3]&0x800))				// нет готовности привода
	{
		if(CT_POD >= 5)
		diagn[15] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[15] &= (~0x01);			// сброс диагностики
	PR_POD = 0;
	norma = 14;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,2,0x40);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[3]&0x800)				// есть готовность привода
	{
		if(CT_POD >= 5)
			diagn[15] |= 0x02;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[15] &= (~0x02);			// сброс диагностики
	SetOut(0,2,0x400);               // сбросить начало движение
	CT_POD = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[3]&0x800)||((TYPE_POD==ABS)&&(PUT_POD!=TEK_ABS_POD))||((TYPE_POD==OTN)&&(PUT_POD!=TEK_OTN_POD)))				// есть готовность привода
	{
		if(CT_POD >= e)
			diagn[15] |= 0x10;		// отказ: "Нет завершения движ. перемещ."
		return;		
	}
	diagn[15] &= (~0x10);			// сброс диагностики
	PR_POD = 0;
	norma = 15;						//"Манипулятор перемещения путь прошел"
    SetOut(1,2,0x40);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------
void VIDK_VR(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x02) return;		// нет связи с контроллером
	SetOut(0,2,0x40);				// снять Стоп механизмов
	PR_VR = 1;
	CT_VR = 0;
	sh_ = 2;
A2:	if(!(zin[3]&0x01))				// нет готовности привода
	{
		if(CT_VR >= 5)
			diagn[16] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[16] &= (~0x01);			// сброс диагностики
	OTVET_VR = 0;
	V_VR = a;
	TYPE_VR = b;
	PUT_VR = c;
	HOME_VR = d;
	KOM_VR = 1;
	CT_VR = 0;
    TEK_OTN_VR = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x02 || !OTVET_VR)	// есть диагностика нет связи или нет ответа
	{
		if(CT_VR >= 5)
			diagn[16] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[16] &= (~0x04);			// сброс диагностики
	KOM_VR = 0;
	if(!HOME_VR)					// не движение в HOME
	{
		SetOut(1,2,0x1000);           // выдать движение
		CT_VR = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,2,0x2000);          		// выдать движение в Home
	CT_VR = 0;
	sh_ = 4;
A4:	if(!(zin[3]&0x02)||(TEK_ABS_VR))				// механизм не пришел в HOME
	{
		if(CT_VR >= e)
			diagn[16] |= 0x08;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;
	}
	diagn[16] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x2000);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[3]&0x01))				// нет готовности привода
	{
		if(CT_VR >= 5)
		diagn[16] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[16] &= (~0x01);			// сброс диагностики
	PR_VR = 0;
	norma = 16;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,2,0x40);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[3]&0x01)				// есть готовность привода
	{
		if(CT_VR >= 5)
			diagn[16] |= 0x02;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[16] &= (~0x02);			// сброс диагностики
	SetOut(0,2,0x1000);               // сбросить начало движение
	CT_VR = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[3]&0x01)||((TYPE_VR==ABS)&&(PUT_VR!=TEK_ABS_VR))||((TYPE_VR==OTN)&&(PUT_VR!=TEK_OTN_VR)))				// есть готовность привода
	{
		if(CT_VR >= e)
			diagn[16] |= 0x10;		// отказ: "Нет завершения движ. перемещ."
		return;		
	}
	diagn[16] &= (~0x10);			// сброс диагностики
	PR_VR = 0;
	norma = 17;						//"Манипулятор перемещения путь прошел"
    SetOut(1,2,0x40);				// выставить Стоп механизмов
	sh_ = 0;	
}
//---------------------------------------------------------------------------

void VIDK_POV(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[2]&0x04) return;		// нет связи с контроллером
	SetOut(0,2,0x40);				// снять Стоп механизмов
	PR_POV = 1;
	CT_POV = 0;
	sh_ = 2;
A2:	if(!(zin[3]&0x08))				// нет готовности привода
	{
		if(CT_POV >= 5)
			diagn[17] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[17] &= (~0x01);			// сброс диагностики
	OTVET_POV = 0;
	V_POV = a;
	TYPE_POV = b;
	PUT_POV = c;
	HOME_POV = d;
	KOM_POV = 1;
	CT_POV = 0;
    TEK_OTN_POV = 0;
	sh_ = 3;
A3:	if(diagnS[2]&0x04 || !OTVET_POV)	// есть диагностика нет связи или нет ответа
	{
		if(CT_POV >= 5)
			diagn[17] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[17] &= (~0x04);			// сброс диагностики
	KOM_POV = 0;
	if(!HOME_POV)					// не движение в HOME
	{
		SetOut(1,2,0x4000);           // выдать движение
		CT_POV = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,2,0x8000);          		// выдать движение в Home
	CT_POV = 0;
	sh_ = 4;
A4:	if(!(zin[3]&0x10)||(TEK_ABS_POV))				// механизм не пришел в HOME
	{
		if(CT_POV >= e)
			diagn[17] |= 0x08;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;
	}
	diagn[17] &= (~0x08);			// сброс диагностики
	SetOut(0,2,0x8000);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[3]&0x08))				// нет готовности привода
	{
		if(CT_POV >= 5)
		diagn[17] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[17] &= (~0x01);			// сброс диагностики
	PR_POV = 0;
	norma = 55;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,2,0x40);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[3]&0x08)				// есть готовность привода
	{
		if(CT_POV >= 5)
			diagn[17] |= 0x02;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[17] &= (~0x02);			// сброс диагностики
	SetOut(0,2,0x4000);               // сбросить начало движение
	CT_POV = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[3]&0x08)||((TYPE_POV==ABS)&&(PUT_POV!=TEK_ABS_POV))||((TYPE_POV==OTN)&&(PUT_POV!=TEK_OTN_POV)))				// есть готовность привода
	{
		if(CT_POV >= e)
			diagn[17] |= 0x10;		// отказ: "Нет завершения движ. перемещ."
		return;
	}
	diagn[17] &= (~0x10);			// сброс диагностики
	PR_POV = 0;
	norma = 56;						//"Манипулятор перемещения путь прошел"
    SetOut(1,2,0x40);				// выставить Стоп механизмов
	sh_ = 0;	
}


////////////////////////////////////////////////////////////////////////////////
void VIBPAR_TEMP1 ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP1 = nasmod[5];            //
}
//---------------------------------------------------------------------------
void RLIMTEMP1 ()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP1 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP1 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP1 = LIM1TEMP1 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP1 = PAR_TEMP1 / DOPTEMP1;	// LIM2 (малый)
		LIM1TEMP1 = PAR_TEMP1 / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDTEMP1 ()						// подготовка аналоговых данных БПН
{
	X_TEMP1 = TEK_TEMP1;	           	// тек.значение температуры
	E_TEMP1 = PAR_TEMP1 - X_TEMP1;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP1 >= 0) DELTEMP1 = E_TEMP1;
	else  DELTEMP1 = E_TEMP1 * (-1);	// вычисление модуля ошибки
}
//------------------------------------------//
//--Подпрограмма выдачи команд на ТЕРМОДАТ--//
//------------------------------------------//
void VIDK_TEMP1 ( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x40 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP1 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP1();			// выбор параметра температуры
						ZAD_TEMP1 = PAR_TEMP1;	// запись задания
					}
				}
				CT_TEMP1 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ((diagnS[2] & 0x40) || (!PR_TEMP))
			{
				if ( CT_TEMP1 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP1 ( 1 , 16 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP1 ( 1 , 16 , 0100 , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP1 ( 2 , 16 , 0200 , X )  - Опрос температуры
void VIDK_TEMP2( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[2] & 0x40 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP2 = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP2();			// выбор параметра температуры
						ZAD_TEMP2 = PAR_TEMP2;	// запись задания
					}
				}
				CT_TEMP2 = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ( ( diagnS[2] & 0x40 ) || ( PR_TEMP == 0 ) )
			{
				if ( CT_TEMP2 > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP2 ( 1 , 17 , 040  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP2 ( 1 , 17 , 0100  , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP2 ( 2 , 17 , 0200 , X )  - Опрос температуры
//---------------------------------------------------------------------------
void PDTEMP2()						// подготовка аналоговых данных БПН
{
	X_TEMP2 = TEK_TEMP2;	           	// тек.значение температуры
	E_TEMP2 = PAR_TEMP2 - X_TEMP2;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP2 >= 0) DELTEMP2 = E_TEMP2;
	else  DELTEMP2 = E_TEMP2 * (-1);	// вычисление модуля ошибки
}
void RLIMTEMP2()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP2 == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP2 = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP2 = LIM1TEMP2 / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP2 = PAR_TEMP2 / DOPTEMP2;	// LIM2 (малый)
		LIM1TEMP2 = PAR_TEMP2 / 2;    	// LIM1 (большой)
	}
}
void VIBPAR_TEMP2 ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP2 = nasmod[6];            //
}
//---------------------------------------------------------------------------
void SBROSR_28()					// "Откл. ВЧГ стола"
{
	shr[28] = 0;        // сброс активизации
	sh[28] = 0;         // режима 29 "Вкл. ВЧГ реактора"
	VRGIS = 0;          // сброс выхода ВЧГ на режим
	A_OUT(4,8192);      // сброс уставки вых. мощности ВЧГ
	SetOut(0,3,0x4000);	// откл. вых. мощн.
	diagn[10]&=(~0xFF);	// сброс диагностик режимов "ВЧГ"
	norma = 30;			// норма: "Сброс режима ВЧГ ИП завершен"
}
//---------------------------------------------------------------------------
void VID_DIAGN_GIS()			// выдача диагностики нет согласования НЧГ стола
{
    if ((shr[28])&&				// есть активизация режима НЧГ стола
        (VRGIS)&&				// есть выход на режим ВЧГ стола
        (aik[11]))				// отраженная мощность не 0
    {
        N_TEK_GIS=aik[10]*10/aik[11];// текущий коэф. согласования
        if(N_TEK_GIS >= nasmod[14])
            diagn[10] &=(~0x08) ;// снять диагностику
        else
            diagn[10] |=0x08 ;	// диагн.: "нет согл. НЧГ  реактора"
    }
    else
    {
        diagn[10] &=(~0x08) ;// снять диагностику
        N_TEK_GIS = 0;
    }
}
//---------------------------------------------------------------------------

void VIBPAR_GIS ()				    // подпрограмма "Выбор параметра для ВЧГ реактора"
{
	PAR_GIS = par[N_ST][8];
}
//---------------------------------------------------------------------------
void RLIMGIS ()						// подпрограмма "Расчет LIM для ВЧГ реактора"
{
    if (VRGIS == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIS = 15;                // допуск 66,6%
        LIM2GIS = (PAR_GIS * 10) / DOPGIS; // LIM2 (малый)
        LIM1GIS = (PAR_GIS*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIS <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIS = 30;           // допуск 33%
	    else  if ( PAR_GIS <= 276 ) // если зад. мощность <= 41Вт
		    DOPGIS = 40;            // допуск 25%
        else DOPGIS = 50;           // иначе допуск 20%

	    if (PAR_GIS == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIS = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIS = LIM1GIS / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIS = PAR_GIS * 10 / DOPGIS; // LIM2 (малый)
	        LIM1GIS = PAR_GIS / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIS ()						// подготовка аналоговых данных ВЧГ реактора
{
	X_TGIS = aik[10];	            // тек.значение падающей мощности
	E_TGIS = PAR_GIS - X_TGIS;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIS >= 0) DELGIS = E_TGIS;
	else  DELGIS = E_TGIS * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void VRR_GIS()						// подпрограмма "Выставить разр. работы ВЧГ стола"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
    if (sh_ == 3) goto A3;
	else return;	// выход

A1:	SetOut(1,3,0x1000);				// выставить разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[2] & 0x01) == 0)		// разр.раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[10] |= 0x10;			// отказ:"Разр. работы ВЧГ не выставилось"
		return;
	}
	diagn[10] &= (~0x10);			// сброс диагностики
    CT_VHG = 0;
	sh_ = 3;
A3: if(!(zin[2]&0x02))              //Есть готовность ВЧГ реактора ИП
    {
        if(CT_VHG>T_VHG)            //время не вышло
            diagn[12]|=0x40;        //отказ:"Нет готовности ВЧГ генератора ИП"
        return;
    }
    diagn[12]&=(~0x40);             //сброс диагностики
    SetOut(1,3,0x2000);              //Выдача сигнала дистанц. управления
    sh_=0;
    return;
}
//------------------------------------------------------------------------------
void ORR_GIS()						// подпрограмма "Снять разр. работы ВЧГ стола"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(0,3,0x1000);				// снять разр.раб. ВЧГ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[2] & 0x01) != 0)		// разр.раб. не снято
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[10] |= 0x20;			// отказ: "Разр. работы ВЧГ не снялось"
		return;
	}
	diagn[10] &= (~0x20);			// сброс диагностики
	sh_ = 0;
}
//------------------------------------------------------------------------------
void VPMAN()						// подпрограмма "Манипулятор включить"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;			        	// выход
	
A1: PR_PER = 1;
    POL_PER=1;
	SetOut(0,2,0x40);		        	// снять стоп
	CT_PER = 0;
    sh_ = 2;
A2: if((!(zin[3]&0x100))||(!(zin[3]&0x400)))	// есть готовность и отсутсвие аварии прижима
	{
		if(CT_PER < T_KPER) return; 	// время вышло
		diagn[20] |= 0x01;			  	// отказ:"Нет готов. механ. ман"
		return;
	}
	diagn[20] &= (~0x01);				// сброс диагностики
	SetOut(1,2,0x100);					// пуск привода прижима
	CT_PER = 0;
    sh_ = 3;
A3: if(zin[3]&0x100) 					// готовность пропала
	{
		if(CT_PER < T_KPRST) return;	// время не вышло
		diagn[20] |= 0x02;				// отказ: "Нет старта мех. прижима"
		SetOut(1,2,0x40);				// вкл. стоп
        SetOut(0,2,0x100);
		return;
	}
	diagn[20] &= (~0x02);				// сброс диагностики
	SetOut(0,2,0x100);					// стоп привода прижима
	CT_PER = 0;
    sh_ = 4;
A4: if(!(zin[3]&0x100)) 				// опрос готовности
	{
		if(CT_PER < T_KPR) return;		// время вышло
		diagn[20] |= 0x04;				// отказ:"Нет завершения движ. мех. прижима"
		return;
	}
	diagn[20] &= (~0x04);				// сброс диагностики
	SetOut(1,2,0x40);					// вкл. стоп
	PR_PER = 0;
    POL_PER=3;
	norma = 13;							//Прижим внизу
	sh_ = 0;
}
//---------------------------------------------------------------------------
void OPMAN()						// подпрограмма "Манипулятор отключить(HOME)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;			// выход
	
A1: SetOut(0,2,0x40);		// снять стоп
	PR_PER = 1;
    POL_PER=2;
	CT_PER = 0;
    sh_ = 2;
A2: if((!(zin[3]&0x100))||(!(zin[3]&0x400)))	// есть готовности и отсутсвий аварий прижима
	{
		if(CT_PER < T_KPER) return; 	// время вышло
		diagn[20] |= 0x01;				// отказ:"Нет готов. механ. прижима"
		return;
	}
	diagn[20] &= (~0x01);				// сброс диагностики
	SetOut(1,2,0x200);					// пуск приводов прижима в HOME
	CT_PER = 0;
    sh_ = 3;
A3: if(!(zin[3]&0x200))
	{
		if(CT_PER < T_KPR) return;		// время не вышло
		diagn[20] |= 0x08;				// отказ: "Механизм прижима не пришел в HOME"
	    return;
	}
	diagn[20] &= (~0x08);				// сброс диагностики
	SetOut(0,2,0x200);					// стоп приводов прижима
	sh_ = 4;
A4: if(!(zin[3]&0x100)) 				// опрос готовности
	{
		diagn[20] |= 0x01;				// отказ:"Нет готовности мех. прижима"
		return;
	}
	diagn[20] &= (~0x01);				// сброс диагностики
	SetOut(1,2,0x40);					// вкл. стоп
	PR_PER = 0;
	norma = 12;							//Прижим в положении HOME
    POL_PER=0;
	sh_ = 0;
}
//------------------------------------------------------------------------------
void VVRM()				// подпрограмма "включить вращение магнетрнов"
{
//--Проверка начальных условий--//
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;      // выход

A1:     SetOut(0,2,0x10);	// сняли стоп
        SetOut(1,2,0x08);	// дали пуск
        CT_47 = 0;
	sh_ = 2;
        return;

A2:     if(zin[2]&0x200)  {
                diagn[12] &= (~0x04); //сбросили диагностику
                sh_ = 0;
                return;
                }
        if(CT_47 >= T_M_VR)
                diagn[12] |= 0x04; //выставили диагностику нет вращаения
        return;

}
//------------------------------------------------------------------------------
void OVRM()				// подпрограмма "отлючить вращение магнетрнов"
{
//--Проверка начальных условий--//
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;      // выход

A1:     SetOut(0,2,0x08);	// сняли пуск

        CT_48 = 0;
	sh_ = 2;
        return;

A2:     if(!(zin[2]&0x200))  {
                diagn[12] &= (~0x08); //сбросили диагностику
                SetOut(1,2,0x10);	// дали стоп
                sh_ = 0;             //выход
                return;
                }
        if(CT_48 >= T_M_VR)
                diagn[12] |= 0x08; //выставили диагностику не выключился
        return;
}
//------------------------------------------------------------------------------
void STVRM()            //подпрограмма "Стоп вращения магнетронов"
{
    // стоп вращ магн
    shr[47] = 0;
    sh[47] = 0;
    shr[48] = 0;
    sh[48] = 0;
    diagn[12] &= (~0x0C); //сняли диагност
    SetOut(1,2,0x10);	// дали стоп
    SetOut(0,2,0x08);	// сняли пуск
}
//------------------------------------------------------------------------------
void OBPN()				// подпрограмма "Отключить БПН (сил. пит. на термодат)"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;      // выход

A1:	SetOut(0,3,0x03);		   	// сброс выходных сигналов на вкл/откл
	diagn[18]&=(~0x08);							// силового питания БПН
	SetOut(1,3,0x02);		   	// выкл. силового питания БПН
	CT_IST = 0;			   		// сброс сч.времени
	sh_ = 2;
A2:	if (zin[0]&0x80)	   	// силовое питание включено
	{
		if (CT_IST<=T_VKL_BPN) return;// время не вышло
		diagn[18]|=0x10;	           // отказ:"Силовое питание БПН не выкл."
		return;
	}
	SetOut(0,3,0x03);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
	diagn[18]&=(~0x10);		   	// сброс диагностики
	sh_ = 0;
	norma = 32;					// норма: "Силовое питание БПН отключено"
 }
//------------------------------------------------------------------------------
void REAKCIA_KZ_BMH1()							// реакция на КЗ БПМ
{
	if(!(diagn[28]&0x08))	// нет диагностик КЗ М3
	{
		if(shr[33]>4)
		// запущен хоть один режим БПМ
		{
			if(PR_KZ_BMH1)
			{
				if(CT_KZ_BMH1 > 2)
				{
					SetOut(0,3,0x100);		// вкл. вых. мощность БПМ
					N_KZ_BMH1++;
					if(N_KZ_BMH1 >= 3)
					{
						if(shr[33])
						diagn[28] |= 0x08; // Отказ: КЗ БПМ
                        N_KZ_BMH1 = 0;
						//if(!shr[5])		// Есть активиз. режима 4 "Сброс РЦ"
						//{
						//    sh[5] = 1;			// активизация режима 4
						//    shr[5] = 1;
						//}
					}
					else PR_KZ_BMH1 = 0;
				}
			}
			else
			{
				if(!(OTVET_BMH1[10]&0x04))		// есть КЗ
				{
					PR_KZ_BMH1 = 1;
					CT_KZ_BMH1 = 0;
					SetOut(1,3,0x100);		// выкл. вых. мощность БПМ
				}
				else PR_KZ_BMH1 = 0;
			}
		}
		else PR_KZ_BMH1 = 0;
	}
	else PR_KZ_BMH1 = 0;
}

//------------------------------------------------------------------------------
void VIBPAR_BMH1()		    // подпрограмма "Выбор параметра для БПМ"
{
    if((N_ST)&&(N_ST!=4))
    {
        BMH1_mode = 0;
    }
    else
    {
        if(par[N_ST][7] > 900) BMH1_mode = 2; // хайпимс режим (ток > 290)
        else if(nasmod[9]) BMH1_mode = 1; // режим мощность с частотой (есть пауза)
        else BMH1_mode = 0;             // режим мощность без частоты
    }

    if(BMH1_mode == 2)
    {
        PAR_BMH1_I = par[N_ST][7]; // хайпимс режим по току
        PAR_BMH1_P = 0xFFF;
    }
    else
    {
        PAR_BMH1_I = par[N_ST][7];
        PAR_BMH1_P = par[N_ST][6];
    }
}
//------------------------------------------------------------------------------
void RLIMBMH1()		            // подпрограмма "Расчет LIM для БПМ"
{
    if(BMH1_mode != 2)  // режимы по мощности
    {
        if (PAR_BMH1_P == 0) // если задание = 0, расшир.лимитов
        {
            LIM1BMH1 = 4095;		    // MAX доп.знач.по входу ап.ср.
            LIM2BMH1 = LIM1BMH1 / 2;          // LIM2 = 0,5 LIM1
        }
        else
        {
            LIM2BMH1 = PAR_BMH1_P/DOPBMH1;	    // LIM2 (малый)
            LIM1BMH1 = PAR_BMH1_P / 2;         // LIM1 (большой)
        }
    }
    else
    {
        if (PAR_BMH1_I == 0) // если задание = 0, расшир.лимитов
        {
            LIM1BMH1 = 4095;		    // MAX доп.знач.по входу ап.ср.
            LIM2BMH1 = LIM1BMH1 / 2;          // LIM2 = 0,5 LIM1
        }
        else
        {
            LIM2BMH1 = PAR_BMH1_I/DOPBMH1;	    // LIM2 (малый)
            LIM1BMH1 = PAR_BMH1_I / 2;         // LIM1 (большой)
        }
    }
}
//------------------------------------------------------------------------------
void PDBMH1()			    // подготовка аналоговых данных БПМ
{ 
    long T1;
    if(BMH1_mode != 2)  // режимы по мощности
    {
        T1 = OTVET_BMH1[6]; // P - тек.мощность магнетрона
        T1 = int((float)T1*4.10); // поправочный коэф. на тек.мощн.
        // Pзад. = К*Ртек. К=(4095/6000)*(6144/1023) = 4.10
        X_TBMH1 = T1 ;		    // тек.значение мощности
        E_TBMH1 = PAR_BMH1_P - X_TBMH1;	    // Хзад - Хтек = Етек (тек.ошибка)
        if(E_TBMH1 >= 0) DELBMH1 = E_TBMH1;
        else  DELBMH1 = E_TBMH1 * (-1);	    // вычисление модуля ошибки
    }
    else
    {
        T1 = OTVET_BMH1[7]; // I - тек.ток магнетрона
        T1 = int((float)T1*2.54); // поправочный коэф. на тек.мощн.
        // Iзад. = К*Iтек. К=(4095/1000)*(614/1023) = 2,54
        X_TBMH1 = T1 ;		    // тек.значение мощности
        E_TBMH1 = PAR_BMH1_I - X_TBMH1;	    // Хзад - Хтек = Етек (тек.ошибка)
        if(E_TBMH1 >= 0) DELBMH1 = E_TBMH1;
        else  DELBMH1 = E_TBMH1 * (-1);	    // вычисление модуля ошибки
    }
}
//------------------------------------------------------------------------------
void VIDK_BMH1(int a, int b, int c, int d, int e)
     // a - код команды (восьмеричный)
     // b - номер бита в байте состояния
     // c - значение бита в байте состояния (0 или 1)
     // d - номер байта массива диагностики
     // e - номер бита массива диагностики
{
    int x;
    if (sh_ == 1) goto A1;
    if (sh_ == 2) goto A2;
    else return;                   	// выход
A1: if(diagnS[3]&0x01) return;		// Есть диагностика "Нет связи с БПМ"
    PR_SV_BMH1 = 0;                 // Обнуление признака положительного
    // Формирование массива заданий
    KOM_BMH1[0] = 0xFFF;		// Iпост.      - R1
    KOM_BMH1[1] = PAR_BMH1_I;		// Iимп.     - R2
    KOM_BMH1[2] = PAR_BMH1_P;		// Pпост
    KOM_BMH1[3] = nasmod[10];		// Uпост.           - R4
    KOM_BMH1[4] = nasmod[19];       // напр. дугозащиты
    KOM_BMH1[5] = nasmod[20];       // ток дугозащиты
    KOM_BMH1[6] = a;                // Код команды    - R5
	if(BMH1_mode == 2)				// режим хайпимс
    {
		KOM_BMH1[6] &= (~0x100);
        KOM_BMH1[6] |= (0x14);
        KOM_BMH1[8] = nasmod[9];        // длит. пауз
    }
    else if(BMH1_mode == 1)         // мощн. с частотой
    {
        KOM_BMH1[6] &= (~0x114);
        KOM_BMH1[8] = nasmod[9];        // длит. пауз
    }
    else
    {
        KOM_BMH1[6] |= 0x100;
        KOM_BMH1[6] &= (~0x14);
        KOM_BMH1[8] = 0;        // длит. пауз
    }
    KOM_BMH1[7] = nasmod[8];         // длит. имп.
	
    CT_BMH1 = 0;                    	// Сброс сч. времени
    sh_ = 2;
A2: if ((diagnS[3]&0x01)||(PR_SV_BMH1 == 0)) // Есть диагностика
					// "Нет связи с БПМ" или нет признака
					// положительного ответа от БПМ
    {
        CT_BMH1 = 0;                	// Сброс сч. времени
        return;
    }
    x = (OTVET_BMH1[9] & b);      	// Ожидание ответа на команду
    if( x != 0 ) x = 1;            	// проверяемый бит = 1
    else x = 0;						// проверяемый бит = 0
    if(x != c)						// Нет ответа от БПМ
    {
        if (CT_BMH1 <= 8) return;  	// Время не вышло (5 сек.)
        diagn[d] |= e;             	// Отказ: "..."
        sh_ = 1;
        return;
    }
    diagn[d] &= (~e);                   // Сброс диагностики
    sh_ = 0;
}
// Команды на БПМ3
// VIDK_BMH1(0x1804,0x800,1,28,0x10) - Включить блок БПМ3
// VIDK_BMH1(0x1004,0x800,0,28,0x20) - Выключить блок БПМ3
// VIDK_BMH1(0x800,0x1000,0,28,0x40) - Включить вых.напряжение БПМ3
// VIDK_BMH1(0x1804,0x1000,1,28,0x80) - Выключить вых.напряжение БПМ3
//---------------------------------------------------------------------------
void SBROS_MEH() 				// режим "Сброс механизмов"
{
    SetOut(1,2,0x40);           //выставить стоп Механизмов

    SetOut(0,2,0xFF00);         //Снять сигналы манипуляторам
    SetOut(0,1,0xC000);         //Снять M0 и NEXT

    shr [9]=0;                   //Cнять активиз. режима
    sh  [9]=0;                   //"Транспортный тест"
    shr [12]=0;                   //Cнять активиз. режима
    sh  [12]=0;                   //"Манипулятор в HOME"
    shr [13]=0;                   //Cнять активиз. режима
    sh  [13]=0;                   //"Манипулятор в камеру"
    shr [14]=0;                   //Cнять активиз. режима
    sh  [14]=0;                   //"Подъём п/д в HOME"
    shr [15]=0;                   //Cнять активиз. режима
    sh  [15]=0;                   //"Подъём п/д старт"
    shr [16]=0;                   //Cнять активиз. режима
    sh  [16]=0;                   //"Вращение п/д в HOME"
    shr [17]=0;                   //Cнять активиз. режима
    sh  [17]=0;                   //"Вращение п/д на угол"
    shr [18]=0;                   //Cнять активиз. режима
    sh  [18]=0;                   //"Подъём п/д в раб поз"
    shr [35]=0;                   //Cнять активиз. режима
    sh  [35]=0;                   //"Поворот заслонки в HOME"
    shr [36]=0;                   //Cнять активиз. режима
    sh  [36]=0;                   //"Поворот заслонки на угол"
    shr [40]=0;                   //Cнять активиз. режима
    sh  [40]=0;                   //"Измерение сопрот вкл."
    shr [41]=0;                   //Cнять активиз. режима
    sh  [41]=0;                   //"Измерение сопрот откл."

    for(int i=0;i<DIAGN_COUNT;i++)
        if((i != 14)&&(i != 23)) diagn[i] = 0;// сброс диагностик кроме аварийных

    PR_PER=0;
    PR_POD=0;
    PR_VR=0;
    PR_POV=0;

    if(zin[3]&0x200)
        POL_PER=0;
    else
        POL_PER=3;


	norma = 59;					// сброс механизмов завершен
}
//---------------------------------------------------------------------------
void AVAR_VODA_BM()				// реакция на отсутствие воды в М1
{
	// есть активизация режимов М1
	if(shr[33])
	{
		if(zin[0]&0x01) CT_VODA_BM = 0;// есть охлаждение магнетр.
		else if(CT_VODA_BM >= T_VODA)// время вышло (5 сек)
		{
			diagn[14] |= 0x10;	// отказ"Авария: Нет охлаждения M"
			if((shr[2])||((shr[3])&&!PR_NALADKA))			// есть активизации режима 2
			{
                if(!(shr[5]))
                {
				    sh[5] = 1;		// активизация режима 5
				    shr[5] = 1;
                }
			}
			else
			{

					shr[34] = 1;	// активизация 34 режима
					sh[34] = 1;

			}
		}
	}
	else
		CT_VODA_BM = 0;
}
//---------------------------------------------------------------------------
void UPR_AVAR_OTKL()			// Управление аварийным отключением
{
	if(zin[1]&0x3004)
    {
        if(!(zin[1]&0x10))
            diagn[23]|=0x04;        //отказ "Авария ТМН камеры"
        else
        {
            if(zin[1]&0x02)
                return;
            diagn[23]|=0x01;        //отказ "Авария: отключение форнасоса камеры"
        }
        if(!(shr[8]))
        {
            shr[8]=1;
            sh[8]=1;
        }
    }
}
//---------------------------------------------------------------------------
void OSBROS()					// подпрограмма Общий сброс
{
    shr [1]  =0;                 //сброс активизю режима 1
    sh  [1]  =0;                 //"Откачка камеры"
    shr [5]  =0;                 //сброс активизю режима 5
    sh  [5]  =0;                 //"Сброс Рабочего цикла"
    shr [6]  =0;                 //сброс активизю режима 6
    sh  [6]  =0;                 //"Сбор пластин"
    shr [7]  =0;                 //сброс активизю режима 7
    sh  [7]  =0;                 //"Отключение установки"
    shr [8]  =0;                 //сброс активизю режима 8
    sh  [8]  =0;                 //"Аварийное отключение установки"
    shr [10]  =0;                 //сброс активизю режима 10
    sh  [10]  =0;                 //"Открыть ЩЗ"
    shr [11]  =0;                 //сброс активизю режима 11
    sh  [11]  =0;                 //"Закрыть ЩЗ"
    shr [19]  =0;                 //сброс активизю режима 19
    sh  [19]  =0;                 //"Высоковакуумная откачка шлюза"
    shr [25]  =0;                 //сброс активизю режима 25
    sh  [25]  =0;                 //"Открыть ДЗ камеры"
    shr [26]  =0;                 //сброс активизю режима 26
    sh  [26]  =0;                 //"Закрыть ДЗ камеры"
    shr [27]  =0;                 //сброс активизю режима 27
    sh  [27]  =0;                 //"ДЗ камеры дросселирование"
    shr [30]  =0;                 //сброс активизю режима 30
    sh  [30]  =0;                 //"Откл. нагрев камеры"
    shr [32]  =0;                 //сброс активизю режима 32
    sh  [32]  =0;                 //"Откл. нагрев п/д"
    shr [34]  =0;                 //сброс активизю режима 34
    sh  [34]  =0;                 //"Откл. БПМ"
    shr [37]  =0;                 //сброс активизю режима 37
    sh  [37]  =0;                 //"Открыть ДЗ масс"
    shr [38]  =0;                 //сброс активизю режима 38
    sh  [38]  =0;                 //"Закрыть ДЗ масс"
    shr [39]  =0;                 //сброс активизю режима 39
    sh  [39]  =0;                 //"ДЗ масс на угол"
    shr [43]  =0;                 //сброс активизю режима 43
    sh  [43]  =0;                 //"Вкл. поддержание газов"
    shr [44]  =0;                 //сброс активизю режима 44
    sh  [44]  =0;                 //"Откл. поддержание газов"
    shr [45]  =0;                 //сброс активизю режима 45
    sh  [45]  =0;                 //"Вкл. откачной пост"
    shr [46]  =0;                 //сброс активизю режима 46
    sh  [46]  =0;                 //"Откл. откачной пост"
    shr [49]  =0;                 //сброс активизю режима 49
    sh  [49]  =0;                 //"Вкл. ТМН камеры"
    shr [50]  =0;                 //сброс активизю режима 50
    sh  [50]  =0;                 //"Откл. ТМН камеры"

    N_ST = 0;
    PR_NALADKA = 0;
    PR_FOTK_SHL=0;
    KOM_DZASL1 = 7;
    KOM_DZASL2 = 7;

    //STVRM();
    shr[48]=0;
    sh[48]=0;

    SBROSR_28();
	RRGOff(ObjRRG[0]);			// отключение РРГ1
	RRGOff(ObjRRG[1]);			// отключение РРГ2
    SetOut(0,1,0x800);
	RRGOff(ObjRRG[2]);			// отключение РРГ3

    SBROS_MEH();				// сброс движений

	for(int i=0;i<DIAGN_COUNT;i++) // сброс всех диагностик
	    diagn[i] = 0;

	SetOut(0,1,0x08);			// отключить звонок
    SetOut(1,3,0x100);          //Выкл. вых. напряжен. БПМ
    SetOut(0,3,0x400);          //Выкл. Ток эмиссии


	norma = 60;					// норма: общий сброс завершен
}
//---------------------------------------------------------------------------
void AVAR_DAVL()      // "Реакция на высокое давление в камере при работе ТМН"
{
    if(zin[1]&0x3004)
    {
        if((zin[0]&0x3000)!=0x2000)
        {
            if(!(diagnS[0]&0x04))			// пока нет связи с Д3
            {
                if(D_D3>=POROG_DAVL)
                {
                    SetOut(0,0,0x04);       //Закрыть ДЗ кам
                    SetOut(1,0,0x08);
                    SetOut(0,1,0x80);       //Закрыть ФК-ОП

                    diagn[23]|=0x08;            //отказ "Авария: высокое давление в камере"

                    shr [1]=0;               //активиз. режима 1
                    sh  [1]=0;               //"Откачка камеры"
                    shr [2]=0;               //активиз. режима 2
                    sh  [2]=0;               //"Тренировка"
                    shr [3]=0;               //активиз. режима 3
                    sh  [3]=0;               //"Рабочий цикл"
                    shr [4]=0;               //активиз. режима 4
                    sh  [4]=0;               //"Технологический процесс"
                    shr [5]=0;               //активиз. режима 5
                    sh  [5]=0;               //"Сброс рабочего цикла"
                    shr [6]=0;               //активиз. режима 6
                    sh  [6]=0;               //"Сбор пластин"
                    shr [10]=0;               //активиз. режима 10
                    sh  [10]=0;               //"Открыть ЩЗ"
                    shr [11]=0;               //активиз. режима 11
                    sh  [11]=0;               //"Закрыть ЩЗ"
                    shr [19]=0;               //активиз. режима 19
                    sh  [19]=0;               //"Высоковакуумная откачка шлюза"
                    shr [25]=0;               //активиз. режима 25
                    sh  [25]=0;               //"Открыть ДЗ камеры"
                    shr [26]=0;               //активиз. режима 26
                    sh  [26]=0;               //"Закрыть ДЗ камеры"
                    shr [27]=0;               //активиз. режима 27
                    sh  [27]=0;               //"Высоковакуумная откачка шлюза"
                    shr [43]=0;               //активиз. режима 43
                    sh  [43]=0;               //"Вкл. поддержание газов"
                    shr [44]=0;               //активиз. режима 44
                    sh  [44]=0;               //"Откл. поддержание газов"

                    SBROS_MEH();
                    //STVRM();
                    shr[48] =1;
                    sh[48]  =1;

                    SetOut(0,3,0x400);      //Выкл. ток эмиссии
                    SetOut(1,3,0x100);      //Выкл. выходн. мощность БПМ

                    KOM_DZASL1=7;

                    SBROSR_28();
                    RRGOff(ObjRRG[0]);			// отключение РРГ1
	                RRGOff(ObjRRG[1]);			// отключение РРГ2
                    SetOut(0,1,0x800);
	                RRGOff(ObjRRG[2]);			// отключение РРГ3

                    if(shr[33])
                    {
                        shr [34]=1;             //активиз. режима 34
                        sh  [34]=1;             //"Сброс БПМ"
                    }

                    if(shr[29])
                    {
                        shr [30]=1;             //активиз. режима 30
                        sh  [30]=1;             //"Откл. нагрева кам"
                    }

                    if(shr[31])
                    {
                        shr [32]=1;             //активиз. режима 32
                        sh  [32]=1;             //"Откл. нагрева п/д"
                    }

                    for(int i=0;i<DIAGN_COUNT;i++)
                        if((i != 14)&&(i != 23)) diagn[i] = 0;// сброс диагностик кроме аварийных
                }
            }

        }
    }
}
//---------------------------------------------------------------------------
void AVAR_DAVL_SHL()      // "Реакция на высокое давление в шлюзе при работе ТМН"
{
    if(zin[1]&0x3004)
    {
        if((zin[1]&0x300)!=0x200)
        {
            if(!(diagnS[0]&0x01))			// пока нет связи с Д1
            {
                if(D_D1>=POROG_DAVL)
                {
                    SetOut(0,0,0x40);       //Закрыть ВК-Шл
                    diagn[23]|=0x10;            //отказ "Авария: высокое давление в шлюзе"
                }
            }
        }
    }
}
int Rash_Pov (int a_zad) //расчёт пути для поворота заслонки при измерении сопротивления
{
    a_zasl = 180.0*(asin((2*RZ*RZ-float(a_zad)*float(a_zad))/(2*RZ*RZ))-asin(XZ/RZ)-FI)/M_PI;
    a_zasl = 90.0 - a_zasl;
    a_zasl = a_zasl * Max_Pov / 360;     //перевод градусов в импульсы
    return a_zasl;
}
int Rash_Vr (int a_zad) //расчёт пути для вращения п/д при измерении сопротивления
{
    a_plast = 90.0 - 180.0*asin((RZ*sin(asin((2*RZ*RZ-float(a_zad)*float(a_zad))/(2*RZ*RZ))-asin(XZ/RZ))-YZ)/float(a_zad))/M_PI;
    a_plast = a_plast * Max_Vr / 360;   //перевод градусов в импульсы
    return a_plast;
}
void VVAK_NASOS()	// подпрограмма "Включить ВВ насос"
   {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	         else return;	// выход

    A1:if ((zin[4] & 0x80) != 0) goto S1;	// насос включен
	SetOut(1,3,0x80);	                // включить питание

	CT_VAK = 0;		    	        // сброс сч.времени
	sh_ = 2;
    A2:if ((zin[4] & 0x80) == 0)	        // насос не вышел на режим
	  {if (CT_VAK <= T_RAZGON_TMN) return;  // время не вышло
	   diagn[24] |= 0x02;		        // отказ:"Нет выхода на режим ВВ насоса"
	   return;}
	diagn[24] &= (~0x02);		        // сброс диагностики
	S1:norma = 61;		     	        // норма:"ВВ насос вышел на режим"
	sh_ = 0;
   }
//------------------------------------------------------------------------------
void OVAK_NASOS()	// подпрограмма "Отключить ВВ Насос"
   {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	         else return;	// выход

    A1:SetOut(0,3,0x80);	                // отключить насос
	CT_VAK = 0;		    	        // сброс сч.времени
	sh_ = 2;
    A2:if ((zin[4] & 0x80) != 0)	        // насос не отключен
	  {
            if (CT_VAK <= T_OTKL_TMN) return;    // время не вышло
	        diagn[24] |= 0x04;		        // отказ: "Нет отключения ВВ насоса"
	        return;
       }
	diagn[24] &= (~0x04);		        // сброс диагностики
	S1:norma = 62;		     	        // норма: "ВВ насос отключен"
	sh_ = 0;
     }
void Fk_Kl6()//Открытие клапана 6 при работе форнасоса камеры
{
    if(zin[1]&0x02)
    {
        if(CT_Kl6>10)
            SetOut(1,2,0x04);

    }
    else
    {
        CT_Kl6=0;
        SetOut(0,2,0x04);
    }
}

/*






//---------------------------------------------------------------------------
void AVAR_DAVL_KN()      // "Реакция на высокое давление в камере при работе КН"
{
    if(diagnS[2]&0x40)return;           //Нет связи с КН
    if((OTVET_KN_M[0]&0x900)==0)return; //КН выключен
    if((zin[2]&0xC00)==0x800)return;    //затвор закрыт
    if((diagnS[0] & 0x08))return;      //нет связи с D4
    if(D_D4 < POROG_DAVL)return;
    SetOut(0,0,0x20);       //закрыть затвор
    SetOut(1,0,0x40);       //закрыть затвор
    diagn[14]|=0x04;            //отказ "высокое давление в камере"
    shr[1] = 0;                      // сброс активизации режимов
       sh[1] = 0;                       // "Откачка"
	   shr[2] = 0;
       sh[2] = 0;                       // "Откачка шлюза"
       shr[3] = 0;
       sh[3] = 0;                       // "РЦ"
	   shr[4] = 0;
       sh[4] = 0;                       // "Тех. процесс"
       shr[5] = 0;
       sh[5] = 0;                       // "Сброс РЦ"
	   shr[6] = 0;
       sh[6] = 0;                       // "Сбор пластин"
	   shr[7] = 0;
       sh[7] = 0;                       // "Отключение установки"

	   shr[10] = 0;
       sh[10] = 0;						// "Открыть ЩЗ"
	   shr[11] = 0;
       sh[11] = 0;						// "Закрыть ЩЗ"


       shr[19] = 0;
       sh[19] = 0;                      // "Закрыть ДЗ"
       shr[25] = 0;
       sh[25] = 0;
       shr[26] = 0;
       sh[26] = 0;
       shr[27] = 0;
       sh[27] = 0;

       SBROSR_28();						// ВЧГ реактора
        SBROS_MEH();						// сброс движений


       SetOut(1,4,0x2A00);                //выдать выкл бмпов



	   RRGOff(ObjRRG[0]);				// отключение РРГ1
	   RRGOff(ObjRRG[1]);				// отключение РРГ2
       RRGOff(ObjRRG[2]);				// отключение РРГ3
	   RRGOff(ObjRRG[3]);				// отключение РРГ4
       if((!(shr[20]))&&(!(shr[21]))&&(!(shr[22]))&&(!(shr[24])))
        SetOut(0,2,0x800);                      //закрыть кл7



       for(int i=0;i<DIAGN_COUNT;i++)
            if((i != 14)&&(i != 14)) diagn[i] = 0;// сброс диагностик кроме аварийных

       KOM_DZASL = 7;                    // "Общий опрос" заслонке
       if(shr[33])
       {
            shr[34]=1;
            sh[34]=1;
       }
       if((shr[35])||(shr[36]))
       {
            shr[37]=1;
            sh[37]=1;
       }
       if(shr[31])
       {
            shr[32]=1;
            sh[32]=1;
       }
       if(shr[38])
       {
            shr[39]=1;
            sh[39]=1;
       }
       if(shr[29])
       {
            shr[30]=1;
            sh[30]=1;
       }
       if(shr[16])
       {
            shr[17]=1;
            sh[17]=1;
       }




}

//---------------------------------------------------------------------------
void AVAR_VODA_II()				// реакция на отсутствие воды в ИИ
{
    if((!(shr[33]))||((zin[0]&0x01)))
    {
        CT_VODA_II=0;
        return;
    }
    if(CT_VODA_II>=T_VODA)
    {
        diagn[14]|=0x10;            //отказ: "Авария: нет охлаждения ИИ"
        if((shr[3])&&!PR_NALADKA)
        {
            shr[5]=1;
            sh[5]=1;
        }
        else
        {
            shr[34]=1;
            sh[34]=1;
        }
    }


}
//---------------------------------------------------------------------------
void OpenFK_TMN_CloseFK_SHL()	// Подпрограмма: Принудительное открытие ФК-ТМН и закрытие ФК-Шл
{
	if(out[4]&0x40 )				// если есть вращение ТМН

	  if((diagnS[0] & 0x10) == 0)		// есть свяь с D5
	   if(D_D5 >= UVAK_ZTMN)			// давление больше 40 Па
		if((zin[0]&0xC00)!=0x400)		// ФК-ТМН не открыт
		{
			if(((zin[0]&0x300)==0x200)&&((zin[0]&0x3000)==0x2000))	// ФК-КАМ и ФК-КН строго закрыт
				SetOut(1,0,0x02);		// открыть ФК-ТМН
			else
				SetOut(0,0,0x05);		// закрыть ФК-КАМ и ФК-КН
		}
}
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------





////////////////////////////////////////////////////////////////////////////////
 void vkl_dist_tmn()    //включить дистанционное управление ТМН
 {
    switch(sh_)
    {
        case 0: return;
        case 1:
        {
            SetOut(1,4,0x20);           //вкл дистанц управление
            CT_1=0;
            sh_=2;
        };break;
        case 2:
        {
            if(zin[4]&0x80)             //дистанц управление включено
            {
                diagn[19]&=(~0x01);         //сброс диагностики
                sh_=0;
                return;
            }
            if(CT_1>=5)
                diagn[19]|=0x01;            //отказ: "Дистанционное управление ТМН не включилось"
        };break;
        default: sh_=0;break;


    }

 }
//---------------------------------------------------------------------------


        */


















