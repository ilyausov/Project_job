//---------------------------------------------------------------------------
//--Файл описания шаблонных функций--//
//---------------------------------------------------------------------------
#include "Klapan.h"
//---------------------------------------------------------------------------
//--Функция инкрементации счетчика объекта--//
//---------------------------------------------------------------------------
void SKlapan::Time()
{
    ctObject++;
}
//---------------------------------------------------------------------------
//--Функция управления объектами через дискретные входы-выходы--//
//---------------------------------------------------------------------------
void Klapan(bool action, SKlapan *object)
{
    switch ( object -> type )
    {
        case 11: DoAction11(action, object); break;
        case 12: DoAction12(action, object); break;
        case 21: DoAction21(action, object); break;
        case 22: DoAction22(action, object); break;
        // неверный тип объекта
        default: diagn[0] |= 0x01; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 1 входом--//
//---------------------------------------------------------------------------
void DoAction11(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 1 дискретным выходом и 2 входами--//
//---------------------------------------------------------------------------
void DoAction12(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 1 входом--//
//---------------------------------------------------------------------------
void DoAction21(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // изучение реакции воздействия на объект
            if ( (bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action )
            {
                // снять диагностику
                diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
                // выставить диагностику
                diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция управления объектом с 2 дискретными выходами и 2 входами--//
//---------------------------------------------------------------------------
void DoAction22(bool action, SKlapan *object)
{
    switch ( sh_ )
    {
        case 1:
        {
            // если нужный результат достигнут - закончить работу
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
            else
            {
                // выставить/снять управляющий дискретный сигнал
                SetOut(action, object->zinOut[0].x, object->zinOut[0].y);
                SetOut(!action, object->zinOut[1].x, object->zinOut[1].y);
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
        }; break;
        case 2:
        {
            // снять диагностики
            diagn[object->diagnObject[(int)(!action)].x] &= (~object->diagnObject[(int)(!action)].y);
            diagn[object->diagnObject[2].x] &= (~object->diagnObject[2].y);
            diagn[object->diagnObject[3].x] &= (~object->diagnObject[3].y);
            // изучение реакции воздействия на объект
            if  (
                    ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == action ) &&
                    ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) != action )
                )
            {
                // обнулить время реакции объекта
                object->ctObject = 0;
                // перейти на следующий шаг
                sh_++;
            }
            // вышло время реакции объекта
            else if ( object->ctObject > object->tkAction[(int)(!action)] )
            {
                // положение объекта неопределено
                if (
                        ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 0 ) &&
                        ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 0 )
                    )
                // выставить диагностику
                diagn[object->diagnObject[2].x] |= object->diagnObject[2].y;
                // положение объекта неоднозначно
                else if (
                            ((bool)( zin[object->zinIn[0].x] & object->zinIn[0].y ) == 1 ) &&
                            ((bool)( zin[object->zinIn[1].x] & object->zinIn[1].y ) == 1 )
                        )
                    // выставить диагностику
                    diagn[object->diagnObject[3].x] |= object->diagnObject[3].y;
                else
                    // выставить диагностику об отсутствии реакции
                    diagn[object->diagnObject[(int)(!action)].x] |= object->diagnObject[(int)(!action)].y;
            }
        }; break;
        case 3:
        {
            // задержка после выполнения активных действий над объектом
            if ( object->ctObject >= object->tkAction[(int)(!action)+2] )
            {
                // выставить норму
                norma = object->normaNmb[(int)(!action)];
                // завершить подпрограмму
                sh_ = 0;
            }
        }; break;
        default: sh_ = 0; break;
    }
}
//---------------------------------------------------------------------------
//--Функция инкремента счетчиков--//
//---------------------------------------------------------------------------
void TimeKlapan()
{
    DzaslMass.Time();
    DzaslKam.Time();
    KlKam.Time();
    KlTmn.Time();
    KlShl.Time();
    FvnKam.Time();
    FvnShl.Time();
    ShZatvor.Time();
    PP.Time();
    VvKl.Time();
    KlOp.Time();



}
//---------------------------------------------------------------------------
//--Функция инициализации объектов с дискретным управлением и дискретной обратной связью--//
//---------------------------------------------------------------------------
void InitObjectsKl()
{
    // описание форнасоса камеры
	FvnKam.type = 11;					// тип 1/1
	// нормы объекта
	FvnKam.normaNmb[0] = 47;				// код нормы включения
	FvnKam.normaNmb[1] = 48;				// код нормы отключения
	// контрольные времена объекта
	FvnKam.tkAction[0] = 7;				// к.время открытия
	FvnKam.tkAction[1] = 20;				// к.время закрытия
	FvnKam.tkAction[2] = 30;				// к.время задержки после открытия
	FvnKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnKam.diagnObject[0].x = 0;			// номер байта диагностики "не открылся"
	FvnKam.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	FvnKam.diagnObject[1].x = 0;			// номер байта диагностики "не закрылся"
	FvnKam.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	FvnKam.diagnObject[2].x = 0;			// номер байта диагностики "не определено"
	FvnKam.diagnObject[2].y = 0x02;		// маска бита диагностики "не определено"
	FvnKam.diagnObject[3].x = 0;			// номер байта диагностики "неоднозначно"
	FvnKam.diagnObject[3].y = 0x02;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnKam.zinOut[0].x = 3;				// номер байта упр. выходного сигнала на "открытие"
	FvnKam.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	FvnKam.zinOut[1].x = 3;				// номер байта упр. выходного сигнала на "закрытие"
	FvnKam.zinOut[1].y = 0x10;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnKam.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	FvnKam.zinIn[0].y = 0x02;			// маска бита ответного входного сигнала об "открытии"
	FvnKam.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	FvnKam.zinIn[1].y = 0x02;			// маска бита ответного входного сигнала о "закрытии"

    // описание форнасоса шлюза
	FvnShl.type = 11;					// тип 1/1
	// нормы объекта
	FvnShl.normaNmb[0] = 45;				// код нормы включения
	FvnShl.normaNmb[1] = 46;				// код нормы отключения
	// контрольные времена объекта
	FvnShl.tkAction[0] = 7;				// к.время открытия
	FvnShl.tkAction[1] = 20;				// к.время закрытия
	FvnShl.tkAction[2] = 30;				// к.время задержки после открытия
	FvnShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	FvnShl.diagnObject[0].x = 0;			// номер байта диагностики "не открылся"
	FvnShl.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	FvnShl.diagnObject[1].x = 0;			// номер байта диагностики "не закрылся"
	FvnShl.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	FvnShl.diagnObject[2].x = 0;			// номер байта диагностики "не определено"
	FvnShl.diagnObject[2].y = 0x20;		// маска бита диагностики "не определено"
	FvnShl.diagnObject[3].x = 0;			// номер байта диагностики "неоднозначно"
	FvnShl.diagnObject[3].y = 0x20;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	FvnShl.zinOut[0].x = 3;				// номер байта упр. выходного сигнала на "открытие"
	FvnShl.zinOut[0].y = 0x20;			// маска бита упр. выходного сигнала  на "открытие"
	FvnShl.zinOut[1].x = 3;				// номер байта упр. выходного сигнала на "закрытие"
	FvnShl.zinOut[1].y = 0x20;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	FvnShl.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	FvnShl.zinIn[0].y = 0x01;			// маска бита ответного входного сигнала об "открытии"
	FvnShl.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	FvnShl.zinIn[1].y = 0x01;			// маска бита ответного входного сигнала о "закрытии"
	
	// описание Кл-Шл
	KlShl.type = 12;						// тип 1/2
	// нормы объекта
	KlShl.normaNmb[0] = 43;				// код нормы включения
	KlShl.normaNmb[1] = 44;				// код нормы отключения
	// контрольные времена объекта
	KlShl.tkAction[0] = 2;				// к.время открытия
	KlShl.tkAction[1] = 2;				// к.время закрытия
	KlShl.tkAction[2] = 2;				// к.время задержки после открытия
	KlShl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlShl.diagnObject[0].x = 1;			// номер байта диагностики "не открылся"
	KlShl.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlShl.diagnObject[1].x = 1;			// номер байта диагностики "не закрылся"
	KlShl.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlShl.diagnObject[2].x = 1;			// номер байта диагностики "не определено"
	KlShl.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlShl.diagnObject[3].x = 1;			// номер байта диагностики "неоднозначно"
	KlShl.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlShl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlShl.zinOut[0].y = 0x300;			// маска бита упр. выходного сигнала  на "открытие"
	KlShl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlShl.zinOut[1].y = 0x300;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlShl.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlShl.zinIn[0].y = 0x4000;			// маска бита ответного входного сигнала об "открытии"
	KlShl.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlShl.zinIn[1].y = 0x8000;			// маска бита ответного входного сигнала о "закрытии"

	// описание Кл-ТМН
	KlTmn.type = 12;					// тип 1/2
	// нормы объекта
	KlTmn.normaNmb[0] = 41;				// код нормы включения
	KlTmn.normaNmb[1] = 42;				// код нормы отключения
	// контрольные времена объекта
	KlTmn.tkAction[0] = 2;				// к.время открытия
	KlTmn.tkAction[1] = 2;				// к.время закрытия
	KlTmn.tkAction[2] = 2;				// к.время задержки после открытия
	KlTmn.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlTmn.diagnObject[0].x = 1;			// номер байта диагностики "не открылся"
	KlTmn.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlTmn.diagnObject[1].x = 1;			// номер байта диагностики "не закрылся"
	KlTmn.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlTmn.diagnObject[2].x = 1;			// номер байта диагностики "не определено"
	KlTmn.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlTmn.diagnObject[3].x = 1;			// номер байта диагностики "неоднозначно"
	KlTmn.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlTmn.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlTmn.zinOut[0].y = 0x02;			// маска бита упр. выходного сигнала  на "открытие"
	KlTmn.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlTmn.zinOut[1].y = 0x02;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlTmn.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlTmn.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	KlTmn.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlTmn.zinIn[1].y = 0x800;			// маска бита ответного входного сигнала о "закрытии"

	// описание Кл-Кам
	KlKam.type = 12;					// тип 1/2
	// нормы объекта
	KlKam.normaNmb[0] = 39;				// код нормы включения
	KlKam.normaNmb[1] = 40;				// код нормы отключения
	// контрольные времена объекта
	KlKam.tkAction[0] = 2;				// к.время открытия
	KlKam.tkAction[1] = 2;				// к.время закрытия
	KlKam.tkAction[2] = 2;				// к.время задержки после открытия
	KlKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlKam.diagnObject[0].x = 2;			// номер байта диагностики "не открылся"
	KlKam.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	KlKam.diagnObject[1].x = 2;			// номер байта диагностики "не закрылся"
	KlKam.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	KlKam.diagnObject[2].x = 2;			// номер байта диагностики "не определено"
	KlKam.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	KlKam.diagnObject[3].x = 2;			// номер байта диагностики "неоднозначно"
	KlKam.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlKam.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	KlKam.zinOut[0].y = 0x01;			// маска бита упр. выходного сигнала  на "открытие"
	KlKam.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	KlKam.zinOut[1].y = 0x01;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlKam.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	KlKam.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	KlKam.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	KlKam.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"

    // описание Кл-ОП
	KlOp.type = 12;					// тип 1/2
	// нормы объекта
	KlOp.normaNmb[0] = 57;				// код нормы включения
	KlOp.normaNmb[1] = 58;				// код нормы отключения
	// контрольные времена объекта
	KlOp.tkAction[0] = 2;				// к.время открытия
	KlOp.tkAction[1] = 2;				// к.время закрытия
	KlOp.tkAction[2] = 2;				// к.время задержки после открытия
	KlOp.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	KlOp.diagnObject[0].x = 2;			// номер байта диагностики "не открылся"
	KlOp.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	KlOp.diagnObject[1].x = 2;			// номер байта диагностики "не закрылся"
	KlOp.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	KlOp.diagnObject[2].x = 2;			// номер байта диагностики "не определено"
	KlOp.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	KlOp.diagnObject[3].x = 2;			// номер байта диагностики "неоднозначно"
	KlOp.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	KlOp.zinOut[0].x = 1;				// номер байта упр. выходного сигнала на "открытие"
	KlOp.zinOut[0].y = 0x80;			// маска бита упр. выходного сигнала  на "открытие"
	KlOp.zinOut[1].x = 1;				// номер байта упр. выходного сигнала на "закрытие"
	KlOp.zinOut[1].y = 0x80;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	KlOp.zinIn[0].x = 2;				// номер байта ответного входного сигнала об "открытии"
	KlOp.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	KlOp.zinIn[1].x = 2;				// номер байта ответного входного сигнала о "закрытии"
	KlOp.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"

    // описание ВВ-Кл
	VvKl.type = 12;						// тип 1/2
	// нормы объекта
	VvKl.normaNmb[0] = 53;				// код нормы включения
	VvKl.normaNmb[1] = 54;				// код нормы отключения
	// контрольные времена объекта
	VvKl.tkAction[0] = 2;				// к.время открытия
	VvKl.tkAction[1] = 2;				// к.время закрытия
	VvKl.tkAction[2] = 2;				// к.время задержки после открытия
	VvKl.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	VvKl.diagnObject[0].x = 3;			// номер байта диагностики "не открылся"
	VvKl.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	VvKl.diagnObject[1].x = 3;			// номер байта диагностики "не закрылся"
	VvKl.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	VvKl.diagnObject[2].x = 3;			// номер байта диагностики "не определено"
	VvKl.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	VvKl.diagnObject[3].x = 3;			// номер байта диагностики "неоднозначно"
	VvKl.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	VvKl.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	VvKl.zinOut[0].y = 0x40;			// маска бита упр. выходного сигнала  на "открытие"
	VvKl.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	VvKl.zinOut[1].y = 0x40;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	VvKl.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	VvKl.zinIn[0].y = 0x100;			// маска бита ответного входного сигнала об "открытии"
	VvKl.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	VvKl.zinIn[1].y = 0x200;			// маска бита ответного входного сигнала о "закрытии"

    // описание ДЗ кам
	DzaslKam.type = 22;						// тип 1/2
	// нормы объекта
	DzaslKam.normaNmb[0] = 27;				// код нормы включения
	DzaslKam.normaNmb[1] = 28;				// код нормы отключения
	// контрольные времена объекта
	DzaslKam.tkAction[0] = 12;				// к.время открытия
	DzaslKam.tkAction[1] = 12;				// к.время закрытия
	DzaslKam.tkAction[2] = 2;				// к.время задержки после открытия
	DzaslKam.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	DzaslKam.diagnObject[0].x = 3;			// номер байта диагностики "не открылся"
	DzaslKam.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	DzaslKam.diagnObject[1].x = 3;			// номер байта диагностики "не закрылся"
	DzaslKam.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	DzaslKam.diagnObject[2].x = 3;			// номер байта диагностики "не определено"
	DzaslKam.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	DzaslKam.diagnObject[3].x = 3;			// номер байта диагностики "неоднозначно"
	DzaslKam.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	DzaslKam.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	DzaslKam.zinOut[0].y = 0x04;			// маска бита упр. выходного сигнала  на "открытие"
	DzaslKam.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	DzaslKam.zinOut[1].y = 0x08;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	DzaslKam.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	DzaslKam.zinIn[0].y = 0x1000;			// маска бита ответного входного сигнала об "открытии"
	DzaslKam.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	DzaslKam.zinIn[1].y = 0x2000;			// маска бита ответного входного сигнала о "закрытии"

    // описание ДЗ масс
	DzaslMass.type = 22;						// тип 1/2
	// нормы объекта
	DzaslMass.normaNmb[0] = 34;				// код нормы включения
	DzaslMass.normaNmb[1] = 35;				// код нормы отключения
	// контрольные времена объекта
	DzaslMass.tkAction[0] = 2;				// к.время открытия
	DzaslMass.tkAction[1] = 2;				// к.время закрытия
	DzaslMass.tkAction[2] = 2;				// к.время задержки после открытия
	DzaslMass.tkAction[3] = 2;				// к.время задержки после закрытия
	// диагностики объекта
	DzaslMass.diagnObject[0].x = 4;			// номер байта диагностики "не открылся"
	DzaslMass.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	DzaslMass.diagnObject[1].x = 4;			// номер байта диагностики "не закрылся"
	DzaslMass.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	DzaslMass.diagnObject[2].x = 4;			// номер байта диагностики "не определено"
	DzaslMass.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	DzaslMass.diagnObject[3].x = 4;			// номер байта диагностики "неоднозначно"
	DzaslMass.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	DzaslMass.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	DzaslMass.zinOut[0].y = 0x10;			// маска бита упр. выходного сигнала  на "открытие"
	DzaslMass.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	DzaslMass.zinOut[1].y = 0x20;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	DzaslMass.zinIn[0].x = 0;				// номер байта ответного входного сигнала об "открытии"
	DzaslMass.zinIn[0].y = 0x10;			// маска бита ответного входного сигнала об "открытии"
	DzaslMass.zinIn[1].x = 0;				// номер байта ответного входного сигнала о "закрытии"
	DzaslMass.zinIn[1].y = 0x20;			// маска бита ответного входного сигнала о "закрытии"

	// описание ЩЗ
	ShZatvor.type = 22;						// тип 2/2
	// нормы объекта
	ShZatvor.normaNmb[0] = 10;				// код нормы включения
	ShZatvor.normaNmb[1] = 11;				// код нормы отключения
	// контрольные времена объекта
	ShZatvor.tkAction[0] = 4;				// к.время открытия
	ShZatvor.tkAction[1] = 4;				// к.время закрытия
	ShZatvor.tkAction[2] = 1;				// к.время задержки после открытия
	ShZatvor.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	ShZatvor.diagnObject[0].x = 4;			// номер байта диагностики "не открылся"
	ShZatvor.diagnObject[0].y = 0x10;		// маска бита диагностики "не открылся"
	ShZatvor.diagnObject[1].x = 4;			// номер байта диагностики "не закрылся"
	ShZatvor.diagnObject[1].y = 0x20;		// маска бита диагностики "не закрылся"
	ShZatvor.diagnObject[2].x = 4;			// номер байта диагностики "не определено"
	ShZatvor.diagnObject[2].y = 0x40;		// маска бита диагностики "не определено"
	ShZatvor.diagnObject[3].x = 4;			// номер байта диагностики "неоднозначно"
	ShZatvor.diagnObject[3].y = 0x80;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	ShZatvor.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	ShZatvor.zinOut[0].y = 0x400;			// маска бита упр. выходного сигнала  на "открытие"
	ShZatvor.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	ShZatvor.zinOut[1].y = 0x800;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	ShZatvor.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	ShZatvor.zinIn[0].y = 0x400;			// маска бита ответного входного сигнала об "открытии"
	ShZatvor.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	ShZatvor.zinIn[1].y = 0x800;			// маска бита ответного входного сигнала о "закрытии"

	// описание подъёмник
	PP.type = 22;					// тип 2/2
	// нормы объекта
	PP.normaNmb[0] = 51;				// код нормы включения
	PP.normaNmb[1] = 52;				// код нормы отключения
	// контрольные времена объекта
	PP.tkAction[0] = 4;				// к.время открытия
	PP.tkAction[1] = 4;				// к.время закрытия
	PP.tkAction[2] = 1;				// к.время задержки после открытия
	PP.tkAction[3] = 1;				// к.время задержки после закрытия
	// диагностики объекта
	PP.diagnObject[0].x = 5;			// номер байта диагностики "не открылся"
	PP.diagnObject[0].y = 0x01;		// маска бита диагностики "не открылся"
	PP.diagnObject[1].x = 5;			// номер байта диагностики "не закрылся"
	PP.diagnObject[1].y = 0x02;		// маска бита диагностики "не закрылся"
	PP.diagnObject[2].x = 5;			// номер байта диагностики "не определено"
	PP.diagnObject[2].y = 0x04;		// маска бита диагностики "не определено"
	PP.diagnObject[3].x = 5;			// номер байта диагностики "неоднозначно"
	PP.diagnObject[3].y = 0x08;		// маска бита диагностики "неоднозначно"
	// дискретные управляющие выходы
	PP.zinOut[0].x = 0;				// номер байта упр. выходного сигнала на "открытие"
	PP.zinOut[0].y = 0x4000;			// маска бита упр. выходного сигнала  на "открытие"
	PP.zinOut[1].x = 0;				// номер байта упр. выходного сигнала на "закрытие"
	PP.zinOut[1].y = 0x8000;			// маска бита упр. выходного сигнала на "закрытие"
	// дискретные входы обратной связи
	PP.zinIn[0].x = 1;				// номер байта ответного входного сигнала об "открытии"
	PP.zinIn[0].y = 0x40;			// маска бита ответного входного сигнала об "открытии"
	PP.zinIn[1].x = 1;				// номер байта ответного входного сигнала о "закрытии"
	PP.zinIn[1].y = 0x80;			// маска бита ответного входного сигнала о "закрытии"




}