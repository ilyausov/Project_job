//---------------------------------------------------------------------------
#pragma hdrstop
#include "Logic.h"
#include "Modules\Mehanika\Mehanika.cpp"
#include "Modules\RRG\RRG.cpp"
#include "Modules\Klapan\Klapan.cpp"
//---------------------------------------------------------------------------
#pragma package(smart_init)

void LogicMain ()
{         
    KOLCO();                    // кольцо
    if ( shr[1] )               // Проверка
    {                           // активации
        R_1();                  // режима 1 "Откачка камеры"
    };
    if ( shr[2] )               // Проверка
    {                           // активации
        R_2();                  // режима 2 "Рабочий цикл"
    };
	if ( shr[3] )               // Проверка
    {                           // активации
        R_3();                  // режима 3 "Тренировка"
    };
	if ( shr[4] )               // Проверка
    {                           // активации
        R_4();                  // режима 4 "Сброс РЦ"
    };
    if ( shr[5] )               // Проверка
    {                           // активации
        R_5();                  // режима 5 "Откл. установки"
    };
    if ( shr[7] )               // Проверка
    {                           // активации
        R_7();                  // режима 7 "Отпыл М1"
    };
    if ( shr[8] )               // Проверка
    {                           // активации
        R_8();                  // режима 8 "Отпыл М2"
    };
	if ( shr[9] )               // Проверка
    {                           // активации
        R_9();                  // режима 9 "Аварийное отключение установки"
    };	
	if ( shr[10] )               // Проверка
    {                            // активации
        R_10();                  // режима 10 "Отпыл М3"
    };	
	if ( shr[20] )               // Проверка
    {                            // активации
        R_20();                  // режима 20 "РРГ1"
    };
    if ( shr[21] )               // Проверка
    {                            // активации
        R_21();                  // режима 21 "РРГ2"
    };
	if ( shr[23] )               // Проверка
    {                            // активации
        R_23();                  // режима 23 "УУН"
    };
	if ( shr[27] )               // Проверка
    {                            // активации
        R_27();                  // режима 27 "Вкл. нагрев"
    };
	if ( shr[28] )               // Проверка
    {                            // активации
        R_28();                  // режима 28 "Откл. нагрев"
    };
    if ( shr[29] )               // Проверка
    {                            // активации
        R_29();                  // режима 29 "Вкл. БПМ1"
    };
    if ( shr[30] )               // Проверка
    {                            // активации
        R_30();                  // режима 30 "Вкл. БПМ2"
    };
    if ( shr[31] )               // Проверка
    {                            // активации
        R_31();                  // режима 31 "Сброс БПМ"
    };
    if ( shr[32] )              // Проверка
    {                           // активации
        R_32();                 // режима 32 "Вкл. ИИ"
    };
    if ( shr[33] )              // Проверка
    {                           // активации
        R_33();                 // режима 33 "Откл. ИИ"
    };
    if ( shr[34] )              // Проверка
    {                           // активации
        R_34();                 // режима 34 "Вкл. ВЧМ"
    };
    if ( shr[36] )              // Проверка
    {                           // активации
        R_36();                 // режима 36 "Откл. нагрева(ручн.)"
    };
    if ( shr[37] )              // Проверка
    {                           // активации
        R_37();                 // режима 37 "Открыть ДЗ"
    };
    if ( shr[38] )              // Проверка
    {                           // активации
        R_38();                 // режима 38 "Закрыть ДЗ"
    };
    if ( shr[39] )              // Проверка
    {                           // активации
        R_39();                 // режима 39 "ДЗ в дросс"
    };
    if ( shr[40] )              // Проверка
    {                           // активации
        R_40();                 // режима 40 "Барабан в исх."
    };
    if ( shr[41] )              // Проверка
    {                           // активации
        R_41();                 // режима 41 "Барабан (вращ. вперед)"
    };
    if ( shr[42] )              // Проверка
    {                           // активации
        R_42();                 // режима 42 "Заслонка в исх."
    };
    if ( shr[43] )              // Проверка
    {                           // активации
        R_43();                 // режима 43 "Заслонка вниз"
    };
    if ( shr[44] )              // Проверка
    {                           // активации
        R_44();                 // режима 44 "Крышка вверх"
    };
    if ( shr[45] )              // Проверка
    {                           // активации
        R_45();                 // режима 45 "Крышка вниз"
    };
    if ( shr[48] )              // Проверка
    {                           // активации
        R_48();                 // режима 48 "Транспортный тест заслонки"
    };
    if ( shr[49] )              // Проверка
    {                           // активации
        R_49();                 // режима 49 "Транспортный тест барабана"
    };
    if ( shr[50] )              // Проверка
    {                           // активации
        R_50();                 // режима 50 "Импульс заслонки"
    };
    if ( shr[52] )              // Проверка
    {                           // активации
        R_52();                 // режима 52 "Импульс барабана"
    };
    if ( shr[53] )              // Проверка
    {                           // активации
        R_53();                 // режима 53 "ДЗ вперед-назад"
    };
	
    POST();                     // дешифрация команд оператора
};
//---------------------------------------------------------------------------
void KOLCO()                    // подпрограмма "Кольцо"
{
    DIAGN_KOLCO();              // диагностика в кольце                                         +
    AVAR_DAVL();                // "Реакция на высокое давление в камере при работе ТМН"        +
    AVAR_VODA_BM();             // реакция на пропадание воды в магнетр.                        +
    AVAR_VODA_II();             // реакция на пропадание воды в ИИ                              +
    UPR_AVAR_OTKL();            // управление режимом R_9 "Авар. откл. установки"               +
    Sopr_Calc();                // расчет сопротивления                                         +
    AVAR_VRASH_BAR();           // выдача аварии барабана                                       +
    VID_DIAGN_GIS();            // выдача диагностики нет согласования ВЧМ                      +
    MEH_AVAR_CHK();		        // слежение за авриями механизма)                               +
    Bar_Spd_Calc();
}
//---------------------------------------------------------------------------
void POST()                     // Почта (приём и дешифрация команд)
{

    switch (qkk)
    {
        case 0:;break;          // проверка на KK = 0
        case 1:                 // проверка на KK = 1
        {
            if ( shr[1] == 0 )  // если режим ещё не активизирован
            {
                shr[1] = 1;     // активизируем
                sh[1]  = 1;     // режим 1 "Откачка камеры"
            }
        }; break;
        case 2:                 // проверка на KK = 2
        {
            if ( shr[2] == 0 )  // если режим ещё не активизирован
            {
                shr[2] = 1;     // активизируем
                sh[2]  = 1;     // режим 2 "Рабочий цикл"
            }
        }; break;
        case 3:                 // проверка на KK = 3
        {
            if ( shr[3] == 0 )  // если режим ещё не активизирован
            {
                shr[3] = 1;     // активизируем
                sh[3]  = 1;     // режим 3 "Тренировка"
            }
        }; break;
        case 4:                 // проверка на KK = 4
        {
            if ( shr[4] == 0 )  // если режим ещё не активизирован
            {
                shr[4] = 1;     // активизируем
                sh[4]  = 1;     // режим 4 "Сброс РЦ"
            }
        }; break;
        case 5:                 // проверка на KK = 5
        {
            if ( shr[5] == 0 )  // если режим ещё не активизирован
            {
                shr[5] = 1;     // активизируем
                sh[5]  = 1;     // режим 5 "Отключение установки"
            }
        }; break;
        case 6:                 // проверка на KK = 6
        {
            OSBROS();           // общий сброс
        }; break;
	    case 20:                // проверка на KK = 20
        {
            PR_Ar = 0;
			shr[20] = 1;    	// активизируем
			sh[20]  = 1;    	// режим 20 "Вкл. РРГ1"
        }; break;
        case 220:                // проверка на KK = 20
        {
			PR_Ar = 1;
			shr[20] = 1;		// активизируем
			sh[20]  = 1;		// режим 20 "Вкл. РРГ1"
        }; break;
        case 120:               // проверка на KK = 120
        {
			RRGOff(ObjRRG[0]);	// отключение РРГ1
        }; break;
        case 21:                // проверка на KK = 21
        {
            if ( shr[21] == 0 ) // если режим ещё не активизирован
            {
                shr[21] = 1;    // активизируем
                sh[21]  = 1;    // режим 21 "РРГ2"
            }
        }; break;
        case 121:               // проверка на KK = 121
        {
            RRGOff(ObjRRG[1]);	// отключение РРГ2
        }; break;		
        case 23:                // проверка на KK = 23
        {
            if ( shr[23] == 0 ) // если режим ещё не активизирован
            {
                shr[23] = 1;    // активизируем
                sh[23]  = 1;    // режим 23 "УУН (вкл.)"
            }
        }; break;
        case 123:               // проверка на KK = 123
        {
            SBROSR_23();        // сброс режима 23 "УУН (выкл.)"
        }; break;
        case 27:                // проверка на KK = 27
        {
            if ( shr[27] == 0 ) // если режим ещё не активизирован
            {
                shr[27] = 1;    // активизируем
                sh[27]  = 1;    // режим 27 "Нагрев (вкл.)"
            }
        }; break;
        case 29:                // проверка на KK = 29
        {
            if ( shr[29] == 0 ) // если режим ещё не активизирован
            {
                shr[29] = 1;    // активизируем
                sh[29]  = 1;    // режим 29 "БПМ1 (вкл.)"
            }
        }; break;
        case 30:                // проверка на KK = 30
        {
            if ( shr[30] == 0 ) // если режим ещё не активизирован
            {
                shr[30] = 1;    // активизируем
                sh[30]  = 1;    // режим 30 "БПМ2 (вкл.)"
            }
        }; break;		
        case 31:                // проверка на KK = 31
        {
            if ( shr[31] == 0 ) // если режим ещё не активизирован
            {
                shr[31] = 1;    // активизируем
                sh[31]  = 1;    // режим 31 "Сброс БПМов"
            }
        }; break;
        case 32:                // проверка на KK = 32
        {
            if ( shr[32] == 0 ) // если режим ещё не активизирован
            {
                shr[32] = 1;    // активизируем
                sh[32]  = 1;    // режим 32 "ИИ (вкл.)"
            }
        }; break;
        case 33:                // проверка на KK = 33
        {
            if ( shr[33] == 0 ) // если режим ещё не активизирован
            {
                shr[33] = 1;    // активизируем
                sh[33]  = 1;    // режим 33 "ИИ (откл.)"
            }
        }; break;
        case 34:
        {
				shr[34] = 1;	// активизируем
                sh[34]  = 1;	// режим 34 "ВЧМ (вкл.)"
        }; break;
        case 134:
        {
				SBROSR_34();	// активизируем сброс ВЧМ
        }; break;
        case 36:                // проверка на KK = 36
        {
            if ( shr[36] == 0 ) // если режим ещё не активизирован
            {
                shr[36] = 1;    // активизируем
                sh[36]  = 1;    // режим 36 "Нагрев ручной (откл.)"
            }
        }; break;
        case 37:                // проверка на KK = 37
        {
            if ( shr[37] == 0 ) // если режим ещё не активизирован
            {
                shr[37] = 1;    // активизируем
                sh[37]  = 1;    // режим 37 "ДЗ открыть"
            }
        }; break;
        case 38:                // проверка на KK = 38
        {
            if ( shr[38] == 0 ) // если режим ещё не активизирован
            {
                shr[38] = 1;    // активизируем
                sh[38]  = 1;    // режим 38 "ДЗ закрыть"
            }
        }; break;
        case 39:                // проверка на KK = 39
        {
            if ( shr[39] == 0 ) // если режим ещё не активизирован
            {
                shr[39] = 1;    // активизируем
                sh[39]  = 1;    // режим 39 "ДЗ в дросс"
            }
        }; break;
        case 40:                // проверка на KK = 40
        {
            if ( shr[40] == 0 ) // если режим ещё не активизирован
            {
                shr[40] = 1;    // активизируем
                sh[40]  = 1;    // режим 40 "Барабан в исходное"
            }
        }; break;
        case 41:                // проверка на KK = 41
        {
            if ( shr[41] == 0 ) // если режим ещё не активизирован
            {
                shr[41] = 1;    // активизируем
                sh[41]  = 1;    // режим 41 "Барабан вперёд"
            }
        }; break;
        case 42:                // проверка на KK = 42
        {
            if ( shr[42] == 0 ) // если режим ещё не активизирован
            {
                shr[42] = 1;    // активизируем
                sh[42]  = 1;    // режим 42 "Заслонка в исходное"
            }
        }; break;
        case 43:                // проверка на KK = 43
        {
            if ( shr[43] == 0 ) // если режим ещё не активизирован
            {
                shr[43] = 1;    // активизируем
                sh[43]  = 1;    // режим 43 "Заслонка вниз"
            }
        }; break;
        case 44:                // проверка на KK = 44
        {
            if ( shr[44] == 0 ) // если режим ещё не активизирован
            {
                shr[44] = 1;    // активизируем
                sh[44]  = 1;    // режим 44 "Крышка вверх"
            }
        }; break;
        case 144:                // проверка на KK = 144
        {
            if ( shr[44] == 0 ) // если режим ещё не активизирован
            {
                shr[44] = 2;    // активизируем
                sh[44]  = 1;    // режим 44 "Крышка вверх"
            }
        }; break;   
        case 45:                // проверка на KK = 45
        {
            if ( shr[45] == 0 ) // если режим ещё не активизирован
            {
                shr[45] = 1;    // активизируем
                sh[45]  = 1;    // режим 45 "Крышка вниз"
            }
        }; break;	
        case 48:                // проверка на KK = 48
        {
            if ( shr[48] == 0 ) // если режим ещё не активизирован
            {
                shr[48] = 1;    // активизируем
                sh[48]  = 1;    // режим 48 "Тр.тест заслонки"
            }
        }; break;
        case 49:                // проверка на KK = 49
        {
            if ( shr[49] == 0 ) // если режим ещё не активизирован
            {
                shr[49] = 1;    // активизируем
                sh[49]  = 1;    // режим 49 "Тр.тест барабана"
            }
        }; break;
        case 50:                // проверка на KK = 50
        {
            if ( shr[50] == 0 ) // если режим ещё не активизирован
            {
                shr[50] = 1;    // активизируем
                sh[50]  = 1;    // режим 50 "Рассчёт импульсов заслонки"
            }
        }; break;
        case 52:                // проверка на KK = 52
        {
            if ( shr[52] == 0 ) // если режим ещё не активизирован
            {
                shr[52] = 1;    // активизируем
                sh[52]  = 1;    // режим 52 "Рассчёт импульсов барабана"
            }
        }; break;
        case 53:                // проверка на KK = 53
        {
            if ( shr[53] == 0 ) // если режим ещё не активизирован
            {
                shr[53] = 1;    // активизируем
                sh[53]  = 1;    // режим 53 "ДЗ вперед-назад"
            }
        }; break;
        case 101:
        {
				SBROS_DZ();	// активизируем стоп привода ДЗ
        }; break;
        case 213:
        {
				MEH_AVAR_SBROS();	// активизируем сброс аварии мех
        }; break;
		
        case 140:               // проверка на KK = 140
        {
            zaslPrRuch = false; // запуск вручную убрать
            pderjPrRuch = false;// запуск вручную убрать
            shr[40] = 0;        // сброс активизации
            sh[40] = 0;         // режима 40 "Барабан в исходное"
            shr[41] = 0;        // сброс активизации
            sh[41] = 0;         // режима 41 "Барабан вращение"
            shr[42] = 0;        // сброс активизации
            sh[42] = 0;         // режима 42 "Заслонка в исходное"
            shr[43] = 0;        // сброс активизации
            sh[43] = 0;         // режима 43 "Заслонка вперёд"
            shr[48] = 0;        // сброс активизации
            sh[48] = 0;         // режима 48 "Тр.тест заслонки"
            shr[49] = 0;        // сброс активизации
            sh[49] = 0;         // режима 49 "Тр.тест барабана"
            shr[50] = 0;        // сброс активизации
            sh[50] = 0;         // режима 50 "Рассчет импульсов заслонки"
            shr[52] = 0;        // сброс активизации
            sh[52] = 0;         // режима 52 "Рассчет импульсов барабана"
            SBROS_MEH();        // сброс механизмов
        }; break;

        default:                // любая другая команда
        {
            diagnS[0] |= 0x80;  // отказ: "неопознанная команда"
            return;
        };
    };
    qkk = 0;                    // сброс кода команды
    diagnS[0] &= ~(0x80);       // сброс диагностики
}
//---------------------------------------------------------------------------
void DIAGN_KOLCO  ()            // "Подпрограмма: "Диагностика в кольце"
{

	//--Диагностика по воде--//

    if(aik[10] < 540)           // Давл воды < 4 бара (0,4 МПа)               ?
        diagn[9] |= 0x01;	    // Отказ: "Нет давления в гидросети"
    else
        diagn[9] &= ~(0x01);    // Сброс диагностики


	if((zin[0] & 0x01) == 0)
		diagn[9] |= 0x02;       // Отказ: "Нет охл. магнетронов"
	else
		diagn[9] &= (~0x02);   	// Сброс диагностики

	if((zin[0] & 0x02) == 0)
		diagn[9] |= 0x04;       // Отказ: "Нет охл. ИИ"
	else
		diagn[9] &= (~0x04);    // Сброс диагностики

	if((zin[0] & 0x04) == 0)
		diagn[9] |= 0x08;       // Отказ:"Нет охл. корпуса и верх крышки"
	else
		diagn[9] &= (~0x08);    // Сброс диагностики

	if((zin[0] & 0x08) == 0)
		diagn[13] |= 0x10;       // Отказ:"Нет охл. нижн крышки"
	else
		diagn[13] &= (~0x10);    // Сброс диагностики

	if((zin[0] & 0x400) == 0)
		diagn[10] |= 0x40;       // Отказ:"Нет компрессора КН"
	else
		diagn[10] &= (~0x40);    // Сброс диагностики
	
	if((zin[0] & 0x40) == 0)
		diagn[9] |= 0x80;       // Отказ:"Нет давления в пневмосети"                ?
	else
		diagn[9] &= (~0x80);    // Сброс диагностики


      /*
	if(zin[2] & 0x04)
		diagn[17] |= 0x08;       // Отказ:"КН: высокая темп. обмотки двигателя"
	else
		diagn[17] &= (~0x08);    // Сброс диагностики

	if(zin[2] & 0x08)
		diagn[17] |= 0x10;       // Отказ:"КН: высокая темп. воды"
	else
		diagn[17] &= (~0x10);    // Сброс диагностики

	if(zin[2] & 0x10)
		diagn[17] |= 0x20;       // Отказ:"КН: низкий поток воды"
	else
		diagn[17] &= (~0x20);    // Сброс диагностики

	if(zin[2] & 0x20)
		diagn[17] |= 0x40;       // Отказ:"КН: низкое давление гелия"
	else
		diagn[17] &= (~0x40);    // Сброс диагностики
	
	if(zin[2] & 0x40)
		diagn[17] |= 0x80;       // Отказ:"КН: ошибка темп. гелия"
	else
		diagn[17] &= (~0x80);    // Сброс диагностики
                                                        */
	if(!(zin[1] & 0x1000))
		diagn[19] |= 0x01;       // Отказ:"Авария привода ДЗ"
	else
		diagn[19] &= (~0x01);    // Сброс диагностики

	if(zin[2] & 0x04)
		diagn[20] |= 0x01;       // Отказ:"ВЧГ перегрев"
	else
		diagn[20] &= (~0x01);    // Сброс диагностики

	if(zin[2] & 0x08)
		diagn[20] |= 0x02;       // Отказ:"ВЧГ предупреждение"
	else
		diagn[20] &= (~0x02);    // Сброс диагностики

	if(zin[2] & 0x10)
		diagn[19] |= 0x02;       // Отказ:"ВЧГ авария "
	else
		diagn[19] &= (~0x02);    // Сброс диагностики


    //-- Диагности по давлению в линиях РРГ1/РРГ2                                        ?

     if(aik[7] < 1103)                // < 0.8 Атм
	 diagn[20] |= 0x10;	        // Отказ: "Низкое давл Ar"
       	else
	 diagn[20] &= ~(0x10);           // Сброс диагностики

        if(aik[7] > nasmod[38])                // > В настройках
	 diagn[20] |= 0x20;	        // Отказ: "Высокое давл Ar"
       	else
	 diagn[20] &= ~(0x20);           // Сброс диагностики

        if(aik[8] < 1103  )                // < 0.8 Атм
	 diagn[20] |= 0x40;	        // Отказ: "Низкое давл N2"
       	else
	 diagn[20] &= ~(0x40);           // Сброс диагностики

        if(aik[8] > nasmod[39])                // > В настройках
	 diagn[20] |= 0x80;	        // Отказ: "Высокое давл N2"
       	else
	 diagn[20] &= ~(0x80);           // Сброс диагностики

	
	//--Диагностика по перегреву воды--//

        if(aik[0] > 901)                // T° > 30°C
	 diagn[9] |= 0x10;	        // Отказ: "Высокая темп. воды охл. магн."
       	else
	 diagn[9] &= ~(0x10);           // Сброс диагностики

        if(aik[1] > 901)                // T° > 30°C
	 diagn[9] |= 0x20;	        // Отказ: "Высокая темп. воды охл. поз. нагр. и ИИ"
       	else
	 diagn[9] &= ~(0x20);           // Сброс диагностики

        if(aik[2] > 901)                // T° > 30°C
	 diagn[9] |= 0x40;	        // Отказ: "Высокая темп. воды охл. корпуса и верх кр. камеры"
       	else
	 diagn[9] &= ~(0x40);           // Сброс диагностики
 
		if(aik[3] > 901)                // T° > 30°C
	 diagn[10] |= 0x20;	        // Отказ: "Высокая темп. воды охл. нижней крышки камеры"
       	else
	 diagn[10] &= ~(0x20);           // Сброс диагностики

		if(aik[9] > 999)                // T° > 30°C                                              ?
	 diagn[13] |= 0x20;	        // Отказ: "Высокая темп. воды охл. компрессора КН"
       	else
	 diagn[13] &= ~(0x20);           // Сброс диагностики

	//--Диагностика отказов двигателей--//

	if((zin[0] & 0x10) != 0)
		diagn[10] |= 0x02;             // Отказ двиг. вращ. барабана"
	else
		diagn[10] &= (~0x02);   	// Сброс диагностики

	if((zin[0] & 0x20) != 0)
		diagn[10] |= 0x04;             // Отказ двиг. вращ. заслонки"
	else
		diagn[10] &= (~0x04);   	// Сброс диагностики

   
	   
}
//---------------------------------------------------------------------------
void MEH_AVAR_CHK()				// сбрасываем аварии
{
	// если нет аварии механизма
	if((zin[1]&0x1000))
		SetOut(0,0,0x4000);		// выдать сигнал "Сброс аварий механизмов"
}
//------------------------------------------------------------------------------
void AVAR_DAVL()      // "Реакция на высокое давление в камере при работе ТМН"
{
 if(out[2]&0x01)				// КН включен?
  if((zin[1]&0xC000) != 0x8000)			// ДЗ не закрыта
     if((diagnS[0]&0x01) == 0)		// есть свяь с D1
	  if(D_D1 >= POROG_DAVL)			// давление больше 100 Па
	  {
        if (!(shr[38]))                    // нет активизации режима 38
        {
            shr[38] = 1;				// активизация режима R_38
	        sh[38] = 1;					// "Закрыть ДЗ" 
        }
       diagn[11] |= 0x40;               // "Авария: высокое давление в камере"
       if(shr[2]||shr[3])               // активизирован РЦ или Тренировка
        {
         shr[4] = 1;                    // активизация режима R_4
         sh[4] = 1;                     // "Сброс РЦ"
         return;
        }
       SBROSR_34();                     // сброс ВЧМ
       if(shr[29]||shr[30])             // активизирован БПМ1,БПМ2
        {
         shr[31] = 1;                   // активизация режима R_31
         sh[31] = 1;                    // "Сброс БПМ"
        }
       if(shr[32])                      // активизирован ИИ
        {
         shr[33] = 1;                   // активизация режима R_33
         sh[33] = 1;                    // "Сброс ИИ"
        }
       if(shr[27])                      // активизирован НАГРЕВ
        {
         shr[36] = 1;                   // активизация режима R_36
         sh[36] = 1;                    // "Откл. НАГРЕВ"
        }
		
		SBROSR_23();					// сброс УУН
		RRGOff(ObjRRG[0]);				// отключение РРГ1
		RRGOff(ObjRRG[1]);				// отключение РРГ2
       SBROS_MEH();                     //
       for (int i=0;i<21;i++)
        if (i != 11) diagn[i] = 0;      // сброс диагностик кроме аварийных
      }
}
//---------------------------------------------------------------------------
void AVAR_VODA_BM()            // "Реакция на пропадание воды в М1 и М2"
{
 if(shr[29]||shr[7]||shr[30]||shr[8]||shr[34])  // есть активизация режимов "БПМ1","БПМ2" , ВЧМ
  {                                    // "Отпыл1","Отпыл2"
   if((zin[0] & 0x01) != 0)
   {
        CT_VODA_BM = 0;// есть охлаждение магнетронов
        return;
   }
   else
   {
    if(CT_VODA_BM >= T_VODA)           // время вышло (5 сек)
     {
        diagn[11] |= 0x01;               // Авария:"Нет охлаждения магнетронов"
        if(shr[2]||shr[3])               // есть активизация "РЦ" или "Тренировка"
        {
            shr[4] = 1;                    // запуск режима 4
            sh[4] = 1;                     // "Сброс РЦ"
            return;
        }
        else
        {
            if(shr[29] || shr[7] || shr[30] || shr[8])
            {
                shr[31] = 1;                   // запуск режима 31
                sh[31] = 1;                    // "Сброс БПМ"
                return;
            }
            else
            {
                SBROSR_34();               // сброс ВЧМ
                return;
            }      
       }
     }
    }
  }
 else
 {
    CT_VODA_BM = 0;
    return;
 }
}
//---------------------------------------------------------------------------
void AVAR_VODA_II()            // "Реакция на пропадание воды в ИИ"
{
    if(shr[32])                  // есть активизация режимов
    {                                    // "Вкл. Нагрев" или "Вкл. ИИ"
        if((zin[0] & 0x02) != 0) CT_VODA_II = 0;// есть охлаждение ИИ
        else if(CT_VODA_II >= T_VODA)           // время вышло (5 сек)
        {
            diagn[11] |= 0x02;               // Авария:"Нет охлаждения ИИ"
            if(shr[2])                       // есть активизация "РЦ"
            {
                shr[4] = 1;                    // запуск режима 4
                sh[4] = 1;                     // "Сброс РЦ"
            }
            else
            {
                shr[33] = 1;                  // запуск режима 33
                sh[33] = 1;                   // "Откл. ИИ"

            }
        }
    }
    else CT_VODA_II = 0;
}
//---------------------------------------------------------------------------
void UPR_AVAR_OTKL()                    // Управление режимом R_9
{
	if(!(out[2]&0x01))                     // кн включен?
	{
        CT_VODA_KN = 0;
        return;                         // выход
    }
    if(zin[0]&0x400)                    // есть охл КН
    {
        CT_VODA_KN = 0;
        return;                         // выход
	}
    if(CT_VODA_KN < T_VODA)return;      // выход
    diagn[11] |= 0x08;  			    // авария нет охл КН
    if(shr[9])return;                   // выход
    shr[9] = 1;                         // активизация Авар. откл уст.
    sh[9] = 1;
}
//---------------------------------------------------------------------------
void Bar_Spd_Calc()             // расчет скорости барабана
{

 if((out[0]&0x02) && (shr[41]||shr[2]))   // есть движения барабана
 {
     pderjPutTek = GetChannel1();
     if((zin[1]&0x04) || (pderjPutTek > 450))  // есть исходник
     {
        if(pderjPutTek > 450) K_OSHIB++;
         pderjPrNeopr = 0;
         CT_BAR = 0;
         diagn[4] &= (~0x20);
         SetChannel1_0();
         pderjPutTek = 0;
         putPderjSpd = 0;
         ctPderjSpd = 0;
         return;
     }
     if(CT_BAR > 30)
     {
        diagn[4] |= 0x20;       // диагностика: "Нет вращения барабана"
     }
     if(ctPderjSpd >= 25)   //  500 мс
     {
        pderjSpeed = int(float(pderjPutTek - putPderjSpd)* 120.0/40.0); // 400 меток на оборот
        ctPderjSpd = 0;
        putPderjSpd = pderjPutTek;
     }
 }
 else
 {
     pderjSpeed = 0;
     CT_BAR = 0;
     ctPderjSpd = 0;
 }
}
//---------------------------------------------------------------------------
void Sopr_Calc()                // расчет сопротивления
{
    // cw
    /*
    M1_N = nasmod[1] + pderjAngle360/2 + pderjAngle360/18;
    if(M1_N > pderjAngle360) M1_N = M1_N - pderjAngle360;
    M1_V = nasmod[1] + 0 - pderjAngle360/18;
    if(M1_V > pderjAngle360) M1_V = M1_V - pderjAngle360;
    M2_N = nasmod[1] + pderjAngle360*3/4 + pderjAngle360/18;
    if(M2_N > pderjAngle360) M2_N = M2_N - pderjAngle360;
    M2_V = nasmod[1] + pderjAngle360/4 - pderjAngle360/18;
    if(M2_V > pderjAngle360) M2_V = M2_V - pderjAngle360;
    M3_N = nasmod[1] + 0 + pderjAngle360/18;
    if(M3_N > pderjAngle360) M3_N = M3_N - pderjAngle360;
    M3_V = nasmod[1] + pderjAngle360/2 - pderjAngle360/18;
    if(M3_V > pderjAngle360) M3_V = M3_V - pderjAngle360;
    */

    // ccw
    M1_N = nasmod[1] + 0 + pderjAngle360/18;
    if(M1_N > pderjAngle360) M1_N = M1_N - pderjAngle360;

    M1_V = nasmod[1] + pderjAngle360/2 - pderjAngle360/18;
    if(M1_V > pderjAngle360) M1_V = M1_V - pderjAngle360;

    VCHM_N = nasmod[1] + pderjAngle360*3/4 + pderjAngle360/18;
    if(VCHM_N > pderjAngle360) VCHM_N = VCHM_N - pderjAngle360;

    VCHM_V = nasmod[1] + pderjAngle360/4 - pderjAngle360/18;
    if(VCHM_V > pderjAngle360) VCHM_V = VCHM_V - pderjAngle360;

    M2_N = nasmod[1] + pderjAngle360/2 + pderjAngle360/18;
    if(M2_N > pderjAngle360) M2_N = M2_N - pderjAngle360;

    M2_V = nasmod[1] + 0 - pderjAngle360/18;
    if(M2_V > pderjAngle360) M2_V = M2_V - pderjAngle360;

    if(par[N_ST][17])     // есть задание сопротивл
    {
        if(!par[N_ST][8])     // нет задание М1
        {
            if(par[N_ST][10])        // Есть задание на ВЧМ
            {
                if(VCHM_N < VCHM_V)     // весь участок попал в диапазон
                {
                    if((pderjPutTek > VCHM_N)&&(pderjPutTek < VCHM_V))
                        goto S0;
                    else return;
                }
                else        // участок разбит на 2
                {
                    if(((pderjPutTek > 0)&&(pderjPutTek < VCHM_V))||
                    ((pderjPutTek > VCHM_N)&&(pderjPutTek < pderjAngle360)))
                        goto S0;
                    else return;
                }
            }
            else    // M2
            {
                if(M2_N < M2_V)     // весь участок попал в диапазон
                {
                    if((pderjPutTek > M2_N)&&(pderjPutTek < M2_V))
                        goto S0;
                    else return;
                }
                else        // участок разбит на 2
                {
                    if(((pderjPutTek > 0)&&(pderjPutTek < M2_V))||
                    ((pderjPutTek > M2_N)&&(pderjPutTek < pderjAngle360)))
                        goto S0;
                    else return;
                }
            }
        }
        else    // M1
        {
            if(M1_N < M1_V)     // весь участок попал в диапазон
            {
                if((pderjPutTek > M1_N)&&(pderjPutTek < M1_V))
                    goto S0;
                else return;
            }
            else        // участок разбит на 2
            {
                if(((pderjPutTek > 0)&&(pderjPutTek < M1_V))||
                ((pderjPutTek > M1_N)&&(pderjPutTek < pderjAngle360)))
                    goto S0;
                else return;
            }
        }
    }
    else return;
    
S0: SOPR = int(float(aik[6])*1000.0*pow(10,nasmod[3])/4095.0);
}
//---------------------------------------------------------------------------
void DIAGN_VKL_KN()	        // диагностика вкл/откл КН
{
	if(out[2]&0x01)		        // есть пуск КН
	{
		if(CT_VKL_KN > 5)
		{
			if(zin[2]&0x01)			// есть входной сигнал вкл. КН
				diagn[10] &= ~(0x80); 	// Сброс диагностики
			else
				diagn[10] |= 0x80;	// Отказ: КН выключился
		}
	}
	else
		CT_VKL_KN = 0;
}
//------------------------------------------------------------------------------
void AVAR_VRASH_BAR()
{
 if(shr[2])
 {
  if(diagn[4]&0x20)
  {
    if(CT_VRASH_BAR > T_KVRASH)
    {
      diagn[11] |= 0x80;	// диагностика: "Авария: Нет вращения барабана"
      if(!shr[4])
        {
          shr[4] = 1;
          sh[4] = 1;
        }
    }
  }
  else
    CT_VRASH_BAR = 0;
  }
}
//-----------------------------------------------------------------------------
void VID_DIAGN_GIS()			// выдача диагностики нет согласования ВЧМ
{
    if ((shr[34])&&				// есть активизация режима ВЧМ
        (VRGIS)&&				// есть выход на режим ВЧМ
        (aik[14]))				// отраженная мощность не 0
    {
        N_TEK_GIS=aik[13]*10/aik[14];// текущий коэф. согласования
        if(N_TEK_GIS >= nasmod[35])
            diagn[21] &= (~0x08);// снять диагностику
        else
            diagn[21] |= 0x08;	// диагн.: "нет согл. ВЧМ"
    }
    else
    {
        diagn[21] &= (~0x08);// снять диагностику
        N_TEK_GIS = 0;
    }
}
//------------------------------------------------------------------------------
void OSBROS()			// подпрограмма Общий сброс
{
  shr[1] = 0;				// сброс активизации режима 1
  sh[1] = 0;				// "Откачка"
  shr[4] = 0;				// сброс активизации режима 4
  sh[4] = 0;				// "Сброс РЦ"
  shr[5] = 0;				// сброс активизации режима 5
  sh[5] = 0;				// "Отключение установки"
  shr[9] = 0;      		       	// сброс активизации режима 9
  sh[9] = 0;      		       	// "Авар. откл. установки"
  shr[28] = 0;      		   	// сброс активизации режима 28
  sh[28] = 0;      		       	// "Откл. Нагрев"
  shr[31] = 0;      		   	// сброс активизации режима 31
  sh[31] = 0;      		       	// "Сброс БПМ"
  shr[33] = 0;      		   	// сброс активизации режима 33
  sh[33] = 0;      		       	// "Сброс ИИ"
  shr[36] = 0;      		   	// сброс активизации режима 36
  sh[36] = 0;      		       	// "Откл. Нагрев"
  shr[40] = 0;				// сброс активизации режима 40
  sh[40] = 0;				// "Барабан в исх"
  shr[41] = 0;				// сброс активизации режима 41
  sh[41] = 0;				// "Барабан вперёд"
  shr[42] = 0;				// сброс активизации режима 42
  sh[42] = 0;				// "Засл в исх"
  shr[43] = 0;				// сброс активизации режима 43
  sh[43] = 0;				// "Засл вперед"
  shr[44] = 0;				// сброс активизации режима 44
  sh[44] = 0;				// "Крышка вверх"
  shr[45] = 0;				// сброс активизации режима 45
  sh[45] = 0;				// "Крышка вниз"
  shr[48] = 0;				// сброс активизации режима 48
  sh[48] = 0;
  shr[49] = 0;				// сброс активизации режима 49
  sh[49] = 0;
  shr[50] = 0;				// сброс активизации режима 50
  sh[50] = 0;
  shr[51] = 0;				// сброс активизации режима 52
  sh[51] = 0;
  shr[52] = 0;				// сброс активизации режима 52
  sh[52] = 0;


  RRGOff(ObjRRG[0]);		// отключение РРГ1
  RRGOff(ObjRRG[1]);		// отключение РРГ2
  SBROSR_23();			    // Сброс УУН

  SBROSR_34();			    // Сброс ВЧМ

  SBROS_MEH();				// сброс механизмов

  SBROS_DZ();               // стоп мех ДЗ

  SetOut(1,1,0xA00);			// блокировка мощности БПМ и БПИИ
  SetOut(0,0,0x04);			// отключить свидетель


  
  N_ST = 0;

  int i;
  for(i=0;i<21;i++)		  // сброс всех диагностик
  diagn[i] = 0;

  norma = 27;			  // норма: общий сброс завершен
}
//---------------------------------------------------------------------------
void TIME ()		               //  подпрограмма управления таймером
{				    // (прерывание с периодом в 1 миллисекунду)
  CT_T1++;	        // Сч.тиков (1 мсек=1кГц)
  CT_DZ++;              // ДЗ 1 мсек тики
  CT_REQUN++;               // счетчик ограничения регулятора
    ctZaslOpros++;
    ctPderjOpros++;
  if(CT_T1 < 20) return;
  CT_T1 = 0;		// Сброс сч.тиков (1 мсек.)
  CT_T20++;		// Счетчик тиков (20мсек = 50Гц)
  // Счетчики тиковские (20 мсек) для устройств и режимов
  ctZaslDvij++;         // (тик) счетчик времени движения заслонки
  ctZaslErr++;          // (тик) счетчик времени движения п/держателя
  ctPderjDvij++;        // (тик) счетчик времени движения п/держателя
  ctPderjErr++;         // (тик) счетчик времени обнаружения ошибок
  ctPderjSpd++;         // (тик) счетчик времени расчета скорости

  CT_VRUN++;                // счетчик вр.выхода на режим
  CT_PR_UN++;               // счетчик вр.выхода при пробое

  //CT_KR++;		    	// (тик) счетчик режимов крышки
  //CT_VHG++;
  CT_KSOPR++;

  if(CT_T20 < 50) return;
  CT_T20 = 0;		// Сброс сч.тиков (20 мсек.)
  // Счетчики секундные (1 сек)

  CT_VODA_BM++;			// отстутствия воды в магнетронах
  CT_VODA_II++;			// отстутствия воды в ИИ
  CT_VODA_KN++;         // нет охл КН
  CT_TEMP++;			// счетчик времени режимов БПН
  CT_BM++;				// счетчик времени режимов БПМ
  CT_II++;				// счетчик времени режимов БПИИ
  CT_IST++;             // сч-к вкл/выкл. источников
  CT_TMN++;				// счетчик времени режимов ТМН
  CT_KR++;			    // (сек) счетчик режимов крышки
  CT_BAR++;
  CT_NAP++;
  CT_VRASH_BAR++;
  CT_VKL_KN++;                  // КН
  CT_KN++;                      // КН
  CT_VHG++;
  
  
  // Счетчики времени режимов (секундные)
  CT_1++;
  CT_2++;
  CT_3++;
  CT_7++;
  CT_8++;
  CT_10++;
  CT_23++;
  CT23K1++;
  CT_27++;
  CT_28++;
  CT27K1++;
  CT_29++;
  CT29K1++;
  CT_30++;
  CT30K1++;
  CT_32++;
  CT32K1++;
  CT_34++;
  CT34K1++;
  CT_39++;
  ct48++;
  ct49++;

  TimeRRG();
  TimeKlapan();

}

//------------------------------------------------------------------------------
//------------  РЕЖИМЫ  --------------------------------------------------------
//------------------------------------------------------------------------------
void R_1 ()            // Режим "Откачка камеры"
 {
  sh_ = sh[1];
  if (shr[1] == 1) goto L1;
  if (shr[1] == 2) goto L2;
  if (shr[1] == 3) goto L3;
  if (shr[1] == 4) goto L4;
  if (shr[1] == 5) goto L5;
  if (shr[1] == 6) goto L6;
  if (shr[1] == 7) goto L7;
  if (shr[1] == 8) goto L8;
  if (shr[1] == 9) goto L9;
  if (shr[1] == 10) goto L10;
  if (shr[1] == 11) goto L11;
  if (shr[1] == 12) goto L12;
  if (shr[1] == 13) goto L13;
  if (shr[1] == 14) goto L14;
  if (shr[1] == 15) goto L15;
  if (shr[1] == 16) goto L16;
  if (shr[1] == 17) goto L17;
  if (shr[1] == 18) goto L18;
  if (shr[1] == 19) goto L19;
  if (shr[1] == 20) goto L20;
  if (shr[1] == 21) goto L21;
  if (shr[1] == 22) goto L22;
  if (shr[1] == 23) goto L23;
  if (shr[1] == 24) goto L24;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[1] = sh_;
  if (sh[1] != 0) goto L100;    // sh_ != 0
  ++shr[1];                     // след. шаг сч.шр1
  if (shr[1] > 24) goto L0;     // число шагов режима
  sh[1] = 1;
L100:return;					// возврат в "кольцо"

L0:norma = 5;					// норма: "Откачка завершена"
  shr[1] = 0;
  goto L100;

L1:	SetOut(0,1,0xE0E0);			// закрыть Кл-НАП, Кл1, Кл2, Кл3, Кл4Ю Кл5
	if(out[2]&0x01)				// КН включён?
		{
			if((zin[1]&0x4000)&&(!(zin[1]&0x8000)))	// ДЗ открыт?
			{
				shr[1] = 17;
				sh_ = 1;
				goto L17_1;		// Переход на шаг 17_1
			}
			if(aik[15]<=nasmod[33])		// Есть разгон?
			{
				shr[1] = 7;
				sh_ = 0;	 	// Переход на шаг 8
				goto L101;
			}
			shr[1] = 6;
			sh_ = 1;			// Переход на подшаг 6_1
			goto L6_1;
		}
	sh_ = 0;
	goto L101;
L2:	Klapan(0,&KlKam);			// закр. ФК-КАМ
	if(sh_) goto L101;
	shr[38] = 1;				// Активиз. режима 38 "Закрыть ДЗ"
	sh[38] = 1;
	goto L101;
L3:	if(shr[38]) goto L101;		// Ожидание конца режима
	shr[1] = 23;                // переход на шаг 24
	sh_ = 0;
	goto L101;
L4: Klapan(1,&Fvn);				// Включить форнасос
	goto L101;
L5: Klapan(1,&KlKn);			// Открыть ФК-КН
	CT_1 = 0;
	goto L101;
L6: if(diagnS[0]&0x02)			// пока нет связи с D2
		goto L101;
	if(D_D2 >= UVAK_KN)		    // проверка уровня вакуума в КН
	{
		if(CT_1 >= T_KKN_OTK)
			diagn[10] |= 0x10;	// диагностика "Отказ: Медленная фороткачка КН"
		goto L101;
	}
	diagn[10] &= (~0x10);			// сброс диагностики

L6_1:SetOut(1,2,0x01);				// Пуск КН
    CT_KN = 0;
    shr[1] = 7;                     //переход на 8 шаг
	sh_ = 0;
	goto L101;

L7: VRR_GIS();                       //вкл разр работы ВЧМ
    if(sh_) goto L101;
    goto L0;                         // ВЫХОД!!!

L8: Klapan(0,&KlKn);				// Закрыть ФК-КН
	goto L101;
L9: if(diagnS[0]&0x01)			// пока нет связи с D1
		goto L101;
	if(D_D1 < UVAK_KAM_V)		// проверка уровня вакуума в шлюзе
	{
		shr[1] = 12;			// Переход на шаг 13
		sh_ = 0;		
		goto L101;
	}
	sh_ = 0;
	goto L101;
L10:Klapan(1,&Fvn);				// Включить форнасос
	goto L101;
L11:Klapan(1,&KlKam);			// Открыть ФК-КАМ
	CT_1 = 0;
	goto L101;
L12:if(diagnS[0]&0x01)			// пока нет связи с D1
		goto L101;
	if(D_D1 >= UVAK_KAM_V)		// проверка уровня вакуума в камере
	{
		if(CT_1 >= T_KKAM)
			diagn[3] |= 0x80;		// диагностика "Медленная фороткачка камеры"
		goto L101;
	}
	diagn[3] &= (~0x80);			// сброс диагностики
	sh_ = 0;
	goto L101;
L13:Klapan(0,&KlKam);			// Закрыть ФК-КАМ
	goto L101;
L14:Klapan(0,&Fvn);				// Откл. форнасос
	goto L101;
L15:if(aik[15] > nasmod[33])
    {
        if(CT_KN > T_KRAZGON)
			diagn[14] |= 0x01;		// диагностика "Медленный разгон КН"
        goto L101;
    }
    diagn[14] &= (~0x01);			// сброс диагностики
    sh_ = 0;
    goto L101;
L16:if(diagnS[0]&0x01)			// пока нет связи с D1
		goto L101;
	if(D_D1 >= UVAK_KAM_N)			// проверка уровня вакуума в камере
	{
		shr[1] = 22;				// Переход на шаг 23
		sh_ = 0;
		goto L101;
	}
	shr[37] = 1;				// Активиз. режим 37
	sh[37] = 1;
	sh_ = 0;
	goto L101;
L17:if(shr[37]) goto L101;		// Ожидание конца режима
L17_1:CT_1 = 0;
	sh_ = 0;
	goto L101;
L18:GoZaslonka(0, 0, 0, 1, 0); // заслонка в исходное
	goto L101;
L19:if(diagnS[0]&0x01)			// пока нет связи с D1
		goto L101;
	if(D_D1 >= nasmod[0])		// проверка уровня вакуума в камере
	{
		if(CT_1 >= T_KKAM_V)
			diagn[3] |= 0x40;	// диагностика "Отказ: Медленная ВВ откачка камеры"
		goto L101;
	}
	diagn[3] &= (~0x40);		// сброс диагностики
	if(!nasmod[10])				// Нет раз. работы с БПМ
	{
		shr[1] = 20;
		sh_ = 1;				// Переход на шаг 20_1
		goto L20_1;
	}
	sh_ = 0;
	goto L101;
L20:VIDK_BM(014004,04000,1,0,010);	// Включить БПМ
	if(sh_) goto L101;
L20_1:if(!nasmod[9]||shr[3])	// Нет раз. раб. с ИИ или тренировка
	{
		shr[1] = 21;
		sh_ = 1;				// Переход на шаг 21_1
		goto L21_1;
	}
	sh_ = 0;
	goto L101;
L21:VIDK_II(014400,04000,1,2,010);	// Включить ИИ
	if(sh_) goto L101;
L21_1:if(!nasmod[8]||shr[3])	// нет раз. раб. с БПН или тренировка
	{
		shr[1] = 6;                 //переход на 7 шаг
	    sh_ = 0;
	    goto L101;
	}
	sh_ = 0;
	goto L101;
L22:VBPN();						// Включить БПН
    if(sh_) goto L101;
    shr[1] = 6;                 //переход на 7 шаг
    sh_ = 0;
	goto L101;
L23:if((zin[1]&0x30) != 0x10)   // крышка не внизу
    {
        diagn[4] |= 0x80;	    // диагностика "Крышка не закрыта"
        goto L101;
    }
    diagn[4] &= (~0x80);		// сброс диагностики
    SetOut(0,1,0xC000);         // закрыть Кл-Нап, Кл5
    shr[1] = 9;                 // переход на шаг 10
    sh_ = 0;
    goto L101;

L24:if(diagnS[0]&0x02)			// пока нет связи с D2
		goto L101;
	if(D_D2 < UVAK_KN)		    // проверка уровня вакуума в КН
	{
		shr[1] = 6;
		sh_ = 1;				// Переход на шаг 6_1
		goto L6_1;
    }
    shr[1] = 3;
    sh_ = 0;				// Переход на шаг 4
    goto L101;
}
//------------------------------------------------------------------------------
void R_2 ()			// Режим "Рабочий цикл"
{
	sh_ = sh[2];
	if (shr[2] < 1 || shr[2] > 70) goto L100;
	if (shr[2] < 10) goto L00;
	if (shr[2] < 20) goto L01;
	if (shr[2] < 30) goto L02;
	if (shr[2] < 40) goto L03;
	if (shr[2] < 50) goto L04;
	if (shr[2] < 60) goto L05;
	else goto L06;

L00:if (shr[2] == 1) goto L1;	if (shr[2] == 2) goto L2;
	if (shr[2] == 3) goto L3;	if (shr[2] == 4) goto L4;
	if (shr[2] == 5) goto L5;	if (shr[2] == 6) goto L6;
	if (shr[2] == 7) goto L7;	if (shr[2] == 8) goto L8;
	if (shr[2] == 9) goto L9;
L01:if (shr[2] == 10) goto L10;	if (shr[2] == 11) goto L11;
	if (shr[2] == 12) goto L12;	if (shr[2] == 13) goto L13;
	if (shr[2] == 14) goto L14;	if (shr[2] == 15) goto L15;
	if (shr[2] == 16) goto L16;	if (shr[2] == 17) goto L17;
	if (shr[2] == 18) goto L18;	if (shr[2] == 19) goto L19;
L02:if (shr[2] == 20) goto L20;	if (shr[2] == 21) goto L21;
	if (shr[2] == 22) goto L22;	if (shr[2] == 23) goto L23;
	if (shr[2] == 24) goto L24;	if (shr[2] == 25) goto L25;
	if (shr[2] == 26) goto L26;	if (shr[2] == 27) goto L27;
	if (shr[2] == 28) goto L28;	if (shr[2] == 29) goto L29;
L03:if (shr[2] == 30) goto L30;	if (shr[2] == 31) goto L31;
	if (shr[2] == 32) goto L32;	if (shr[2] == 33) goto L33;
	if (shr[2] == 34) goto L34;	if (shr[2] == 35) goto L35;
	if (shr[2] == 36) goto L36;	if (shr[2] == 37) goto L37;
	if (shr[2] == 38) goto L38;	if (shr[2] == 39) goto L39;
L04:if (shr[2] == 40) goto L40;	if (shr[2] == 41) goto L41;
	if (shr[2] == 42) goto L42;	if (shr[2] == 43) goto L43;
	if (shr[2] == 44) goto L44;	if (shr[2] == 45) goto L45;
	if (shr[2] == 46) goto L46;	if (shr[2] == 47) goto L47;
	if (shr[2] == 48) goto L48;	if (shr[2] == 49) goto L49;
L05:if (shr[2] == 50) goto L50;	if (shr[2] == 51) goto L51;
	if (shr[2] == 52) goto L52;	if (shr[2] == 53) goto L53;
	if (shr[2] == 54) goto L54;	if (shr[2] == 55) goto L55;
	if (shr[2] == 56) goto L56;	if (shr[2] == 57) goto L57;
	if (shr[2] == 58) goto L58;	if (shr[2] == 59) goto L59;
L06:if (shr[2] == 60) goto L60;	if (shr[2] == 61) goto L61;
	if (shr[2] == 62) goto L62;	if (shr[2] == 63) goto L63;
	if (shr[2] == 64) goto L64;	if (shr[2] == 65) goto L65;
	if (shr[2] == 66) goto L66;	if (shr[2] == 67) goto L67;
    if (shr[2] == 68) goto L68;	if (shr[2] == 69) goto L69;
    if (shr[2] == 70) goto L70;
	else goto L100;         			// выход
	
// конечный диспетчер режима
L101:sh[2] = sh_;
	if (sh[2] != 0) goto L100;			// sh_ != 0
	++shr[2];					// след. шаг сч.шр2
	if (shr[2] > 70) goto L0;			// число шагов режима
	sh[2] = 1;
L100:return;						// возврат в "кольцо"

L0: norma = 6;						// норма: "РЦ завершен"
	shr[2] = 0;
	goto L100;

L1:	N_ST = 0;
	T_PROC = 0;
        if(!nasmod[27])                 // РЦ без напуска
        {
                shr[2] = 5;                 // переход на аг 6
                sh_ = 0;
                goto L101;
        }
	Klapan(0,&KlKam);				// закрыть ФК-Кам
	if(sh_) goto L101;
	shr[38] = 1;					// активизация режима R_38
	sh[38] = 1;					// "Закрыть ДЗ"
	goto L101;
L2:	if(shr[38]) goto L101;				// ожидание конца режима "Закрыть ДЗ"
	SetOut(0,1,0xE0);				// закрыть Кл1, Кл2, Кл3
    shr[2] = 3;                     // переход на 4 шаг
	sh_ = 0;
	goto L101;
L3:	if(!VRTEMP) goto L101;				// ожидание вых. на режим
	shr[2] = 21;
	sh_ = 1;					// переход на режим L21_1
	goto L21_1;
L4:	NAP_KAM();                        	        // напуск в камеру
    if(sh_) goto L101;
    otvet = 0;
    goto L101;
L5:	if(!otvet)					// нет ответа оператора
	{
		if(!(zin[1] & 0x10))			// крышка не внизу
			SetOut(0,1,0xC000);		// закрыть Кл-НАП, Кл5
		goto L101;
	}
	sh_ = 0;
	goto L101;
L6:	if(!(zin[1] & 0x10))			       // крышка не внизу
	{
		diagn[4] |= 0x80;			// отказ: "Крышка не закрыта"
		goto L101;
	}
	diagn[4] &= (~0x80);				// сброс диагностики
	shr[1] = 1;					// активизация режима R_1
	sh[1] = 1;					// "Откачка"
	sh_ = 0;
	goto L101;
L7:	if(shr[1]) goto L101;				// ожидание конца режима
	A_OUT(1,nasmod[23]);				// задать скорость вращения барабана
	SetOut(1,0,0x02);				// включить вращение барабана
	sh_ = 0;
	goto L101;
L8:	if((diagnS[0] & 0x01) != 0) goto L101;          // нет связи c D1
	if(D_D1 >= nasmod[0]) goto L101;	        // проверка ур. вакуума по D1
	if(!nasmod[8] || !par[1][12])		        // нет рр БПН или задания
	{
		shr[2] = 11;
		goto L11_1;				// переход на шаг 11_1
	}
	N_ST = 1;
	shr[27] = 1;					// активизация режима R_27
	sh[27] = 1;					// "Вкл. нагрев"
	sh_ = 0;
	goto L101;
L9:	if(!VRTEMP) goto L101;				// ожидание выхода на режим
	CT_2 = 0;
	sh_ = 0;
	goto L101;
L10:if(CT_2 <= par[N_ST][5]) 			        // ожидание выхода на режим
	{
		T_PROC = CT_2;
		goto L101;
	}
	shr[28] = 1;					// активизация режима R_28
	sh[28] = 1;					// "Откл. нагрев"
	sh_ = 0;
	goto L101;
L11:if(shr[28]) goto L101;				// ожидание конца режима
    T_PROC = 0;
L11_1:if(!nasmod[9] || !par[2][3] || !par[2][5])        // нет рр и задания ИИ
	{
		shr[2] = 19;				// переход на шаг 20
		sh_ = 0;
		goto L101;
	}
	N_ST = 2;
	sh_ = 0;
	goto L101;
L12:GoZaslonka(zaslUgolAbs,nasmod[2],0,0,0);		        // заслонка в нагрев
	if(sh_) goto L101;
	shr[39] = 1;					// активизация режима R_39
	sh[39] = 1;					// "ДЗ"
	goto L101;
L13:if(shr[39]) goto L101;				// ожидание выхода на режим ДЗ
	PR_Ar = 1;
	shr[20] = 1;					// активизация режима R_20
	sh[20] = 1;					// "РРГ1"
	sh_ = 0;
	goto L101;
L14:if(!(ObjRRG[0]->vRRG)) goto L101;	                // ожидание выхода на режим
	shr[32] = 1;					// активизация режима R_32
	sh[32] = 1;					// "Вкл. ИИ"
	sh_ = 0;
	goto L101;
L15:if(!VRII) goto L101;				// ожидание выхода на режим
	CT_2 = 0;
	sh_ = 0;
	goto L101;
L16:if(CT_2 <= par[N_ST][5])			        // ожидание конца очистки
	{
		T_PROC = CT_2;
		goto L101;
	}
	shr[33] = 1;					// активизация режима R_33
	sh[33] = 1;					// "Откл. ИИ"
	sh_ = 0;
	goto L101;
L17:if(shr[33]) goto L101;				// ожидание конца режима
	RRGOff(ObjRRG[0]);				// отключение РРГ1
	T_PROC = 0;
	shr[37] = 1;					// активизация режима R_37
	sh[37] = 1;					// "Открыть ДЗ"
	sh_ = 0;
L18:if(shr[37]) goto L101;				// ожидание выхода на режим
	sh_ = 0;
	goto L101;
L19:if((diagnS[0] & 0x01) != 0) goto L101;              // нет связи c D1
	if(D_D1 >= nasmod[22]) goto L101;	        // проверка ур. вакуума по D1
	sh_ = 0;
	goto L101;
L20:if(!nasmod[8] || !par[3][12])		        // нет рр и задания БПН
	{
        T_PROC = 0;
	    N_ST = 4;
		shr[2] = 24;
        sh_ = 1;
		goto L24_1;				// переход на шаг 24_1
	}
	N_ST = 3;
	shr[27] = 1;					// активизация режима R_27
	sh[27] = 1;					// "Вкл. нагрев"
    shr[2] = 21;                // переход на 22 шаг
	sh_ = 0;
	goto L101;

L21:if(shr[28]) goto L101; 				// ожидание конца режима 28 "Откл. нагрева"
L21_1:shr[39] = 1;					// активизация режима R_39
	sh[39] = 1;					// "ДЗ в дросс"
	shr[2] = 24;			
	sh_ = 0;					// переход на шаг 25
	goto L101;

L22:if(!VRTEMP) goto L101;				// ожидание выхода на режим
	CT_2 = 0;
	sh_ = 0;
	goto L101;
L23:if(CT_2 <= par[N_ST][5])			// ожидание конца нагрева
	{
		T_PROC = CT_2;
		goto L101;
	}
	if(par[N_ST+1][12])					// напыление с нагревом
	{
        T_PROC = 0;
	    N_ST = 4;
		shr[2] = 24;
		goto L24_2;						// переход на шаг 24_2
	}
	shr[28] = 1;						// активизация режима R_28
	sh[28] = 1;
	sh_ = 0;
	goto L101;
L24:if(shr[28]) goto L101;				// ожидание конца режима
L24_1:  T_PROC = 0;
	    N_ST = 4;
L24_2:  if((!nasmod[10] || (!par[N_ST][5] && !par[N_ST][17]) || (!par[N_ST][8] && !par[N_ST][9])) && ((!par[N_ST][5] && !par[N_ST][17]) || !par[N_ST][10]) && (!par[N_ST][5] || !par[N_ST][12])  )
	{	// нет рр или задания напыления 
		shr[2] = 51;
		goto L51_1;						// переход на шаг 51_1
	}
	A_OUT(1,nasmod[11]);				// задать скорость вращения барабана
	SetOut(1,0,0x02);					// включить вращение барабана
	if(par[N_ST][12])
	{
		if(shr[27])						// Есть задание по To на напыление
		{
			shr[2] = 21;
            sh_ = 1;
			goto L21_1;					// переход на шаг L21_1
		}
		shr[27] = 1;					// активизация режима R_27
		sh[27] = 1;						// "Вкл. нагрев"
		shr[2] = 2;
		sh_ = 0;						// переход на шаг 3
		goto L101;
	}
	if(shr[27])							
	{
		shr[28] = 1;					// активизация режима R_28
		sh[28] = 1;						// "Откл. нагрева"
		shr[2] = 20;
		sh_ = 0;						// переход на шаг 21
		goto L101;
	}
	shr[2] = 21;
    sh_ = 1;
	goto L21_1;							// переход на шаг L21_1
L25:if(shr[39]) goto L101;				// ожидание выхода на режим
	if(!par[N_ST][1])					// нет параметра РРГ1
	{
		shr[2] = 26;					// переход на шаг 26_1
		sh_ = 1;
		goto L26_1;
	}
	shr[21] = 1;						// активизация режима R_21
	sh[21] = 1;							// "Вкл. РРГ2"
	sh_ = 0;
	goto L101;
L26:if(!ObjRRG[1]->vRRG) goto L101;		// ожидание выхода на режим
L26_1:if(!par[N_ST][2])
    {
        shr[2] = 27;					// переход на шаг 27_1
		sh_ = 1;
		goto L27_1;
    }
    if(par[N_ST][10])                  // есть зад на ВЧМ по мощн
    {
        PR_DAVL_PODJ = 1;
    }
    shr[23] = 1;						// активизация режима R_23
	sh[23] = 1;							// "Вкл. УУН"	
	sh_ = 0;
	goto L101;
L27:if(!VRUN) goto L101;				// ожидание выхода на режим
L27_1:if(!par[N_ST][8])					// нет задания М1
	{
		if(par[N_ST][9])				// есть задание на М2
		{
			shr[2] = 34;				// переход на шаг 35
			sh_ = 0;
			goto L101;
		}
		if(par[N_ST][10])				// Есть зад. на ВЧМ
		{
			shr[2] = 41;				// переход на шаг 42
			sh_ = 0;
			goto L101;
		}
		CT_2 = 0;
		shr[2] = 67;
		sh_ = 0;						// переход на шаг 68
		goto L101;	
	}	
	sh_ = 0;
	goto L101;
L28:GoZaslonka(zaslUgolAbs,nasmod[2],0,0,0); // заслонка в ИИ                                +
	if(sh_) goto L101;
    if(!nasmod[5])                      // работа без отпыла М1
    {
        shr[29] = 1;                    // активизация режима 29
        sh[29] = 1;
        shr[2] = 64;                    // переход на шаг 65
        goto L101;
    }
	shr[7] = 1;							// активизация режима R_7
	sh[7] = 1;							// "Отпыл М1"
	goto L101;
L29:if(shr[7]) goto L101;				// ожидание конца режима
	CT_2 = 0;
	sh_ = 0;
	goto L101;
L30:if(CT_2 <= nasmod[5])				// ожидание конца отпыла М1
	{
		goto L101;
	}
	sh_ = 0;
	goto L101;
L31:GoZaslonka(zaslUgolAbs,nasmod[2]+ zaslAngle360/4,0,0,0);	// заслонка в нагрев М1     +
	if(sh_) goto L101;
	if(!par[N_ST][17])					// работа по времени
	{
		CT_2 = 0;
		shr[2] = 32;					// переход на шаг 33
		goto L101;
	}
    SetOut(1,0,0x04);               // подключить свидетель
	goto L101;
L32:if(SOPR > par[N_ST][17])  // ожидание конца процесса
    {
        CT_KSOPR = 0;
        goto L101;
    }
    if(CT_KSOPR < T_KSOPR) goto L101;
    Z_SOPR = SOPR;
    ZU_SOPR = int(360.0*float(pderjPutTek)/float(pderjAngle360));
	shr[2] = 33;
	goto L33_1;							// переход на шаг 33_1
L33:if(CT_2 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_2;
		goto L101;
	}
L33_1:  sh_ = 0;
	goto L101;
L34:    GoZaslonka(zaslUgolAbs,nasmod[2] + zaslAngle360/2,0,0,0); // заслонка в ВЧМ         +
	if(sh_) goto L101;
        shr[31] = 1;						// активизация режима R_31
	sh[31] = 1;							// "Откл. БПМ"
	shr[2] = 49;						// переход на шаг 50
	goto L101;
L35:GoZaslonka(zaslUgolAbs,nasmod[2]+ zaslAngle360/2,0,0,0);	// заслонка в М2            +
	if(sh_) goto L101;
    if(!nasmod[7])                     // работа без отпыла М2
    {
        shr[30] = 1;                    // активизация режима 30
        sh[30] = 1;
        shr[2] = 65;                    // переход на шаг 66
        goto L101;
    }
	shr[8] = 1;							// активизация режима R_8
	sh[8] = 1;							// "Отпыл М2"	
	goto L101;
L36:if(shr[8]) goto L101;				// ожидание конца режима
	CT_2 = 0;
	sh_ = 0;
	goto L101;
L37:if(CT_2 <= nasmod[7])				// ожидание конца отпыла М2
	{
		goto L101;
	}
	sh_ = 0;
	goto L101;
L38:GoZaslonka(zaslUgolAbs,nasmod[2]+ zaslAngle360*3/4,0,0,0); // заслонка в М2             +
	if(sh_) goto L101;
	if(!par[N_ST][17])					// работа по времени
	{
		CT_2 = 0;
		shr[2] = 39;					// переход на шаг 40
		goto L101;
	}
    SetOut(1,0,0x04);               // подключить свидетель
	goto L101;
L39:    if(SOPR > par[N_ST][17])  // ожидание конца процесса
        {
          CT_KSOPR = 0;
          goto L101;
        }
        if(CT_KSOPR < T_KSOPR) goto L101;
        Z_SOPR = SOPR;
        ZU_SOPR = int(360.0*float(pderjPutTek)/float(pderjAngle360));
	shr[2] = 40;
	goto L40_1;							// переход на шаг 40_1
L40:if(CT_2 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_2;
		goto L101;
	}
L40_1:  sh_ = 0;
	goto L101;
L41:GoZaslonka(zaslUgolAbs,nasmod[2],0,0,0);	// заслонка в ИИ
	if(sh_) goto L101;
        shr[31] = 1;						// активизация режима R_31
	sh[31] = 1;							// "Откл. БПМ"
        shr[2] = 49;						// переход на шаг 50
	goto L101;
L42:GoZaslonka(zaslUgolAbs,nasmod[2]+ zaslAngle360/4,0,0,0);		// заслонка в ВЧМ       +
	if(sh_) goto L101;
    shr[34] = 1;                    // активизация режима 34  ВЧМ
    sh[34] = 1;
    sh_ = 0;
    goto L101;
L43:if(!VRGIS) goto L101;				// ожидание выхода на режим ВЧМ
	sh_ = 0;
	goto L101;
L44:if(diagn[21] & 0x08)goto L101;	// "нет согласования ВЧМ"
    PR_DAVL_PODJ = 0;
    shr[23] = 1;
    sh[23] = 1;                     // актив УУН
	sh_ = 0;
	goto L101;

L45:if(!VRUN) goto L101;				// ожидание выхода на режим УУН
    if(nasmod[29])			        // есть зад по темп ВЧМ
	{
		CT_2 = 0;
        sh_ = 0;
		goto L101;                  //перезод на 46 шаг
	}
    shr[2] = 69;					// переход на шаг 70
    sh_ = 0;
	goto L101;

L46:if(CT_2 <= nasmod[29])goto L101;	//ждем нагрев
    shr[2] = 69;					// переход на шаг 70
    sh_ = 0;
	goto L101;

L47:if(SOPR > par[N_ST][17])  // ожидание конца процесса
    {
        CT_KSOPR = 0;
        goto L101;
    }
    if(CT_KSOPR < T_KSOPR) goto L101;
    Z_SOPR = SOPR;
    ZU_SOPR = int(360.0*float(pderjPutTek)/float(pderjAngle360));
	shr[2] = 48;
	goto L48_1;							// переход на шаг 48_1
L48:if(CT_2 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_2;
		goto L101;
	}
L48_1:SBROSR_34();
    sh_ = 0;
	goto L101;
L49:GoZaslonka(zaslUgolAbs,nasmod[2]+ zaslAngle360*3/4,0,0,0);   // заслонка в М2            +
    if(sh_) goto L101;
	shr[2] = 50;
    sh_ = 1;
    goto L50_1;
L50:if(shr[31]) goto L101;				// ожидание конца режима
L50_1:SBROSR_23();						// откл. УУН
	RRGOff(ObjRRG[1]);					// отключение РРГ2
	T_PROC = 0;
	shr[37] = 1;						// активизация режима R_37
	sh[37] = 1;							// "Открыть ДЗ"
	sh_ = 0;
	goto L101;
L51:if(shr[37]) goto L101;              // ожидание заверш. режима
    N_ST++;
	if((N_ST <= N_ST_MAX))	            // проверка
	{
		if(par[N_ST][17]||par[N_ST][5]) // есть зад. по R или t
        {
            sh_ = 0;
            goto L101;
        }
	}
L51_1:A_OUT(1,nasmod[23]);				// задать скорость вращения барабана
	SetOut(1,0,0x02);					// включить вращение барабана
	if(!par[7][5])						// нет задания времени отпыла
	{
		shr[2] = 54;
        sh_ = 1;
		goto L54_1;						// переход на шаг 54_1
	}
	N_ST = 7;
	shr[27] = 1;						// активизация режима R_27
	sh[27] = 1;							// "Вкл. нагрев"
	shr[2] = 52;
	sh_ = 0;
	goto L101;
L52:if((diagnS[0] & 0x01) != 0) goto L101; 	// нет связи c D1
	if(D_D1 >= nasmod[22]) goto L101;		// проверка ур. вакуума по D1
	shr[2] = 24;
	sh_ = 1;
	goto L24_2;
L53:if(!VRTEMP) goto L101;				// ожидание выхода на режим
	CT_2 = 0;
	sh_ = 0;
	goto L101;
L54:if(CT_2 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_2;
		goto L101;
	}
L54_1:shr[28] = 1;						// активизация режима R_28
	sh[28] = 1;							// "Откл. нагрев"	
	sh_ = 0;
	goto L101;
L55:if(shr[28]) goto L101;				// ожидание конца режима
	T_PROC = 0;
	SetOut(0,0,0x02);					// отключить вращение барабана		
	A_OUT(1,8192);						// сбросить скорость вращения барабана
	if(!par[8][12] && !par[8][5])		// нет задания T и времени остывания
	{
		shr[2] = 57;
		goto L57_1;						// переход на шаг 57_1
	}
	N_ST = 8;
	if(!par[N_ST][12])					// задание не по T
	{
		CT_2 = 0;
		shr[2] = 56;					// переход на шаг 56
        sh_ = 0;
		goto L101;
	}
    CT_2 = 0;
	sh_ = 0;
	goto L101;
L56:if((diagnS[0] & 0x04) != 0) goto L101; // нет связи c термодатом
	if(TEK_TEMP > par[N_ST][12])       // проверка температуры
        {
                CT_2 = 0;
                goto L101;
        }
        if(CT_2 < T_KOST) goto L101;
	shr[2] = 57;
	goto L57_1;							// переход на шаг 48_1
L57:if(CT_2 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_2;
		goto L101;
	}
L57_1:N_ST = 0;
	T_PROC = 0;
    SetOut(0,0,0x04);                   // отключить свидетель
    shr[2] = 68;                        //переход на 69 шаг
	sh_ = 0;
    goto L101;

L58:OBPN();								// отключить БПН
	if(sh_) goto L101;
	if(!nasmod[10])						// нет рр БПМ
	{
		sh_ = 1;
		shr[2] = 59;
		goto L59_1;						// переход на шаг 59_1
	}
	goto L101;
L59:VIDK_BM(010004,04000,0,0,020);		// выкл. БПМ
	if(sh_) goto L101;
L59_1:if(!nasmod[9])					// нет рр ИИ
	{
		sh_ = 1;
		shr[2] = 60;
		goto L60_1;						// переход на шаг 60_1
	}
	sh_ = 0;
	goto L101;
L60:VIDK_II(010000,04000,0,2,020); 		// выкл. БПИИ
	if(sh_) goto L101;
L60_1:if(!nasmod[34])                   // работа без напуска
    {
        goto L0;                        // ВЫХОД!!!
    }
    shr[38] = 1;						// активизация режима R_38
	sh[38] = 1;							// "Закрыть ДЗ"		
	sh_ = 0;
	goto L101;
L61: if((shr[38]) != 0) goto L101;				// ожидание выхода на режим

    //SetOut(1,1,0x8000);			        // открыть Кл-НАП
    //SetOut(0,1,0x4000);			        // закрыть Кл5
	sh_ = 0;
	goto L101;
L62: GoZaslonka(0, 0, 0, 1, 0);			// заслонка в исходное
	goto L101;
L63: NAP_KAM();							// напуск в камеру
    goto L101;
L64:if(zin[1] & 0x10) goto L101;		// крышка не внизу
	SetOut(0,1,0xC000);					// закрыть Кл-НАП
	sh_ = 0;
	goto L0;                            // ВЫХОД!!!
L65:if(!VRBM) goto L101;               // ожидание выхода на режим
    shr[2] = 30;                        // переход на шаг 31
    sh_ = 0;
    goto L101;
L66:if(!VRBM) goto L101;               // ожидание выхода на режим
    shr[2] = 37;                        // переход на шаг 38
    sh_ = 0;
    goto L101;

L67:if(!VRBM) goto L101;               // ожидание выхода на режим
    shr[2] = 44;                        // переход на шаг 45
    sh_ = 0;
    goto L101;

L68:if(CT_2 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_2;
		goto L101;
	}
    shr[2] = 50;
    sh_ = 1;
    goto L50_1;
L69:ORR_GIS();
    if(sh_) goto L101;
    shr[2] = 57;                        //переход на 58 шаг
    sh_ = 0;
    goto L101;
L70:GoZaslonka(zaslUgolAbs,nasmod[2]+ zaslAngle360/2,0,0,0);		// заслонка в ВЧМ         +
    if(sh_) goto L101;
	if(!par[N_ST][17])					// работа по времени
	{
		CT_2 = 0;
		shr[2] = 47;					// переход на шаг 48
		goto L101;
	}
    SetOut(1,0,0x04);               // подключить свидетель
    shr[2] = 46;					// переход на шаг 47
    sh_ = 0;
    goto L101;  
}
//------------------------------------------------------------------------------
void R_3 ()								// Режим "Тренировка"
{
	sh_ = sh[3];

	if (shr[3] == 1) goto L1;
	if (shr[3] == 2) goto L2;
	if (shr[3] == 3) goto L3;
	if (shr[3] == 4) goto L4;
	if (shr[3] == 5) goto L5;
	if (shr[3] == 6) goto L6;
	if (shr[3] == 7) goto L7;
	if (shr[3] == 8) goto L8;
	if (shr[3] == 9) goto L9;
	if (shr[3] == 10) goto L10;
	if (shr[3] == 11) goto L11;
	if (shr[3] == 12) goto L12;
	if (shr[3] == 13) goto L13;
	if (shr[3] == 14) goto L14;
	if (shr[3] == 15) goto L15;
	if (shr[3] == 16) goto L16;
	if (shr[3] == 17) goto L17;
	if (shr[3] == 18) goto L18;
	if (shr[3] == 19) goto L19;
	if (shr[3] == 20) goto L20;
	if (shr[3] == 21) goto L21;
	if (shr[3] == 22) goto L22;
	if (shr[3] == 23) goto L23;
    if (shr[3] == 24) goto L24;
    if (shr[3] == 25) goto L25;
	else goto L100;						// выход
	// конечный диспетчер режима
L101:sh[3] = sh_;
	if (sh[3] != 0) goto L100;			// sh_ != 0
	++shr[3];							// след. шаг сч.шр3
	if (shr[3] > 25) goto L0;			// число шагов режима
	sh[3] = 1;
L100:return;							// возврат в "кольцо"

L0: norma = 9;							// норма: "Тренировка завершена"
	shr[3] = 0;
	goto L100;

L1:	T_PROC = 0;
	shr[1] = 1;							// активизация режима R_1
	sh[1] = 1;							// "Откачка камеры"
	sh_ = 0;
	goto L101;
L2:	if(shr[1]) goto L101;				// ожидание конца режима
	if(!par[9][8] || !par[9][5] || !nasmod[10])
	// нет задания тренировки М1
	{
		shr[3] = 8;
		goto L8_1;
	}
	N_ST = 9;
	shr[39] = 1;						// активизация режима R_39
	sh[39] = 1;							// "ДЗ дросс"
	sh_ = 0;
	goto L101;
L3:	if(shr[39]) goto L101;				// ожидание выхода на режим ДЗ дросс
	shr[23] = 1;						// активизация режима R_23
	sh[23] = 1;							// "УУН"	
	sh_ = 0;
	goto L101;
L4:	GoZaslonka(zaslUgolAbs,nasmod[2],0,0,0); 		// заслонка в ИИ
	goto L101;
L5:	if(!VRUN) goto L101;				// ожидание выхода на режим
	shr[29] = 1;						// активизация режима R_29
	sh[29] = 1;							// "Вкл. БПМ1"	
	sh_ = 0;
	goto L101;
L6:	if(!VRBM) goto L101;				// ожидание выхода на режим
	CT_3 = 0;
	sh_ = 0;
	goto L101;
L7:	if(CT_3 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_3;
		goto L101;
	}
	shr[31] = 1;						// активизация режима R_31
	sh[31] = 1;							// "Откл. БПМ"		
	sh_ = 0;
	goto L101;
L8:	if(shr[31]) goto L101;				// ожидание конца режима
	T_PROC = 0;
L8_1:if(!par[10][9] || !par[10][5] || !nasmod[10])
	// нет задания тренировки М2
	{
		shr[3] = 14;
		goto L14_1;
	}
	N_ST = 10;
	shr[39] = 1;						// активизация режима R_39
	sh[39] = 1;							// "ДЗ дросс"
	sh_ = 0;
	goto L101;
L9:	if(shr[39]) goto L101;				// ожидание выхода на режим
	shr[23] = 1;						// активизация режима R_23
	sh[23] = 1;							// "УУН"	
	sh_ = 0;
	goto L101;
L10:GoZaslonka(zaslUgolAbs,nasmod[2] + zaslAngle360/2,0,0,0);		// заслонка в пол. ВЧМ
	goto L101;
L11:if(!VRUN) goto L101;				// ожидание выхода на режим
	shr[30] = 1;						// активизация режима R_30
	sh[30] = 1;							// "Вкл. БПМ2"
	sh_ = 0;
	goto L101;
L12:if(!VRBM) goto L101;				// ожидание выхода на режим
	CT_3 = 0;
	sh_ = 0;
	goto L101;
L13:if(CT_3 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_3;
		goto L101;
	}
	shr[31] = 1;						// активизация режима R_31
	sh[31] = 1;							// "Откл. БПМ"		
	sh_ = 0;
	goto L101;
L14:if(shr[31]) goto L101;				// ожидание конца режима
	T_PROC = 0;
L14_1: if((!par[11][10])||(!par[11][5]))	// Есть пар-ры тренировки на ВЧМ
	{
		shr[3] = 21;
		sh_ = 1;
		goto L21_1;						// переход на шаг 20_1
	}	
	N_ST = 11;
	shr[39] = 1;						// активизация режима R_39
	sh[39] = 1;							// "ДЗ на угол"
	sh_ = 0;
	goto L101;
L15:if(shr[39]) goto L101;				// ожидание выхода на режим
    PR_DAVL_PODJ = 1;
	shr[23] = 1;						// активизация режима 23
	sh[23] = 1;							// "УУН"
	sh_ = 0;
	goto L101;
L16:GoZaslonka(zaslUgolAbs,nasmod[2] + zaslAngle360/4,0,0,0);	// заслонка в пол. М1
	goto L101;
L17:if(!VRUN) goto L101;				// ожидание выхода на режим
	shr[34] = 1;						// активизация режима R_34
	sh[34] = 1;							// "Вкл. БПМ3"
	sh_ = 0;
	goto L101;
L18:if(!VRGIS) goto L101;				// ожидание выхода на режим
	sh_ = 0;
	goto L101;
L19:if(diagn[21] & 0x08)goto L101;			    // "Нет согласования ВЧМ"
    PR_DAVL_PODJ = 0;
	shr[23] = 1;						// активизация режима УУН
	sh[23] = 1;
	sh_ = 0;
	goto L101;
L20:if(!VRUN) goto L101;				// ожидание выхода на режим
    CT_3 = 0;
	sh_ = 0;
	goto L101;
L21:if(CT_3 <= par[N_ST][5])			// ожидание конца процесса
	{
		T_PROC = CT_3;
		goto L101;
	}
    SBROSR_34();                        // сброс ВЧМ
    T_PROC = 0;
L21_1:SBROSR_23();						// откл. УУН
	N_ST = 0;
	shr[37] = 1;						// активизация режима R_37
	sh[37] = 1;							// "Открыть ДЗ"
	sh_ = 0;
	goto L101;
L22:if(shr[37]) goto L101;				// ожидание выхода на режим
	sh_ = 0;
	goto L101;
L23:if((diagnS[0] & 0x01) != 0) goto L101; // нет связи c D1
	if(D_D1 >= nasmod[22]) goto L101;	// проверка ур. вакуума по D1
	sh_ = 0;
	goto L101;
L24:VIDK_BM(010004,04000,0,0,020);		// выкл. БПМ
	goto L101;
L25:ORR_GIS();                          // снять разр работы ВЧМ
    goto L101;
}
//------------------------------------------------------------------------------
void R_4 ()								// Режим "Сброс РЦ"
{
	sh_ = sh[4];
	if (shr[4] == 1) goto L1;
	if (shr[4] == 2) goto L2;
	if (shr[4] == 3) goto L3;
	if (shr[4] == 4) goto L4;
	if (shr[4] == 5) goto L5;
	if (shr[4] == 6) goto L6;
	if (shr[4] == 7) goto L7;
	if (shr[4] == 8) goto L8;
	if (shr[4] == 9) goto L9;
	if (shr[4] == 10) goto L10;
	if (shr[4] == 11) goto L11;
	if (shr[4] == 12) goto L12;
	if (shr[4] == 13) goto L13;
	if (shr[4] == 14) goto L14;
	if (shr[4] == 15) goto L15;
    if (shr[4] == 16) goto L16;
	else goto L100;						// выход
	// конечный диспетчер режима

L101:sh[4] = sh_;
	if (sh[4] != 0) goto L100;			// sh_ != 0
	++shr[4];							// след. шаг сч.шр4
	if (shr[4] > 16) goto L0;			// число шагов режима
	sh[4] = 1;
L100:return;							// возврат в "кольцо"

L0:	norma = 10;							// норма: "Сброс РЦ"
	shr[4] = 0;
	goto L100;

L1:	if(shr[2])							// есть актив. РЦ
		PR_RC = 1;
	else
		PR_RC = 0;
	shr[2] = 0;							// сброс актив. РЦ
	sh[2] = 0;
	shr[3] = 0;							// сброс актив. Тренировки
	sh[3] = 0;
	if(!shr[7] && !shr[8] && !shr[29] && !shr[30])
		// нет активизации БПМ
	{
		sh_ = 0;
		goto L101;
	}
	shr[31] = 1;						// активизация режима R_31
	sh[31] = 1;							// "Откл. БПМ"	
	sh_ = 0;
	goto L101;
L2:	if(shr[31]) goto L101;				// ожидание конца режима
        if(!shr[32])						// нет активизации ИИ
	{
		sh_ = 0;
		goto L101;
	}
	shr[33] = 1;						// активизация режима R_33
	sh[33] = 1;							// "Откл. ИИ"	
	sh_ = 0;
	goto L101;	
L3:	if(shr[33])	goto L101;				// ожидание конца режима
    SBROSR_34();                        //сброс ВЧМ
    if(!shr[27])						// нет активизации нагрева
	{
		sh_ = 0;;
		goto L101;
	}
	shr[28] = 1;						// активизация режима R_28
	sh[28] = 1;							// "Откл. БПН"	
	sh_ = 0;
	goto L101;	
L4:	if(shr[28])	goto L101;				// ожидание конца режима
    RRGOff(ObjRRG[0]);					// отключение РРГ1
	RRGOff(ObjRRG[1]);					// отключение РРГ2	
	SBROSR_23();						// отключение УУН
	shr[1] = 0;							// сброс активизации режима R_1
	sh[1] = 0;							// "Откачка"
	diagn[3] &= (~0xC0);				// сброс диагностик режима
    diagn[10] &= (~0x10);
    diagn[12] &= (~0xFF);
    diagn[13] &= (~0xFF);
    diagn[14] &= (~0xFF);
    diagn[15] &= (~0xC0);
    diagn[18] &= (~0xFF);
    
	SBROS_MEH();						// сброс механизмов
	shr[44] = 0;						// сброс актив. "Крышка вверх"
	sh[44] = 0;
	shr[45] = 0;						// сброс актив. "Крышка вниз"
	sh[45] = 0;
    shr[4] = 14;                        // переход на 15 шаг
    sh_ = 0;
    goto L101;

L5:	OBPN();								// отключение БПН
	if(sh_) goto L101;
	if(!nasmod[10])						// нет рр БПМ
	{
		sh_ = 1;
		shr[4] = 6;
		goto L6_1;
	}
	goto L101;
L6:	VIDK_BM(010004,04000,0,0,020);		// выкл. БПМ
	if(sh_) goto L101;
L6_1:if(!nasmod[9])						// нет рр ИИ
	{
		sh_ = 1;
		shr[4] = 7;
		goto L7_1;
	}
	sh_ = 0;
	goto L101;
L7:	VIDK_II(010000,04000,0,2,020); 		// выкл. БПИИ
	if(sh_) goto L101;
L7_1:if(shr[9])							// есть активизация "Аварийное откл. устан."
	{
		shr[5] = 1;						// сброс активизация режима R_5
		sh[5] = 1;						// "Отключение установки"
        N_ST = 0;
        shr[4] = 16;                    // ВЫХОД!!!
        sh_ = 0;
        goto L101;
	}
	sh_ = 0;
	goto L101;
L8:     otvet = 0;
	sh_ = 0;
	goto L101;
L9:	if(!otvet) goto L101;				// ожидание ответа оператора
    if(otvet==2)shr[4]=16;              //выход
	sh_ = 0;
	goto L101;
L10:Klapan(0,&KlKam);					// закрыть ФК-Кам
	if(sh_) goto L101;
	shr[38] = 1;						// активизация режима R_38
	sh[38] = 1;							// "ДЗ"
	goto L101;
L11:if(shr[38]) goto L101;				// ожидание выхода на режим ДЗ
	sh_ = 0;
	goto L101;
L12:GoZaslonka(0, 0, 0, 1, 0);			// заслонка в исходное
	goto L101;
L13:NAP_KAM();							// напуск в камеру
    goto L101;
L14:if(zin[1] & 0x10) goto L101;		// крышка внизу
	SetOut(0,1,0xC000);					// закрыть Кл-НАП
    N_ST = 0;
	shr[4] = 16;						// ВЫХОД!!!
	sh_ = 0;
	goto L101;
L15:ORR_GIS();                          //снять разр раб ВЧМ
    if(sh_) goto L101;
    if(!PR_RC)							// не был активирован РЦ
	{
		shr[4] = 15;
		sh_ = 0;
		goto L101;
	}
    shr[4] = 4;                        // переход на 5 шаг
	sh_ = 0;
	goto L101;
L16:VIDK_BM(010004,04000,0,0,020);		// выкл. БПМ
	goto L101;
}
//------------------------------------------------------------------------------
void R_5 ()			// Режим "Отключение установки"
{
	sh_ = sh[5];

	if (shr[5] == 1) goto L1;
	if (shr[5] == 2) goto L2;
	if (shr[5] == 3) goto L3;
	if (shr[5] == 4) goto L4;
	if (shr[5] == 5) goto L5;
	if (shr[5] == 6) goto L6;
	if (shr[5] == 7) goto L7;
	if (shr[5] == 8) goto L8;
	if (shr[5] == 9) goto L9;
    if (shr[5] == 10) goto L10;
	else goto L100;				// выход
	// конечный диспетчер режима
	
L101:sh[5] = sh_;
	if (sh[5] != 0) goto L100;		// SH != 0
	++shr[5];				// след. шаг сч.шр5
	if (shr[5] > 10) goto L0;		// число шагов режима
	sh[5] = 1;
L100:return;					// возврат в "кольцо"

L0:	norma = 7;				// норма: "Отключение установки завершено"
	shr[5] = 0;
	goto L100;

L1: shr[1] = 0;					// сброс активизации режима R_1
	sh[1] = 0;				// "Откачка камеры"
	SetOut(0,1,0xC0E0);			// закрыть Кл1, Кл2, Кл3, Кл-НАП, Кл5
	SetOut(0,1,0x500);			// снять внешнее упр. БПМ и БПИИ
	SetOut(0,1,0x04);			// отключить питание БПН
	SetOut(1,1,0x08);
	shr[38] = 1;				// активизация режима R_38
	sh[38] = 1;				// закрыть ДЗ
	sh_ = 0;
	goto L101;
L2:	if(shr[38]) goto L101;			// ожидание выхода на режим
	sh_ = 0;
	goto L101;
L3:	Klapan(0,&KlKam);			// закрыть ФК-Кам
    goto L101;
L4:	SetOut(0,2,0x01);				// стоп КН
    sh_ = 0;
	goto L101;
L5:	Klapan(0,&KlKn);			// закрыть ФК-КН
	goto L101;
L6:	Klapan(0,&Fvn);				// откл. форнасос
    if(sh_) goto L101;
    SetOut(1,1,0x2000);         //откр Кл4
    sh_ = 0;
	goto L101;
L7:	OBPN();					// откл. БПН
	if(sh_) goto L101;
	if(nasmod[10])				// есть рр БПМ
	{
		sh_ = 0;
		goto L101;
	}
	sh_ = 1;
	shr[5] = 8;
	goto L8_1;				// переход на шаг 9_1
L8:	VIDK_BM(010004,04000,0,0,020);		// выкл. БПМ
	if(sh_) goto L101;
L8_1:if(nasmod[9])				// есть рр БПИИ
	{
		sh_ = 0;
		goto L101;
	}
	shr[5] = 9;
	sh_ = 0;
	goto L101;
L9:VIDK_II(010000,04000,0,2,020); 		// выкл. БПИИ
	goto L101;
L10:ORR_GIS();                          //снять разр раб ВЧМ
    goto L101;
}
//------------------------------------------------------------------------------
void R_7()                            // Режим "Отпыл М1"
  {
	sh_ = sh[7];
	if (shr[7] == 1) goto L1;
	if (shr[7] == 2) goto L2;
	if (shr[7] == 3) goto L3;
	if (shr[7] == 4) goto L4;
	if (shr[7] == 5) goto L5;
	if (shr[7] == 6) goto L6;
	if (shr[7] == 7) goto L7;
	if (shr[7] == 8) goto L8;
	if (shr[7] == 9) goto L9;
	else goto L100;	//Выход

		// Конечный диспетчер режима
   L101:sh[7] = sh_;
	if(sh[7] != 0) goto L100;           // SH != 0
	++shr[7];                           // След. шаг
	if(shr[7] > 9) goto L0;             // Число шагов режима
	sh[7] = 1;
   L100:return;		                    // Возврат в "кольцо"

L0:norma = 23;                              // "Отпыл M1 завершен"
   shr[7] = 0;                              // Конец режима
   goto L100;
	
L1: VKBPM1();                       // вкл. пускатель М1
    if(sh_!=0) goto L101;           // ожидание завершения
    VRBM = 0;                       // сброс признака выхода на режим БПМ
    diagn[0] &= (~0xFF);            // сброс диагностики режима БПМ
    goto L101;
// Проверка включения и включение подсистем БПМ1
L2: if (PR_SV_BM == 0) goto L101;   // Нет готовности связи БПМ1
    if((OTVET_BM[8]&04000) != 0)    // Блок включен
    {
        shr[7] = 4;
        goto L4_1;                  // Переход на L4_1
    }
    sh_ = 0;
    goto L101;
L3: VIDK_BM(014004,04000,1,0,010);  // Вкл. блок БПМ
    if (sh_!=0) goto L101;
    CT_7 = 0;                       // сброс счетчика времени режима
    goto L101;
L4: if ( CT_7 <= 2 ) goto L101;     // задержка 2 сек на включение Uвых
              // Расчет и выдача первичной уставки
L4_1:UST_BM = 91;                   // 80Вт - начальная уставка
    PAR_BM1 = UST_BM;
    SetOut(0,1,0x200);        		// снятие блокировки Uвых БПМ
    sh_ = 0;
    goto L101;
L5: VIDK_BM (04004,010000,0,0,040);  //Вкл. Uвых. БПМ
    goto L101;
		 // Расчет новой уставки
L6:	UST_BM += nasmod[4];             // Уставка БПМ=УСТ.+Приращение
    if(UST_BM > par[N_ST][8])           // MAX уставки достигнут
    UST_BM = par[N_ST][8];              // УСТ.= MAX заданию
    PAR_BM1 = UST_BM;
    sh_ = 0;
    goto L101;
L7:	VIDK_BM(04004,010000,0,0,040);   //Вкл. Uвых. БПМ1
    if(sh_ != 0) goto L101;
    CT_7 = 0;
    goto L101;                      // Сброс сч.времени режима
L8:if(CT_7 <= T_KUSTBM) goto L101;  // Время выдачи уставки не вышло (5сек.)
    if(UST_BM != par[N_ST][8])          // MAX уставка не достигнута
     {shr[7] = 5;
      sh_ = 0;
      goto L101;}                   // Возврат на L6
    shr[29] = 1;                    // Активизация режима
    sh[29] = 1;                     // БПМ1
    sh_ = 0;
    goto L101;
L9:if(VRBM == 0) goto L101;         // Нет выхода на режим БПМ
    sh_ = 0;
    goto L101;
}
//------------------------------------------------------------------------------
void R_8()                             // Режим "Отпыл М2"
  {
	sh_ = sh[8];
	if (shr[8] == 1) goto L1;
        if (shr[8] == 2) goto L2;
	if (shr[8] == 3) goto L3;
	if (shr[8] == 4) goto L4;
	if (shr[8] == 5) goto L5;
	if (shr[8] == 6) goto L6;
	if (shr[8] == 7) goto L7;
	if (shr[8] == 8) goto L8;
	if (shr[8] == 9) goto L9;
	else goto L100;	//Выход

		// Конечный диспетчер режима
   L101:sh[8] = sh_;
	if(sh[8] != 0) goto L100;           // SH != 0
	++shr[8];                           // След. шаг
	if(shr[8] > 9) goto L0;             // Число шагов режима
	sh[8] = 1;
   L100:return;		                    // Возврат в "кольцо"

L0:norma = 24;                              // "Отпыл БПМ завершен"
   shr[8] = 0;                              // Конец режима
   goto L100;

L1: VKBPM2();                       // вкл. пускатель М2
    if(sh_!=0) goto L101;           // ожидание завершения
    VRBM = 0;                       // сброс признака выхода на режим БПМ
    diagn[0] &= (~0xFF);            // сброс диагностики режима БПМ
    goto L101;
// Проверка включения и включение подсистем БПМ
L2: if (PR_SV_BM == 0) goto L101;   // Нет готовности связи БПМ
    if((OTVET_BM[8]&04000) != 0)    // Блок включен
    {
        shr[8] = 4;
        goto L4_1;                  // Переход на L4_1
    }
    sh_ = 0;
    goto L101;
L3: VIDK_BM(014004,04000,1,0,010);  // Вкл. блок БПМ
    if ( sh_ != 0 ) goto L101;
    CT_8 = 0;                       // сброс счетчика времени режима
    goto L101;
L4: if ( CT_8 <= 2 ) goto L101;     // задержка 2 сек на включение Uвых
              // Расчет и выдача первичной уставки
L4_1:UST_BM = 91;                   // 80Вт - начальная уставка
    PAR_BM2 = UST_BM;
    SetOut(0,1,0x200);        		// снятие блокировки Uвых БПМ
    sh_ = 0;
    goto L101;
L5: VIDK_BM(04004,010000,0,0,040);  //Вкл. Uвых. БПМ
    goto L101;
		 // Расчет новой уставки
L6:UST_BM += nasmod[6];             // Уставка БПМ=УСТ.+Приращение
    if(UST_BM > par[N_ST][9])          // MAX уставки достигнут
     UST_BM = par[N_ST][9];            // УСТ.= MAX заданию
    PAR_BM2 = UST_BM;
    sh_ = 0;
    goto L101;
L7:VIDK_BM(04004,010000,0,0,040);   //Вкл. Uвых. БПМ1
    if(sh_ != 0) goto L101;
    CT_8 = 0;
    goto L101;                      // Сброс сч.времени режима
L8:if(CT_8 <= T_KUSTBM) goto L101;  // Время выдачи уставки не вышло (5сек.)
    if(UST_BM != par[N_ST][9])         // MAX уставка не достигнута
     {shr[8] = 5;
      sh_ = 0;
      goto L101;}                   // Возврат на L6
    shr[30] = 1;                    // Активизация режима
    sh[30] = 1;                     // БПМ2
    sh_ = 0;
    goto L101;
L9:if(VRBM == 0) goto L101;         // Нет выхода на режим БПМ
    sh_ = 0;
    goto L101;
}
//------------------------------------------------------------------------------
void R_9()		// Режим "Аварийное отключение"
{
	sh_ = sh[9];
	if (shr[9] == 1) goto L1;
	if (shr[9] == 2) goto L2;
	if (shr[9] == 3) goto L3;
	if (shr[9] == 4) goto L4;
	if (shr[9] == 5) goto L5;
	if (shr[9] == 6) goto L6;
	else goto L100;	//Выход

		// Конечный диспетчер режима
L101:sh[9] = sh_;
	if(sh[9] != 0) goto L100;			// SH != 0
	++shr[9];					// След. шаг
	if(shr[9] > 6) goto L0;				// Число шагов режима
	sh[9] = 1;
L100:return;						// Возврат в "кольцо"

L0:	norma = 33;					// "Аварийное откл. устан. завершено"
	shr[9] = 0;					// Конец режима
	goto L100;

L1: shr[38] = 1;                //закрыть ДЗ в HOME
    sh[38] = 1;
    if(shr[4] != 0)					// "Сброс РЦ" уже запущен
	{
		shr[9] = 4;				// переход на L5
		sh_ = 0;
		goto L101;
	}
	if(shr[2] || shr[3])				// есть активизации
	{
	shr[4] = 1;					// запустить режим "Сброс РЦ"
	sh[4] = 1;
    shr[9] = 4;
    sh_ = 0;
    goto L101;
	}
    SBROSR_34();                //Сброс ВЧМ
    if(shr[7]||shr[29]||shr[8]||shr[30])	// запущен хотя бы один
	{
		shr[31] = 1;					// активизация режима сброс БПМ
		sh[31] = 1;
		sh_ = 0;
		goto L101;
	}
	shr[9] = 2;					// переход
	goto L2_1;
L2:	if(shr[31] != 0) goto L101;			// ожидание звершения
L2_1:if(shr[32] == 0)					// есть активизация ИИ
	{
		shr[9] = 3;
		goto L3_1;
	}
	shr[33] = 1;						// активизация режима "Сброс ИИ"
	sh[33] = 1;
	sh_ = 0;
	goto L101;
L3:	if(shr[33] != 0) goto L101;			// ожидание окончания режима
L3_1:if(shr[27] == 0)					// запущен режим нагрева
	{
		shr[9] = 4;
		goto L4_1;
	}
	shr[36] = 1;						// активизация режима "Откл. Нагрев ручн."
	sh[36] = 1;
	sh_ = 0;
	goto L101;
L4:	if(shr[36] != 0) goto L101;			// ожидание конца режима
L4_1:RRGOff(ObjRRG[0]);					// отключение РРГ1
	RRGOff(ObjRRG[1]);					// отключение РРГ2
	SBROSR_23();						// отключение УУН
	SBROS_MEH();						// сброс механизмов
	shr[9] = 5;
	goto L5_1;
L5:	if(shr[4] != 0) goto L101;			// режим "Сброс РЦ" закончен
L5_1:if(shr[5] == 0)					// нет активизации "Сброс устан."
	{
		shr[5] = 1;						// активизировать режима "Сброс устан."
		sh[5] = 1;
	}
	sh_ = 0;
	goto L101;
L6:	if(shr[5] != 0) goto L101;			// ожидание конца режима
	sh_ = 0;
	goto L101;
}
//------------------------------------------------------------------------------
void R_10()                             // Режим "Отпыл М3"
  { /*
	sh_ = sh[10];
	if (shr[10] == 1) goto L1;
    if (shr[10] == 2) goto L2;
	if (shr[10] == 3) goto L3;
	if (shr[10] == 4) goto L4;
	if (shr[10] == 5) goto L5;
	if (shr[10] == 6) goto L6;
	if (shr[10] == 7) goto L7;
	if (shr[10] == 8) goto L8;
	if (shr[10] == 9) goto L9;
	else goto L100;	//Выход

		// Конечный диспетчер режима
   L101:sh[10] = sh_;
	if(sh[10] != 0) goto L100;	// SH != 0
	++shr[10];			// След. шаг
	if(shr[10] > 9) goto L0;	// Число шагов режима
	sh[10] = 1;
   L100:return;				// Возврат в "кольцо"

L0:norma = 20;				// "Отпыл БПМ завершен"
   shr[10] = 0;				// Конец режима
   goto L100;

L1: VKBPM3();                       	// вкл. пускатель М3
    if(sh_!=0) goto L101;           	// ожидание завершения
    VRBM = 0;                       	// сброс признака выхода на режим БПМ
    diagn[0] &= (~0xFF);            	// сброс диагностики режима БПМ
    goto L101;
// Проверка включения и включение подсистем БПМ
L2: if (PR_SV_BM == 0) goto L101;   	// Нет готовности связи БПМ
    if((OTVET_BM[8]&04000) != 0)    	// Блок включен
    {
        shr[10] = 4;
        goto L4_1;                  	// Переход на L4_1
    }
    sh_ = 0;
    goto L101;
L3: VIDK_BM(014004,04000,1,0,010);  	// Вкл. блок БПМ
    if ( sh_ != 0 ) goto L101;
    CT_10 = 0;                       	// сброс счетчика времени режима
    goto L101;
L4: if ( CT_10 <= 2 ) goto L101;     	// задержка 2 сек на включение Uвых
// Расчет и выдача первичной уставки
L4_1:UST_BM = 91;                   	// 80Вт - начальная уставка
    PAR_BM3 = UST_BM;
    SetOut(0,1,0x200);        			// снятие блокировки Uвых БПМ
    sh_ = 0;
    goto L101;
L5:VIDK_BM (04004,010000,0,0,040);  	//Вкл. Uвых. БПМ
    goto L101;
// Расчет новой уставки
L6:UST_BM += nasmod[28];             	// Уставка БПМ=УСТ.+Приращение
    if(UST_BM > par[N_ST][18])          	// MAX уставки достигнут
     UST_BM = par[N_ST][18];            	// УСТ.= MAX заданию
    PAR_BM3 = UST_BM;
    sh_ = 0;
    goto L101;
L7:VIDK_BM(04004,010000,0,0,040);   	//Вкл. Uвых. БПМ1
    if(sh_ != 0) goto L101;
    CT_10 = 0;
    goto L101;                      	// Сброс сч.времени режима
L8:if(CT_10 <= T_KUSTBM) goto L101;  	// Время выдачи уставки не вышло (5сек.)
    if(UST_BM != par[N_ST][18])         	// MAX уставка не достигнута
     {shr[10] = 5;
      sh_ = 0;
      goto L101;}                   	// Возврат на L6
    shr[34] = 1;                    	// Активизация режима
    sh[34] = 1;                     	// БПМ2
    sh_ = 0;
    goto L101;
L9:if(VRBM == 0) goto L101;         	// Нет выхода на режим БПМ
    sh_ = 0;
    goto L101;
    */
}
//------------------------------------------------------------------------------
void R_20()			// РЕЖИМ 20 "Включить РРГ1"
{
	// выставление параметра РРГ
	ObjRRG[0]->parRRG = par[N_ST][0];
	// запуск режима
	RRGOn(ObjRRG[0],PR_Ar);		// включение РРГ1
}
//---------------------------------------------------------------------------
void R_21()			// РЕЖИМ 21 "Включить РРГ2"
{
	// выставление параметра РРГ
	ObjRRG[1]->parRRG = par[N_ST][1];
	// запуск режима
	RRGOn(ObjRRG[1],1);		// включение РРГ2
}
//---------------------------------------------------------------------------
void R_23 ()			         // режим  "УУН"
{			                 // индекс устройства UN
	sh_ = sh[23];
	if (shr[23] == 1) goto L1;
	if (shr[23] == 2) goto L2;
	if (shr[23] == 3) goto L3;
    else goto L100;                      // на выход

					//    | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[23] = sh_;		        //    |                           |
     if (sh[23] != 0) goto L100;	//    |    SH != 0                |
     shr[23]++;				//    |    след.шаг сч.шр 23      |
     sh[23] = 1;			//    |                           |
L100:return;				//    |    возврат в "кольцо"     |

L1: VRUN = 0;		                 // сброс признака выхода на режим УУН
    A_OUT(4,8192);		         	// обнуление уставки
    diagn[8] &= (~0x07);	         // сброс диагностик режима УУН (РРГ1)
    SetOut(1,1,0x20);     			//открыть клапан Кл1
    CT_23 = 0;				// обнуление сч.вр.режима УУН
    sh_ = 0;
    goto L101;
L2: if(CT_23 <= 3) goto L101;		//задержка 3сек на откачку магистрали РРГ1
    CT_23 = 0;				// обнуление сч.вр.режима УУН
    sh_ = 0;
    goto L101;
L3: RABUN();					// работа УУН
    goto L101;
}
//----------------------------------------------------------------------------
void RABUN ()			         // подпрограмма "Работа УУН"
{
    long T1;
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else goto A100;	                // на выход
	// расчет приращений LIMU при пробое
A1: PORCPR_UN = LIMUUN / T_VPRB_UN;	// расчет порции
	LIMUPR_UN = LIMUUN % T_VPRB_UN;	// остаток-нач.ограничение
				 // по уставке при пробое
	// расчет приращений LIMU при выходе на режим
	PORCNV_UN = LIMUUN / T_VREJ_UN;	// расчет порции
	LIMU_UN = LIMUUN % T_VREJ_UN;	// остаток-нач.ограничение по
					// уставке при выходе на реж.
	CT_VRUN = 0;		        // обнуление счетчика выхода на режим
	E_PUN = 0;		        // обнуление предыдущей ошибки,
	SOUN = 0;		        // сумматора остатков,
	U_PUN = 0;		        // предыдущей уставки,
	VRUN = 0;		        // признака выхода на режим УУН
	PROBUN = 0;		        // признак отработки пробоя
	sh_ = 2;
	// выход на режим УУН
A2: VIBPAR_UN();		        	// выбор параметра УУН
	REQUN();	        			// регулятор УУН
	if (CT_VRUN == 0) goto A100;    // пров. CT.VR на ноль (время не вышло)
	T1 = CT_VRUN; T1 *= PORCNV_UN;
	if (T1 > LIMUUN) goto S1;       // MAX достигнут
	LIMU_UN = T1;		        	// выдача текущего LIMU
A100:return;			        	// выход
S1: LIMU_UN = LIMUUN;	            // выдача MAX LIMU
	CT23K1 = 0;		        		// сброс счетчика к.времени опред.ошибки
	CT_23 = 0;		        		// и выхода на режим
	sh_ = 3;
	// анализ выхода на режим УУН
A3: UN_G();		                	// регулятор УУН с отработкой пробоя
	if (DELUN < LIM2UN) goto S2;    // Тош < LIM
	CT23K1 = 0;
	if (CT_23 > T_VRUN)	        	// время выхода на режим вышло
	diagn[8] |= 0x01;               // отказ: "нет выхода на режим УУН"
	goto S3;
S2: if (CT23K1 <= T_KUN) goto S4;	// Т.K.тек <= Т.K.зад
	diagn[8] &= (~0x01);	        // сброс д."нет выхода на режим УУН"
	VRUN = 1;		        		// признак выхода на режим УУН
	goto S3;
S4: VRUN = 0;	                    // сброс признака выхода на режим УУН
S3: if (VRUN == 0) goto S5;	        // нет выхода на режим УУН
	CT_23 = 0;	        			// сброс счетчика режима УУН
	sh_ = 4;
	goto A100;
S5: diagn[8] &= (~0x06);	        // сброс д."нет рег.УУН" и "б.ош.рег.УУН"
	goto A100;
A4: UN_G();		                	// регулятор УУН с отработкой пробоя
	goto A100;
}
//----------------------------------------------------------------------------
void UN_G ()		             // подпрограмма "рег.УУН с отработкой пробоя"
{
    long T1;
	// определение пробоя УУН
    //  if ((ZIN2 & 01400) != 0) goto S3;// пробой: перегрузка или дуга
	if (PROBUN == 0		                 // нет отработки пробоя
			|| CT_PR_UN == 0) goto S2;
	// расчет и выдача текущей LIMU_UN
	T1 = CT_PR_UN; T1 *= PORCPR_UN;
	if (T1 > LIMUUN) goto S1;    	// MAX достигнут
	LIMU_UN = T1;	             	// выдача текущей LIMU
	goto S2;
S1: LIMU_UN = LIMUUN;				// выдача MAX LIMU
	PROBUN = 0;	             		// сброс признака отработки пробоя
	goto S2;
	// начальная отработка пробоя
S3: PROBUN = 1;		             	// признак отработки пробоя УУН
	LIMU_UN = LIMUPR_UN;         	// выдать начальное ограничение
	CT_PR_UN = 0;		     		// сброс сч.пробоя
S2: UN_D();
}
//----------------------------------------------------------------------------
void UN_D ()		             // подпрограмма "рег.УУН с диагностикой"
{
	VIBPAR_UN();		     		// выбор параметра УУН
	REQUN();		     			// регулятор УУН
	RLIMUN();	             		// расчет LIM1,LIM2 для УУН
	if (DELUN <= LIM1UN) goto S1;	// модуль Ет <= LIM1
	diagn[8] |= 0x04;	     		// отказ: "нет регулирования УУН"
	goto S2;
S1: diagn[8] &= (~0x04);	     	// сброс д."нет регулирования УУН"
	if (DELUN <= LIM2UN) goto S2;	// LIM2 (зона регулирования)
	diagn[8] |= 0x02;	     		// отказ: "большая ошибка рег.УУН"
	goto A100;
S2: diagn[8] &= (~0x02);     	    // сброс д."большая ошибка рег.УУН"
A100:return;
}
//----------------------------------------------------------------------------
void RLIMUN ()		             // подпрограмма "Расчет LIM для УУН"
{
	if (PAR_UN == 0)	     	// если задание = 0, расшир.лимитов
    {
       LIM1UN = 7000;			// MAX доп.знач.по входу ап.ср.
	   LIM2UN = LIM1UN / 5;		// LIM2 = 0,2 LIM1 (для датчика 979)
    }
    else
    {
	LIM2UN = PAR_UN / DOPUN;	// LIM2 (малый)
	    LIM1UN = PAR_UN / 5;    // LIM1 (большой) - 20% (для датчика 979)
    }
}
//----------------------------------------------------------------------------
void REQUN ()			         // подпрограмма "Регулятор УУН"
{
    long T1,PPSUN,PISUN;
	int PSUN,ISUN,INVSOUN;

	if (CT_REQUN <= T_REQUN) return;// ограничение регулятора УУН
	CT_REQUN=0;			            // по быстродействию
	PDUN();               		 	// подготовка аналоговых данных УУН
	VBKUN();			         	// выбор коэф-тов регулятора УУН
	// расчет пропорциональной составляющей регулятора
	T1 = K_PUN;			         	// расширение коэф-та до типа LONG
	PPSUN = T1 * (E_TUN - E_PUN);	// полная Р-сост.=Кр * (Етек - Епред)
	PSUN = PPSUN / 100;	         	// P-составляющая регулятора со смещением
	// проверка Р-составляющей на лимит
	if (PSUN < 0) goto S1;	     	// если "-"
	if (PSUN > LIMPUN) PSUN = LIMPUN; // если > LIM
	goto S0;
S1: if ((PSUN + LIMPUN) > 0) goto S0;
	PSUN = LIMPUN * (-1);		 // если < (-LIM)
	// расчет интегральной составляющей регулятора
S0: T1 = K_IUN;			         // расширение коэф-та до типа LONG
	PISUN = T1 * E_TUN;		     // полная I-сост.= Ки * Етек
	ISUN = PISUN / 100;	         // I-составляющая регулятора со смещением
	{ // суммирование остатков
	SOUN += PISUN % 100;	 		// прибав.остатка деления к сумматору
	    if (SOUN < 0) goto S1_1; 	// сумматор меньше нуля
	    if (SOUN < LOUN) goto S1_3; // сравнение с лимитом остатков
	    ISUN = ISUN + 1;		 	// увеличение I-сост.на (...)
	    goto S1_2;
S1_1:   INVSOUN = SOUN * (-1);	 	// изменение знака сумматора остатков
	    if (INVSOUN < LOUN) goto S1_3;
	    ISUN = ISUN - 1;		 	// уменьшение I-сост.на (...)
S1_2:   SOUN = 0;			     	// обнуление сумматора
	}
	// проверка I-составляющей на лимит
S1_3:if (ISUN < 0) goto S2;		 	// если "-"
	if (ISUN > LIMIUN) ISUN = LIMIUN; // если > LIM
	goto S3;
S2: if ((ISUN + LIMIUN) > 0) goto S3;
	ISUN = LIMIUN * (-1);		 	// если < (-LIM)
S3: U_PUN += (PSUN + ISUN);	     	// уставка = Uпред + (P-сост + I-сост)
	// ограничение по уставке
	if (U_PUN < 0) goto S4;	     	// < 0
	if (U_PUN > LIMU_UN) U_PUN = LIMU_UN; // LIMU_UN - переменный
	goto S5;
S4: U_PUN = 0;
S5: E_PUN = E_TUN;		      		// запоминание ошибки
	A_VIH = U_PUN+8192;	  			// выдача уставки (уст+8192+4095(5в))
	A_OUT (4,A_VIH);	    		// со смещением для платы DA8
}
//----------------------------------------------------------------------------
void PDUN ()			         // подготовка аналоговых данных УУН
{
	X_TUN = D_D1;		         	// тек.значение давления
	E_TUN = PAR_UN - X_TUN;	     	// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TUN >= 0) DELUN = E_TUN;
	else  DELUN = E_TUN * (-1);	 	// вычисление модуля ошибки
}
//----------------------------------------------------------------------------
void VBKUN ()			         // выбор коэф-тов регулятора УУН
{
    int i;
    for (i = 0; i <= 8; i++)
	   if (DELUN > MZRUN[i]) {} else break;	// опред.зоны регулирования
	K_PUN = MKPUN[i]; K_IUN = MKIUN[i];		// коэф-ты для P- и I- сост.
}
//----------------------------------------------------------------------------
void VIBPAR_UN ()		         // подпрограмма "Выбор параметра УУН"
{
    if(PR_DAVL_PODJ)
    {
        PAR_UN = par[N_ST][15];
    }
    else
    {
        PAR_UN = par[N_ST][2];
    }

}
//------------------------------------------------------------------------------
void SBROSR_23()                         // "Сброс режима 23 <УУН> (РРГ1)"
{
   shr[23] = 0;                          // сброс активизации режима "УУН"
   sh[23] = 0;
   diagn[8] &= (~0x07);                  // сброс диагностик
   SetOut(0,1,0x20);                   // закрыть клапан УУН (Кл1 РРГ1)
   A_OUT(4,8192);                        // сброс уставки
   PAR_UN = 0;                           // сброс параметра
   norma = 22;                           // норма: "Сброс УУН завершен"
}
 //------------------------------------------------------------------------------
 //---------------------------------------------------------------------------
//--Режим "Вкл. нагрева"--//
//---------------------------------------------------------------------------
void R_27 ()	             		// режим "Вкл. нагрева"
{
	sh_ = sh[27];
	if (shr[27] == 1) goto L1;
	if (shr[27] == 2) goto L2;
	if (shr[27] == 3) goto L3;
	if (shr[27] == 4) goto L4;
	if (shr[27] == 5) goto L5;
	if (shr[27] == 6) goto L6;
	else goto L100;        			// на выход

									// | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[27] = sh_;	   				// |                           |
	if (sh[27] != 0) goto L100;	  	// |    SH != 0                |
	shr[27]++;		        		// |    след.шаг 	           |
	sh[27] = 1;		        		// |			               |
L100:return;			     		// |    возврат в "кольцо"	   |

L1:	SetOut(0,1,0x0C);		   		// сброс вых.сигналов на вкл/выкл
									// силового питания БПН
    SetOut(1,1,0x04);				// Вкл. пускатель нагревателя
	shr[28] = 0;                    // режима 28
	sh[28] = 0;                     // 'Откл. нагрева'
	VRTEMP = 0;               		// сброс признака выхода на режим БПН
	diagn[1] &= (~0xFF);      		// сброс диагностики режима БПН
	CT_27 = 0;						// сброс сч.времени режима
	sh_ = 0;                         // и ответов от БПН
	goto L101;
L2:	if (CT_27<=T_VKL_BPN) goto L101;// задержка на откл. реле и пускателя
	sh_ = 0;
	goto L101;
L3:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		SetOut(1,1,0x04);			// вкл. силовое питание БПН
		CT_27 = 0;              	// сброс сч.времени режима
		sh_ = 0;
		goto L101;					// переход на L4
	}
	shr[27] = 4;
	goto L4_1;
L4:	if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
	{
		if (CT_27<=T_VKL_BPN) goto L101;
		diagn[1]|=0x08;				// отказ:"Силовое питание БПН не вкл."
		goto L101;
	}
L4_1:	SetOut(0,1,0x0C);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
	diagn[1]&=(~0x08);	       		// сброс диагностики
	sh_ = 0;
	goto L101;
L5:	VIBPAR_TEMP();		     		// выбор параметра БПН
	VIDK_TEMP (1,1,020,1); 		// выдать задание по температуре
	if(sh_) goto L101;            //
	ZPAR_TEMP = PAR_TEMP;			// запоминание параметра задания температуры
	CT_27 = 0;	           			// сброс
	CT27K1 = 0;	             		// счетчиков
	goto L101;
	// выход на режим и диагностика
L6: VIBPAR_TEMP();		     		// выбор параметра БПН
	if ( PAR_TEMP == ZPAR_TEMP )   	// параметр не изменился
	{  	sh_ = 0;	goto L6_8; } 		// обход задания
	VIDK_TEMP (1,1,020,1); 	 	// выдать задание по температуре
	if(sh_!=0) goto L101;            //
	ZPAR_TEMP = PAR_TEMP; 			// зап.парам.задания температуры
L6_8:	PDTEMP ();                 	// Подготовка аналоговых данных
	RLIMTEMP();	        			// расчет LIM для БПН
	if (DELTEMP<=LIM1TEMP)goto L6_4;// модуль Ет <= LIM1
	if (VRTEMP == 0) goto L6_6;		// нет выхода на режим
	diagn[1] |= 0x04;		        // отказ: "нет регулирования БПН"
	goto L6_5;	            		// на сброс диагн."больш.ош."
L6_4:diagn[1] &= (~0x04);	   		// сброс д."нет регулирования БПН"
	if (DELTEMP<=LIM2TEMP)goto L6_5;// LIM2 (зона регулирования)
	if (VRTEMP == 0) goto L6_6;		// нет выхода на режим
	diagn[1] |= 0x02;		       	// отказ: "б.ош.регулирования БПН"
	goto L6_7;
L6_5:diagn[1] &= (~0x02);	   		// сброс д."б.ош.регулирования БПН"
	goto L6_7;
L6_6:CT27K1 = 0;
L6_7:if (CT_27<=T_VRTEMP) goto L6_2;// Ттек <= Тзад
	if (VRTEMP != 0) goto L6_1;     // есть выход на режим
	diagn[1] |= 0x01;		        // отказ: "нет выхода на режим БПН"
	goto L6_2;
L6_1:diagn[1] &= (~0x01);	       	// сброс д."нет выхода на режим БПН"
L6_2:if (CT27K1<=T_KTEMP) goto L6_3;// Т.K.тек <= Т.K.зад
	VRTEMP = 1;	               		// выход на режим
L6_3:shr[27]=5;                 		// Возврат на L6
	goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_TEMP ()			      // подпрограмма "Выбор параметра для БПН"
{
	PAR_TEMP = par[N_ST][12];            // Ручн.
}
//---------------------------------------------------------------------------
void RLIMTEMP ()				   	// подпрограмма "Расчет LIM для БПН"
{
	if (PAR_TEMP == 0)	        	// если задание = 0, расшир.лимитов
	{
		LIM1TEMP = 3500;	      	// MAX доп.знач.по входу ап.ср. (350°)
		LIM2TEMP = LIM1TEMP / 2;  	// LIM2 = 0,5 LIM1
	}
	else
	{
		LIM2TEMP = PAR_TEMP / DOPTEMP;	// LIM2 (малый)
		LIM1TEMP = PAR_TEMP / 2;    	// LIM1 (большой)
	}
}
//---------------------------------------------------------------------------
void PDTEMP ()						// подготовка аналоговых данных БПН
{
	X_TEMP = TEK_TEMP;	           	// тек.значение температуры
	E_TEMP = PAR_TEMP - X_TEMP;		// Хзад - Хтек = Етек (тек.ошибка)
	if (E_TEMP >= 0) DELTEMP = E_TEMP;
	else  DELTEMP = E_TEMP * (-1);	// вычисление модуля ошибки
}
//------------------------------------------//
//--Подпрограмма выдачи команд на ТЕРМОДАТ--//
//------------------------------------------//
void VIDK_TEMP ( int a, int b, int c, int d )
// a - код команды к ТЕРМОДАТУ
// b - номер байта массива диагностики
// c - номер бита массива диагностики
// d - признак задания температуры
{
	switch ( sh_ )
	{
		case 1:
		{
			if ( ( diagnS[1] & 0x04 ) == 0 ) 	// нет диагностики "нет связи с ТЕРМОДАТОМ"
			{
				PR_TEMP = 0;					// обнуление признака положительного ответа GEN
				KOM_TEMP = a;					// выдача заданной команды
				if ( KOM_TEMP != 2 )          	// НЕ опрос температуры
				{
					if ( d==0 )	ZAD_TEMP = 0;	// анализ признака задания температуры
					else
					{
						VIBPAR_TEMP();			// выбор параметра температуры
						ZAD_TEMP = PAR_TEMP;	// запись задания
					}
				}
				CT_TEMP = 0;                     // сброс сч. времени
				sh_ = 2;							// переход на второй шаг
			}
		}; break;
		case 2:
		{
			// если есть диагностика "нет связи с ТЕРМОДАТОМ" или нет пр.полож.ответа
			if ( ( ( diagnS[1] & 0x04 ) == 0x04 ) || ( PR_TEMP == 0 ) )
			{
				if ( CT_TEMP > 5 ) 				// время ожидания вышло
					diagn[b] |= c;              // отказ: "..."
			}
			// есть связь и признак положительного ответа
			else
			{
				diagn[b] &= (~c);				// сброс диагностики
				KOM_TEMP = 2;					// запись кода опроса температры
				sh_ = 0;
			}
		}; break;
		default: sh_ = 0; break;
	}
}
// Команды на ТЕРМОДАТ
//            КК    диагн
// VIDK_TEMP ( 1 , 1 , 020  , 1 )  - Вкл. нагрев ( задание не равно 0 )
// VIDK_TEMP ( 1 , 1 , 040  , 0 )  - Выкл. нагрев ( задание равно 0 )
// VIDK_TEMP ( 2 , 1 , 0100 , X )  - Опрос температуры
//---------------------------------------------------------------------------
void R_28() // режим 28 "Откл. БПН"
{
	sh_ = sh[28];

L00:if (shr[28] == 1)  goto L1;        
      if (shr[28] == 2) goto L2;
	else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101: sh[28] = sh_;
	if (sh[28] != 0) goto L100;   // SH != 0
	shr[28]++;                    // след.шаг сч.шр1
	if (shr[28] > 2) goto L0;    	// число шагов режима
	sh[28] = 1;
L100: return;                  	// возврат в "кольцо"

L0: shr[28] = 0;
	goto L100;

//--Проверка начальных условий--//
L1: sh[27]  = 0;                  // режима 27
	shr[27] = 0;                  // "Вкл. БПН"
	diagn[1] &= (~0xFF);		// сброс диагностик БПН и контроля ответов БПН
	sh_ = 0;
	goto L101;
L2: VIDK_TEMP(1,1,040,0);		// выкл. БПН 0 температуры
	goto L101;
}
//------------------------------------------------------------------------------
void R_29 ()	                    // режим "БПМ1"
{
	sh_ = sh[29];
	if (shr[29] == 1) goto L1;
	if (shr[29] == 2) goto L2;
	if (shr[29] == 3) goto L3;
	if (shr[29] == 4) goto L4;
	if (shr[29] == 5) goto L5;
	if (shr[29] == 6) goto L6;
    else goto L100;              // на выход

                                    // | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[29] = sh_;	   	            // |                           |
    if (sh[29] != 0) goto L100;       // |    SH != 0                |
    shr[29]++;		            // |    след.шаг 	           |
    sh[29] = 1;		            // |			   |
L100:return;			    // |    возврат в "кольцо"	   |

L1: PR_SOPR_BM = 0;
    VRBM = 0;                       // сброс признака выхода на режим БПМ
    //SetOut(1,0,0x04);               // подключить свидетель
    diagn[0] &= (~0xFF);            // сброс диагностик режима БПМ
// Проверка включения и включение подсистем БПМ
    if (PR_SV_BM == 0) goto L101;   // Нет готовности связи БПМ
    if((OTVET_BM[8]&04000) != 0)    // Блок включен
    {
        shr[29] = 3;
        sh_ = 0;
        goto L101;                  // Переход на L4
    }
    sh_ = 0;
    goto L101;
L2: VIDK_BM(014004,04000,1,0,010);  // Вкл. блок БПМ
    if(sh_!=0) goto L101;
    CT_29 = 0;                      // сброс счетчика времени режима
    goto L101;
L3: if(CT_29 <= 2) goto L101;       // задержка 2 сек на включение пускателя БПМ
    sh_ = 0;
    goto L101;
L4: SetOut(0,1,0x200);        		// снятие блокировки Uвых БПМ
	VKBPM1();                       // вкл. пускатель М1
    if(sh_!=0) goto L101;
    VIBPAR_BM1();		    // выбор параметра БПМ1
    RLIMBM1();	  	            // задание LIM для БПМ1
    goto L101;
// выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_BM(04004,010000,0,0,040);  // Вкл. Uвых. БПМ
    if(sh_!=0) goto L101;
    CT_29 = 0;	            	    // сброс
    CT29K1 = 0;	            	    // счетчиков
    goto L101;
// выход на режим и диагностика
L6: VIBPAR_BM1();		    // выбор параметра БПМ1
    VIDK_BM(04004,010000,0,0,040);  // выдать уставку БПМ
    if(sh_!=0) goto L101;           // (Вкл.Uвых.)
    PDBM1 ();                       // Подготовка аналоговых данных
    RLIMBM1();	        	    // новый расчет LIM для БПМ1
    if (DELBM <= LIM1BM) goto L6_4; // модуль Ет <= LIM1
    if (VRBM == 0) goto L6_6;	    // нет выхода на режим
    diagn[0] |= 0x04;		    // отказ: "нет регулирования БПМ"
    goto L6_5;	            	    // на сброс диагн."больш.ош."
L6_4:diagn[0] &= (~0x04);	    // сброс д."нет регулирования БПМ"
    if (DELBM <= LIM2BM) goto L6_5; // LIM2 (зона регулирования)
    if (VRBM == 0) goto L6_6;	    // нет выхода на режим
    diagn[0] |= 0x02;		    // отказ: "б.ош.регулирования БПМ"
    goto L6_7;
L6_5:diagn[0] &= (~0x02);	    // сброс д."б.ош.регулирования БПМ"
    goto L6_7;
L6_6:CT29K1 = 0;
L6_7:if(CT_29 <= T_VRBM) goto L6_2; // Ттек <= Тзад
    if(VRBM != 0) goto L6_1;        // есть выход на режим
    diagn[0] |= 0x01;		    // отказ: "нет выхода на режим БПМ"
    goto L6_2;
L6_1:diagn[0] &= (~0x01);	    // сброс д."нет выхода на режим БПМ"
L6_2:if(CT29K1 <= T_KBM) goto L6_3; // Т.K.тек <= Т.K.зад
    VRBM = 1;	               	    // выход на режим
L6_3:shr[29] = 5;                   // Возврат на L6
    goto L101;
}
//------------------------------------------------------------------------------
void VIBPAR_BM1 ()		    // подпрограмма "Выбор параметра для БПМ1"
{
        if(par[N_ST][17]&&nasmod[25]&&nasmod[26])
        {
          if((SOPR < nasmod[26]) || PR_SOPR_BM)
          {
             PAR_BM1 = nasmod[25];
             PR_SOPR_BM = 1;
             return;
          }
        }
	PAR_BM1 = par[N_ST][8];
}
//------------------------------------------------------------------------------
void RLIMBM1 ()		            // подпрограмма "Расчет LIM для БПМ1"
{
    if (PAR_BM1 == 0)	            // если задание = 0, расшир.лимитов
     {
      LIM1BM = 4095;		    // MAX доп.знач.по входу ап.ср.
      LIM2BM = LIM1BM / 2;          // LIM2 = 0,5 LIM1
     }
    else
     {
      LIM2BM = PAR_BM1/DOPBM;	    // LIM2 (малый)
      LIM1BM = PAR_BM1 / 2;         // LIM1 (большой)
     }
}
//------------------------------------------------------------------------------
void PDBM1 ()			    // подготовка аналоговых данных БПМ1
{ 
    long T1;
    T1 = OTVET_BM[6];       // P - тек.мощность магнетрона
    T1=(T1*34)/10;          // поправочный коэф. на тек.мощн.
                           //Pзад.=К*Ртек.
                           // К=(4095/3600)*(3072/1023)=3,4
    X_TBM = T1 ;		    // тек.значение мощности
    E_TBM = PAR_BM1 - X_TBM;	    // Хзад - Хтек = Етек (тек.ошибка)
    if (E_TBM >= 0) DELBM = E_TBM;
    else  DELBM = E_TBM * (-1);	    // вычисление модуля ошибки
}
//------------------------------------------------------------------------------
void R_30 ()	                    // режим "БПМ2"
{
	sh_ = sh[30];
	if (shr[30] == 1) goto L1;
	if (shr[30] == 2) goto L2;
	if (shr[30] == 3) goto L3;
	if (shr[30] == 4) goto L4;
	if (shr[30] == 5) goto L5;
	if (shr[30] == 6) goto L6;
    else goto L100;              // на выход

                                    // | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[30] = sh_;	   	    		// |                           |
    if (sh[30] != 0) goto L100;     // |    SH != 0                |
    shr[30]++;		            	// |    след.шаг 	           |
    sh[30] = 1;		            	// |			   |
L100:return;			    		// |    возврат в "кольцо"	   |

L1: PR_SOPR_BM = 0;
    VRBM = 0;                       // сброс признака выхода на режим БПМ
    //SetOut(1,0,0x04);             // подключить свидетель
    diagn[0] &= (~0xFF);            // сброс диагностик режима БПМ
// Проверка включения и включение подсистем БПМ
    if (PR_SV_BM == 0) goto L101;   // Нет готовности связи БПМ
    if((OTVET_BM[8]&04000) != 0)    // Блок включен
    {
        shr[30] = 3;
        sh_ = 0;
        goto L101;                  // Переход на L4
    }
    sh_ = 0;
    goto L101;
L2: VIDK_BM(014004,04000,1,0,010);  // Вкл. блок БПМ
    if(sh_!=0) goto L101;
    CT_30 = 0;                      // сброс счетчика времени режима
    goto L101;
L3: if(CT_30 <= 2) goto L101;       // задержка 2 сек на включение пускателя БПМ
    sh_ = 0;
    goto L101;
L4: SetOut(0,1,0x200);        		// снятие блокировки Uвых БПМ
	VKBPM2();                       // вкл. пускатель М2
    if(sh_!=0) goto L101;
    VIBPAR_BM2();		    		// выбор параметра БПМ2
    RLIMBM2();	  	           	 	// задание LIM для БПМ2
    goto L101;
// выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_BM(04004,010000,0,0,040);  // Вкл. Uвых. БПМ
    if(sh_!=0) goto L101;
    CT_30 = 0;	            	    // сброс
    CT30K1 = 0;	            	    // счетчиков
    goto L101;
// выход на режим и диагностика
L6: VIBPAR_BM2();		    		// выбор параметра БПМ2
    VIDK_BM(04004,010000,0,0,040);  // выдать уставку БПМ
    if(sh_!=0) goto L101;           // (Вкл.Uвых.)
    PDBM2();                        // Подготовка аналоговых данных
    RLIMBM2();	        	    	// новый расчет LIM для БПМ2
    if (DELBM <= LIM1BM) goto L6_4; // модуль Ет <= LIM1
    if (VRBM == 0) goto L6_6;	    // нет выхода на режим
    diagn[0] |= 0x04;		    	// отказ: "нет регулирования БПМ"
    goto L6_5;	            	    // на сброс диагн."больш.ош."
L6_4:diagn[0] &= (~0x04);	    	// сброс д."нет регулирования БПМ"
    if (DELBM <= LIM2BM) goto L6_5; // LIM2 (зона регулирования)
    if (VRBM == 0) goto L6_6;	    // нет выхода на режим
    diagn[0] |= 0x02;		    	// отказ: "б.ош.регулирования БПМ"
    goto L6_7;
L6_5:diagn[0] &= (~0x02);	    	// сброс д."б.ош.регулирования БПМ"
    goto L6_7;
L6_6:CT30K1 = 0;
L6_7:if(CT_30 <= T_VRBM) goto L6_2; // Ттек <= Тзад
    if(VRBM != 0) goto L6_1;        // есть выход на режим
    diagn[0] |= 0x01;		    	// отказ: "нет выхода на режим БПМ"
    goto L6_2;
L6_1:diagn[0] &= (~0x01);	    	// сброс д."нет выхода на режим БПМ"
L6_2:if(CT30K1 <= T_KBM) goto L6_3; // Т.K.тек <= Т.K.зад
    VRBM = 1;	               	    // выход на режим
L6_3:shr[30] = 5;                   // Возврат на L6
    goto L101;
}
//------------------------------------------------------------------------------
void VIBPAR_BM2 ()		    // подпрограмма "Выбор параметра для БПМ2"
{
        if(par[N_ST][17]&&nasmod[25]&&nasmod[26])
        {
          if((SOPR < nasmod[26]) || PR_SOPR_BM)
          {
             PAR_BM2 = nasmod[25];
             PR_SOPR_BM = 1;
             return;
          }
        }
	PAR_BM2 = par[N_ST][9];
}
//------------------------------------------------------------------------------
void RLIMBM2 ()		            // подпрограмма "Расчет LIM для БПМ2"
{
    if (PAR_BM2 == 0)	            // если задание = 0, расшир.лимитов
     {
      LIM1BM = 4095;		    // MAX доп.знач.по входу ап.ср.
      LIM2BM = LIM1BM / 2;          // LIM2 = 0,5 LIM1
     }
    else
     {
      LIM2BM = PAR_BM2/DOPBM;	    // LIM2 (малый)
      LIM1BM = PAR_BM2 / 2;         // LIM1 (большой)
     }
}
//------------------------------------------------------------------------------
void PDBM2 ()			    // подготовка аналоговых данных БПМ2
{ 
    long T1;
    T1 = OTVET_BM[6];               // P - мощность магнетрона
    T1=(T1*34)/10;          // поправочный коэф. на тек.мощн.
                           //Pзад.=К*Ртек.
                           // К=(4095/3600)*(3072/1023)=3,4
    X_TBM = T1 ;		    // тек.значение мощности
    E_TBM = PAR_BM2 - X_TBM;	    // Хзад - Хтек = Етек (тек.ошибка)
    if (E_TBM >= 0) DELBM = E_TBM;
    else  DELBM = E_TBM * (-1);	    // вычисление модуля ошибки
}
//------------------------------------------------------------------------------
void VIDK_BM(int a, int b, int c, int d, int e)
     // a - код команды (восьмеричный)
     // b - номер бита в байте состояния
     // c - значение бита в байте состояния (0 или 1)
     // d - номер байта массива диагностики
     // e - номер бита массива диагностики
{
    int x;
    if (sh_ == 1) goto A1;
    if (sh_ == 2) goto A2;
    else return;                   	// выход
A1: SetOut(1,1,0x100);              	// Вкл.дист. управление
    if(diagnS[0] & 0x08) return;  	// Есть диагностика "Нет связи с БПМ"
    PR_SV_BM = 0;                 	// Обнуление признака положительного
                                        // ответа от БПМ1
	                               	// Формирование массива заданий
    KOM_BM[0] = 4095;                   // Ion.(15А)      - R1
    KOM_BM[1] = nasmod[19];                   // Uon.(650В)     - R2
    if(shr[29]||shr[7])                // БПМ1 или Отпыл1
     KOM_BM[2] = PAR_BM1;
    else if(shr[30]||shr[8])           // БПМ2 или Отпыл2
     KOM_BM[2] = PAR_BM2;
	 else if(shr[34]||shr[10])         // БПМ3 или Отпыл3
     KOM_BM[2] = PAR_BM3;
    else KOM_BM[2] = 0;
    if(shr[29]||shr[7])                // БПМ1 или Отпыл1
     KOM_BM[3] = nasmod[30];
    else if(shr[30]||shr[8])           // БПМ2 или Отпыл2
     KOM_BM[3] = nasmod[31];
	 else if(shr[34]||shr[10])         // БПМ3 или Отпыл3
     KOM_BM[3] = nasmod[32];
    else KOM_BM[3] = 0;
    KOM_BM[4] = a;                		// Код команды    - R5
	if((shr[29]||shr[7])&&nasmod[30])	// есть задание частоты
		KOM_BM[4] |= 01000;			// вкл. режим с дискр. паузой
	else if((shr[30]||shr[8])&&nasmod[31])	// есть задание частоты
		KOM_BM[4] |= 01000;			// вкл. режим с дискр. паузой
	else if((shr[34]||shr[10])&&nasmod[32])	// есть задание частоты
		KOM_BM[4] |= 01000;			// вкл. режим с дискр. паузой
	else
		KOM_BM[4] &= (~01000);
    CT_BM = 0;                    	// Сброс сч. времени
    sh_ = 2;
A2: if ((diagnS[0] & 0x08) || (PR_SV_BM == 0)) // Есть диагностика
					// "Нет связи с БПМ" или нет признака
					// положительного ответа от БПМ
    {
        CT_BM = 0;                	// Сброс сч. времени
        return;
    }
    x = ( OTVET_BM[8] & b );      	// Ожидание ответа на команду
    if( x != 0 ) x = 1;            	// проверяемый бит = 1
    else x = 0;			        // проверяемый бит = 0
    if(x != c)			        // Нет ответа от БПМ
    {
        if (CT_BM <= 5) return;  	// Время не вышло (5 сек.)
        diagn[d] |= e;             	// Отказ: "..."
        sh_ = 1;
        return;
    }
    diagn[d] &= (~e);                   // Сброс диагностики
    sh_ = 0;
}
// Команды на БПМ1
// VIDK_BM ( 014004 , 04000  , 1 , 0 , 010  ) - Включить блок БПМ1
// VIDK_BM ( 010004 , 04000  , 0 , 0 , 020  ) - Выключить блок БПМ1
// VIDK_BM ( 004004 , 010000 , 0 , 0 , 040  ) - Включить вых.напряжение БПМ1
// VIDK_BM ( 014004 , 010000 , 1 , 0 , 0100 ) - Выключить вых.напряжение БПМ1
//------------------------------------------------------------------------------
void R_31 ()            // Режим "Сброс БПМ"
 {
  sh_ = sh[31];
  if (shr[31] == 1) goto L1;
  if (shr[31] == 2) goto L2;
  if (shr[31] == 3) goto L3;
  if (shr[31] == 4) goto L4;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[31] = sh_;
  if (sh[31] != 0) goto L100;  // SH != 0
  ++shr[31];                   // след. шаг сч.шр1
  if (shr[31] > 4) goto L0;    // число шагов режима
  sh[31] = 1;
L100:return;                   // возврат в "кольцо"

L0:norma = 14;                 // норма: "Сброс БПМ завершен"
  shr[31] = 0;
  goto L100;

L1:PR_SOPR_BM = 0;
  shr[29] = 0;                // сброс активизации режима R_29
  sh[29] = 0;                  // "БПМ1"
  shr[7] = 0;                  // сброс активизации режима R_7
  sh[7] = 0;                   // "Отпыл М1"
  shr[30] = 0;                // сброс активизации режима R_30
  sh[30] = 0;                  // "БПМ2"
  shr[8] = 0;                  // сброс активизации режима R_8
  sh[8] = 0;                   // "Отпыл М2"
  SetOut(1,1,0x200);           // выставить блокировку Uвых БПМ
  sh_ = 0;
  goto L101;
L2:VIDK_BM(014004,010000,1,0,0100); // команда "Выкл. Uвых БПМ"
  if(sh_!=0) goto L101;        // ожидание завершения
  diagn[0] &= (~0xFF);         // сброс диагностик реж. БПМ
  goto L101;
L3:OKBPM();                    // отключение коммутатора магнетронов
  if(sh_!=0) goto L101;        // ожидание завершения
  PAR_BM1 = 0;                 // сброс параметров БПМ1 и БПМ2
  PAR_BM2 = 0;
  if((shr[2]==0)&&(shr[3]==0)&&(shr[4]==0)) goto L101;
  shr[31] = 4;                 // нет активизации ни одного режима
  goto L101;
L4:VIDK_BM(010004,04000,0,0,020);// откл. БПМ
  goto L101;  
}
//------------------------------------------------------------------------------
void R_32 ()	                     // режим "ИИ"
{
	sh_ = sh[32];
	if (shr[32] == 1) goto L1;
	if (shr[32] == 2) goto L2;
	if (shr[32] == 3) goto L3;
	if (shr[32] == 4) goto L4;
	if (shr[32] == 5) goto L5;
	if (shr[32] == 6) goto L6;
    else goto L100;              // на выход

				                 // | КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[32] = sh_;	   	         // |                           |
	if (sh[32] != 0) goto L100;  //	|    SH != 0                |
	shr[32]++;		             //	|    след.шаг 	            |
	sh[32] = 1;		             //	|			                |
L100:return;			         // |    возврат в "кольцо"	    |

L1: VRII = 0;                    // сброс признака выхода на режим ИИ
	diagn[2] &= (~0x7F);         // сброс диагностики режима ИИ
        SetOut(0,0,0x04);        // отключить свидетель
	sh_ = 0;
	goto L101;
// Проверка включения и включение подсистем ИИ
L2: if (PR_SV_II == 0) goto L101;	// Нет готовности связи ИИ
    if((OTVET_II[8]&04000) != 0)	// Блок включен
     {
      shr[32]=4;
      goto L4_1;               	// Переход на L4_1
     }
    sh_ = 0;
    goto L101;
L3: VIDK_II(014000,04000,1,2,010);// Вкл. блок ИИ
    if(sh_!= 0) goto L101;
    CT_32 = 0;                    // сброс счетчика времени режима
    goto L101;
L4: if(CT_32 <= 2) goto L101;  	// задержка 2 сек на включение Uвых
L4_1:SetOut(0,1,0x800);			// снять блокировку мощности БПИИ
	VIBPAR_II();		        // выбор параметра ИИ
    RLIMII();	  	            // задание LIM для ИИ
    sh_ = 0;
    goto L101;
// выдать начальную уставку (Вкл.Uвых.)
L5: VIDK_II (0104000,010000,0,2,040);// вкл. Uвых ИИ
    if(sh_!=0) goto L101;
    CT_32 = 0;	            	 // сброс
    CT32K1 = 0;	            	 // счетчиков
    goto L101;
// выход на режим и диагностика
L6: VIBPAR_II();		         // выбор параметра ИИ
    VIDK_II (0104000,010000,0,2,040);// выдать уставку ИИ
    if(sh_!=0) goto L101;        	// (Вкл.Uвых.)
    PDII ();                     	// Подготовка аналоговых данных
    RLIMII();	        	     	// новый расчет LIM для ИИ
    if(DELII <= LIM1II) goto L6_4;	// модуль Ет <= LIM1
    if(VRII == 0) goto L6_6;	 	// нет выхода на режим
    diagn[2] |= 0x04;		        // отказ: "нет регулирования ИИ"
    goto L6_5;	            	 	// на сброс диагн."больш.ош."
L6_4:diagn[2] &= (~0x04);	        // сброс д."нет регулирования ИИ"
    if(DELII <= LIM2II) goto L6_5;	// LIM2 (зона регулирования)
    if(VRII == 0) goto L6_6;	 	// нет выхода на режим
    diagn[2] |= 0x02;		        // отказ: "б.ош.регулирования ИИ"
    goto L6_7;
L6_5:diagn[2] &= (~0x02);	        // сброс д."б.ош.регулирования ИИ"
    goto L6_7;
L6_6:CT32K1 = 0;
L6_7:if(CT_32 <= T_VRII) goto L6_2;	// Ттек <= Тзад
    if (VRII != 0) goto L6_1;    	// есть выход на режим
    diagn[2] |= 0x01;		        // отказ: "нет выхода на режим ИИ"
    goto L6_2;
L6_1:diagn[2] &= (~0x01);	         // сброс д."нет выхода на режим ИИ"
L6_2:if (CT32K1 <= T_KII) goto L6_3; // Т.K.тек <= Т.K.зад
    VRII = 1;	               	 	 // выход на режим
L6_3:shr[32]=5;                      // Возврат на L6
    goto L101;
}
//------------------------------------------------------------------------------
void VIBPAR_II ()		         // подпрограмма "Выбор параметра для ИИ"
{
    PAR_II = par[N_ST][3];        // задание из таблицы параметров (Ручн.)
}
//------------------------------------------------------------------------------
void RLIMII ()		             // подпрограмма "Расчет LIM для ИИ"
{
	if (PAR_II == 0)	         // если задание = 0, расшир.лимитов
    {
        LIM1II = 4095;		     // MAX доп.знач.по входу ап.ср.
	    LIM2II = LIM1II / 2;     // LIM2 = 0,5 LIM1
    }
    else
    {
        LIM2II = PAR_II/DOPII;	 // LIM2 (малый)
	    LIM1II = PAR_II / 2;     // LIM1 (большой)
    }
}
//------------------------------------------------------------------------------
void PDII ()			         // подготовка аналоговых данных ИИ
{
    long T1;
	T1 = OTVET_II[5];            // I - ток ИИ
	T1=(T1*4095)/999;            // поправочный коэф. на тек.мощн. 4095/999=4.1
	X_TII = T1 ;		         // тек.значение мощности
	E_TII = PAR_II - X_TII;	     // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TII >= 0) DELII = E_TII;
	else  DELII = E_TII * (-1);	 // вычисление модуля ошибки
}
//---------------------------------------------------------------------------
// Подпрограмма выдачи команд на ИИ
//---------------------------------------------------------------------------
void VIDK_II(int a, int b, int c, int d, int e)
     // a - код команды (восьмеричный)
     // b - номер бита в байте состояния
     // c - значение бита в байте состояния (0 или 1)
     // d - номер байта массива диагностики
     // e - номер бита массива диагностики
{
    int x;
    if (sh_ == 1) goto A1;
    if (sh_ == 2) goto A2;
    else return;                   // выход
A1: SetOut(1,1,0x400);             // Вкл.дист. управление
    if(diagnS[0] & 0x10) return;   // Есть диагностика "Нет связи с ИИ"
    PR_SV_II = 0;                  // Обнуление признака положительного
				   // ответа от ИИ
	                           // Формирование массива заданий
    KOM_II[0] = PAR_II;            // Ion.(0,5А)     - R1
    KOM_II[1] = 4095;              // Uon.(3000В)    - R2   
    KOM_II[2] = 4095;              // Pon.(0-1000Вт) - R3  
    KOM_II[3] = 0;                 // (нет)          - R4
    KOM_II[4] = a;                 // Код команды    - R5
    CT_II = 0;                     // Сброс сч. времени
    sh_ = 2;
A2: if((diagnS[0] & 0x10) || (PR_SV_II == 0)) // Есть диагностика
                                   // "Нет связи с ИИ" или нет признака
				   // положительного ответа от ИИ
    {
        CT_II = 0;                 // Сброс сч. времени
        return;
    }
    x = ( OTVET_II[8] & b );       // Ожидание ответа на команду
    if( x != 0 ) x = 1;            // проверяемый бит = 1
    else x = 0;			           // проверяемый бит = 0
    if(x != c)			           // Нет ответа от ИИ
    {
        if (CT_II <= 5) return;    // Время не вышло (5 сек.)
        diagn[d] |= e;             // Отказ: "..."
        sh_ = 1;
        return;
    }
    diagn[d] &= (~e);              // Сброс диагностики
    sh_ = 0;
}
// Команды на ИИ
// VIDK_II ( 014000 , 04000  , 1 , 2 , 010  ) - Включить блок ИИ
// VIDK_II ( 010000 , 04000  , 0 , 2 , 020  ) - Выключить блок ИИ
// VIDK_II ( 0104000 , 010000 , 0 , 2 , 040  ) - Включить вых.напряжение ИИ
// VIDK_II ( 014000 , 010000 , 1 , 2 , 0100 ) - Выключить вых.напряжение ИИ
//---------------------------------------------------------------------------
void R_33 ()                        // Сброс ИИ
{
  sh_ = sh[33];
  if (shr[33] == 1)  goto L1;
  if (shr[33] == 2)  goto L2;
  if (shr[33] == 3)  goto L3;
  else goto L100;// на выход

//--КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА--//

L101:sh[33] = sh_;
  if (sh[33] != 0) goto L100;   // SH != 0
  shr[33]++;                    // след.шаг сч.шр33
  if (shr[33] > 3) goto L0;     // число шагов режима
  sh[33] = 1;
L100: return;                   // возврат в "кольцо"

L0:norma = 21;                  // норма: "Сброс ИИ завершен"
  shr[33] = 0;
  goto L100;

L1:shr[32] = 0;                 // сброс активизации режима 32
  sh[32] = 0;                   // "ИИ"
  SetOut(1,1,0x800);           // выставить блокировку Uвых БПИИ
  sh_ = 0;
  goto L101;
L2:VIDK_II(014000,010000,1,2,0100);// выкл. Uвых БПИИ
  if(sh_!=0) goto L101;
  PAR_II = 0;                   // сброс параметра
  diagn[2] &= (~0x7F);          // сброс диагностик ИИ
  if((shr[2]==0)&&(shr[4]==0)) goto L101;// нет активизации режимов 2 и 4
  shr[33] = 3;                  // выход
  goto L101;
L3:VIDK_II(010000,04000,0,2,020);// откл. БПИИ
  goto L101;
}
//------------------------------------------------------------------------------
void R_34 ()	                    // режим "Вкл. ВЧГ стола (по мощн.)"
{
	sh_ = sh[34];
	if (shr[34] == 1) goto L1;
	if (shr[34] == 2) goto L2;
	if (shr[34] == 3) goto L3;
	if (shr[34] == 4) goto L4;
	else goto L100;					// на выход
									//	| КОНЕЧНЫЙ ДИСПЕТЧЕР РЕЖИМА |
L101:sh[34] = sh_;					//  |                           |
	if(sh[34]) goto L100;			//	|    sh != 0                |
	shr[34]++;						//	|    след.шаг 	            |
	sh[34] = 1;						//  |			                |
L100:return;						//  |    возврат в "кольцо"	    |

L1: PR_SOPR_BM = 0;
    VRGIS = 0;                      // сброс признака выхода на режим ВЧГ
	diagn[21] &= (~0xFF);			// сброс диагностики режима ВЧГ
    A_OUT(8,8192);                  // обнуление уставки
    VRR_GIS();						// выставить разр. работы ВЧГ
    goto L101;
L2: VIBPAR_GIS();                   // выбор параметров ВЧГ
    A_OUT(8,2*PAR_GIS+8192);        // выдача уставки на ВЧГ
    sh_ = 0;                        // перейти на след. шаг
    goto L101;
L3: SetOut(1,2,0x10);				// включение выходной мощности ВЧГ
        CT_34 = 0;                      // очистка счетчиков
    CT34K1 = 0;                     // режима
    sh_=0;
    goto L101;
// выход на режим и диагностика
L4: VIBPAR_GIS();                   // выбор параметров ВЧГ
    A_OUT(8,2*PAR_GIS+8192);        // выдача уставки на ВЧГ
	PDGIS ();                   	// Подготовка аналоговых данных
	RLIMGIS();	        			// новый расчет LIM для ВЧГ
	if (DELGIS <= LIM1GIS) goto L4_4;// модуль Ет <= LIM1
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[21] |= 0x04;		        // отказ: "нет регулирования ВЧГ"
	goto L4_5;	            		// на сброс диагн."больш.ош."
L4_4:diagn[21] &= (~0x04);	   	    // сброс д."нет регулирования ВЧГ"
	if (DELGIS <= LIM2GIS) goto L4_5;// LIM2 (зона регулирования)
	if (VRGIS == 0) goto L4_6;		// нет выхода на режим
	diagn[21] |= 0x02;		        // отказ: "б.ош.регулирования ВЧГ"
	goto L4_7;
L4_5:diagn[21] &= (~0x02);	   	    // сброс д."б.ош.регулирования ВЧГ"
	goto L4_7;
L4_6:CT34K1 = 0;
L4_7:if (CT_34 <= T_VRGIS) goto L4_2;// Ттек <= Тзад
	if (VRGIS != 0) goto L4_1;      // есть выход на режим
	diagn[21] |= 0x01;		        // отказ: "нет выхода на режим ВЧГ"
	goto L4_2;
L4_1:diagn[21] &= (~0x01);	        // сброс д."нет выхода на режим ВЧГ"
L4_2:if (CT34K1 <= T_KGIS) goto L4_3;// Т.K.тек <= Т.K.зад
    VRGIS = 1;	               		// выход на режим
    norma = 61;                     // норма: "ВЧГ п/д вышел на режим"
L4_3:shr[34]=3;                     // Возврат на L4
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
void VIBPAR_GIS ()				    // подпрограмма "Выбор параметра для ВЧГ"
{                                   // выбор из таблицы параметров

        if(par[N_ST][17]&&nasmod[37]&&nasmod[26])
        {
          if((SOPR < nasmod[26]) || PR_SOPR_BM)
          {
             PAR_GIS = nasmod[37];
             PR_SOPR_BM = 1;
             return;
          }
        }
	PAR_GIS = par[N_ST][10];
}
//---------------------------------------------------------------------------
void RLIMGIS ()						// подпрограмма "Расчет LIM для ВЧГ"
{
    if (VRGIS == 0)                 // если нет выхода на режим ВЧГ
    {
        DOPGIS = 15;                // допуск 66,6%
        LIM2GIS = (PAR_GIS * 10) / DOPGIS; // LIM2 (малый)
        LIM1GIS = (PAR_GIS*10)/12;  // LIM1 (большой)
    }
    else                            // есть выход на режим ВЧГ
    {
    	if ( PAR_GIS <= 138 )       // если зад. мощность <= 20Вт
	    	 DOPGIS = 30;           // допуск 33%
	    else  if ( PAR_GIS <= 276 ) // если зад. мощность <= 40Вт
		    DOPGIS = 40;            // допуск 25%
        else DOPGIS = 50;           // иначе допуск 20%

	    if (PAR_GIS == 0)	        // если задание = 0, расшир.лимитов
	    {
		    LIM1GIS = 4095;		    // MAX доп.знач.по входу ап.ср.
	        LIM2GIS = LIM1GIS / 2;  // LIM2 = 0,5 LIM1
	    }
        else
        {
	        LIM2GIS = PAR_GIS * 10 / DOPGIS; // LIM2 (малый)
	        LIM1GIS = PAR_GIS / 2;      // LIM1 (большой)
        }
    }
}
//---------------------------------------------------------------------------
void PDGIS ()						// подготовка аналоговых данных ВЧГ
{
	X_TGIS = aik[13];	            // тек.значение падающей мощности
	E_TGIS = PAR_GIS - X_TGIS;	    // Хзад - Хтек = Етек (тек.ошибка)
	if (E_TGIS >= 0) DELGIS = E_TGIS;
	else  DELGIS = E_TGIS * (-1);	// вычисление модуля ошибки
}
//---------------------------------------------------------------------------
void SBROSR_34 ()                    // "Откл. ВЧМ"
{
    PR_SOPR_BM = 0;
	shr[34] = 0;        // сброс активизации
	sh[34] = 0;         // режима 27 "Вкл. ВЧГ стола"
	VRGIS = 0;          // сброс выхода ВЧГ на режим
	A_OUT(8,8192);      // сброс уставки вых. мощности ВЧГ
	SetOut(0,2,0x10);	// откл. вых. мощн.
	diagn[21]&=(~0xFF);	// сброс диагностик режимов "ВЧГ"
	norma = 60;			// норма: "Сброс режима ВЧГ п/д завершен"
}
//------------------------------------------------------------------------------
void R_36 ()            // Режим "Откл. НАГРЕВ" ручн.
 {                      
  sh_ = sh[36];
  if (shr[36] == 1) goto L1;
  if (shr[36] == 2) goto L2;
  if (shr[36] == 3) goto L3;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[36] = sh_;
  if (sh[36] != 0) goto L100;  // SH != 0
  ++shr[36];                   // след. шаг сч.шр36
  if (shr[36] > 3) goto L0;    // число шагов режима
  sh[36] = 1;
L100:return;                   // возврат в "кольцо"

L0:shr[36] = 0;
  goto L100;

L1:shr[28] = 1;                // активизация режима R_28
  sh[28] = 1;                  // "Откл. НАГРЕВ"
  sh_ = 0;
  goto L101;
L2:if(shr[28] != 0) goto L101; // ожидание конца режима "Откл. БПН"
  sh_ = 0;
  goto L101;
L3:OBPN();                     // откл. сил. питание БПН
  goto L101;
 }
//---------------------------------------------------------------------------
void R_37 ()                    // режим 37 "Д/заслонка открыть"
{
  sh_ = sh[37];
  if (shr[37] == 1) goto L1;
  if (shr[37] == 2) goto L2;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[37] = sh_;
	if (sh[37] != 0) goto L100;    // SH != 0
	++shr[37];                     // след. шаг сч.шр5
	if (shr[37] > 2) goto L0;     // число шагов режима
	sh[37] = 1;
L100:return;                    // возврат в "кольцо"

L0:	norma = 40;                   // норма: "ДЗ открылась"
	shr[37] = 0;
	goto L100;

L1: sh[38] = 0;     // дезактивизировать режим 38
    shr[38] = 0;
    sh[39] = 0;     // дезактивизировать режим 39
    shr[39] = 0;
    VIDK_DZ(0,ABS,par_t[0],0,20);
    goto L101;

L2: if(!(zin[1]&0x4000) || (zin[1]&0x8000)) // ДЗ не открылась       //if (!(zin[1] & 0xC000) == 0x4000)
    {
      diagn[13] |= 0x40;		        // ДЗ не открылась
      goto L101;
    }
    diagn[13] &= (~0x40); // сброс диагностик ДЗ
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
void R_38 ()                    // режим 38 "Д/заслонка закрыть"
{
  sh_ = sh[38];
  if (shr[38] == 1) goto L1;
  if (shr[38] == 2) goto L2;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[38] = sh_;
	if (sh[38] != 0) goto L100;    // SH != 0
	++shr[38];                     // след. шаг сч.шр5
	if (shr[38] > 2) goto L0;     // число шагов режима
	sh[38] = 1;
L100:return;                    // возврат в "кольцо"

L0:	norma = 41;                   // норма: "ДЗ закрылась"
	shr[38] = 0;
	goto L100;

L1: sh[37] = 0;     // дезактивизировать режим 37
    shr[37] = 0;
    sh[39] = 0;     // дезактивизировать режим 39
    shr[39] = 0;
    VIDK_DZ(0,0,0,1,20);
    goto L101;
L2: if((zin[1]&0x4000) || !(zin[1]&0x8000)) // ДЗ не закрылась
    {
      diagn[13] |= 0x80;		        // ДЗ не закрылась
      goto L101;
    }
    diagn[13] &= (~0x80); // сброс диагностик ДЗ
    sh_ = 0;
    goto L101;
}
//---------------------------------------------------------------------------
void R_39 ()            // Режим "Дросселирование"
 {
  sh_ = sh[39];
  if (shr[39] == 1) goto L1;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[39] = sh_;
	if (sh[39] != 0) goto L100;    // SH != 0
	++shr[39];                     // след. шаг сч.шр
	if (shr[39] > 1) goto L0;     // число шагов режима
	sh[39] = 1;
L100:return;                    // возврат в "кольцо"

L0:	norma = 65;                   // норма: "ДЗ в дросс"
	shr[39] = 0;
	goto L100;

L1:	shr[37] = 0;			// сброс активизации режима 37
	sh[37] = 0;
	shr[38] = 0;			// сброс активизации режима 38
	sh[38] = 0;
    VIDK_DZ(0,ABS,int((float)par[N_ST][6]*(float)par_t[0]/100.0),0,20); // открыть ДЗ на угол
    goto L101;
}
//---------------------------------------------------------------------------
void R_53() // Режим "ДЗ вперед/назад"
 {
  sh_ = sh[53];
  if (shr[53] == 1) goto L1;
      else goto L100;         // выход
  // конечный диспетчер режима

L101:sh[53] = sh_;
	if (sh[53] != 0) goto L100;    // SH != 0
	++shr[53];                     // след. шаг сч.шр
	if (shr[53] > 1) goto L0;     // число шагов режима
	sh[53] = 1;
L100:return;                    // возврат в "кольцо"

L0:	norma = 67;                   // норма: "ДЗ в дросс"
	shr[53] = 0;
	goto L100;

L1:	shr[37] = 0;			// сброс активизации режима 37
	sh[37] = 0;
	shr[38] = 0;			// сброс активизации режима 38
	sh[38] = 0;
    VIDK_DZ(par[0][14],OTN,par[0][13],0,60); // открыть ДЗ на угол
    goto L101;

}
//---------------------------------------------------------------------------
void R_40 ()                    // режим 40 "Барабан в исх."
{
    switch ( shr[40] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            shr[41] = 0;
            sh[41] = 0;    
            pderjPrRuch = true;  // запуск вручную
            sh_ = sh[40];
            GoPderjatel(0, 0, 0, 1, 0); // п/держ. в исходное
            if (sh_==0)         // если заслонка в исходном
            {
                pderjPrRuch = false; // запуск вручную убрать
                sh[40] = 0;     // дезактивизировать режим 40
                shr[40] = 0;    // "П/держ. в исходное"
            }
            sh[40] = sh_;
        }; break;
    }
}
//---------------------------------------------------------------------------
void R_41 ()                    // режим 41 "Барабан вперёд"
{	
    switch ( shr[41] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            shr[40] = 0;
            sh[40] = 0;
            A_OUT(1,nasmod[23]);
            SetOut(1,0,0x02);
        }; break;	
    }
}
//---------------------------------------------------------------------------
void R_42 ()                    // режим 42 "Заслонка в исходное"
{
    switch ( shr[42] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            zaslPrRuch = true;  // запуск вручную
            sh_ = sh[42];
            GoZaslonka(0, 0, 0, 1, 0); // заслонка в исходное
            if (sh_==0)         // если заслонка в исходном
            {
                zaslPrRuch = false; // запуск вручную убрать
                sh[42] = 0;     // дезактивизировать режим 42
                shr[42] = 0;    // "Заслонка в исходное"
            }
            sh[42] = sh_;
        }; break;
    }
}
//---------------------------------------------------------------------------
void R_43 ()                    // режим 43 "Заслонка вперёд"
{
    switch ( shr[43] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            zaslPrRuch = true;  // запуск вручную
            sh_ = sh[43];
            GoZaslonka(0, par[0][11], 0, 0, 0); // заслонка вперёд
            if (sh_==0)         // если заслонка прошла путь
            {
                zaslPrRuch = false; // запуск вручную убрать
                sh[43] = 0;     // дезактивизировать режим 43
                shr[43] = 0;    // "Заслонка вперёд"
            }
            sh[43] = sh_;
        }; break;
    }
}
//---------------------------------------------------------------------------
void R_44 ()            // Режим "Крышка вверх" ручн.
{
	sh_ = sh[44];
    if (shr[44] == 1) goto L1;
	if (shr[44] == 2) goto L2;
	else goto L100;         // выход
	// конечный диспетчер режима

L101:  sh[44] = sh_;
	if (sh[44] != 0) goto L100;  // SH != 0
	++shr[44];                   // след. шаг сч.шр44
	if (shr[44] > 2) goto L0;    // число шагов режима
	sh[44] = 1;
L100:   return;                   // возврат в "кольцо"

L0:	shr[44] = 0;
	goto L100;

L1: GoPderjatel(0, 0, 0, 1, 0); // п/держ. в исходное
    goto L101;
L2: KR_VVERH();
	goto L101;
}
//---------------------------------------------------------------------------
void R_45 ()            // Режим "Крышка вниз" ручн.
{
	sh_ = sh[45];
	if (shr[45] == 1) goto L1;
    if (shr[45] == 2) goto L2;
	else goto L100;         // выход
	// конечный диспетчер режима

L101:sh[45] = sh_;
	if (sh[45] != 0) goto L100;  // SH != 0
	++shr[45];                   // след. шаг сч.шр45
	if (shr[45] > 2) goto L0;    // число шагов режима
	sh[45] = 1;
L100:   return;                   // возврат в "кольцо"

L0:	shr[45] = 0;
	goto L100;

L1: GoPderjatel(0, 0, 0, 1, 0); // п/держ. в исходное
    goto L101;
L2:	KR_VNIZ();
	goto L101;
}
//---------------------------------------------------------------------------
void R_48 ()                    // режим 48 "Транспортный тест заслонки"
{
    sh_ = sh[48];
    switch ( shr[48] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            // заслонка в переукладку через исходное
            GoZaslonka(0, nasmod[2], 0, 0, 1);
            // если заслонка приехала, сбросить сч. вр.
            if ( !sh_ ) ct48 = 0;
        }; break;
        case 2:
        {
            // задержка между движениями
            if ( ct48 > tk48 )
            {
                // идти в угол №1 в массиве углов
                zaslStepNmb = 1;
                sh_ = 0;
            }
        }; break;
        case 3:
        {
            // прошли все серединные углы
            if ( zaslStepNmb > zaslStepMaxNmb )
                // перейти на 6 шаг
                shr[48] = 5;
            // не прошли все серединные углы, идти на 4 шаг
            sh_ = 0;
        }; break;
        case 4:
        {
            // заслонка в заданный угол
            GoZaslonka(zaslUgolAbs, nasmod[2] + zaslTrTestUgol[zaslStepNmb], 0, 0, 0);
            // если заслонка приехала, сбросить сч. вр.
            if ( !sh_ ) ct48 = 0;
        }; break;
        case 5:
        {
            // задержка между движениями
            if ( ct48 > tk48 )
            {
                // идти в след. угол в массиве углов
                zaslStepNmb++;
                // перейти на 3 шаг
                shr[48] = 2;
                sh_ = 0;
            }
        }; break;
        case 6:
        {
            // заслонка в переукладку
            GoZaslonka(zaslUgolAbs, nasmod[2], 0, 0, 0);
            // если заслонка приехала, сбросить сч. вр.
            if ( !sh_ )
            {
                zaslStepNmb = 0;
                norma = 49;
            }
        }; break;
    }

    // диспетчер
    if ( ! sh_ )
    {
        shr[48]++;
        sh_ = 1;
    }
    sh[48] = sh_;
}
//---------------------------------------------------------------------------
void R_49 ()                    // режим 49 "Транспортный тест барабана"
{
    shr[49] = 0;
	sh[49] = 0;
}
//---------------------------------------------------------------------------
void R_50 ()                    // режим 50 "Рассчет импульсов заслонки"
{
    switch ( shr[50] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            zaslPrRuch = true;  // запуск вручную
            sh_ = sh[50];
            CountZaslFRP();     // рассчет импульсов заслонки
            if (sh_==0)         // если подпрограмма рассчета завершена
            {
                zaslPrRuch = false; // запуск вручную убрать
                sh[50] = 0;     // дезактивизировать режим 50
                shr[50] = 0;    // "Рассчет импульсов заслонки"
            }
            sh[50] = sh_;
        }; break;
    }
}
//---------------------------------------------------------------------------
void R_52 ()                    // режим 52 "Рассчет импульсов барабана"
{
    switch ( shr[52] )
    {
        case 0: ;break;         // 0 - нет режима
        case 1:
        {
            pderjPrRuch = true;  // запуск вручную
            sh_ = sh[52];
            CountPderjFRP();    // рассчет импульсов п/держателя
            if (sh_==0)         // если подпрограмма рассчета завершена
            {
                pderjPrRuch = false; // запуск вручную убрать
                sh[52] = 0;     // дезактивизировать режим 50
                shr[52] = 0;    // "Рассчет импульсов п/держателя"
            }
            sh[52] = sh_;
        }; break;
    }
}
//------------------------------------------------------------------------------
//---------  ПОДПРОГРАММЫ  -----------------------------------------------------
//-------------------------поворот заслонки-------------------------------------
void VIDK_DZ(unsigned char a,unsigned char b,int c,bool d,unsigned int e)
// выдача команд на манип. перем.
{
	// a - скорость (0-бол.,1-мал.,2-ползущ.)
	// b - тип движения ( ABS | OTN )
	// c - путь (  )
	// d - признак движение в HOME
	// e - контр. время перемещения в сек
	
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	if (sh_ == 7) goto A7;
	else return;	// выход

A1:	if(diagnS[0]&0x20) return;		// нет связи с контроллером
	SetOut(0,0,0x2000);				// снять Стоп механизмов
	PR_DZ = 1;
	CT_DZ = 0;
	sh_ = 2;
A2:	if(!(zin[1]&0x400))				// нет готовности привода
	{
		if(CT_DZ >= 5)
			diagn[16] |= 0x01;		// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[16] &= (~0x01);			// сброс диагностики
	OTVET_DZ = 0;
	V_DZ = a;
	TYPE_DZ = b;
	PUT_DZ = c;
	HOME_DZ = d;
	KOM_DZ = 1;
	CT_DZ = 0;
    TEK_OTN_DZ = 0;
	sh_ = 3;
A3:	if(diagnS[0]&0x20 || !OTVET_DZ)	// есть диагностика нет связи или нет ответа
	{
		if(CT_DZ >= 5)
			diagn[16] |= 0x04;		// отказ: "Нет ответа на команду перем."
		return;
	}
	diagn[16] &= (~0x04);			// сброс диагностики
	KOM_DZ = 0;
	if(!HOME_DZ)					// не движение в HOME
	{
		SetOut(1,0,0x800);           // выдать движение
		CT_DZ = 0;
		sh_ = 6;
		return;
	}
	SetOut(1,0,0x1000);          		// выдать движение в Home
	CT_DZ = 0;
	sh_ = 4;
A4:	if(!(zin[1]&0x800)||(TEK_ABS_DZ))				// механизм не пришел в HOME
	{
		if(CT_DZ >= e*1000)
			diagn[16] |= 0x10;		// отказ: "Мех. перем. не пришел в пол. HOME"
		return;
	}
	diagn[16] &= (~0x10);			// сброс диагностики
	SetOut(0,0,0x1000);               // снять движение в Home
	sh_ = 5;
A5:	if(!(zin[1]&0x400))				// нет готовности привода
	{
		if(CT_DZ >= 5)
		diagn[16] |= 0x01;			// отказ: "Нет готовности привода перем."
		return;
	}
	diagn[16] &= (~0x01);			// сброс диагностики
	PR_DZ = 0;
	norma = 69;						//"Манипулятор перемещения пришел в исходном"
    SetOut(1,0,0x2000);				// выставить Стоп механизмов
	sh_ = 0;
	return;
A6:	if(zin[1]&0x400)				// есть готовность привода
	{
		if(CT_DZ >= 5)
			diagn[16] |= 0x04;		// отказ: "Нет ответа на START движ. перемещ."
		return;
	}
	diagn[16] &= (~0x04);			// сброс диагностики
	SetOut(0,0,0x800);               // сбросить начало движение
	CT_DZ = 0;
	sh_ = 7;
	return;
A7:	if(!(zin[1]&0x400)||((TYPE_DZ==ABS)&&(PUT_DZ!=TEK_ABS_DZ))||((TYPE_DZ==OTN)&&(PUT_DZ!=TEK_OTN_DZ))) // есть готовность привода
	{
		if(CT_DZ >= e*1000)
			diagn[16] |= 0x20;		// отказ: "Нет завершения движ. перемещ."
		return;
	}
	diagn[16] &= (~0x20);			// сброс диагностики
	PR_DZ = 0;
	norma = 68;						//"Манипулятор перемещения путь прошел"
    SetOut(1,0,0x2000);				// выставить Стоп механизмов
	sh_ = 0;
}

/*void VIDK_DZ_HOME(unsigned int a)
// перемещение механизма в Home
{
	// a - контр. время перемещения в сек (выдача диагностики)
	// VR_HOME(10);	// механизм перемещения в Home с 10 сек контр. временем

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	// выход

A1:	SetOut(0,0,0x2000);		// снять "стоп механизмов"
	PR_DZ = 1;
	CT_DZ = 0;
	sh_ = 2;
A2:	if(!(zin[1]&0x400))		// нет готовности привода
	{
		if(CT_DZ >= 2000)	// 2 сек в 1 мс тиках
			diagn[16] |= 0x01;	// диагностика "Нет готовности привода .."
		return;
	}
	diagn[16] &= (~0x01);			// сброс диагностики
	CT_DZ = 0;
    TEK_OTN_DZ = 0;
	SetOut(1,0,0x1000);           	// выдать сигнал движения в Home
	sh_ = 3;
A3:	if(!(zin[1]&0x800)||(TEK_ABS_DZ < -5)||(TEK_ABS_DZ > 5)) // механизм не пришел в Home
	{
		if(CT_DZ >= (a*1000))
			diagn[16] |= 0x10;		// отказ: "Привод .. не пришел в Home"
		return;
	}
	diagn[16] &= (~0x10);			// сброс диагностики
	SetOut(0,0,0x1000);               // снять движение в Home
	CT_DZ = 0;
	sh_ = 4;
A4:	if(!(zin[1]&0x400))				// нет готовности привода
	{
		if(CT_DZ >= 2000)			// 2 сек в 1 мс тиках
		diagn[16] |= 0x01;			// отказ: "Нет готовности привода.."
		return;
	}
	diagn[16] &= (~0x01);			// сброс диагностики
	PR_DZ = 0;
    SetOut(1,0,0x2000);				// выставить Стоп механизмов
	sh_ = 0;
}
//-----------------------------------------------------------------------------
void VIDK_DZ(bool prRS,unsigned char a,int b,int c,unsigned int d, unsigned int e)
// выдача команд на механизм для стандартных движений
{
	// prRS - необходимость записи задания по RS
	// a - тип движения (соответствует типам в контроллере стр.61):
	// ABS = 1 - по абсолютной координате
	// OTN = 2 - по относительной координате
	// CON = 7 - "бесконечное"
	// ABS_F = 10 - абс. движение в прямом напр. (для циклич.)
	// ABS_R = 11 - абс. движение в обратном напр. (для циклич.)
	// b - путь (в имп)
	// c - скорость (в имп/сек)
	// d - контр. время перемещения в сек (выдача диагностики)
	// e - время перемещения в сек (для движений по времени)
	// VIDK_VR(0,0,0,0,10,0); // движение по выбранным параметрам с 10 сек контр. временем
	// VIDK_VR(1,OTN,par[3],v_mech[0][1],15,0); // с записью параметров с 15 сек контр. временем
	// VIDK_VR(0,0,0,0,0,30); // движение по выбранным параметрам длительностью 30 сек
	// VIDK_VR(1,CON,0,par[2],0,0); // "бесконечное" движение без контроля окончания
	// VIDK_VR(0,0,0,0,0,0); // движение по выбранным параметрам без контроля окончания

	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	if (sh_ == 5) goto A5;
	if (sh_ == 6) goto A6;
	else return;	// выход

A1:	SetOut(0,0,0x2000);		// снять "стоп механизмов"
	PR_DZ = 1;
	if(!(zin[1]&0x400))				// нет готовности привода
	{
		diagn[16] |= 0x01;			// отказ: "Нет готовности привода перемещения"
		return;
	}
	diagn[16] &= (~0x01);				// сброс диагностики
	CT_DZ = 0;
	TYPE_DZ = a;
	PUT_DZ = b;
	V_DZ = c;
	TEK_OTN_DZ = 0;
	if(prRS)						// нужна запись задания
	{
		if(diagnS[0]&0x20) return;	// нет связи с контроллером
		KOM_DZ = 1;
		OTVET_DZ = 0;
		sh_ = 2;
		goto A2;					// переход на шаг 3
	}
	SetOut(1,0,0x800);           	// выдать сигнал старт движения
	CT_DZ = 0;
	sh_ = 3;						// переход на шаг 3
	goto A3;
A2:	if(diagnS[0]&0x20||(!OTVET_DZ))	// есть диагностика нет связи или нет ответа
	{
		if(CT_DZ >= 5000)
			diagn[16] |= 0x04;		// отказ: "Нет ответа на команду приводу перемещения"
		return;
	}
	diagn[16] &= (~0x04);			// сброс диагностики
	KOM_DZ = 0;
	SetOut(1,0,0x800);           		// выдать сигнал старт движения
	CT_DZ = 0;
	sh_ = 3;
A3:	if(zin[1]&0x400)					// готовность привода не пропала
	{
		if(CT_DZ >= 2000)
			diagn[16] |= 0x08;		// отказ: "Нет начала движения привода перемещения"
		return;
	}
	diagn[16] &= (~0x08);			// сброс диагностики
	SetOut(0,0,0x800);               // сбросить сигнал старт движения
	CT_DZ = 0;
	if(e)							// задано время движения
	{
		sh_ = 4;
		goto A4;					// переход на шаг 4
	}
	else if(d)						// задано контрольное время
	{
		sh_ = 6;
		goto A6;					// переход на шаг 6
	}
	sh_ = 0;						// выход без контроля окончания
	return;
A4:	if(CT_DZ <= (e*1000))		// время не вышло
		return;
	SetOut(1,0,0x2000);				// выставить Стоп механизмов
	CT_DZ = 0;
	sh_ = 5;
A5:	if(!(zin[1]&0x400))				// нет готовности привода
	{
		if(CT_DZ >= 2000)			// 2 сек в 1 мс тиках
			diagn[16] |= 0x20;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[16] &= (~0x20);			// сброс диагностики
	sh_ = 6;
	goto S1;
A6:	if(!(zin[1]&0x400)||(prRS&&(((a==ABS)&&((TEK_ABS_DZ < b-5)||(TEK_ABS_DZ > b+5)))||((a==OTN)&&((TEK_OTN_DZ < b-5)||(TEK_OTN_DZ > b+5))))))
	// нет готовности привода или пути не достигнуты для "RS-овских"
	{
		if(CT_DZ >= (d*1000))		// контрольное время движения
			diagn[16] |= 0x20 ;		// отказ: "Нет завершения движения привода перемещения"
		return;
	}
	diagn[16] &= (~0x20);				// сброс диагностики
S1:	PR_DZ = 0;
	norma =56 ;						// "Привод перемещения выполнил движение"
    SetOut(1,0,0x2000);				// выставить Стоп механизмов
	sh_ = 0;
}*/
//------------------------------------------------------------------------------
void NEOPR_POL_MEH()            // запись признаков неопр. пол. мех.
 {
  // if(aout[2] > 8192)
  // zaslPrNeopr = 1;
 }
//------------------------------------------------------------------------------
void SBROS_MEH() 				// режим "Сброс механизмов"
{
	// сброс движения барабана и заслонки
	// сброс режимов
	shr[40] = 0;           		// барабан в исх.
	sh[40]  = 0;
	shr[41] = 0;           		// барабан вперед.
	sh[41]  = 0;
	shr[42] = 0;           		// заслонка в исх
	sh[42]  = 0;
	shr[43] = 0;           		// заслонка вперед
	sh[43]  = 0;
	shr[48] = 0;           		// транс. тест засл
	sh[48]  = 0;

	shr[44] = 0;           		// крышка вверх
	sh[44]  = 0;
	shr[45] = 0;           		// крышка вниз
	sh[45]  = 0;

    A_OUT(0, 8192);			// сброс уставки скорости крышки
	SetOut(0,1,0x03);		// сброс сигналов старт, реверс крышки
    //SetOut(1,1,0x10);			// выдать сигнал сброс крышки


	diagn[4]&=(~0x3F);	// сброс диагностик барабана
    diagn[5]&=(~0x1F);	       	// сброс диагностик заслонки
		
	SetOut(0,0,0x0A);	// сброс вращения
	A_OUT(1,8192);
	A_OUT(2,8192);

	norma = 66;		// сброс механизмов завершен
}
//------------------------------------------------------------------------------
void SBROS_DZ() 				// режим "Сброс мех ДЗ"
{
    SetOut(1,0,0x2000);	// STOP
    SetOut(0,0,0x800);	// START
    SetOut(0,0,0x1000);	// HOME

	shr[37] = 0;           		// ДЗ открыть
	sh[37]  = 0;
	shr[38] = 0;           		// ДЗ закрыть HOME
	sh[38]  = 0;
	shr[39] = 0;           		// ДЗ дросс
	sh[39]  = 0;
	shr[53] = 0;           		// ДЗ вперед-назад
	sh[53]  = 0;

    //сброс диагностик и признаков движения
    PR_DZ = 0;
    diagn[16]&=(~0xFF);	// сброс диагностик ДЗ
    diagn[18]&=(~0xFF);	// сброс диагностик ДЗ
    diagn[13]&=(~0xC0);	// сброс диагностик ДЗ
}
//------------------------------------------------------------------------------
void VBPN ()	// подпрограмма "Включить БПН (сил. пит. на термодат)"
 {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	         else return;	   		// выход

A1:SetOut(0,1,0x0C);				// сброс выходных сигналов на вкл/откл
									// силового питания БПН
   CT_IST = 0;			   			// сброс сч.времени
   sh_ = 2;                        	// и ответов от БПН
A2:if (CT_IST<=T_VKL_BPN) return;  	// задержка на откл. реле и пускателя
   sh_ = 3;
A3:if ((zin[0]&0x80)!=0) goto S0;	//  силовое питание БПН включено
   SetOut(1,1,0x04);				// вкл. силовое питание БПН
   CT_IST = 0;						// сброс сч.времени
   sh_ = 4;
   return;
A4:if ((zin[0]&0x80)==0)			// нет включения силового питания БПН
    {
     if (CT_IST<=T_VKL_BPN) return;	// время не вышло
     diagn[1]|=0x08;				// отказ:"Силовое питание БПН не вкл."
     return;
    }
S0:SetOut(0,1,0x0C);				// сброс всех сигналов на вкл/выкл
									// силового питания БПН
   diagn[1]&=(~0x08);				// сброс диагностики
   sh_ = 0;
   norma = 1;                      // норма: "Силовое питание БПН включено"
 }
//------------------------------------------------------------------------------
void OBPN ()	// подпрограмма "Отключить БПН (сил. пит. на термодат)"
 {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	         else return;      // выход

A1:SetOut(0,1,0x0C);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
   SetOut(1,1,0x08);		   	// выкл. силового питания БПН
   CT_IST = 0;			   		// сброс сч.времени
   sh_ = 2;
A2:if ((zin[0]&0x80)!=0)	   	// силовое питание включено
    {
     if (CT_IST<=T_VKL_BPN) return;// время не вышло
     diagn[1]|=0x80;	           // отказ:"Силовое питание БПН не выкл."
     return;
    }
   SetOut(0,1,0x0C);		   	// сброс выходных сигналов на вкл/откл
								// силового питания БПН
   diagn[1]&=(~0x80);		   	// сброс диагностики
   sh_ = 0;
   norma = 2;					// норма: "Силовое питание БПН отключено"
 }
//------------------------------------------------------------------------------
void VKBPM1 ()	// подпрограмма "Включить коммутатор М1"
 {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	        // выход

A1:	if((zin[0] & 0x300) == 0x100) goto S0;	// есть включение коммут. М1
	sh_ = 2;
A2:	if((zin[1] & 0x100) == 0)				// нет выкл. вых мощн. БПМ
    {
		diagn[3]|=0x04;						// отказ: "Вых. мощ. БПМ не выключ."
		return;
    }
	diagn[3]&=(~0x04);						// сброс диагностики
	SetOut(0,0,0x300);						// отключение обоих каналов коммут.
	CT_IST = 0;								// сброс счетчика
	sh_ = 3;
A3:	if(CT_IST <= T_VKL_BPN) return;			// задержка на откл. пускателя
	SetOut(1,0,0x100);                   	// вкл. коммутатор М1
	CT_IST = 0;                           	// сброс счетчика
	sh_ = 4;
A4:	if((zin[0] & 0x300) != 0x100)        	// М2 подключен
    {
		if(CT_IST < T_KL) return;          	// задержка
		diagn[3]|=0x08;                   	// отказ: "Нет подкл. М1"
		return;
    }
	diagn[3]&=(~0x08);                    	// сброс диагностики
S0:	norma = 11;                          	// норма: "М1 подключен"
	sh_ = 0;
 }
 //------------------------------------------------------------------------------
void VKBPM2 ()	// подпрограмма "Включить коммутатор М2"
 {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	if (sh_ == 3) goto A3;
	if (sh_ == 4) goto A4;
	else return;	        // выход

A1:	if((zin[0] & 0x300) == 0x200) goto S0;   // есть включение коммут. М2
	sh_ = 2;
A2:	if((zin[1] & 0x100) == 0)            // нет выкл. вых мощн. БПМ
    {
		diagn[3]|=0x04;              // отказ: "Вых. мощ. БПМ не выключ."
		return;
    }
	diagn[3]&=(~0x04);                   // сброс диагностики
	SetOut(0,0,0x300);                   // отключение обоих каналов коммут.
	CT_IST = 0;                          // сброс счетчика
	sh_ = 3;
A3:	if(CT_IST <= T_VKL_BPN) return;      // задержка на откл. пускателя
	SetOut(1,0,0x200);                   // вкл. коммутатор М2
	CT_IST = 0;                          // сброс счетчика
	sh_ = 4;
A4:	if((zin[0] & 0x300) != 0x200)        // М3 подключен
    {
		if(CT_IST < T_KL) return;    // задержка
		diagn[3]|=0x10;              // отказ: "Нет подкл. М2"
		return;
    }
	diagn[3]&=(~0x10);                   // сброс диагностики
S0:	norma = 12;                          // норма: "М2 подключен"
	sh_ = 0;
 }
//------------------------------------------------------------------------------
void OKBPM ()	// подпрограмма "Отключить коммутатор БПМ"
 {
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	        // выход

A1:	if((zin[1] & 0x100) == 0)            // нет выкл. вых мощности
	{
		diagn[3]|=0x04;                    // отказ: "Вых. мощность БПМ не выключена"
		return;
	}
	diagn[3]&=(~0x04);                    // сброс диагностики
	SetOut(0,0,0x300);
	CT_IST = 0;
	sh_ = 2;
A2:	if((zin[0] & 0x300) != 0)            // магнетроны не отключены
	{
		if(CT_IST < T_KL) return;          // задержка
		diagn[3]|=0x20;                   // отказ: "Нет откл. магнетронов"
		return;
    }
	diagn[3]&=(~0x20);                    // сброс диагностики
	norma = 13;                           // норма: "Магнетроны отключены"
	sh_ = 0;
 }
//---------------------------------------------------------------------------
void VRR_GIS()						// подпрограмма "Выставить разр. работы ВЧМ"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
    if (sh_ == 3) goto A3;
	else return;	// выход

A1:	SetOut(1,2,0x04);				// выставить разр.раб. ВЧМ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;

A2:	if((zin[2] & 0x01) == 0)		// разр.раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[21] |= 0x10;			// отказ:"Разр. работы ВЧМ не выставилось"
        return;
	}
	diagn[21] &= (~0x10);			// сброс диагностики
    CT_VHG = 0;
    sh_ = 3;

A3: if((zin[2] & 0x02) == 0)		// готовность .раб. не выставлено
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[21] |= 0x40;			// отказ:"Готовность. работы ВЧМ не выставилось"
        return;
	}
	diagn[21] &= (~0x40);			// сброс диагностики
    SetOut(1,2,0x08);           // вкл ДУ
    sh_ = 0;
}
//------------------------------------------------------------------------------
void ORR_GIS()						// подпрограмма "Снять разр. работы ВЧМ"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;	// выход

A1:	SetOut(0,2,0x04);				// снять разр.раб. ВЧМ
	CT_VHG = 0;					// сброс сч.времени
	sh_ = 2;
A2:	if((zin[2] & 0x01) != 0)		// разр.раб. не снято
	{
		if(CT_VHG <= T_VHG) return;	// время не вышло
		diagn[21] |= 0x20;			// отказ: "Разр. работы ВЧМ"
		return;
	}
	diagn[21] &= (~0x20);			// сброс диагностики
        SetOut(0,2,0x08);				// снять ДУ ВЧМ
	sh_ = 0;
}
//------------------------------------------------------------------------------
void KR_VVERH ()				// подпрограмма "Крышка вверх"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;				// выход

A1: A_OUT(0, 8192);				// сброс уставки скорости
	SetOut(0,1,0x03);			// сброс сигналов старт, реверс
    if (!(zin[1]&0x10) && (zin[1]&0x20))   //    (((zin[1] & 0x30) == 0x20))
    {
        sh_ = 2;
        goto A2_1;
    }
    SetOut(1,1,0x01);			// старт
    SetOut(0,1,0x02);			// сброс  реверс
    A_OUT(0,8192 + 2*410);		// уставка скорости
	CT_KR = 0;
	sh_ = 2;
    return;

A2:	if ((zin[1]&0x10) || !(zin[1]&0x20) )   // было         (!((zin[1] & 0x30) == 0x20))
    {
		if(CT_KR > T_KKR)
        {
			diagn[6] |= 0x40;	        // диагностика "Крышка не поднялась"
            A_OUT(0,8192);				// сброс уставки скорости
            SetOut(0,1,0x03);			// сброс сигналов старт, реверс
        }
		return;
    }
    diagn[6] &= (~0x40);		// сброс диагностики
A2_1:A_OUT(0,8192);				// сброс уставки скорости
    SetOut(0,1,0x03);			// сброс сигналов старт, реверс
	sh_ = 0;
    return;
}
//------------------------------------------------------------------------------
void KR_VNIZ ()					// подпрограмма "Крышка вниз"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;				// выход

A1: A_OUT(0, 8192);				// сброс уставки скорости
	SetOut(0,1,0x03);			// сброс сигналов старт, реверс
    if ((zin[1]&0x10) && (!(zin[1]&0x20)))    //  ((zin[1] & 0x30) == 0x10)
    {
        sh_ = 2;
        goto A2_1;
    }
    SetOut(0,1,0x01);			// старт
    SetOut(1,1,0x02);			// сброс  реверс
    A_OUT(0,8192 + 2*410);		// уставка скорости
	CT_KR = 0;
	sh_ = 2;
    return;

A2:	if ((!(zin[1]&0x10)) || (zin[1]&0x20))    //  (!(zin[1] & 0x30) == 0x10)
    {
		if(CT_KR > T_KKR)
        {
			diagn[6] |= 0x80;	        // диагностика "Крышка не опустилась"
            A_OUT(0,8192);				// сброс уставки скорости
            SetOut(0,1,0x03);			// сброс сигналов старт, реверс
        }
		return;
    }
    diagn[6] &= (~0x80);		// сброс диагностики
A2_1:A_OUT(0,8192);				// сброс уставки скорости
    SetOut(0,1,0x03);			// сброс сигналов старт, реверс
	sh_ = 0;
    return;
}
//------------------------------------------------------------------------------
void NAP_KAM ()					// подпрограмма "Напуск в камеру"
{
	if (sh_ == 1) goto A1;
	if (sh_ == 2) goto A2;
	else return;				// выход

A1: if(nasmod[36]==1)
    {
        SetOut(1,1,0x4000);		        // открыть Кл5
        SetOut(0,1,0x8000);		        // закрыть Кл-НАП
    }
    else
    {
        SetOut(0,1,0x4000);		        // закрыть Кл5
        SetOut(1,1,0x8000);		        // открыть Кл-НАП
    }
	if((diagnS[0] & 0x01) != 0) return; // нет связи c D1
	if(D_D1 < UVAK_ATM) return;		// проверка ур. вакуума по D1
    SetOut(0,1,0x4000);		        // закрыть Кл5
    SetOut(1,1,0x8000);		        // открыть Кл-НАП
    CT_NAP = 0;
    sh_ = 2;

A2: if(CT_NAP < 30) return;
    sh_ = 0;
}
//---------------------------------------------------------------------------
void MEH_AVAR_SBROS()			// сброс аварий механизма (не в кольце)
{
	SetOut(1,0,0x4000);			// выдать сигнал "Сброс аварий мех"(по кнопке)

}

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
