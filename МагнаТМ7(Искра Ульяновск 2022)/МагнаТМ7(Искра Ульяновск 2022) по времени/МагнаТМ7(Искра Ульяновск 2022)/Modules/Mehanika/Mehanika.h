#ifndef MehanikaH
#define MehanikaH
//---------------------------------------------------------------------------
//--КОЛИЧЕСТВО ОБОРОТОВ--//
//---------------------------------------------------------------------------
float
    //zaslAngle360 = 258356.0,
    zaslAngle360 = 1033348.0,
    dzaslAngle360 = 108160.0,
    pderjAngle360 = 400.0;
//---------------------------------------------------------------------------
//--ЗАСЛОНКА--//
//---------------------------------------------------------------------------
bool
    pr_op_zasl = false,     // признак первого включения

    zaslPrRuch = false,     // признак запуска подпрограммы вручную
                            // true (1) - запустили вручную
                            // false (0) - запустили из автомата
    zaslPrNeopr = true,     // признак неопределенного положения
                            // механизма заслонки
                            // true (1) - положение неопределено
                            // false (0) - положение определено
    zaslPrIsh = false,      // признак пересечения исходника
                            // механизмом заслонки
                            // true (1) - пересекал
                            // false (0) - не пересекал
    zaslPrNahVIsh = false,  // признак нахождения механизма в исходном положении
                            // true (1) - находится
                            // false (0) - не находится
    zaslPrFront2 = false;   // признак пересечения заслонкой второго фронта исх.
                            // true (1) - пересёк
                            // false (0) - не пересёк
unsigned char
    zaslStepNmb = 0,        // текущий шаг транспортного теста
    zaslStepMaxNmb = 0;     // максимальный шаг транспортного теста
unsigned int
    ctZaslOpros = 0,        // (мс) задержка на опрос заслонки
    ctZaslDvij = 0,         // (тик) счетчик времени движения заслонки
    ctZaslErr = 0,          // (тик) счетчик времени обнаружения ошибок
    tkZaslOpros = 0,        // (мс) 1 мс задержка на опрос ФРП заслонки
    tkZaslIzIsh = 100,      // (тик) 2 сек, контр. сч. времени выхода из исх.
    tkZaslDvij = 12000,      // (тик) 120 сек, контр. счетчик на все движения засл.
    tkZaslRazgon = 150,     // (тик) 3 сек, к. время разгона механизма
    tkZaslBezDvij = 100;    // (тик) 2 сек, к. сч. на окончание изменения ФРП
long
    zaslCountFRP = 0,       // (код) количество импульсов ФРП в 360 градусах
    zaslP1 = 0,             // (код) путь разгона механизма заслонки
    zaslP4 = zaslAngle360 / 360.0, // (код) 1 градус путь торможения механизма заслонки
    zaslPutMin = zaslAngle360 * 5.0 / 360.0, // (код) 3 градуса минимальный путь движения
    zaslUgolPodhoda = 40,   // (код) угол подхода к заданному
    zaslPutZad = 0,         // (код) задание пути
    zaslPutTek = 0,         // (код) тек. знач. пройденного пути, счетчик пути
    zaslUgolPred = 0,       // (код) значение предыдущего положения ФРП
    zaslUgolTek = 0,        // (код) значение текущего положения ФРП
    zaslUgolAbs = 0,        // (код) абсолютное значение угла механизма засл.
#define TR_TEST_UGOL_COUNT 256
    zaslTrTestUgol[TR_TEST_UGOL_COUNT]; // (код) значения углов гранспортного теста
// Внутренние подпрограммы
void CountZaslFRP();        // рассчет кол-ва импульсов в 360 градусах
void ZaslVibNapr();         // выбор и установка направления на заслонку
void SetZaslPut(long, long);// рассчет заданного пути
unsigned char ZaslDvijAnalis(); // анализ наличия сбоев в движении заслонки
void SetZaslV(float vMin, float vMax); // подпрограмма рассчета и выдачи скорости
// подпрограмма движения механизма заслонки
unsigned char GoZaslonka(long zaslUgol1, long zaslUgol2, bool izIsh, bool vIsh, bool cherezIsh);
/*
//---------------------------------------------------------------------------
//--Д.ЗАСЛОНКА--//
//---------------------------------------------------------------------------
bool
    dzaslPrRuch = false,    // признак запуска подпрограммы вручную
                            // true (1) - запустили вручную
                            // false (0) - запустили из автомата
    dzaslPrNeopr = true,    // признак неопределенного положения
                            // механизма д.заслонки
                            // true (1) - положение неопределено
                            // false (0) - положение определено
    dzaslPrIsh = false,     // признак пересечения исходника
                            // механизмом дросс. заслонки
                            // true (1) - пересекал
                            // false (0) - не пересекал
    dzaslPrNahVIsh = false, // признак нахождения механизма в исходном положении
                            // true (1) - находится
                            // false (0) - не находится
    dzaslPrFront2 = false;  // признак пересечения д.заслонкой второго фронта исх.
                            // true (1) - пересёк
                            // false (0) - не пересёк
unsigned int
    ctDzaslOpros = 0,       // (мс) задержка на опрос заслонки
    ctDzaslDvij = 0,        // (тик) счетчик времени движения д.заслонки
    ctDzaslErr = 0,         // (тик) счетчик времени обнаружения ошибок
    tkDzaslOpros = 0,       // (мс) 1 мс задержка на опрос ФРП д/заслонки
    tkDzaslIzIsh = 100,     // (тик) 2 сек, контр. сч. времени выхода из исх.
    tkDzaslDvij = 7500,     // (тик) 150 сек, контр. счетчик на все движения д.засл.
    tkDzaslRazgon = 150,    // (тик) 3 сек, к. время разгона механизма
    tkDzaslBezDvij = 100;   // (тик) 2 сек, к. сч. на окончание изменения ФРП
long
    dzaslCountFRP = 0,      // (код) количество импульсов ФРП в 360 градусах
    dzaslP1 = 0,            // (код) путь разгона механизма д.заслонки
    dzaslP4 = dzaslAngle360 / 360.0, // (код) 1 градус путь торможения механизма д.заслонки
    dzaslPutMin = dzaslAngle360 * 3.0 / 360.0, // (код) 3 градуса минимальный путь движения
    dzaslUgolPodhoda = 40,  // (код) угол подхода к заданному
    dzaslPutZad = 0,        // (код) задание пути
    dzaslPutTek = 0,        // (код) тек. знач. пройденного пути, счетчик пути
    dzaslUgolPred = 0,      // (код) значение предыдущего положения ФРП
    dzaslUgolTek = 0,       // (код) значение текущего положения ФРП
    dzaslUgolAbs = 0;       // (код) абсолютное значение угла механизма д.засл.
// Внутренние подпрограммы
void CountDzaslFRP();       // рассчет кол-ва импульсов в 360 градусах
void DzaslVibNapr(long, long); // выбор и установка направления на д.заслонку
void SetDzaslPut(long, long); // рассчет заданного пути
unsigned char DzaslDvijAnalis(); // анализ наличия сбоев в движении д.заслонки
void SetDzaslV(float vMin, float vMax); // подпрограмма рассчета и выдачи скорости
// подпрограмма движения механизма заслонки
unsigned char GoDZaslonka(long dzaslUgol1, long dzaslUgol2, bool izIsh, bool vIsh, bool cherezIsh);
*/
//---------------------------------------------------------------------------
//--П/ДЕРЖАТЕЛЬ--//
//---------------------------------------------------------------------------
bool
    pderjPrRuch = false,    // признак запуска подпрограммы вручную
                            // true (1) - запустили вручную
                            // false (0) - запустили из автомата
    pderjPrNeopr = true,    // признак неопределенного положения
                            // механизма п/держателя
                            // true (1) - положение неопределено
                            // false (0) - положение определено
    pderjPrIsh = false,     // признак пересечения исходника
                            // механизмом п/держателя
                            // true (1) - пересекал
                            // false (0) - не пересекал
    pderjPrNahVIsh = false, // признак нахождения механизма в исходном положении
                            // true (1) - находится
                            // false (0) - не находится
    pderjPrFront2 = false;  // признак пересечения п/держ. второго фронта исх.
                            // true (1) - пересёк
                            // false (0) - не пересёк
unsigned char
    pderjStepNmb = 0,       // текущий шаг транспортного теста
    pderjStepMaxNmb = 0;    // максимальный шаг транспортного теста
unsigned int
    ctPderjOpros = 0,       // (мс) задержка на опрос п/держателя
    ctPderjDvij = 0,        // (тик) счетчик времени движения п/держателя
    ctPderjErr = 0,         // (тик) счетчик времени обнаружения ошибок
    tkPderjOpros = 0,       // (мс) 1 мс задержка на опрос ФРП п/держателя
    tkPderjIzIsh = 100,     // (тик) 2 сек, контр. сч. времени выхода из исх.
    tkPderjDvij = 7500,     // (тик) 150 сек, контр. счетчик на все движения п/держателя
    tkPderjRazgon = 150,    // (тик) 3 сек, к. время разгона механизма
    tkPderjBezDvij = 100;   // (тик) 2 сек, к. сч. на окончание изменения ФРП
long
    pderjCountFRP = 0,      // (код) количество импульсов ФРП в 360 градусах
    pderjP1 = 0,            // (код) путь разгона механизма п/держателя
    pderjP4 = pderjAngle360 / 360.0, // (код) 1 градус путь торможения механизма п/держателя
    pderjPutMin = pderjAngle360 * 3.0 / 360.0 , // (код) 3 градуса минимальный путь движения
    pderjUgolPodhoda = 40,  // (код) угол подхода к заданному
    pderjPutZad = 0,        // (код) задание пути
    pderjPutTek = 0,        // (код) тек. знач. пройденного пути, счетчик пути
    pderjUgolPred = 0,      // (код) значение предыдущего положения ФРП
    pderjUgolTek = 0,       // (код) значение текущего положения ФРП
    pderjUgolAbs = 0;       // (код) абсолютное значение угла механизма п/держателя
    pderjTrTestUgol[TR_TEST_UGOL_COUNT]; // (код) значения углов гранспортного теста
// Внутренние подпрограммы
void CountPderjFRP();       // рассчет кол-ва импульсов в 360 градусах
void PderjVibNapr();        // выбор и установка направления на п/держателя
void SetPderjPut(long, long); // рассчет заданного пути
unsigned char PderjDvijAnalis(); // анализ наличия сбоев в движении п/держателя
void SetPderjV(float vMin, float vMax); // подпрограмма рассчета и выдачи скорости
// подпрограмма движения механизма подложкодержателя
unsigned char GoPderjatel(long pderjUgol1, long pderjUgol2, bool izIsh, bool vIsh, bool cherezIsh);
// Для рассчета скорости барабана !!!
unsigned long
        putPderjSpd = 0;        // предыдущее знаечение пути
unsigned int
        pderjSpeed = 0;         // скорость барабана обор/мин

unsigned int
    M1_N = 0,       // границы зон съема сопротивления
    M1_V = 0,
    VCHM_N = 0,
    VCHM_V = 0,
    M2_N = 0,
    M2_V = 0;
//---------------------------------------------------------------------------
extern
    unsigned int
        zin[],
        out[],
        nasmod[];
extern
    unsigned char
        sh_,
        norma,
        diagn[];
//---------------------------------------------------------------------------
extern void A_OUT(unsigned int Nmb, unsigned int Value);    // задание аналогового выхода
extern void SetOut( bool, unsigned char, unsigned int);     // управление дискретным сигналом
//---------------------------------------------------------------------------
#endif
