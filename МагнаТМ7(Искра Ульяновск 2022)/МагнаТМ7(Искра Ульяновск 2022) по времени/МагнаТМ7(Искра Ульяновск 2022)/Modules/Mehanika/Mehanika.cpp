#include "Mehanika.h"
#include "Modules\Mehanika\pci1784\pci1784.cpp"
//---------------------------------------------------------------------------
//--Рассчет кол-ва импульсов в 360 градусах--//
//---------------------------------------------------------------------------
void CountZaslFRP()
{
    // анализ работы механизма в движении
    if ( ( sh_ > 1 ) && ZaslDvijAnalis() ) return;
    switch ( sh_ )
    {
        // ШАГ1. Выдача уставки анализ положения механизма
        case 1:
        {
            // выдать минимальную уставку скорости
            A_OUT(2, nasmod[16]);
            // выдать направление движения
            ZaslVibNapr();
            // находимся в исходнике?
            if ( zin[1] & 0x0008 )  sh_ = 2;   // В исх -> 2 шаг
            else                    sh_ = 3;   // НЕ в исх. -> 3 шаг
            // сбросили сч. времени обнаружения ошибок
            ctZaslErr = 0;
        }; break;
        // ШАГ2. Ожидание ВЫХОДА из исходника
        case 2:
        {
            // вышли из исходника
            if ( ! (zin[1] & 0x0008 ) ) sh_ = 3;
        }; break;
        // ШАГ3. Ожидание ВХОДА в исходник
        case 3:
        {
            // вышли в исходник
            if ( zin[1] & 0x0008 )
            {
                // сбросить счетчик ФРП механизма
                SetChannel2_0();
                // выставить в ноль предыдущий угол
                zaslUgolPred = 0;
                // выставить в ноль текущий угол
                zaslUgolTek = 0;
                sh_ = 4;
            }
        }; break;
        // ШАГ4. Ожидание ВЫХОДА из исходника
        case 4:
        {
            // вышли из исходника
            if ( ! (zin[1] & 0x0008 ) ) sh_ = 5;
        }; break;
        // ШАГ5. Ожидание ВХОДА в исходник, рассчет импульсов ФРП, выход
        case 5:
        {
            // вышли в исходник
            if ( zin[1] & 0x0008 )
            {
                // сбросить счетчик ФРП механизма
                zaslCountFRP = zaslUgolTek;
                // сбросить скорости
                A_OUT(2, 8192);
                // сброс направления движения
                SetOut(0, 0, 0x0008);
                norma = 46;
                sh_ = 0;
            }
        }; break;
    }
}
//---------------------------------------------------------------------------
//--Подпрограмма движения механизма заслонки--//
//---------------------------------------------------------------------------
unsigned char GoZaslonka(long zaslUgol1, long zaslUgol2, bool izIsh, bool vIsh, bool cherezIsh)
{
    while ( zaslUgol1 < 0 ) zaslUgol1 += zaslAngle360;
    while ( zaslUgol1 >= zaslAngle360 ) zaslUgol1 -= zaslAngle360;
    while ( zaslUgol2 < 0 ) zaslUgol2 += zaslAngle360;
    while ( zaslUgol2 >= zaslAngle360 ) zaslUgol2 -= zaslAngle360;
    switch ( sh_ )
    {
        // ШАГ 1. Анализ положения механизма, задание мин. скор. и направления
        case 1:
        {
            // если расстояние между заданными углами менее контрольного
            if  (
                    (
                        ( ( abs ( zaslUgol1 - zaslUgol2 ) ) < zaslPutMin ) ||
                        ( ( abs ( zaslUgol1 - zaslUgol2 ) ) > ( zaslAngle360 - zaslPutMin ) )
                    ) &&
                    ( !cherezIsh ) &&
                    ( !vIsh ) &&
                    ( !zaslPrRuch ) &&
                    ( zaslUgol1 != zaslUgol2 )
                )
            {
                // норма: "Мех. заслонки путь прошёл"
                norma = 15;
                // завершение подпрограммы
                sh_ = 0;
                // выход из подпрограммы
                return 7;
            }
            // движение ИЗ исходника?
            if ( izIsh )
            {
                // нет датчика исходного положения?
                if ( ! ( zin[1] & 0x0008 ) )
                {
                    // отказ: "механизм заслонки не в исходном"
                    diagn[5] |= 0x01;
                    // выход из подпрограммы
                    return 1;
                }
                // есть датчик исходного положения
                else
                {
                    // выставить признак нахождения в исходном
                    zaslPrNahVIsh = true;
                    // сброс диагностики
                    diagn[5] &= (~0x01);
                }
            }
            // движение В исходник?
            if ( vIsh )
            {
                // есть датчик исходного положения?
                if ( zin[1] & 0x0008 )
                {
                    // выставить признак нахождения в исходном
                    zaslPrNahVIsh = true;
                    // сбросить признак неопределенного положения механизма
                    zaslPrNeopr = false;
                    // норма: "Мех. заслонки в исходнике"
                    norma = 28;
                    // завершение подпрограммы
                    sh_ = 0;
                    // выход из подпрограммы
                    return 2;
                }
            }
            // выбор и установка направления заслонки
            ZaslVibNapr();
            // выставить минимальную скорость
            A_OUT(2, nasmod[16]);
            // сброс сч. времени
            ctZaslDvij = 0;
            // переход на следующий шаг
            sh_ = 2;
        }; break;
        // ШАГ 2. Анализ выхода из исходника
        case 2:
        {
            // механизм в исходном и движение из исходного
            if ( izIsh && ( zin[1] & 0x0008 ) )
            {
                // выставить признак нахождения в исходном
                zaslPrNahVIsh = true;
                // сбросить признак неопределенного положения механизма
                zaslPrNeopr = false;
                // время ожидания выхода из исходника вышло
                if ( ctZaslDvij > tkZaslIzIsh )
                {
                    // сброс направления движения
                    SetOut(0, 0, 0x0008);
                    // сброс скорости
                    A_OUT(2, 8192);
                    // отказ: "нет выхода мех. из исходного"
                    diagn[5] |= 0x02;
                }
            }
            // механизм не в исходном положении
            else
            {
                // выставить ФРП заслонки в ноль
                SetChannel2_0();
                // сброс дигностики
                diagn[5] &= (~0x02);
                // сброс сч. пути
                zaslPutTek = 0;
                // сброс сч. времени
                ctZaslDvij = 0;
                // сброс сч. ошибок
                ctZaslErr = 0;
                // возможно считать датчик ФРП?
                if ( ctZaslOpros >= tkZaslOpros )
                {
                    // сбросить счётчик опроса ФРП
                    ctZaslOpros = 0;
                    // считать текущее значение угла механизма
                    zaslUgolTek = GetChannel2();
                }
                else return 5;
                // приравнять предыдущее текущему
                zaslUgolPred = zaslUgolTek;
                // время разгона механизма обнулить
                zaslP1 = 0;
                // сбросить признак пересечения 2 фронта исходника
                zaslPrFront2 = false;
                // сбросить признак пересечения исх. положения
                zaslPrIsh = false;
                // рассчитать заданный путь
                SetZaslPut(zaslUgol1, zaslUgol2);
                // перейти на следующи шаг
                sh_ = 3;
            }
        }; break;
        // ШАГ 3. Движение механизма
        case 3:
        {
            // если нет сбоев в движении механизма
            if ( ! ZaslDvijAnalis() )
            {
                // пересчитать абсолютное значение угла
                if ( ! zaslPrNeopr )
                    zaslUgolAbs += abs(zaslUgolTek-zaslUgolPred);
                // механизм в исходном положении
                if ( zin[1] & 0x0008 )
                {
                    // выставить признак нахождения в исходном
                    zaslPrNahVIsh = true;
                    // сбросить признак неопределенного положения механизма
                    zaslPrNeopr = false;
                    // выставить признак прохождения мех. через исходное
                    zaslPrIsh = true;
                    // движение должно окончиться в исходном положении?
                    if ( vIsh )
                    {
                        pr_op_zasl = true;
                        // сброс направления движения
                        SetOut(0, 0, 0x0008);
                        // сброс скорости
                        A_OUT(2, 8192);
                        // сброс сч. времени
                        ctZaslDvij = 0;
                        // норма: "Мех. заслонки в исходнике"
                        norma = 28;
                        // перейти на следующий шаг
                        sh_ = 4;
                        // выход из подпрограммы
                        return 4;
                    }
                }
                // механизм не в исходном положении
                else
                {
                    // если произошёл выход из исходника
                    if ( zaslPrNahVIsh )
                    {
                        // сбросить сч. абс. значения угла
                        zaslUgolAbs = 0;
                        // сбросить признак нахождения в исходном
                        zaslPrNahVIsh = false;
                        // выставить признак пересечения 2 фронта исходника
                        zaslPrFront2 = true;
                    }
                }
                // движение через исходное и нет признака пересеч. исх.
                if ( cherezIsh && ( ! zaslPrFront2 ) )
                    // выход из подпрограммы
                    return 3;
                // пересчитать пройденный путь
                zaslPutTek +=  abs(zaslUgolTek-zaslUgolPred);
                // если начальное положение определено
                if ( ! zaslPrNeopr )
                    // рассчитать и выдать скорость движения
                    SetZaslV(nasmod[16], nasmod[12]);
                // если движение не в исходник и путь пройден
                if  ( ! vIsh &&
                        (
                            // для ручного режима
                            ( zaslPrRuch && ( zaslPutZad <= zaslPutTek ) ) ||
                            // для автоматического режима
                            ( ( ! zaslPrRuch ) && ( abs ( zaslUgolAbs - zaslUgol2 ) < zaslUgolPodhoda ) )
                        )
                    )
                {
                        pr_op_zasl = true;
                        // сброс направления движения
                        SetOut(0, 0, 0x0008);
                        // сброс скорости
                        A_OUT(2, 8192);
                        // сброс сч. времени
                        ctZaslDvij = 0;
                        // норма: "Мех. заслонки путь прошёл"
                        norma = 15;
                        // перейти на следующи шаг
                        sh_ = 4;
                }
            }
        }; break;
        // ШАГ 4. Инерционность останова механизма
        case 4:
        {
            // возможно считать датчик ФРП?
            if ( ctZaslOpros >= tkZaslOpros )
            {
                // сбросить счётчик опроса ФРП
                ctZaslOpros = 0;
                // считать текущее значение угла механизма
                zaslUgolTek = GetChannel2();
            }
            else return 6;
            // пересчитать абсолютное значение угла
            // if ( ! zaslPrNeopr )
                zaslUgolAbs += abs(zaslUgolTek-zaslUgolPred);
            // если произошёл выход из исходника и был признак нахождения в исходнике
            if ( zaslPrNahVIsh && ( ! ( zin[1] & 0x0008 ) ) )
            {
                // сбросить сч. абс. значения угла
                zaslUgolAbs = 0;
                // сбросить признак нахождения в исходном
                zaslPrNahVIsh = false;
            }
            else if ( zin[1] & 0x0008 )
                // выставить признак нахождения в исходном
                zaslPrNahVIsh = true;
            // если текущий угол не равен предыдущему
            if ( zaslUgolTek != zaslUgolPred )
                // сброс сч. времени
                ctZaslDvij = 0;
            // вышло время без движения
            if ( ctZaslDvij > tkZaslBezDvij )
                // выход из подпрограммы
                sh_ = 0;
            // приравнять предыдущее значение угла текущему
            zaslUgolPred = zaslUgolTek;
        }; break;
        // НЕОПОЗНАННЫЙ ШАГ. Окончание подпрограммы
        default: sh_ = 0; break;
    }
    // выход из подпрограммы
    return 0;
}
//---------------------------------------------------------------------------
//--Подпрограмма анализа сбоев в движении--//
//---------------------------------------------------------------------------
unsigned char ZaslDvijAnalis()
{
    // приравнять предыдущее значение угла текущему
    zaslUgolPred = zaslUgolTek;
    // возможно считать датчик ФРП?
    if ( ctZaslOpros >= tkZaslOpros )
    {
        // сбросить счётчик опроса ФРП
        ctZaslOpros = 0;
        // считать текущее значение угла механизма
        zaslUgolTek = GetChannel2();
    }
    else return 0;
    // если текущее значение менее предыдущего
    if ( zaslUgolTek < zaslUgolPred )
    {
        // отказ: "Сбой мех. заслонки в движении: КОД1"
        diagn[5] |= 0x08;
        // сброс направления движения
        SetOut(0, 0, 0x0008);
        // сброс скорости
        A_OUT(2, 8192);
        // вернуть код 1
        return 1;
    }
    // если нет изменения текущего значения угла
    else if ( zaslUgolTek == zaslUgolPred )
    {
        // время отсутствия изменений более контрольного
        if ( ctZaslErr > tkZaslBezDvij )
        {
            // отказ: "Сбой мех. заслонки в движении: КОД2"
            diagn[5] |= 0x10;
            // сброс направления движения
            SetOut(0, 0, 0x0008);
            // сброс скорости
            A_OUT(2, 8192);
            // вернуть код 2
            return 2;
        }
    }
    // если время движения вышло
    else if ( ctZaslDvij > tkZaslDvij )
    {
            // отказ: "Сбой мех. заслонки в движении: КОД2"
            diagn[5] |= 0x04;
            // сброс направления движения
            SetOut(0, 0, 0x0008);
            // сброс скорости
            A_OUT(2, 8192);
            // вернуть код 3
            return 3;
    }
    else
    {
        // сброс диагностик
        diagn[5] &= (~0x18);
        // сброс сч. времени
        ctZaslErr = 0;
        // вернуть код 0
        return 0;
    }
}
//---------------------------------------------------------------------------
//--Подпрограмма рассчета скорости--//
//---------------------------------------------------------------------------
void SetZaslV(float vMin, float vMax)
{   
    // рассчетная скорость
    unsigned int v = vMin;
    // если заданный путь более пути подхода
    if ( ( zaslPutZad - zaslPutTek ) > zaslP4 )
    {
        // если путь разгона равен 0 (не пройден)
        if ( !zaslP1 )
        {
            // рассчитать скорость по пропорции
            v = (unsigned int)(vMin+((vMax-vMin)*ctZaslDvij)/tkZaslRazgon);
            // если рассчетная скорость больше максимальной
            if ( v >= vMax )
            {
                // приравнять рассчетную к максимальной
                v = vMax;
                // путь разгона пройден
                zaslP1 = zaslPutTek;
            }
            // нет возможности для разгона?
            if ( ( zaslPutTek * 2 + zaslP4 ) >= zaslPutZad )
            {
                // путь разгона пройден
                zaslP1 = zaslPutTek;
            }
        }
        // путь разгона пройден
        else
        {
            // пора подходить на малой скорости
            if ( ( zaslPutZad - zaslPutTek ) <= zaslP4 )
                v = vMin;
            // пора тормозить?
            else if ( ( zaslPutZad - zaslPutTek ) <= ( zaslP1 + zaslP4 ) )
            {
                // рассчитать скорость по пропорции
                v = (unsigned int)(vMax -((vMax-vMin)*ctZaslDvij)/tkZaslRazgon);
                // если скорость менее минимальной
                if ( v < vMin )
                    // приравнять скорость к минимальной
                    v = vMin;
            }
            // тормозить ещё рано
            else
            {
                // сбросить сч. времени
                ctZaslDvij = 0;
                // скорость максимальная
                v = vMax;
            }
        }
    }
    // выставить скорость
    A_OUT(2, v);   
}
//---------------------------------------------------------------------------
//--Подпрограмма выбора и установки направления заслонки--//
//---------------------------------------------------------------------------
void ZaslVibNapr()
{   
    // выставить направление движения вперед
    SetOut(1, 0, 0x0008);
}
//---------------------------------------------------------------------------
//--Подпрограмма рассчета заданного пути--//
//---------------------------------------------------------------------------
void SetZaslPut(long zaslUgol1, long zaslUgol2)
{
    // для заслонки путь 0 - 360 градусов и в одном направлении, поэтому
    if ( zaslUgol1 > zaslUgol2 )
        zaslPutZad = zaslUgol2 + zaslAngle360 - zaslUgol1;
    else
        zaslPutZad = zaslUgol2 - zaslUgol1;
}
/*
//---------------------------------------------------------------------------
//--Рассчет кол-ва импульсов в 360 градусах--//
//---------------------------------------------------------------------------
void CountDzaslFRP()
{
    // анализ работы механизма в движении
    if ( ( sh_ > 1 ) && DzaslDvijAnalis() ) return;
    switch ( sh_ )
    {
        // ШАГ1. Выдача уставки анализ положения механизма
        case 1:
        {
            // выдать минимальную уставку скорости
            A_OUT(3, nasmod[17]);
            // выдать направление движения
            DzaslVibNapr(0, 1);
            // находимся в исходнике?
            if ( zin[1] & 0x0010 )  sh_ = 2;   // В исх -> 2 шаг
            else                    sh_ = 3;   // НЕ в исх. -> 3 шаг
            // сбросили сч. времени обнаружения ошибок
            ctDzaslErr = 0;
        }; break;
        // ШАГ2. Ожидание ВЫХОДА из исходника
        case 2:
        {
            // вышли из исходника
            if ( ! (zin[1] & 0x0010 ) ) sh_ = 3;
        }; break;
        // ШАГ3. Ожидание ВХОДА в исходник
        case 3:
        {
            // вышли в исходник
            if ( zin[1] & 0x0010 )
            {
                // сбросить счетчик ФРП механизма
                SetDzasl0();
                // выставить в ноль предыдущий угол
                dzaslUgolPred = 0;
                // выставить в ноль текущий угол
                dzaslUgolTek = 0;
                sh_ = 4;
            }
        }; break;
        // ШАГ4. Ожидание ВЫХОДА из исходника
        case 4:
        {
            // вышли из исходника
            if ( ! (zin[1] & 0x0010 ) ) sh_ = 5;
        }; break;
        // ШАГ5. Ожидание ВХОДА в исходник, рассчет импульсов ФРП, выход
        case 5:
        {
            // вышли в исходник
            if ( zin[1] & 0x0010 )
            {
                // сбросить счетчик ФРП механизма
                dzaslCountFRP = dzaslUgolTek;
                // сбросить скорость
                A_OUT(3, 8192);
                // сброс направления движения
                SetOut(0, 0, 0x0060);
                norma = 47;
                sh_ = 0;
            }
        }; break;
    }
}
//---------------------------------------------------------------------------
//--Подпрограмма движения механизма д.заслонки--//
//---------------------------------------------------------------------------
unsigned char GoDZaslonka(long dzaslUgol1, long dzaslUgol2, bool izIsh, bool vIsh, bool cherezIsh)
{
    while ( dzaslUgol1 < 0 ) dzaslUgol1 += dzaslAngle360;
    while ( dzaslUgol1 >= dzaslAngle360 ) dzaslUgol1 -= dzaslAngle360;
    while ( dzaslUgol2 < 0 ) dzaslUgol2 += dzaslAngle360;
    while ( dzaslUgol2 >= dzaslAngle360 ) dzaslUgol2 -= dzaslAngle360;
    switch ( sh_ )
    {
        // ШАГ 1. Анализ положения механизма, задание мин. скор. и направления
        case 1:
        {
            // если расстояние между заданными углами менее контрольного
            if  (
                    (
                        ( ( abs ( dzaslUgol1 - dzaslUgol2 ) ) < dzaslPutMin ) ||
                        ( ( abs ( dzaslUgol1 - dzaslUgol2 ) ) > ( dzaslAngle360 - dzaslPutMin ) )
                    ) &&
                    ( !cherezIsh ) &&
                    ( !vIsh ) &&
                    ( !dzaslPrRuch ) &&
                    ( dzaslUgol1 != dzaslUgol2 )
                )
            {
                // норма: "Мех. д/заслонки путь прошёл"
                norma = 16;
                // завершение подпрограммы
                sh_ = 0;
                // выход из подпрограммы
                return 7;
            }
            // движение ИЗ исходника?
            if ( izIsh )
            {
                // нет датчика исходного положения?
                if ( ! ( zin[1] & 0x0010 ) )
                {
                    // отказ: "механизм д.заслонки не в исходном"
                    diagn[6] |= 0x01;
                    // выход из подпрограммы
                    return 1;
                }
                // есть датчик исходного положения
                else
                {
                    // выставить признак нахождения в исходном
                    dzaslPrNahVIsh = true;
                    // сброс диагностики
                    diagn[6] &= (~0x01);
                }
            }
            // движение В исходник?
            if ( vIsh )
            {
                // есть датчик исходного положения?
                if ( zin[1] & 0x0010 )
                {
                    // выставить признак нахождения в исходном
                    dzaslPrNahVIsh = true;
                    // сбросить признак неопределенного положения механизма
                    dzaslPrNeopr = false;
                    // норма: "Мех. д.заслонки в исходнике"
                    norma = 29;
                    // завершение подпрограммы
                    sh_ = 0;
                    // выход из подпрограммы
                    return 2;
                }
            }
            // выбор и установка направления заслонки
            DzaslVibNapr(dzaslUgol1, dzaslUgol2);
            // выставить минимальную скорость
            A_OUT(3, nasmod[17]);
            // сброс сч. времени
            ctDzaslDvij = 0;
            // переход на следующий шаг
            sh_ = 2;
        }; break;
        // ШАГ 2. Анализ выхода из исходника
        case 2:
        {
            // механизм в исходном и движение из исходного
            if ( izIsh && ( zin[1] & 0x0010 ) )
            {
                // выставить признак нахождения в исходном
                dzaslPrNahVIsh = true;
                // сбросить признак неопределенного положения механизма
                dzaslPrNeopr = false;
                // время ожидания выхода из исходника вышло
                if ( ctDzaslDvij > tkDzaslIzIsh )
                {
                    // сброс направления движения
                    SetOut(0, 0, 0x0060);
                    // сброс скорости
                    A_OUT(3, 8192);
                    // отказ: "нет выхода мех. из исходного"
                    diagn[6] |= 0x02;
                }
            }
            // механизм не в исходном положении
            else
            {
                // выставить ФРП заслонки в ноль
                SetDzasl0();
                // сброс дигностики
                diagn[6] &= (~0x02);
                // сброс сч. пути
                dzaslPutTek = 0;
                // сброс сч. времени
                ctDzaslDvij = 0;
                // сброс сч. ошибок
                ctDzaslErr = 0;
                // возможно считать датчик ФРП?
                if ( ctDzaslOpros >= tkDzaslOpros )
                {
                    // сбросить счётчик опроса ФРП
                    ctDzaslOpros = 0;
                    // считать текущее значение угла механизма
                    dzaslUgolTek = GetDzaslUgol();
                }
                else return 5;
                // приравнять предыдущее текущему
                dzaslUgolPred = dzaslUgolTek;
                // время разгона механизма обнулить
                dzaslP1 = 0;
                // сбросить признак пересечения исх. положения
                dzaslPrIsh = false;
                // сбросить признак пересечения 2 фронта исходника
                dzaslPrFront2 = false;
                // рассчитать заданный путь
                SetDzaslPut(dzaslUgol1, dzaslUgol2);
                // перейти на следующи шаг
                sh_ = 3;
            }
        }; break;
        // ШАГ 3. Движение механизма
        case 3:
        {
            // если нет сбоев в движении механизма
            if ( ! DzaslDvijAnalis() )
            {
                if ( ! dzaslPrNeopr )
                {
                    // пересчитать абсолютное значение угла
                    if ( dzaslUgol1 <= dzaslUgol2 )
                        dzaslUgolAbs += abs(dzaslUgolTek-dzaslUgolPred);
                    else
                        dzaslUgolAbs -= abs(dzaslUgolTek-dzaslUgolPred);
                }
                // механизм в исходном положении
                if ( zin[1] & 0x0010 )
                {
                    // выставить признак нахождения в исходном
                    dzaslPrNahVIsh = true;
                    // сбросить признак неопределенного положения механизма
                    dzaslPrNeopr = false;
                    // выставить признак прохождения мех. через исходное
                    dzaslPrIsh = true;
                    // движение должно окончиться в исходном положении?
                    if ( vIsh )
                    {
                        // сброс направления движения
                        SetOut(0, 0, 0x0060);
                        // сброс скорости
                        A_OUT(3, 8192);
                        // сброс сч. времени
                        ctDzaslDvij = 0;
                        // норма: "Мех. д.заслонки в исходнике"
                        norma = 29;
                        // перейти на следующий шаг
                        sh_ = 4;
                        // выход из подпрограммы
                        return 4;
                    }
                }
                // механизм не в исходном положении
                else
                {
                    if ( dzaslPrNahVIsh )
                    {
                        // сбросить признак нахождения в исходном
                        dzaslPrNahVIsh = false;
                        // выставить признак пересечения 2 фронта исходника
                        dzaslPrFront2 = true;
                        // сбросить сч. абс. значения угла
                        dzaslUgolAbs = 0;
                    }
                }
                // движение через исходное и нет признака пересеч. исх.
                if ( cherezIsh && ( ! dzaslPrFront2 ) )
                    // выход из подпрограммы
                    return 3;
                // пересчитать пройденный путь
                dzaslPutTek +=  abs(dzaslUgolTek-dzaslUgolPred);
                // если начальное положение определено
                if ( ! dzaslPrNeopr )
                    // рассчитать и выдать скорость движения
                    SetDzaslV(nasmod[17], nasmod[13]);
                // если движение не в исходник и путь пройден
                if  ( ! vIsh &&
                        (
                            // для ручного режима
                            ( dzaslPrRuch && ( dzaslPutZad <= dzaslPutTek ) ) ||
                            // для автоматического режима
                            ( ( ! dzaslPrRuch ) && ( abs ( dzaslUgolAbs - dzaslUgol2 ) < dzaslUgolPodhoda ) )
                        )
                    )
                {
                    // сброс направления движения
                    SetOut(0, 0, 0x0060);
                    // сброс скорости
                    A_OUT(3, 8192);
                    // сброс сч. времени
                    ctDzaslDvij = 0;
                    // норма: "Мех. д.заслонки путь прошёл"
                    norma = 16;
                    // перейти на следующи шаг
                    sh_ = 4;
                }
            }
        }; break;
        // ШАГ 4. Инерционность останова механизма
        case 4:
        {
            // возможно считать датчик ФРП?
            if ( ctDzaslOpros >= tkDzaslOpros )
            {
                // сбросить счётчик опроса ФРП
                ctDzaslOpros = 0;
                // считать текущее значение угла механизма
                dzaslUgolTek = GetDzaslUgol();
            }
            else return 6;
            // пересчитать абсолютное значение угла
            if ( ! dzaslPrNeopr )
            {
                if ( dzaslUgol1 <= dzaslUgol2 )
                    dzaslUgolAbs += abs(dzaslUgolTek-dzaslUgolPred);
                else
                    dzaslUgolAbs -= abs(dzaslUgolTek-dzaslUgolPred);
            }
            // если есть признак нахождения в исх. и нет исходника
            if ( dzaslPrNahVIsh && ( ! ( zin[1] & 0x0010 ) ) )
            {
                // сбросить признак нахождения в исходном
                dzaslPrNahVIsh = false;
                // сбросить сч. абс. значения угла
                dzaslUgolAbs = 0;
            }
            // если находится в исходнике
            else if ( zin[1] & 0x0010 )
                // выставить признак нахождения в исходном
                dzaslPrNahVIsh = true;
            // если текущий угол не равен предыдущему
            if ( dzaslUgolTek != dzaslUgolPred )
                // сброс сч. времени
                ctDzaslDvij = 0;
            // вышло время без движения
            if ( ctDzaslDvij > tkDzaslBezDvij )
                // выход из подпрограммы
                sh_ = 0;
            // приравнять предыдущее значение угла текущему
            dzaslUgolPred = dzaslUgolTek;
        }; break;
        // НЕОПОЗНАННЫЙ ШАГ. Окончание подпрограммы
        default: sh_ = 0; break;
    }
    // выход из подпрограммы
    return 0;
}
//---------------------------------------------------------------------------
//--Подпрограмма анализа сбоев в движении--//
//---------------------------------------------------------------------------
unsigned char DzaslDvijAnalis()
{
    // приравнять предыдущее значение угла текущему
    dzaslUgolPred = dzaslUgolTek;
    // возможно считать датчик ФРП?
    if ( ctDzaslOpros >= tkDzaslOpros )
    {
        // сбросить счётчик опроса ФРП
        ctDzaslOpros = 0;
        // считать текущее значение угла механизма
        dzaslUgolTek = GetDzaslUgol();
    }
    else return 0;
    // если текущее значение менее предыдущего
    if ( dzaslUgolTek < dzaslUgolPred )
    {
        // отказ: "Сбой мех. д.заслонки в движении: КОД1"
        diagn[6] |= 0x08;
        // сброс направления движения
        SetOut(0, 0, 0x0060);
        // сброс скорости
        A_OUT(3, 8192);
        // вернуть код 1
        return 1;
    }
    // если нет изменения текущего значения угла
    else if ( dzaslUgolTek == dzaslUgolPred )
    {
        // время отсутствия изменений более контрольного
        if ( ctDzaslErr > tkDzaslBezDvij )
        {
            // отказ: "Сбой мех. заслонки в движении: КОД2"
            diagn[6] |= 0x10;
            // сброс направления движения
            SetOut(0, 0, 0x0060);
            // сброс скорости
            A_OUT(3, 8192);
            // вернуть код 2
            return 2;
        }
    }
    else
    {
        // сброс диагностик
        diagn[6] &= (~0x18);
        // сброс сч. времени
        ctDzaslErr = 0;
        // вернуть код 0
        return 0;
    }
}
//---------------------------------------------------------------------------
//--Подпрограмма рассчета скорости--//
//---------------------------------------------------------------------------
void SetDzaslV(float vMin, float vMax)
{
    // рассчетная скорость
    unsigned int v = vMin;
    // если заданный путь более пути подхода
    if ( ( dzaslPutZad - dzaslPutTek ) > dzaslP4 )
    {
        // если путь разгона равен 0 (не пройден)
        if ( !dzaslP1 )
        {
            // рассчитать скорость по пропорции
            v = (unsigned int)(vMin+((vMax-vMin)*ctDzaslDvij)/tkDzaslRazgon);
            // если рассчетная скорость больше максимальной
            if ( v >= vMax )
            {
                // приравнять рассчетную к максимальной
                v = vMax;
                // путь разгона пройден
                dzaslP1 = dzaslPutTek;
            }
            // нет возможности для разгона?
            if ( ( dzaslPutTek * 2 + dzaslP4 ) >= dzaslPutZad )
            {
                // путь разгона пройден
                dzaslP1 = dzaslPutTek;
            }
        }
        // путь разгона пройден
        else
        {
            // пора подходить на малой скорости
            if ( ( dzaslPutZad - dzaslPutTek ) <= dzaslP4 )
                v = vMin;
            // пора тормозить?
            else if ( ( dzaslPutZad - dzaslPutTek ) <= ( dzaslP1 + dzaslP4 ) )
            {
                // рассчитать скорость по пропорции
                v = (unsigned int)(vMax -((vMax-vMin)*ctDzaslDvij)/tkDzaslRazgon);
                // если скорость менее минимальной
                if ( v < vMin )
                    // приравнять скорость к минимальной
                    v = vMin;
            }
            // тормозить ещё рано
            else
            {
                // сбросить сч. времени
                ctDzaslDvij = 0;
                // скорость максимальная
                v = vMax;
            }
        }
    }
    // выставить скорость
    A_OUT(3, v);
}
//---------------------------------------------------------------------------
//--Подпрограмма выбора и установки направления д.заслонки--//
//---------------------------------------------------------------------------
void DzaslVibNapr(long dzaslUgol1, long dzaslUgol2)
{
    // если текущий угол менее нужного
    if ( dzaslUgol1 <= dzaslUgol2 )
        // выставить направление движения вперед
        SetOut(1, 0, 0x0020);
    // иначе
    else
        // выставить направление движения назад
        SetOut(1, 0, 0x0040);
}
//---------------------------------------------------------------------------
//--Подпрограмма рассчета заданного пути--//
//---------------------------------------------------------------------------
void SetDzaslPut(long dzaslUgol1, long dzaslUgol2)
{
    // для д.заслонки путь (-180) - 180 градусов,
    // в любом направлении поэтому
    dzaslPutZad = abs(dzaslUgol2 - dzaslUgol1);
}
*/
//---------------------------------------------------------------------------
//--Рассчет кол-ва импульсов в 360 градусах--//
//---------------------------------------------------------------------------
void CountPderjFRP()
{
    // анализ работы механизма в движении
    if ( ( sh_ > 1 ) && PderjDvijAnalis() ) return;
    switch ( sh_ )
    {
        // ШАГ1. Выдача уставки анализ положения механизма
        case 1:
        {
            // выдать минимальную уставку скорости
            A_OUT(1, nasmod[15]);
            // выдать направление движения
            PderjVibNapr();
            // находимся в исходнике?
            if ( zin[1] & 0x0004 )  sh_ = 2;   // В исх -> 2 шаг
            else                    sh_ = 3;   // НЕ в исх. -> 3 шаг
            // сбросили сч. времени обнаружения ошибок
            ctPderjErr = 0;
        }; break;
        // ШАГ2. Ожидание ВЫХОДА из исходника
        case 2:
        {
            // вышли из исходника
            if ( ! (zin[1] & 0x0004 ) ) sh_ = 3;
        }; break;
        // ШАГ3. Ожидание ВХОДА в исходник
        case 3:
        {
            // вышли в исходник
            if ( zin[1] & 0x0004 )
            {
                // сбросить счетчик ФРП механизма
                SetChannel1_0();
                // выставить в ноль предыдущий угол
                pderjUgolPred = 0;
                // выставить в ноль текущий угол
                pderjUgolTek = 0;
                sh_ = 4;
            }
        }; break;
        // ШАГ4. Ожидание ВЫХОДА из исходника
        case 4:
        {
            // вышли из исходника
            if ( ! (zin[1] & 0x0004 ) ) sh_ = 5;
        }; break;
        // ШАГ5. Ожидание ВХОДА в исходник, рассчет импульсов ФРП, выход
        case 5:
        {
            // вышли в исходник
            if ( zin[1] & 0x0004 )
            {
                // сбросить счетчик ФРП механизма
                pderjCountFRP = pderjUgolTek;
                // сброс скорости
                A_OUT(1, 8192);
                // сброс направления движения
                SetOut(0, 0, 0x0002);
                norma = 48;
                sh_ = 0;
            }
        }; break;
    }
}
//---------------------------------------------------------------------------
//--Подпрограмма движения механизма п/держателя--//
//---------------------------------------------------------------------------
unsigned char GoPderjatel(long pderjUgol1, long pderjUgol2, bool izIsh, bool vIsh, bool cherezIsh)
{
    while ( pderjUgol1 < 0 ) pderjUgol1 += pderjAngle360;
    while ( pderjUgol1 >= pderjAngle360 ) pderjUgol1 -= pderjAngle360;
    while ( pderjUgol2 < 0 ) pderjUgol2 += pderjAngle360;
    while ( pderjUgol2 >= pderjAngle360 ) pderjUgol2 -= pderjAngle360;
    switch ( sh_ )
    {
        // ШАГ 1. Анализ положения механизма, задание мин. скор. и направления
        case 1:
        {
            // если расстояние между заданными углами менее контрольного
            if  (
                    (
                        ( ( abs ( pderjUgol1 - pderjUgol2 ) ) < pderjPutMin ) ||
                        ( ( abs ( pderjUgol1 - pderjUgol2 ) ) > ( pderjAngle360 - pderjPutMin ) )
                    ) &&
                    ( !cherezIsh ) &&
                    ( !vIsh ) &&
                    ( !pderjPrRuch ) &&
                    ( pderjUgol1 != pderjUgol2 )
                )
            {
                // норма: "Мех. п/держателя путь прошёл"
                norma = 17;
                // завершение подпрограммы
                sh_ = 0;
                // выход из подпрограммы
                return 7;
            }
            // движение ИЗ исходника?
            if ( izIsh )
            {
                // нет датчика исходного положения?
                if ( ! ( zin[1] & 0x0004 ) )
                {
                    // отказ: "механизм п/держателя не в исходном"
                    diagn[4] |= 0x01;
                    // выход из подпрограммы
                    return 1;
                }
                // есть датчик исходного положения
                else
                {
                    // выставить признак нахождения в исходном
                    pderjPrNahVIsh = true;
                    // сброс диагностики
                    diagn[4] &= (~0x01);
                }
            }
            // движение В исходник?
            if ( vIsh )
            {
                // есть датчик исходного положения?
                if ( zin[1] & 0x0004 )
                {
                    // выставить признак нахождения в исходном
                    pderjPrNahVIsh = true;
                    // сбросить признак неопределенного положения механизма
                    pderjPrNeopr = false;
                    // норма: "Мех. п/держателя в исходнике"
                    norma = 32;
                    // завершение подпрограммы
                    sh_ = 0;
                    // выход из подпрограммы
                    return 2;
                }
            }
            // выбор и установка направления заслонки
            PderjVibNapr();
            // выставить минимальную скорость
            A_OUT(1, nasmod[15]);
            // сброс сч. времени
            ctPderjDvij = 0;
            // переход на следующий шаг
            sh_ = 2;
        }; break;
        // ШАГ 2. Анализ выхода из исходника
        case 2:
        {
            // движение из исходника и механизм в исходном
            if ( izIsh && ( zin[1] & 0x0004 ) )
            {
                // выставить признак нахождения в исходном
                pderjPrNahVIsh = true;
                // сбросить признак неопределенного положения механизма
                pderjPrNeopr = false;
                // время ожидания выхода из исходника вышло
                if ( ctPderjDvij > tkPderjIzIsh )
                {
                    // сброс направления движения
                    SetOut(0, 0, 0x0002);
                    // сброс скорости
                    A_OUT(1, 8192);
                    // отказ: "нет выхода мех. из исходного"
                    diagn[4] |= 0x02;
                }
            }
            // механизм не в исходном положении
            else
            {
                // выставить ФРП п/держателя в ноль
                SetChannel1_0();
                // сброс дигностики
                diagn[4] &= (~0x02);
                // сброс сч. пути
                pderjPutTek = 0;
                // сброс сч. времени
                ctPderjDvij = 0;
                // сброс сч. ошибок
                ctPderjErr = 0;
                // возможно считать датчик ФРП?
                if ( ctPderjOpros >= tkPderjOpros )
                {
                    // сбросить счётчик опроса ФРП
                    ctPderjOpros = 0;
                    // считать текущее значение угла механизма
                    pderjUgolTek = GetChannel1();
                }
                else return 5;
                // приравнять предыдущее текущему
                pderjUgolPred = pderjUgolTek;
                // время разгона механизма обнулить
                pderjP1 = 0;
                // сбросить признак пересечения исх. положения
                pderjPrIsh = false;
                // сбросить признак пересечения 2 фронта исходника
                pderjPrFront2 = false;
                // рассчитать заданный путь
                SetPderjPut(pderjUgol1, pderjUgol2);
                // перейти на следующи шаг
                sh_ = 3;
            }
        }; break;
        // ШАГ 3. Движение механизма
        case 3:
        {
            // если нет сбоев в движении механизма
            if ( ! PderjDvijAnalis() )
            {
                // пересчитать абсолютное значение угла
                if ( ! pderjPrNeopr )
                    pderjUgolAbs += abs(pderjUgolTek-pderjUgolPred);
                // механизм в исходном положении
                if ( zin[1] & 0x0004 )
                {
                    // выставить признак нахождения в исходном
                    pderjPrNahVIsh = true;
                    // сбросить признак неопределенного положения механизма
                    pderjPrNeopr = false;
                    // выставить признак прохождения мех. через исходное
                    pderjPrIsh = true;
                    // движение должно окончиться в исходном положении?
                    if ( vIsh )
                    {
                        // сброс направления движения
                        SetOut(0, 0, 0x0006);
                        // сброс скорости
                        A_OUT(1, 8192);
                        // сброс сч. времени
                        ctPderjDvij = 0;
                        // норма: "Мех. п/держателя в исходнике"
                        norma = 32;
                        // перейти на следующий шаг
                        sh_ = 4;
                        // выход из подпрограммы
                        return 4;
                    }
                }
                // механизм не в исходном положении
                else
                {
                    // если есть признак нахождения механизма в исходном
                    if ( pderjPrNahVIsh )
                    {
                        // сбросить признак нахождения в исходном
                        pderjPrNahVIsh = false;
                        // выставить признак пересечения 2 фронта исходника
                        pderjPrFront2 = true;
                        // сбросить сч. абс. значения угла
                        pderjUgolAbs = 0;
                    }
                }
                // движение через исходное и нет признака пересеч. исх.
                if ( cherezIsh && ( ! pderjPrFront2 ) )
                    // выход из подпрограммы
                    return 3;
                // пересчитать пройденный путь
                pderjPutTek +=  abs(pderjUgolTek-pderjUgolPred);
                // если начальное положение определено
                if ( ! pderjPrNeopr )
                    // рассчитать и выдать скорость движения
                    SetPderjV(nasmod[15], nasmod[11]);
                // если движение не в исходник и путь пройден
                if  ( ! vIsh &&
                        (
                            // для ручного режима
                            ( pderjPrRuch && ( pderjPutZad <= pderjPutTek ) ) ||
                            // для автоматического режима
                            ( ( ! pderjPrRuch ) && ( abs ( pderjUgolAbs - pderjUgol2 ) < pderjUgolPodhoda ) )
                        )
                    )
                {
                    // сброс направления движения
                    SetOut(0, 0, 0x0002);
                    // сброс скорости
                    A_OUT(1, 8192);
                    // сброс сч. времени
                    ctPderjDvij = 0;
                    // норма: "Мех. п/држателя путь прошёл"
                    norma = 17;
                    // перейти на следующи шаг
                    sh_ = 4;
                }
            }
        }; break;
        // ШАГ 4. Инерционность останова механизма
        case 4:
        {
            // возможно считать датчик ФРП?
            if ( ctPderjOpros >= tkPderjOpros )
            {
                // сбросить счётчик опроса ФРП
                ctPderjOpros = 0;
                // считать текущее значение угла механизма
                pderjUgolTek = GetChannel1();
            }
            else return 6;
            // пересчитать абсолютное значение угла
            if ( ! pderjPrNeopr )
                pderjUgolAbs += abs(pderjUgolTek-pderjUgolPred);
            // если есть признак нахождения механизма в исходном и нет исходника
            if ( pderjPrNahVIsh && ( ! ( zin[1] & 0x0004 ) ) )
            {
                // сбросить признак нахождения в исходном
                pderjPrNahVIsh = false;
                // сбросить сч. абс. значения угла
                pderjUgolAbs = 0;
            }
            // если механизм находится в исходном
            else if ( zin[1] & 0x0004 )
                // выставить признак нахождения в исходном
                pderjPrNahVIsh = false;
            // если текущий угол не равен предыдущему
            if ( pderjUgolTek != pderjUgolPred )
                // сброс сч. времени
                ctPderjDvij = 0;
            // вышло время без движения
            if ( ctPderjDvij > tkPderjBezDvij )
                // выход из подпрограммы
                sh_ = 0;
            // приравнять предыдущее значение угла текущему
            pderjUgolPred = pderjUgolTek;
        }; break;
        // НЕОПОЗНАННЫЙ ШАГ. Окончание подпрограммы
        default: sh_ = 0; break;
    }
    // выход из подпрограммы
    return 0;
}
//---------------------------------------------------------------------------
//--Подпрограмма анализа сбоев в движении--//
//---------------------------------------------------------------------------
unsigned char PderjDvijAnalis()
{
    // приравнять предыдущее значение угла текущему
    pderjUgolPred = pderjUgolTek;
    // возможно считать датчик ФРП?
    if ( ctPderjOpros >= tkPderjOpros )
    {
        // сбросить счётчик опроса ФРП
        ctPderjOpros = 0;
        // считать текущее значение угла механизма
        pderjUgolTek = GetChannel1();
    }
    else return 0;
    // если текущее значение менее предыдущего
    if ( pderjUgolTek < pderjUgolPred )
    {
        // отказ: "Сбой мех. п/держателя в движении: КОД1"
        diagn[4] |= 0x08;
        // сброс направления движения
        SetOut(0, 0, 0x0002);
        // сброс скорости
        A_OUT(1, 8192);
        // вернуть код 1
        return 1;
    }
    // если нет изменения текущего значения угла
    else if ( pderjUgolTek == pderjUgolPred )
    {
        // время отсутствия изменений более контрольного
        if ( ctPderjErr > tkPderjBezDvij )
        {
            // отказ: "Сбой мех. п/держателя в движении: КОД2"
            diagn[4] |= 0x10;
            // сброс направления движения
            SetOut(0, 0, 0x0002);
            // сброс скорости
            A_OUT(1, 8192);
            // вернуть код 2
            return 2;
        }
    }
    else
    {
        // сброс диагностик
        diagn[4] &= (~0x18);
        // сброс сч. времени
        ctPderjErr = 0;
        // вернуть код 0
        return 0;
    }
}
//---------------------------------------------------------------------------
//--Подпрограмма рассчета скорости--//
//---------------------------------------------------------------------------
void SetPderjV(float vMin, float vMax)
{
    // рассчетная скорость
    unsigned int v = vMin;
    // если заданный путь более пути подхода
    if ( ( pderjPutZad - pderjPutTek ) > pderjP4 )
    {
        // если путь разгона равен 0 (не пройден)
        if ( !pderjP1 )
        {
            // рассчитать скорость по пропорции
            v = (unsigned int)(vMin+((vMax-vMin)*ctPderjDvij)/tkPderjRazgon);
            // если рассчетная скорость больше максимальной
            if ( v >= vMax )
            {
                // приравнять рассчетную к максимальной
                v = vMax;
                // путь разгона пройден
                pderjP1 = pderjPutTek;
            }
            // нет возможности для разгона?
            if ( ( pderjPutTek * 2 + pderjP4 ) >= pderjPutZad )
            {
                // путь разгона пройден
                pderjP1 = pderjPutTek;
            }
        }
        // путь разгона пройден
        else
        {
            // пора подходить на малой скорости
            if ( ( pderjPutZad - pderjPutTek ) <= pderjP4 )
                v = vMin;
            // пора тормозить?
            else if ( ( pderjPutZad - pderjPutTek ) <= ( pderjP1 + pderjP4 ) )
            {
                // рассчитать скорость по пропорции
                v = (unsigned int)(vMax -((vMax-vMin)*ctPderjDvij)/tkPderjRazgon);
                // если скорость менее минимальной
                if ( v < vMin )
                    // приравнять скорость к минимальной
                    v = vMin;
            }
            // тормозить ещё рано
            else
            {
                // сбросить сч. времени
                ctPderjDvij = 0;
                // скорость максимальная
                v = vMax;
            }
        }
    }
    // выставить скорость
    A_OUT(1, v);
}
//---------------------------------------------------------------------------
//--Подпрограмма выбора и установки направления п/держателя--//
//---------------------------------------------------------------------------
void PderjVibNapr()
{
    // выставить направление движения вперед
    SetOut(1, 0, 0x0002);
}
//---------------------------------------------------------------------------
//--Подпрограмма рассчета заданного пути--//
//---------------------------------------------------------------------------
void SetPderjPut(long pderjUgol1, long pderjUgol2)
{
    // для заслонки путь 0 - 360 градусов и в одном направлении, поэтому
    if ( pderjUgol1 > pderjUgol2 )
        pderjPutZad = pderjUgol2 + pderjAngle360 - pderjUgol1;
    else
        pderjPutZad = pderjUgol2 - pderjUgol1;
}
//---------------------------------------------------------------------------

